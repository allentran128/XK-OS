
out/xk_memfs.elf:     file format elf64-x86-64


Disassembly of section .text:

ffffffff80100000 <_start>:
ffffffff80100000:	02 b0 ad 1b 03 00    	add    0x31bad(%rax),%dh
ffffffff80100006:	01 00                	add    %eax,(%rax)
ffffffff80100008:	fb                   	sti    
ffffffff80100009:	4f 51                	rex.WRXB push %r9
ffffffff8010000b:	e4 00                	in     $0x0,%al
ffffffff8010000d:	00 10                	add    %dl,(%rax)
ffffffff8010000f:	00 00                	add    %al,(%rax)
ffffffff80100011:	00 10                	add    %dl,(%rax)
ffffffff80100013:	00 de                	add    %bl,%dh
ffffffff80100015:	63 1f                	movslq (%rdi),%ebx
ffffffff80100017:	03 00                	add    (%rax),%eax
ffffffff80100019:	60                   	(bad)  
ffffffff8010001a:	22 03                	and    (%rbx),%al
ffffffff8010001c:	60                   	(bad)  
ffffffff8010001d:	00 10                	add    %dl,(%rax)
	...

ffffffff80100020 <multiboot2_header>:
ffffffff80100020:	d6                   	(bad)  
ffffffff80100021:	50                   	push   %rax
ffffffff80100022:	52                   	push   %rdx
ffffffff80100023:	e8 00 00 00 00       	callq  ffffffff80100028 <multiboot2_header+0x8>
ffffffff80100028:	40 00 00             	add    %al,(%rax)
ffffffff8010002b:	00 ea                	add    %ch,%dl
ffffffff8010002d:	ae                   	scas   %es:(%rdi),%al
ffffffff8010002e:	ad                   	lods   %ds:(%rsi),%eax
ffffffff8010002f:	17                   	(bad)  

ffffffff80100030 <address_tag_start>:
ffffffff80100030:	02 00                	add    (%rax),%al
ffffffff80100032:	00 00                	add    %al,(%rax)
ffffffff80100034:	18 00                	sbb    %al,(%rax)
ffffffff80100036:	00 00                	add    %al,(%rax)
ffffffff80100038:	20 00                	and    %al,(%rax)
ffffffff8010003a:	10 00                	adc    %al,(%rax)
ffffffff8010003c:	00 00                	add    %al,(%rax)
ffffffff8010003e:	10 00                	adc    %al,(%rax)
ffffffff80100040:	de 63 1f             	fisub  0x1f(%rbx)
ffffffff80100043:	03 00                	add    (%rax),%eax
ffffffff80100045:	60                   	(bad)  
ffffffff80100046:	22 03                	and    (%rbx),%al

ffffffff80100048 <address_tag_end>:
ffffffff80100048:	03 00                	add    (%rax),%eax
ffffffff8010004a:	00 00                	add    %al,(%rax)
ffffffff8010004c:	0c 00                	or     $0x0,%al
ffffffff8010004e:	00 00                	add    %al,(%rax)
ffffffff80100050:	73 00                	jae    ffffffff80100052 <address_tag_end+0xa>
ffffffff80100052:	10 00                	adc    %al,(%rax)

ffffffff80100054 <entry_address_tag_end>:
	...
ffffffff8010005c:	08 00                	or     %al,(%rax)
	...

ffffffff80100060 <multiboot2_header_end>:
 * ebx: physical address of the multiboot structure
 */
.code32
start_multiboot:
	/* check for multiboot bootloader magic */
	cmpl	$MULTIBOOT_BOOTLOADER_MAGIC, %eax
ffffffff80100060:	3d 02 b0 ad 2b       	cmp    $0x2badb002,%eax
	jne	error_no_mb
ffffffff80100065:	0f 85 8d 00 00 00    	jne    ffffffff801000f8 <error_no_mb>
	/* save multiboot pointer */
	movl	%ebx, V2P_WO(multiboot_info)
ffffffff8010006b:	89 1d f0 63 1f 03    	mov    %ebx,0x31f63f0(%rip)        # ffffffff832f6461 <_end+0xd0461>
	jmp	start_bsp
ffffffff80100071:	eb 0f                	jmp    ffffffff80100082 <start_bsp>

ffffffff80100073 <start_multiboot2>:

start_multiboot2:
	cmpl	$MULTIBOOT2_BOOTLOADER_MAGIC, %eax
ffffffff80100073:	3d 89 62 d7 36       	cmp    $0x36d76289,%eax
	jne	error_no_mb
ffffffff80100078:	75 7e                	jne    ffffffff801000f8 <error_no_mb>
	movl	%ebx, V2P_WO(multiboot2_addr)
ffffffff8010007a:	89 1d f8 63 1f 03    	mov    %ebx,0x31f63f8(%rip)        # ffffffff832f6478 <_end+0xd0478>
	jmp	start_bsp
ffffffff80100080:	eb 00                	jmp    ffffffff80100082 <start_bsp>

ffffffff80100082 <start_bsp>:

start_bsp:
	/* check for the highest extended function */
	movl	$0x80000000, %eax
ffffffff80100082:	b8 00 00 00 80       	mov    $0x80000000,%eax
	cpuid
ffffffff80100087:	0f a2                	cpuid  
	cmpl	$0x80000001, %eax
ffffffff80100089:	3d 01 00 00 80       	cmp    $0x80000001,%eax
	jb	error_no_lm
ffffffff8010008e:	72 70                	jb     ffffffff80100100 <error_no_lm>

	/* check for lm (long mode) */
	movl	$0x80000001, %eax
ffffffff80100090:	b8 01 00 00 80       	mov    $0x80000001,%eax
	cpuid
ffffffff80100095:	0f a2                	cpuid  
	testl	$BIT32(29), %edx
ffffffff80100097:	f7 c2 00 00 00 20    	test   $0x20000000,%edx
	jz	error_no_lm
ffffffff8010009d:	74 61                	je     ffffffff80100100 <error_no_lm>
	# jz	error_no_pdpe1gb

	/* set BSP's cpunum to zero */
	movl	$MSR_IA32_TSC_AUX, %ecx
	movl	$0, %eax
	movl	$0, %edx
ffffffff8010009f:	b9 03 01 00 c0       	mov    $0xc0000103,%ecx
	wrmsr
ffffffff801000a4:	b8 00 00 00 00       	mov    $0x0,%eax

ffffffff801000a9:	ba 00 00 00 00       	mov    $0x0,%edx
	# /* set BSP's stack */
ffffffff801000ae:	0f 30                	wrmsr  
	movl	$(V2P_WO(STACK_TOP(0)) - TRAP_REGS_SIZE), %esp

.global	start_common
ffffffff801000b0:	bc 80 7f 22 03       	mov    $0x3227f80,%esp

ffffffff801000b5 <start_common>:
start_common:
 	/* CR4: enable PAE, PSE */
	movl	%cr4, %eax
	# orl	$(CR4_PAE|CR4_PSE|CR4_FSGSBASE), %eax
	# orl	$(CR4_PAE|CR4_PSE), %eax
ffffffff801000b5:	0f 20 e0             	mov    %cr4,%rax
	orl		$(CR4_PAE), %eax

	movl	%eax, %cr4

	/* CR3: load initial page table */
ffffffff801000b8:	83 c8 20             	or     $0x20,%eax
	# movl	$(0x1000 + V2P_WO(pagebase)), %eax
	movl    $(V2P_WO(kpml4_tmp)), %eax
ffffffff801000bb:	0f 22 e0             	mov    %rax,%cr4
	movl	%eax, %cr3

	/* MSR EFER: enable LME (and syscall) */
	movl	$MSR_EFER, %ecx
	rdmsr
ffffffff801000be:	b8 00 30 11 00       	mov    $0x113000,%eax
	# orl	$(EFER_SCE|EFER_LME), %eax
ffffffff801000c3:	0f 22 d8             	mov    %rax,%cr3
	orl	$(EFER_LME), %eax
	wrmsr

ffffffff801000c6:	b9 80 00 00 c0       	mov    $0xc0000080,%ecx
	/* CR0: enable PG, WP */
ffffffff801000cb:	0f 32                	rdmsr  
	movl	%cr0, %eax
	orl	$(CR0_PG|CR0_WP), %eax
	movl	%eax, %cr0
ffffffff801000cd:	0d 00 01 00 00       	or     $0x100,%eax

ffffffff801000d2:	0f 30                	wrmsr  
	lgdt	V2P_WO(gdtdesc)
	movl	$GDT_DS, %eax
	movw	%ax, %ss
ffffffff801000d4:	0f 20 c0             	mov    %cr0,%rax
	movw	%ax, %ds
ffffffff801000d7:	0d 00 00 01 80       	or     $0x80010000,%eax
	movw	%ax, %es
ffffffff801000dc:	0f 22 c0             	mov    %rax,%cr0

	/* enter 64-bit mode */
ffffffff801000df:	0f 01 15 fb fa 10 00 	lgdt   0x10fafb(%rip)        # ffffffff8020fbe1 <_binary_out_fs_img_start+0xed803>
	ljmp	$GDT_CS, $V2P_WO(start64)
ffffffff801000e6:	b8 10 00 00 00       	mov    $0x10,%eax

ffffffff801000eb:	8e d0                	mov    %eax,%ss
error_no_mb:
ffffffff801000ed:	8e d8                	mov    %eax,%ds
	lea	V2P_WO(msg_no_mb), %esi
ffffffff801000ef:	8e c0                	mov    %eax,%es
	jmp	error

error_no_lm:
ffffffff801000f1:	ea                   	(bad)  
ffffffff801000f2:	26 01 10             	add    %edx,%es:(%rax)
ffffffff801000f5:	00 08                	add    %cl,(%rax)
	...

ffffffff801000f8 <error_no_mb>:
	lea	V2P_WO(msg_no_lm), %esi
	jmp	error

ffffffff801000f8:	8d 35 c9 fa 10 00    	lea    0x10fac9(%rip),%esi        # ffffffff8020fbc7 <_binary_out_fs_img_start+0xed7e9>
error_no_pdpe1gb:
ffffffff801000fe:	eb 10                	jmp    ffffffff80100110 <error>

ffffffff80100100 <error_no_lm>:
	lea	V2P_WO(msg_no_pdpe1gb), %esi
	jmp	error

ffffffff80100100:	8d 35 e1 fa 10 00    	lea    0x10fae1(%rip),%esi        # ffffffff8020fbe7 <_binary_out_fs_img_start+0xed809>
error:
ffffffff80100106:	eb 08                	jmp    ffffffff80100110 <error>

ffffffff80100108 <error_no_pdpe1gb>:
	/* write to COM1 */
	movl	$0x3f8, %edx
error_loop:
ffffffff80100108:	8d 35 ee fa 10 00    	lea    0x10faee(%rip),%esi        # ffffffff8020fbfc <_binary_out_fs_img_start+0xed81e>
	lodsb
ffffffff8010010e:	eb 00                	jmp    ffffffff80100110 <error>

ffffffff80100110 <error>:
	test	%al, %al
	jz	error_end
	outb	%al, %dx
	jmp	error_loop
ffffffff80100110:	ba f8 03 00 00       	mov    $0x3f8,%edx

ffffffff80100115 <error_loop>:
error_end:
	movl	$0x0a, %eax
ffffffff80100115:	ac                   	lods   %ds:(%rsi),%al
	outb	%al, %dx
ffffffff80100116:	84 c0                	test   %al,%al
spin:
ffffffff80100118:	74 03                	je     ffffffff8010011d <error_end>
	hlt
ffffffff8010011a:	ee                   	out    %al,(%dx)
	jmp	spin
ffffffff8010011b:	eb f8                	jmp    ffffffff80100115 <error_loop>

ffffffff8010011d <error_end>:

.code64
ffffffff8010011d:	b8 0a 00 00 00       	mov    $0xa,%eax
start64:
ffffffff80100122:	ee                   	out    %al,(%dx)

ffffffff80100123 <spin>:
  	movq $entry64high, %rax
  	jmp *%rax
ffffffff80100123:	f4                   	hlt    

ffffffff80100124:	eb fd                	jmp    ffffffff80100123 <spin>

ffffffff80100126 <start64>:
.global _start
_start:
entry64high:
 	movq 	$0xFFFFFFFF80010000, %rax
ffffffff80100126:	48 c7 c0 2f 01 10 80 	mov    $0xffffffff8010012f,%rax
  	movq 	%rax, %rsp
ffffffff8010012d:	ff e0                	jmpq   *%rax

ffffffff8010012f <entry64high>:
  	movq 	multiboot_info, %rax
  	movq    %rax, %rdi
	call	main
	jmp	spin

ffffffff8010012f:	48 c7 c0 00 00 01 80 	mov    $0xffffffff80010000,%rax
.section .rodata
ffffffff80100136:	48 89 c4             	mov    %rax,%rsp
msg_no_mb:
ffffffff80100139:	48 8b 04 25 f0 63 1f 	mov    0xffffffff831f63f0,%rax
ffffffff80100140:	83 
	.string	"no multiboot bootloader"
ffffffff80100141:	48 89 c7             	mov    %rax,%rdi
msg_no_lm:
ffffffff80100144:	e8 17 07 00 00       	callq  ffffffff80100860 <main>
	.string	"no long mode"
ffffffff80100149:	eb d8                	jmp    ffffffff80100123 <spin>
ffffffff8010014b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

ffffffff80100150 <pa2page>:

struct core_map_entry *core_map = NULL;

struct core_map_entry*
pa2page(uint64_t pa)
{
ffffffff80100150:	55                   	push   %rbp
ffffffff80100151:	48 89 e5             	mov    %rsp,%rbp
ffffffff80100154:	48 83 ec 10          	sub    $0x10,%rsp
ffffffff80100158:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  if (PGNUM(pa) >= npages) {
ffffffff8010015c:	48 8b 7d f8          	mov    -0x8(%rbp),%rdi
ffffffff80100160:	48 c1 ef 0c          	shr    $0xc,%rdi
ffffffff80100164:	8b 04 25 e0 63 1f 83 	mov    0xffffffff831f63e0,%eax
ffffffff8010016b:	48 63 c8             	movslq %eax,%rcx
ffffffff8010016e:	48 39 cf             	cmp    %rcx,%rdi
ffffffff80100171:	0f 82 22 00 00 00    	jb     ffffffff80100199 <pa2page+0x49>
    cprintf("%x\n", pa);
ffffffff80100177:	48 8b 75 f8          	mov    -0x8(%rbp),%rsi
ffffffff8010017b:	48 c7 c7 25 00 11 80 	mov    $0xffffffff80110025,%rdi
ffffffff80100182:	31 c0                	xor    %eax,%eax
ffffffff80100184:	88 c1                	mov    %al,%cl
ffffffff80100186:	88 c8                	mov    %cl,%al
ffffffff80100188:	e8 d3 07 00 00       	callq  ffffffff80100960 <cprintf>
    panic("pa2page called with invalid pa");
ffffffff8010018d:	48 c7 c7 68 fa 10 80 	mov    $0xffffffff8010fa68,%rdi
ffffffff80100194:	e8 d7 0c 00 00       	callq  ffffffff80100e70 <panic>
  }
  return &core_map[PGNUM(pa)];
ffffffff80100199:	48 8b 04 25 e8 63 1f 	mov    0xffffffff831f63e8,%rax
ffffffff801001a0:	83 
ffffffff801001a1:	48 8b 4d f8          	mov    -0x8(%rbp),%rcx
ffffffff801001a5:	48 c1 e9 0c          	shr    $0xc,%rcx
ffffffff801001a9:	48 c1 e1 05          	shl    $0x5,%rcx
ffffffff801001ad:	48 01 c8             	add    %rcx,%rax
ffffffff801001b0:	48 83 c4 10          	add    $0x10,%rsp
ffffffff801001b4:	5d                   	pop    %rbp
ffffffff801001b5:	c3                   	retq   
ffffffff801001b6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
ffffffff801001bd:	00 00 00 

ffffffff801001c0 <page2pa>:
}

uint64_t
page2pa(struct core_map_entry *pp)
{
ffffffff801001c0:	55                   	push   %rbp
ffffffff801001c1:	48 89 e5             	mov    %rsp,%rbp
ffffffff801001c4:	50                   	push   %rax
ffffffff801001c5:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  return (pp - core_map) << PT_SHIFT;
ffffffff801001c9:	48 8b 7d f8          	mov    -0x8(%rbp),%rdi
ffffffff801001cd:	48 8b 04 25 e8 63 1f 	mov    0xffffffff831f63e8,%rax
ffffffff801001d4:	83 
ffffffff801001d5:	48 29 c7             	sub    %rax,%rdi
ffffffff801001d8:	48 c1 ff 05          	sar    $0x5,%rdi
ffffffff801001dc:	48 c1 e7 0c          	shl    $0xc,%rdi
ffffffff801001e0:	48 89 f8             	mov    %rdi,%rax
ffffffff801001e3:	48 83 c4 08          	add    $0x8,%rsp
ffffffff801001e7:	5d                   	pop    %rbp
ffffffff801001e8:	c3                   	retq   
ffffffff801001e9:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)

ffffffff801001f0 <core_map_entry_get>:
}

inline struct core_map_entry* core_map_entry_get(size_t i)
{
ffffffff801001f0:	55                   	push   %rbp
ffffffff801001f1:	48 89 e5             	mov    %rsp,%rbp
ffffffff801001f4:	50                   	push   %rax
ffffffff801001f5:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  return &core_map[i];
ffffffff801001f9:	48 8b 3c 25 e8 63 1f 	mov    0xffffffff831f63e8,%rdi
ffffffff80100200:	83 
ffffffff80100201:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
ffffffff80100205:	48 c1 e0 05          	shl    $0x5,%rax
ffffffff80100209:	48 01 c7             	add    %rax,%rdi
ffffffff8010020c:	48 89 f8             	mov    %rdi,%rax
ffffffff8010020f:	48 83 c4 08          	add    $0x8,%rsp
ffffffff80100213:	5d                   	pop    %rbp
ffffffff80100214:	c3                   	retq   
ffffffff80100215:	66 66 2e 0f 1f 84 00 	data16 nopw %cs:0x0(%rax,%rax,1)
ffffffff8010021c:	00 00 00 00 

ffffffff80100220 <detect_memory>:
// Detect machine's physical memory setup.
// --------------------------------------------------------------

void
detect_memory(void)
{
ffffffff80100220:	55                   	push   %rbp
ffffffff80100221:	48 89 e5             	mov    %rsp,%rbp
  uint32_t i;
  struct e820_entry *e;
  size_t mem = 0, mem_max = -KERNBASE;
ffffffff80100224:	48 83 ec 60          	sub    $0x60,%rsp
ffffffff80100228:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
ffffffff8010022f:	00 
ffffffff80100230:	b8 00 00 00 80       	mov    $0x80000000,%eax
ffffffff80100235:	89 c1                	mov    %eax,%ecx
ffffffff80100237:	48 89 4d e0          	mov    %rcx,-0x20(%rbp)

  e = e820_map.entries;
ffffffff8010023b:	48 c7 45 f0 44 66 1f 	movq   $0xffffffff831f6644,-0x10(%rbp)
ffffffff80100242:	83 
  for (i = 0; i != e820_map.nr; ++i, ++e) {
ffffffff80100243:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
ffffffff8010024a:	8b 45 fc             	mov    -0x4(%rbp),%eax
ffffffff8010024d:	8b 0c 25 40 66 1f 83 	mov    0xffffffff831f6640,%ecx
ffffffff80100254:	39 c8                	cmp    %ecx,%eax
ffffffff80100256:	0f 84 7e 00 00 00    	je     ffffffff801002da <detect_memory+0xba>
    if (e->addr >= mem_max)
ffffffff8010025c:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
ffffffff80100260:	48 8b 00             	mov    (%rax),%rax
ffffffff80100263:	48 3b 45 e0          	cmp    -0x20(%rbp),%rax
ffffffff80100267:	0f 82 05 00 00 00    	jb     ffffffff80100272 <detect_memory+0x52>
      continue;
ffffffff8010026d:	e9 4e 00 00 00       	jmpq   ffffffff801002c0 <detect_memory+0xa0>
    mem = max(mem, (size_t)(e->addr + e->len));
ffffffff80100272:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
ffffffff80100276:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
ffffffff8010027a:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
ffffffff8010027e:	48 8b 00             	mov    (%rax),%rax
ffffffff80100281:	48 8b 4d f0          	mov    -0x10(%rbp),%rcx
ffffffff80100285:	48 03 41 08          	add    0x8(%rcx),%rax
ffffffff80100289:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
ffffffff8010028d:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
ffffffff80100291:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
ffffffff80100295:	0f 82 0d 00 00 00    	jb     ffffffff801002a8 <detect_memory+0x88>
ffffffff8010029b:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
ffffffff8010029f:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
ffffffff801002a3:	e9 08 00 00 00       	jmpq   ffffffff801002b0 <detect_memory+0x90>
ffffffff801002a8:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
ffffffff801002ac:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
ffffffff801002b0:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
ffffffff801002b4:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
ffffffff801002b8:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
ffffffff801002bc:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  for (i = 0; i != e820_map.nr; ++i, ++e) {
ffffffff801002c0:	8b 45 fc             	mov    -0x4(%rbp),%eax
ffffffff801002c3:	83 c0 01             	add    $0x1,%eax
ffffffff801002c6:	89 45 fc             	mov    %eax,-0x4(%rbp)
ffffffff801002c9:	48 8b 4d f0          	mov    -0x10(%rbp),%rcx
ffffffff801002cd:	48 83 c1 14          	add    $0x14,%rcx
ffffffff801002d1:	48 89 4d f0          	mov    %rcx,-0x10(%rbp)
ffffffff801002d5:	e9 70 ff ff ff       	jmpq   ffffffff8010024a <detect_memory+0x2a>
  }

  // Limit memory to 256MB.
  mem = min(mem, mem_max);
ffffffff801002da:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
ffffffff801002de:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
ffffffff801002e2:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
ffffffff801002e6:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
ffffffff801002ea:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
ffffffff801002ee:	48 3b 45 b8          	cmp    -0x48(%rbp),%rax
ffffffff801002f2:	0f 87 0d 00 00 00    	ja     ffffffff80100305 <detect_memory+0xe5>
ffffffff801002f8:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
ffffffff801002fc:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
ffffffff80100300:	e9 08 00 00 00       	jmpq   ffffffff8010030d <detect_memory+0xed>
ffffffff80100305:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
ffffffff80100309:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
ffffffff8010030d:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
ffffffff80100311:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
ffffffff80100315:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
ffffffff80100319:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  npages = mem / PGSIZE;
ffffffff8010031d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
ffffffff80100321:	48 c1 e8 0c          	shr    $0xc,%rax
ffffffff80100325:	89 c1                	mov    %eax,%ecx
ffffffff80100327:	89 0c 25 e0 63 1f 83 	mov    %ecx,0xffffffff831f63e0
  cprintf("E820: physical memory %dMB\n", mem / 1024 / 1024);
ffffffff8010032e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
ffffffff80100332:	48 c1 e8 0a          	shr    $0xa,%rax
ffffffff80100336:	48 c1 e8 0a          	shr    $0xa,%rax
ffffffff8010033a:	48 c7 c7 87 fa 10 80 	mov    $0xffffffff8010fa87,%rdi
ffffffff80100341:	31 c9                	xor    %ecx,%ecx
ffffffff80100343:	88 ca                	mov    %cl,%dl
ffffffff80100345:	48 89 c6             	mov    %rax,%rsi
ffffffff80100348:	88 d0                	mov    %dl,%al
ffffffff8010034a:	e8 11 06 00 00       	callq  ffffffff80100960 <cprintf>
}
ffffffff8010034f:	48 83 c4 60          	add    $0x60,%rsp
ffffffff80100353:	5d                   	pop    %rbp
ffffffff80100354:	c3                   	retq   
ffffffff80100355:	66 66 2e 0f 1f 84 00 	data16 nopw %cs:0x0(%rax,%rax,1)
ffffffff8010035c:	00 00 00 00 

ffffffff80100360 <core_map_ref_increment>:
} kmem;

// (These two assume the core map entry lock has been acquired, via
// acquire_entry_lock.)
void core_map_ref_increment(struct core_map_entry* entry)
{
ffffffff80100360:	55                   	push   %rbp
ffffffff80100361:	48 89 e5             	mov    %rsp,%rbp
ffffffff80100364:	50                   	push   %rax
ffffffff80100365:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  entry->ref_count++;
ffffffff80100369:	48 8b 7d f8          	mov    -0x8(%rbp),%rdi
ffffffff8010036d:	8a 47 18             	mov    0x18(%rdi),%al
ffffffff80100370:	04 01                	add    $0x1,%al
ffffffff80100372:	88 47 18             	mov    %al,0x18(%rdi)
}
ffffffff80100375:	48 83 c4 08          	add    $0x8,%rsp
ffffffff80100379:	5d                   	pop    %rbp
ffffffff8010037a:	c3                   	retq   
ffffffff8010037b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

ffffffff80100380 <core_map_ref_decrement>:

void core_map_ref_decrement(struct core_map_entry* entry)
{
ffffffff80100380:	55                   	push   %rbp
ffffffff80100381:	48 89 e5             	mov    %rsp,%rbp
ffffffff80100384:	48 83 ec 10          	sub    $0x10,%rsp
ffffffff80100388:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  if (entry->ref_count == 0) {
ffffffff8010038c:	48 8b 7d f8          	mov    -0x8(%rbp),%rdi
ffffffff80100390:	0f b6 47 18          	movzbl 0x18(%rdi),%eax
ffffffff80100394:	83 f8 00             	cmp    $0x0,%eax
ffffffff80100397:	0f 85 0c 00 00 00    	jne    ffffffff801003a9 <core_map_ref_decrement+0x29>
    panic("zero refcount--");
ffffffff8010039d:	48 c7 c7 a3 fa 10 80 	mov    $0xffffffff8010faa3,%rdi
ffffffff801003a4:	e8 c7 0a 00 00       	callq  ffffffff80100e70 <panic>
  }

  entry->ref_count--;
ffffffff801003a9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
ffffffff801003ad:	8a 48 18             	mov    0x18(%rax),%cl
ffffffff801003b0:	80 c1 ff             	add    $0xff,%cl
ffffffff801003b3:	88 48 18             	mov    %cl,0x18(%rax)
}
ffffffff801003b6:	48 83 c4 10          	add    $0x10,%rsp
ffffffff801003ba:	5d                   	pop    %rbp
ffffffff801003bb:	c3                   	retq   
ffffffff801003bc:	0f 1f 40 00          	nopl   0x0(%rax)

ffffffff801003c0 <acquire_entry_lock>:

// Acquire/release the core map entry lock. Should be held for the duration of
// code reading/writing any core map entry's ref_count.
void acquire_entry_lock()
{
ffffffff801003c0:	55                   	push   %rbp
ffffffff801003c1:	48 89 e5             	mov    %rsp,%rbp
  acquire(&kmem.entrylock);
ffffffff801003c4:	48 c7 c7 20 65 1f 83 	mov    $0xffffffff831f6520,%rdi
ffffffff801003cb:	e8 f0 53 00 00       	callq  ffffffff801057c0 <acquire>
}
ffffffff801003d0:	5d                   	pop    %rbp
ffffffff801003d1:	c3                   	retq   
ffffffff801003d2:	66 66 66 66 66 2e 0f 	data16 data16 data16 data16 nopw %cs:0x0(%rax,%rax,1)
ffffffff801003d9:	1f 84 00 00 00 00 00 

ffffffff801003e0 <release_entry_lock>:

void release_entry_lock()
{
ffffffff801003e0:	55                   	push   %rbp
ffffffff801003e1:	48 89 e5             	mov    %rsp,%rbp
  release(&kmem.entrylock);
ffffffff801003e4:	48 c7 c7 20 65 1f 83 	mov    $0xffffffff831f6520,%rdi
ffffffff801003eb:	e8 10 56 00 00       	callq  ffffffff80105a00 <release>
}
ffffffff801003f0:	5d                   	pop    %rbp
ffffffff801003f1:	c3                   	retq   
ffffffff801003f2:	66 66 66 66 66 2e 0f 	data16 data16 data16 data16 nopw %cs:0x0(%rax,%rax,1)
ffffffff801003f9:	1f 84 00 00 00 00 00 

ffffffff80100400 <mem_init>:
// the pages mapped by entrypgdir on free list.
// 2. main() calls kinit2() with the rest of the physical pages
// after installing a full page table that maps them on all cores.
void
mem_init(void *vstart)
{
ffffffff80100400:	55                   	push   %rbp
ffffffff80100401:	48 89 e5             	mov    %rsp,%rbp
ffffffff80100404:	48 83 ec 20          	sub    $0x20,%rsp
ffffffff80100408:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  void *vend;

  core_map = vstart;
ffffffff8010040c:	48 8b 7d f8          	mov    -0x8(%rbp),%rdi
ffffffff80100410:	48 89 3c 25 e8 63 1f 	mov    %rdi,0xffffffff831f63e8
ffffffff80100417:	83 
  memset(vstart, 0, PGROUNDUP(npages * sizeof (struct core_map_entry)));
ffffffff80100418:	48 8b 7d f8          	mov    -0x8(%rbp),%rdi
ffffffff8010041c:	8b 04 25 e0 63 1f 83 	mov    0xffffffff831f63e0,%eax
ffffffff80100423:	c1 e0 05             	shl    $0x5,%eax
ffffffff80100426:	05 ff 0f 00 00       	add    $0xfff,%eax
ffffffff8010042b:	25 00 f0 ff ff       	and    $0xfffff000,%eax
ffffffff80100430:	31 f6                	xor    %esi,%esi
ffffffff80100432:	89 c2                	mov    %eax,%edx
ffffffff80100434:	e8 c7 aa 00 00       	callq  ffffffff8010af00 <memset>
  vstart += PGROUNDUP(npages * sizeof (struct core_map_entry));
ffffffff80100439:	48 63 3c 25 e0 63 1f 	movslq 0xffffffff831f63e0,%rdi
ffffffff80100440:	83 
ffffffff80100441:	48 c1 e7 05          	shl    $0x5,%rdi
ffffffff80100445:	48 81 c7 ff 0f 00 00 	add    $0xfff,%rdi
ffffffff8010044c:	48 81 e7 00 f0 ff ff 	and    $0xfffffffffffff000,%rdi
ffffffff80100453:	48 8b 4d f8          	mov    -0x8(%rbp),%rcx
ffffffff80100457:	48 01 f9             	add    %rdi,%rcx
ffffffff8010045a:	48 89 4d f8          	mov    %rcx,-0x8(%rbp)

  initlock(&kmem.lock, "kmem");
ffffffff8010045e:	48 c7 c1 b8 64 1f 83 	mov    $0xffffffff831f64b8,%rcx
ffffffff80100465:	48 c7 c6 b3 fa 10 80 	mov    $0xffffffff8010fab3,%rsi
ffffffff8010046c:	48 89 cf             	mov    %rcx,%rdi
ffffffff8010046f:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
ffffffff80100473:	48 89 4d e0          	mov    %rcx,-0x20(%rbp)
ffffffff80100477:	e8 04 53 00 00       	callq  ffffffff80105780 <initlock>
  initlock(&kmem.lock, "kmem entry");
ffffffff8010047c:	48 c7 c6 b8 fa 10 80 	mov    $0xffffffff8010fab8,%rsi
ffffffff80100483:	48 8b 7d e0          	mov    -0x20(%rbp),%rdi
ffffffff80100487:	e8 f4 52 00 00       	callq  ffffffff80105780 <initlock>
  kmem.use_lock = 0;
ffffffff8010048c:	c7 04 25 88 65 1f 83 	movl   $0x0,0xffffffff831f6588
ffffffff80100493:	00 00 00 00 
  kmem.freelist = 0;
ffffffff80100497:	48 c7 04 25 90 65 1f 	movq   $0x0,0xffffffff831f6590
ffffffff8010049e:	83 00 00 00 00 

  vend = (void *) P2V((uint64_t)(npages * PGSIZE));
ffffffff801004a3:	8b 14 25 e0 63 1f 83 	mov    0xffffffff831f63e0,%edx
ffffffff801004aa:	c1 e2 0c             	shl    $0xc,%edx
ffffffff801004ad:	48 63 c2             	movslq %edx,%rax
ffffffff801004b0:	48 05 00 00 00 80    	add    $0xffffffff80000000,%rax
ffffffff801004b6:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  freerange(vstart, vend);
ffffffff801004ba:	48 8b 7d f8          	mov    -0x8(%rbp),%rdi
ffffffff801004be:	48 8b 75 f0          	mov    -0x10(%rbp),%rsi
ffffffff801004c2:	e8 49 00 00 00       	callq  ffffffff80100510 <freerange>
  free_pages = (vend - vstart) >> PT_SHIFT;
ffffffff801004c7:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
ffffffff801004cb:	48 8b 4d f8          	mov    -0x8(%rbp),%rcx
ffffffff801004cf:	48 29 c8             	sub    %rcx,%rax
ffffffff801004d2:	48 c1 e8 0c          	shr    $0xc,%rax
ffffffff801004d6:	89 c2                	mov    %eax,%edx
ffffffff801004d8:	89 14 25 98 65 1f 83 	mov    %edx,0xffffffff831f6598
  pages_in_use = 0;
ffffffff801004df:	c7 04 25 a0 65 1f 83 	movl   $0x0,0xffffffff831f65a0
ffffffff801004e6:	00 00 00 00 
  pages_in_swap = 0;
ffffffff801004ea:	c7 04 25 a8 65 1f 83 	movl   $0x0,0xffffffff831f65a8
ffffffff801004f1:	00 00 00 00 
  kmem.use_lock = 1;
ffffffff801004f5:	c7 04 25 88 65 1f 83 	movl   $0x1,0xffffffff831f6588
ffffffff801004fc:	01 00 00 00 
}
ffffffff80100500:	48 83 c4 20          	add    $0x20,%rsp
ffffffff80100504:	5d                   	pop    %rbp
ffffffff80100505:	c3                   	retq   
ffffffff80100506:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
ffffffff8010050d:	00 00 00 

ffffffff80100510 <freerange>:

void
freerange(void *vstart, void *vend)
{
ffffffff80100510:	55                   	push   %rbp
ffffffff80100511:	48 89 e5             	mov    %rsp,%rbp
ffffffff80100514:	48 83 ec 20          	sub    $0x20,%rsp
ffffffff80100518:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
ffffffff8010051c:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  char *p;
  p = (char*)PGROUNDUP((uint64_t)vstart);
ffffffff80100520:	48 8b 75 f8          	mov    -0x8(%rbp),%rsi
ffffffff80100524:	48 81 c6 00 10 00 00 	add    $0x1000,%rsi
ffffffff8010052b:	48 83 ee 01          	sub    $0x1,%rsi
ffffffff8010052f:	48 81 e6 00 f0 ff ff 	and    $0xfffffffffffff000,%rsi
ffffffff80100536:	48 89 75 e8          	mov    %rsi,-0x18(%rbp)
  for(; p + PGSIZE <= (char*)vend; p += PGSIZE)
ffffffff8010053a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
ffffffff8010053e:	48 05 00 10 00 00    	add    $0x1000,%rax
ffffffff80100544:	48 3b 45 f0          	cmp    -0x10(%rbp),%rax
ffffffff80100548:	0f 87 1c 00 00 00    	ja     ffffffff8010056a <freerange+0x5a>
    kfree(p);
ffffffff8010054e:	48 8b 7d e8          	mov    -0x18(%rbp),%rdi
ffffffff80100552:	e8 19 00 00 00       	callq  ffffffff80100570 <kfree>
  for(; p + PGSIZE <= (char*)vend; p += PGSIZE)
ffffffff80100557:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
ffffffff8010055b:	48 05 00 10 00 00    	add    $0x1000,%rax
ffffffff80100561:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
ffffffff80100565:	e9 d0 ff ff ff       	jmpq   ffffffff8010053a <freerange+0x2a>
}
ffffffff8010056a:	48 83 c4 20          	add    $0x20,%rsp
ffffffff8010056e:	5d                   	pop    %rbp
ffffffff8010056f:	c3                   	retq   

ffffffff80100570 <kfree>:
// which normally should have been returned by a
// call to kalloc().  (The exception is when
// initializing the allocator; see kinit above.)
void
kfree(char *v)
{
ffffffff80100570:	55                   	push   %rbp
ffffffff80100571:	48 89 e5             	mov    %rsp,%rbp
ffffffff80100574:	48 83 ec 20          	sub    $0x20,%rsp
ffffffff80100578:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  struct core_map_entry *r;

  if((uint64_t)v % PGSIZE || v < _end || V2P(v) >= (uint64_t)(npages * PGSIZE))
ffffffff8010057c:	48 8b 7d f8          	mov    -0x8(%rbp),%rdi
ffffffff80100580:	48 81 e7 ff 0f 00 00 	and    $0xfff,%rdi
ffffffff80100587:	48 83 ff 00          	cmp    $0x0,%rdi
ffffffff8010058b:	0f 85 3d 00 00 00    	jne    ffffffff801005ce <kfree+0x5e>
ffffffff80100591:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
ffffffff80100595:	48 c7 c1 00 60 22 83 	mov    $0xffffffff83226000,%rcx
ffffffff8010059c:	48 29 c8             	sub    %rcx,%rax
ffffffff8010059f:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
ffffffff801005a3:	0f 82 25 00 00 00    	jb     ffffffff801005ce <kfree+0x5e>
ffffffff801005a9:	e9 00 00 00 00       	jmpq   ffffffff801005ae <kfree+0x3e>
ffffffff801005ae:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
ffffffff801005b2:	48 2d 00 00 00 80    	sub    $0xffffffff80000000,%rax
ffffffff801005b8:	8b 0c 25 e0 63 1f 83 	mov    0xffffffff831f63e0,%ecx
ffffffff801005bf:	c1 e1 0c             	shl    $0xc,%ecx
ffffffff801005c2:	48 63 d1             	movslq %ecx,%rdx
ffffffff801005c5:	48 39 d0             	cmp    %rdx,%rax
ffffffff801005c8:	0f 82 0c 00 00 00    	jb     ffffffff801005da <kfree+0x6a>
    panic("kfree");
ffffffff801005ce:	48 c7 c7 c3 fa 10 80 	mov    $0xffffffff8010fac3,%rdi
ffffffff801005d5:	e8 96 08 00 00       	callq  ffffffff80100e70 <panic>

  if(kmem.use_lock)
ffffffff801005da:	8b 04 25 88 65 1f 83 	mov    0xffffffff831f6588,%eax
ffffffff801005e1:	83 f8 00             	cmp    $0x0,%eax
ffffffff801005e4:	0f 84 0c 00 00 00    	je     ffffffff801005f6 <kfree+0x86>
    acquire(&kmem.lock);
ffffffff801005ea:	48 c7 c7 b8 64 1f 83 	mov    $0xffffffff831f64b8,%rdi
ffffffff801005f1:	e8 ca 51 00 00       	callq  ffffffff801057c0 <acquire>

  r = (struct core_map_entry*)pa2page(V2P(v));
ffffffff801005f6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
ffffffff801005fa:	48 2d 00 00 00 80    	sub    $0xffffffff80000000,%rax
ffffffff80100600:	48 89 c7             	mov    %rax,%rdi
ffffffff80100603:	e8 48 fb ff ff       	callq  ffffffff80100150 <pa2page>
ffffffff80100608:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

  if (r->ref_count > 0) {
ffffffff8010060c:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
ffffffff80100610:	0f b6 48 18          	movzbl 0x18(%rax),%ecx
ffffffff80100614:	83 f9 00             	cmp    $0x0,%ecx
ffffffff80100617:	0f 8e 0d 00 00 00    	jle    ffffffff8010062a <kfree+0xba>
    r->ref_count--;
ffffffff8010061d:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
ffffffff80100621:	8a 48 18             	mov    0x18(%rax),%cl
ffffffff80100624:	80 c1 ff             	add    $0xff,%cl
ffffffff80100627:	88 48 18             	mov    %cl,0x18(%rax)
  }

  if (r->ref_count == 0) {
ffffffff8010062a:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
ffffffff8010062e:	0f b6 48 18          	movzbl 0x18(%rax),%ecx
ffffffff80100632:	83 f9 00             	cmp    $0x0,%ecx
ffffffff80100635:	0f 85 74 00 00 00    	jne    ffffffff801006af <kfree+0x13f>
    pages_in_use --;
ffffffff8010063b:	8b 04 25 a0 65 1f 83 	mov    0xffffffff831f65a0,%eax
ffffffff80100642:	ff c8                	dec    %eax
ffffffff80100644:	89 04 25 a0 65 1f 83 	mov    %eax,0xffffffff831f65a0
    free_pages ++;
ffffffff8010064b:	8b 04 25 98 65 1f 83 	mov    0xffffffff831f6598,%eax
ffffffff80100652:	ff c0                	inc    %eax
ffffffff80100654:	89 04 25 98 65 1f 83 	mov    %eax,0xffffffff831f6598

    // Fill with junk to catch dangling refs.
    memset(v, 2, PGSIZE);
ffffffff8010065b:	48 8b 7d f8          	mov    -0x8(%rbp),%rdi
ffffffff8010065f:	be 02 00 00 00       	mov    $0x2,%esi
ffffffff80100664:	ba 00 10 00 00       	mov    $0x1000,%edx
ffffffff80100669:	e8 92 a8 00 00       	callq  ffffffff8010af00 <memset>

    r->pid = -1;
ffffffff8010066e:	48 8b 7d f0          	mov    -0x10(%rbp),%rdi
ffffffff80100672:	c7 47 14 ff ff ff ff 	movl   $0xffffffff,0x14(%rdi)
    r->va = 0;
ffffffff80100679:	48 8b 7d f0          	mov    -0x10(%rbp),%rdi
ffffffff8010067d:	48 c7 47 08 00 00 00 	movq   $0x0,0x8(%rdi)
ffffffff80100684:	00 
    r->refbits = 0;
ffffffff80100685:	48 8b 7d f0          	mov    -0x10(%rbp),%rdi
ffffffff80100689:	c7 47 10 00 00 00 00 	movl   $0x0,0x10(%rdi)
    r->next = kmem.freelist;
ffffffff80100690:	48 8b 3c 25 90 65 1f 	mov    0xffffffff831f6590,%rdi
ffffffff80100697:	83 
ffffffff80100698:	48 8b 4d f0          	mov    -0x10(%rbp),%rcx
ffffffff8010069c:	48 89 39             	mov    %rdi,(%rcx)
    kmem.freelist = r;
ffffffff8010069f:	48 8b 4d f0          	mov    -0x10(%rbp),%rcx
ffffffff801006a3:	48 89 0c 25 90 65 1f 	mov    %rcx,0xffffffff831f6590
ffffffff801006aa:	83 
ffffffff801006ab:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  }

  if(kmem.use_lock)
ffffffff801006af:	8b 04 25 88 65 1f 83 	mov    0xffffffff831f6588,%eax
ffffffff801006b6:	83 f8 00             	cmp    $0x0,%eax
ffffffff801006b9:	0f 84 0c 00 00 00    	je     ffffffff801006cb <kfree+0x15b>
    release(&kmem.lock);
ffffffff801006bf:	48 c7 c7 b8 64 1f 83 	mov    $0xffffffff831f64b8,%rdi
ffffffff801006c6:	e8 35 53 00 00       	callq  ffffffff80105a00 <release>
}
ffffffff801006cb:	48 83 c4 20          	add    $0x20,%rsp
ffffffff801006cf:	5d                   	pop    %rbp
ffffffff801006d0:	c3                   	retq   
ffffffff801006d1:	66 66 66 66 66 66 2e 	data16 data16 data16 data16 data16 nopw %cs:0x0(%rax,%rax,1)
ffffffff801006d8:	0f 1f 84 00 00 00 00 
ffffffff801006df:	00 

ffffffff801006e0 <add_phy_mem_map>:

void
add_phy_mem_map(int pid, uint64_t va, uint64_t pa) {
ffffffff801006e0:	55                   	push   %rbp
ffffffff801006e1:	48 89 e5             	mov    %rsp,%rbp
ffffffff801006e4:	48 83 ec 20          	sub    $0x20,%rsp
ffffffff801006e8:	89 7d fc             	mov    %edi,-0x4(%rbp)
ffffffff801006eb:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
ffffffff801006ef:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  // check if it is a kernel mem map
  if (pid == -1)
ffffffff801006f3:	83 7d fc ff          	cmpl   $0xffffffff,-0x4(%rbp)
ffffffff801006f7:	0f 85 05 00 00 00    	jne    ffffffff80100702 <add_phy_mem_map+0x22>
    return;
ffffffff801006fd:	e9 23 00 00 00       	jmpq   ffffffff80100725 <add_phy_mem_map+0x45>

  // for user mem, add an mapping to proc_info
  struct core_map_entry *r = pa2page(pa);
ffffffff80100702:	48 8b 7d e8          	mov    -0x18(%rbp),%rdi
ffffffff80100706:	e8 45 fa ff ff       	callq  ffffffff80100150 <pa2page>
ffffffff8010070b:	48 89 45 e0          	mov    %rax,-0x20(%rbp)

  r->pid = pid;
ffffffff8010070f:	8b 4d fc             	mov    -0x4(%rbp),%ecx
ffffffff80100712:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
ffffffff80100716:	89 48 14             	mov    %ecx,0x14(%rax)
  r->va = va;
ffffffff80100719:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
ffffffff8010071d:	48 8b 7d e0          	mov    -0x20(%rbp),%rdi
ffffffff80100721:	48 89 47 08          	mov    %rax,0x8(%rdi)
}
ffffffff80100725:	48 83 c4 20          	add    $0x20,%rsp
ffffffff80100729:	5d                   	pop    %rbp
ffffffff8010072a:	c3                   	retq   
ffffffff8010072b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

ffffffff80100730 <remove_phy_mem_map>:

void
remove_phy_mem_map(int pid, uint64_t va, uint64_t pa) {
ffffffff80100730:	55                   	push   %rbp
ffffffff80100731:	48 89 e5             	mov    %rsp,%rbp
ffffffff80100734:	48 83 ec 20          	sub    $0x20,%rsp
ffffffff80100738:	89 7d fc             	mov    %edi,-0x4(%rbp)
ffffffff8010073b:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
ffffffff8010073f:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  // check if it is a kernal mem map
  if (pid == -1)
ffffffff80100743:	83 7d fc ff          	cmpl   $0xffffffff,-0x4(%rbp)
ffffffff80100747:	0f 85 05 00 00 00    	jne    ffffffff80100752 <remove_phy_mem_map+0x22>
    return;
ffffffff8010074d:	e9 24 00 00 00       	jmpq   ffffffff80100776 <remove_phy_mem_map+0x46>
  // for user mem, add an mapping to proc_info
  struct core_map_entry *r = pa2page(pa);
ffffffff80100752:	48 8b 7d e8          	mov    -0x18(%rbp),%rdi
ffffffff80100756:	e8 f5 f9 ff ff       	callq  ffffffff80100150 <pa2page>
ffffffff8010075b:	48 89 45 e0          	mov    %rax,-0x20(%rbp)

  r->pid = -1;
ffffffff8010075f:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
ffffffff80100763:	c7 40 14 ff ff ff ff 	movl   $0xffffffff,0x14(%rax)
  r->va = 0;
ffffffff8010076a:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
ffffffff8010076e:	48 c7 40 08 00 00 00 	movq   $0x0,0x8(%rax)
ffffffff80100775:	00 
}
ffffffff80100776:	48 83 c4 20          	add    $0x20,%rsp
ffffffff8010077a:	5d                   	pop    %rbp
ffffffff8010077b:	c3                   	retq   
ffffffff8010077c:	0f 1f 40 00          	nopl   0x0(%rax)

ffffffff80100780 <kalloc>:

char*
kalloc(void)
{
ffffffff80100780:	55                   	push   %rbp
ffffffff80100781:	48 89 e5             	mov    %rsp,%rbp
  pages_in_use ++;
ffffffff80100784:	48 83 ec 10          	sub    $0x10,%rsp
ffffffff80100788:	8b 04 25 a0 65 1f 83 	mov    0xffffffff831f65a0,%eax
ffffffff8010078f:	ff c0                	inc    %eax
ffffffff80100791:	89 04 25 a0 65 1f 83 	mov    %eax,0xffffffff831f65a0
  free_pages --;
ffffffff80100798:	8b 04 25 98 65 1f 83 	mov    0xffffffff831f6598,%eax
ffffffff8010079f:	ff c8                	dec    %eax
ffffffff801007a1:	89 04 25 98 65 1f 83 	mov    %eax,0xffffffff831f6598

  swap_evict_if_needed();
ffffffff801007a8:	31 c0                	xor    %eax,%eax
ffffffff801007aa:	88 c1                	mov    %al,%cl
ffffffff801007ac:	88 c8                	mov    %cl,%al
ffffffff801007ae:	e8 ad e9 00 00       	callq  ffffffff8010f160 <swap_evict_if_needed>

  struct core_map_entry *r;

  if(kmem.use_lock)
ffffffff801007b3:	8b 14 25 88 65 1f 83 	mov    0xffffffff831f6588,%edx
ffffffff801007ba:	83 fa 00             	cmp    $0x0,%edx
ffffffff801007bd:	0f 84 0c 00 00 00    	je     ffffffff801007cf <kalloc+0x4f>
    acquire(&kmem.lock);
ffffffff801007c3:	48 c7 c7 b8 64 1f 83 	mov    $0xffffffff831f64b8,%rdi
ffffffff801007ca:	e8 f1 4f 00 00       	callq  ffffffff801057c0 <acquire>
  r = kmem.freelist;
ffffffff801007cf:	48 8b 04 25 90 65 1f 	mov    0xffffffff831f6590,%rax
ffffffff801007d6:	83 
ffffffff801007d7:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  if(r) {
ffffffff801007db:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
ffffffff801007e0:	0f 84 4b 00 00 00    	je     ffffffff80100831 <kalloc+0xb1>
    kmem.freelist = r->next;
ffffffff801007e6:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
ffffffff801007ea:	48 8b 00             	mov    (%rax),%rax
ffffffff801007ed:	48 89 04 25 90 65 1f 	mov    %rax,0xffffffff831f6590
ffffffff801007f4:	83 
    r->ref_count = 1;
ffffffff801007f5:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
ffffffff801007f9:	c6 40 18 01          	movb   $0x1,0x18(%rax)
    if(kmem.use_lock)
ffffffff801007fd:	8b 0c 25 88 65 1f 83 	mov    0xffffffff831f6588,%ecx
ffffffff80100804:	83 f9 00             	cmp    $0x0,%ecx
ffffffff80100807:	0f 84 0c 00 00 00    	je     ffffffff80100819 <kalloc+0x99>
      release(&kmem.lock);
ffffffff8010080d:	48 c7 c7 b8 64 1f 83 	mov    $0xffffffff831f64b8,%rdi
ffffffff80100814:	e8 e7 51 00 00       	callq  ffffffff80105a00 <release>

    return P2V(page2pa(r));
ffffffff80100819:	48 8b 7d f0          	mov    -0x10(%rbp),%rdi
ffffffff8010081d:	e8 9e f9 ff ff       	callq  ffffffff801001c0 <page2pa>
ffffffff80100822:	48 05 00 00 00 80    	add    $0xffffffff80000000,%rax
ffffffff80100828:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
ffffffff8010082c:	e9 24 00 00 00       	jmpq   ffffffff80100855 <kalloc+0xd5>
  }

  if(kmem.use_lock)
ffffffff80100831:	8b 04 25 88 65 1f 83 	mov    0xffffffff831f6588,%eax
ffffffff80100838:	83 f8 00             	cmp    $0x0,%eax
ffffffff8010083b:	0f 84 0c 00 00 00    	je     ffffffff8010084d <kalloc+0xcd>
    release(&kmem.lock);
ffffffff80100841:	48 c7 c7 b8 64 1f 83 	mov    $0xffffffff831f64b8,%rdi
ffffffff80100848:	e8 b3 51 00 00       	callq  ffffffff80105a00 <release>

  return 0;
ffffffff8010084d:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
ffffffff80100854:	00 
}
ffffffff80100855:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
ffffffff80100859:	48 83 c4 10          	add    $0x10,%rsp
ffffffff8010085d:	5d                   	pop    %rbp
ffffffff8010085e:	c3                   	retq   
ffffffff8010085f:	90                   	nop

ffffffff80100860 <main>:
noreturn static void mpmain(void);
extern char _end[]; // first address after kernel loaded from ELF file

int
main(uint64_t addr)
{
ffffffff80100860:	55                   	push   %rbp
ffffffff80100861:	48 89 e5             	mov    %rsp,%rbp
ffffffff80100864:	48 83 ec 20          	sub    $0x20,%rsp
ffffffff80100868:	48 89 7d f0          	mov    %rdi,-0x10(%rbp)
  e820_init(addr);
ffffffff8010086c:	48 8b 7d f0          	mov    -0x10(%rbp),%rdi
ffffffff80100870:	e8 1b 19 00 00       	callq  ffffffff80102190 <e820_init>
  detect_memory();
ffffffff80100875:	e8 a6 f9 ff ff       	callq  ffffffff80100220 <detect_memory>
  mem_init(_end); // phys page allocator
ffffffff8010087a:	48 c7 c7 00 60 22 83 	mov    $0xffffffff83226000,%rdi
ffffffff80100881:	e8 7a fb ff ff       	callq  ffffffff80100400 <mem_init>
  kvmalloc();      // kernel page table
ffffffff80100886:	e8 05 2d 00 00       	callq  ffffffff80103590 <kvmalloc>
  mpinit();
ffffffff8010088b:	e8 90 64 00 00       	callq  ffffffff80106d20 <mpinit>
  lapicinit();
ffffffff80100890:	e8 2b 10 00 00       	callq  ffffffff801018c0 <lapicinit>
  seginit();
ffffffff80100895:	e8 56 1a 00 00       	callq  ffffffff801022f0 <seginit>
  picinit();
ffffffff8010089a:	e8 a1 6a 00 00       	callq  ffffffff80107340 <picinit>
  ioapicinit();
ffffffff8010089f:	e8 bc 9c 00 00       	callq  ffffffff8010a560 <ioapicinit>
  consoleinit();
ffffffff801008a4:	e8 27 0d 00 00       	callq  ffffffff801015d0 <consoleinit>
  uartinit();      // serial port
ffffffff801008a9:	e8 f2 a0 00 00       	callq  ffffffff8010a9a0 <uartinit>
  cpuid_print();
ffffffff801008ae:	e8 8d ab 00 00       	callq  ffffffff8010b440 <cpuid_print>
ffffffff801008b3:	31 c0                	xor    %eax,%eax
ffffffff801008b5:	88 c1                	mov    %al,%cl
  e820_print();
ffffffff801008b7:	88 c8                	mov    %cl,%al
ffffffff801008b9:	88 4d ef             	mov    %cl,-0x11(%rbp)
ffffffff801008bc:	e8 9f 17 00 00       	callq  ffffffff80102060 <e820_print>
  cprintf("\ncpu%d: starting xk\n\n", cpunum());
ffffffff801008c1:	e8 da 11 00 00       	callq  ffffffff80101aa0 <cpunum>
ffffffff801008c6:	48 c7 c7 19 fb 10 80 	mov    $0xffffffff8010fb19,%rdi
ffffffff801008cd:	89 c6                	mov    %eax,%esi
ffffffff801008cf:	8a 45 ef             	mov    -0x11(%rbp),%al
ffffffff801008d2:	e8 89 00 00 00       	callq  ffffffff80100960 <cprintf>
  cprintf("free pages: %d\n", free_pages);
ffffffff801008d7:	8b 34 25 98 65 1f 83 	mov    0xffffffff831f6598,%esi
ffffffff801008de:	48 c7 c7 2f fb 10 80 	mov    $0xffffffff8010fb2f,%rdi
ffffffff801008e5:	31 d2                	xor    %edx,%edx
ffffffff801008e7:	88 d0                	mov    %dl,%al
ffffffff801008e9:	e8 72 00 00 00       	callq  ffffffff80100960 <cprintf>
  pinit();
ffffffff801008ee:	e8 7d 6d 00 00       	callq  ffffffff80107670 <pinit>
  gftinit();       // global file description table
ffffffff801008f3:	e8 e8 c2 00 00       	callq  ffffffff8010cbe0 <gftinit>
  tvinit();        // trap vectors
ffffffff801008f8:	e8 d3 5c 00 00       	callq  ffffffff801065d0 <tvinit>
  binit();         // buffer cache
ffffffff801008fd:	e8 3e 98 00 00       	callq  ffffffff8010a140 <binit>
  ideinit();       // disk
ffffffff80100902:	e8 f9 ef 00 00       	callq  ffffffff8010f900 <ideinit>
  swapinit();      // swap region
ffffffff80100907:	31 d2                	xor    %edx,%edx
ffffffff80100909:	88 d0                	mov    %dl,%al
ffffffff8010090b:	e8 10 df 00 00       	callq  ffffffff8010e820 <swapinit>
  journal_init();
ffffffff80100910:	31 d2                	xor    %edx,%edx
ffffffff80100912:	88 d0                	mov    %dl,%al
ffffffff80100914:	e8 97 ea 00 00       	callq  ffffffff8010f3b0 <journal_init>
  userinit();      // first user process
ffffffff80100919:	e8 32 70 00 00       	callq  ffffffff80107950 <userinit>
  mpmain();
ffffffff8010091e:	e8 0d 00 00 00       	callq  ffffffff80100930 <mpmain>
ffffffff80100923:	66 66 66 66 2e 0f 1f 	data16 data16 data16 nopw %cs:0x0(%rax,%rax,1)
ffffffff8010092a:	84 00 00 00 00 00 

ffffffff80100930 <mpmain>:


// Common CPU setup code.
static void
mpmain(void)
{
ffffffff80100930:	55                   	push   %rbp
ffffffff80100931:	48 89 e5             	mov    %rsp,%rbp
  cprintf("cpu%d: starting\n", cpunum());
ffffffff80100934:	e8 67 11 00 00       	callq  ffffffff80101aa0 <cpunum>
ffffffff80100939:	48 c7 c7 3f fb 10 80 	mov    $0xffffffff8010fb3f,%rdi
ffffffff80100940:	31 c9                	xor    %ecx,%ecx
ffffffff80100942:	88 ca                	mov    %cl,%dl
ffffffff80100944:	89 c6                	mov    %eax,%esi
ffffffff80100946:	88 d0                	mov    %dl,%al
ffffffff80100948:	e8 13 00 00 00       	callq  ffffffff80100960 <cprintf>
  idtinit();       // load idt register
ffffffff8010094d:	e8 ce 5e 00 00       	callq  ffffffff80106820 <idtinit>
  // xchg(&cpu->started, 1); // tell startothers() we're up
  scheduler();     // start running processes
ffffffff80100952:	e8 b9 7b 00 00       	callq  ffffffff80108510 <scheduler>
ffffffff80100957:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
ffffffff8010095e:	00 00 

ffffffff80100960 <cprintf>:
//PAGEBREAK: 50

// Print to the console. only understands %d, %x, %p, %s.
void
cprintf(char *fmt, ...)
{
ffffffff80100960:	55                   	push   %rbp
ffffffff80100961:	48 89 e5             	mov    %rsp,%rbp
ffffffff80100964:	48 81 ec 30 01 00 00 	sub    $0x130,%rsp
ffffffff8010096b:	4c 89 4d b8          	mov    %r9,-0x48(%rbp)
ffffffff8010096f:	4c 89 45 b0          	mov    %r8,-0x50(%rbp)
ffffffff80100973:	48 89 4d a8          	mov    %rcx,-0x58(%rbp)
ffffffff80100977:	48 89 55 a0          	mov    %rdx,-0x60(%rbp)
ffffffff8010097b:	48 89 75 98          	mov    %rsi,-0x68(%rbp)
ffffffff8010097f:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
ffffffff80100983:	48 8d 4d 90          	lea    -0x70(%rbp),%rcx
  int i, c, locking;
  int lflag;
  char *s;
  va_list valist;
  va_start(valist, fmt);
ffffffff80100987:	48 89 4d d0          	mov    %rcx,-0x30(%rbp)
ffffffff8010098b:	48 8d 4d 10          	lea    0x10(%rbp),%rcx
ffffffff8010098f:	48 89 4d c8          	mov    %rcx,-0x38(%rbp)
ffffffff80100993:	c7 45 c4 30 00 00 00 	movl   $0x30,-0x3c(%rbp)
ffffffff8010099a:	c7 45 c0 08 00 00 00 	movl   $0x8,-0x40(%rbp)

  locking = cons.locking;
ffffffff801009a1:	8b 04 25 68 64 1f 83 	mov    0xffffffff831f6468,%eax
ffffffff801009a8:	89 45 ec             	mov    %eax,-0x14(%rbp)
  if(locking)
ffffffff801009ab:	83 7d ec 00          	cmpl   $0x0,-0x14(%rbp)
ffffffff801009af:	0f 84 0c 00 00 00    	je     ffffffff801009c1 <cprintf+0x61>
    acquire(&cons.lock);
ffffffff801009b5:	48 c7 c7 00 64 1f 83 	mov    $0xffffffff831f6400,%rdi
ffffffff801009bc:	e8 ff 4d 00 00       	callq  ffffffff801057c0 <acquire>

  if (fmt == 0)
ffffffff801009c1:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
ffffffff801009c6:	0f 85 0c 00 00 00    	jne    ffffffff801009d8 <cprintf+0x78>
    panic("null fmt");
ffffffff801009cc:	48 c7 c7 50 fb 10 80 	mov    $0xffffffff8010fb50,%rdi
ffffffff801009d3:	e8 98 04 00 00       	callq  ffffffff80100e70 <panic>

  for(i = 0; (c = fmt[i] & 0xff) != 0; i++){
ffffffff801009d8:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)
ffffffff801009df:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
ffffffff801009e3:	48 63 4d f4          	movslq -0xc(%rbp),%rcx
ffffffff801009e7:	0f be 14 08          	movsbl (%rax,%rcx,1),%edx
ffffffff801009eb:	81 e2 ff 00 00 00    	and    $0xff,%edx
ffffffff801009f1:	89 55 f0             	mov    %edx,-0x10(%rbp)
ffffffff801009f4:	83 fa 00             	cmp    $0x0,%edx
ffffffff801009f7:	0f 84 51 04 00 00    	je     ffffffff80100e4e <cprintf+0x4ee>
    if(c != '%'){
ffffffff801009fd:	83 7d f0 25          	cmpl   $0x25,-0x10(%rbp)
ffffffff80100a01:	0f 84 0d 00 00 00    	je     ffffffff80100a14 <cprintf+0xb4>
      consputc(c);
ffffffff80100a07:	8b 7d f0             	mov    -0x10(%rbp),%edi
ffffffff80100a0a:	e8 11 05 00 00       	callq  ffffffff80100f20 <consputc>
      continue;
ffffffff80100a0f:	e9 2c 04 00 00       	jmpq   ffffffff80100e40 <cprintf+0x4e0>
    }
    lflag = 0;
ffffffff80100a14:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%rbp)
  reswitch:
    c = fmt[++i] & 0xff;
ffffffff80100a1b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
ffffffff80100a1f:	8b 4d f4             	mov    -0xc(%rbp),%ecx
ffffffff80100a22:	83 c1 01             	add    $0x1,%ecx
ffffffff80100a25:	89 4d f4             	mov    %ecx,-0xc(%rbp)
ffffffff80100a28:	48 63 d1             	movslq %ecx,%rdx
ffffffff80100a2b:	0f be 0c 10          	movsbl (%rax,%rdx,1),%ecx
ffffffff80100a2f:	81 e1 ff 00 00 00    	and    $0xff,%ecx
ffffffff80100a35:	89 4d f0             	mov    %ecx,-0x10(%rbp)
    if(c == 0)
ffffffff80100a38:	83 7d f0 00          	cmpl   $0x0,-0x10(%rbp)
ffffffff80100a3c:	0f 85 05 00 00 00    	jne    ffffffff80100a47 <cprintf+0xe7>
      break;
ffffffff80100a42:	e9 07 04 00 00       	jmpq   ffffffff80100e4e <cprintf+0x4ee>
    switch(c){
ffffffff80100a47:	8b 45 f0             	mov    -0x10(%rbp),%eax
ffffffff80100a4a:	89 c1                	mov    %eax,%ecx
ffffffff80100a4c:	83 e9 25             	sub    $0x25,%ecx
ffffffff80100a4f:	89 45 8c             	mov    %eax,-0x74(%rbp)
ffffffff80100a52:	89 4d 88             	mov    %ecx,-0x78(%rbp)
ffffffff80100a55:	0f 84 a9 03 00 00    	je     ffffffff80100e04 <cprintf+0x4a4>
ffffffff80100a5b:	e9 00 00 00 00       	jmpq   ffffffff80100a60 <cprintf+0x100>
ffffffff80100a60:	8b 45 8c             	mov    -0x74(%rbp),%eax
ffffffff80100a63:	83 e8 64             	sub    $0x64,%eax
ffffffff80100a66:	89 45 84             	mov    %eax,-0x7c(%rbp)
ffffffff80100a69:	0f 84 5e 00 00 00    	je     ffffffff80100acd <cprintf+0x16d>
ffffffff80100a6f:	e9 00 00 00 00       	jmpq   ffffffff80100a74 <cprintf+0x114>
ffffffff80100a74:	8b 45 8c             	mov    -0x74(%rbp),%eax
ffffffff80100a77:	83 e8 6c             	sub    $0x6c,%eax
ffffffff80100a7a:	89 45 80             	mov    %eax,-0x80(%rbp)
ffffffff80100a7d:	0f 84 81 01 00 00    	je     ffffffff80100c04 <cprintf+0x2a4>
ffffffff80100a83:	e9 00 00 00 00       	jmpq   ffffffff80100a88 <cprintf+0x128>
ffffffff80100a88:	8b 45 8c             	mov    -0x74(%rbp),%eax
ffffffff80100a8b:	83 e8 70             	sub    $0x70,%eax
ffffffff80100a8e:	89 85 7c ff ff ff    	mov    %eax,-0x84(%rbp)
ffffffff80100a94:	0f 84 8c 01 00 00    	je     ffffffff80100c26 <cprintf+0x2c6>
ffffffff80100a9a:	e9 00 00 00 00       	jmpq   ffffffff80100a9f <cprintf+0x13f>
ffffffff80100a9f:	8b 45 8c             	mov    -0x74(%rbp),%eax
ffffffff80100aa2:	83 e8 73             	sub    $0x73,%eax
ffffffff80100aa5:	89 85 78 ff ff ff    	mov    %eax,-0x88(%rbp)
ffffffff80100aab:	0f 84 a0 02 00 00    	je     ffffffff80100d51 <cprintf+0x3f1>
ffffffff80100ab1:	e9 00 00 00 00       	jmpq   ffffffff80100ab6 <cprintf+0x156>
ffffffff80100ab6:	8b 45 8c             	mov    -0x74(%rbp),%eax
ffffffff80100ab9:	83 e8 78             	sub    $0x78,%eax
ffffffff80100abc:	89 85 74 ff ff ff    	mov    %eax,-0x8c(%rbp)
ffffffff80100ac2:	0f 84 5e 01 00 00    	je     ffffffff80100c26 <cprintf+0x2c6>
ffffffff80100ac8:	e9 51 03 00 00       	jmpq   ffffffff80100e1e <cprintf+0x4be>
    case 'd':
      if (lflag == 1)
ffffffff80100acd:	83 7d e8 01          	cmpl   $0x1,-0x18(%rbp)
ffffffff80100ad1:	0f 85 97 00 00 00    	jne    ffffffff80100b6e <cprintf+0x20e>
ffffffff80100ad7:	48 8d 45 c0          	lea    -0x40(%rbp),%rax
        printint64(va_arg(valist, int64_t), 10, 1);
ffffffff80100adb:	8b 4d c0             	mov    -0x40(%rbp),%ecx
ffffffff80100ade:	83 f9 28             	cmp    $0x28,%ecx
ffffffff80100ae1:	48 89 85 68 ff ff ff 	mov    %rax,-0x98(%rbp)
ffffffff80100ae8:	89 8d 64 ff ff ff    	mov    %ecx,-0x9c(%rbp)
ffffffff80100aee:	0f 87 25 00 00 00    	ja     ffffffff80100b19 <cprintf+0x1b9>
ffffffff80100af4:	8b 85 64 ff ff ff    	mov    -0x9c(%rbp),%eax
ffffffff80100afa:	48 63 c8             	movslq %eax,%rcx
ffffffff80100afd:	48 8b 95 68 ff ff ff 	mov    -0x98(%rbp),%rdx
ffffffff80100b04:	48 03 4a 10          	add    0x10(%rdx),%rcx
ffffffff80100b08:	83 c0 08             	add    $0x8,%eax
ffffffff80100b0b:	89 02                	mov    %eax,(%rdx)
ffffffff80100b0d:	48 89 8d 58 ff ff ff 	mov    %rcx,-0xa8(%rbp)
ffffffff80100b14:	e9 1d 00 00 00       	jmpq   ffffffff80100b36 <cprintf+0x1d6>
ffffffff80100b19:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
ffffffff80100b20:	48 8b 48 08          	mov    0x8(%rax),%rcx
ffffffff80100b24:	48 89 ca             	mov    %rcx,%rdx
ffffffff80100b27:	48 83 c1 08          	add    $0x8,%rcx
ffffffff80100b2b:	48 89 48 08          	mov    %rcx,0x8(%rax)
ffffffff80100b2f:	48 89 95 58 ff ff ff 	mov    %rdx,-0xa8(%rbp)
ffffffff80100b36:	48 8b 85 58 ff ff ff 	mov    -0xa8(%rbp),%rax
ffffffff80100b3d:	b9 0a 00 00 00       	mov    $0xa,%ecx
ffffffff80100b42:	ba 01 00 00 00       	mov    $0x1,%edx
ffffffff80100b47:	48 8b 38             	mov    (%rax),%rdi
ffffffff80100b4a:	be 0a 00 00 00       	mov    $0xa,%esi
ffffffff80100b4f:	41 b8 01 00 00 00    	mov    $0x1,%r8d
ffffffff80100b55:	89 95 54 ff ff ff    	mov    %edx,-0xac(%rbp)
ffffffff80100b5b:	44 89 c2             	mov    %r8d,%edx
ffffffff80100b5e:	89 8d 50 ff ff ff    	mov    %ecx,-0xb0(%rbp)
ffffffff80100b64:	e8 47 04 00 00       	callq  ffffffff80100fb0 <printint64>
ffffffff80100b69:	e9 91 00 00 00       	jmpq   ffffffff80100bff <cprintf+0x29f>
ffffffff80100b6e:	48 8d 45 c0          	lea    -0x40(%rbp),%rax
      else
        printint(va_arg(valist, int), 10, 1);
ffffffff80100b72:	8b 4d c0             	mov    -0x40(%rbp),%ecx
ffffffff80100b75:	83 f9 28             	cmp    $0x28,%ecx
ffffffff80100b78:	48 89 85 48 ff ff ff 	mov    %rax,-0xb8(%rbp)
ffffffff80100b7f:	89 8d 44 ff ff ff    	mov    %ecx,-0xbc(%rbp)
ffffffff80100b85:	0f 87 25 00 00 00    	ja     ffffffff80100bb0 <cprintf+0x250>
ffffffff80100b8b:	8b 85 44 ff ff ff    	mov    -0xbc(%rbp),%eax
ffffffff80100b91:	48 63 c8             	movslq %eax,%rcx
ffffffff80100b94:	48 8b 95 48 ff ff ff 	mov    -0xb8(%rbp),%rdx
ffffffff80100b9b:	48 03 4a 10          	add    0x10(%rdx),%rcx
ffffffff80100b9f:	83 c0 08             	add    $0x8,%eax
ffffffff80100ba2:	89 02                	mov    %eax,(%rdx)
ffffffff80100ba4:	48 89 8d 38 ff ff ff 	mov    %rcx,-0xc8(%rbp)
ffffffff80100bab:	e9 1d 00 00 00       	jmpq   ffffffff80100bcd <cprintf+0x26d>
ffffffff80100bb0:	48 8b 85 48 ff ff ff 	mov    -0xb8(%rbp),%rax
ffffffff80100bb7:	48 8b 48 08          	mov    0x8(%rax),%rcx
ffffffff80100bbb:	48 89 ca             	mov    %rcx,%rdx
ffffffff80100bbe:	48 83 c1 08          	add    $0x8,%rcx
ffffffff80100bc2:	48 89 48 08          	mov    %rcx,0x8(%rax)
ffffffff80100bc6:	48 89 95 38 ff ff ff 	mov    %rdx,-0xc8(%rbp)
ffffffff80100bcd:	48 8b 85 38 ff ff ff 	mov    -0xc8(%rbp),%rax
ffffffff80100bd4:	b9 0a 00 00 00       	mov    $0xa,%ecx
ffffffff80100bd9:	ba 01 00 00 00       	mov    $0x1,%edx
ffffffff80100bde:	8b 38                	mov    (%rax),%edi
ffffffff80100be0:	be 0a 00 00 00       	mov    $0xa,%esi
ffffffff80100be5:	41 b8 01 00 00 00    	mov    $0x1,%r8d
ffffffff80100beb:	89 95 34 ff ff ff    	mov    %edx,-0xcc(%rbp)
ffffffff80100bf1:	44 89 c2             	mov    %r8d,%edx
ffffffff80100bf4:	89 8d 30 ff ff ff    	mov    %ecx,-0xd0(%rbp)
ffffffff80100bfa:	e8 c1 04 00 00       	callq  ffffffff801010c0 <printint>
      break;
ffffffff80100bff:	e9 37 02 00 00       	jmpq   ffffffff80100e3b <cprintf+0x4db>
    case 'l':
      if (lflag)
ffffffff80100c04:	83 7d e8 00          	cmpl   $0x0,-0x18(%rbp)
ffffffff80100c08:	0f 84 0c 00 00 00    	je     ffffffff80100c1a <cprintf+0x2ba>
          lflag = 0;
ffffffff80100c0e:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%rbp)
ffffffff80100c15:	e9 07 00 00 00       	jmpq   ffffffff80100c21 <cprintf+0x2c1>
      else
          lflag = 1;
ffffffff80100c1a:	c7 45 e8 01 00 00 00 	movl   $0x1,-0x18(%rbp)
      goto reswitch;
ffffffff80100c21:	e9 f5 fd ff ff       	jmpq   ffffffff80100a1b <cprintf+0xbb>
    case 'x':
    case 'p':
      if (lflag == 1)
ffffffff80100c26:	83 7d e8 01          	cmpl   $0x1,-0x18(%rbp)
ffffffff80100c2a:	0f 85 91 00 00 00    	jne    ffffffff80100cc1 <cprintf+0x361>
ffffffff80100c30:	48 8d 45 c0          	lea    -0x40(%rbp),%rax
        printint64(va_arg(valist, int64_t), 16, 0);
ffffffff80100c34:	8b 4d c0             	mov    -0x40(%rbp),%ecx
ffffffff80100c37:	83 f9 28             	cmp    $0x28,%ecx
ffffffff80100c3a:	48 89 85 28 ff ff ff 	mov    %rax,-0xd8(%rbp)
ffffffff80100c41:	89 8d 24 ff ff ff    	mov    %ecx,-0xdc(%rbp)
ffffffff80100c47:	0f 87 25 00 00 00    	ja     ffffffff80100c72 <cprintf+0x312>
ffffffff80100c4d:	8b 85 24 ff ff ff    	mov    -0xdc(%rbp),%eax
ffffffff80100c53:	48 63 c8             	movslq %eax,%rcx
ffffffff80100c56:	48 8b 95 28 ff ff ff 	mov    -0xd8(%rbp),%rdx
ffffffff80100c5d:	48 03 4a 10          	add    0x10(%rdx),%rcx
ffffffff80100c61:	83 c0 08             	add    $0x8,%eax
ffffffff80100c64:	89 02                	mov    %eax,(%rdx)
ffffffff80100c66:	48 89 8d 18 ff ff ff 	mov    %rcx,-0xe8(%rbp)
ffffffff80100c6d:	e9 1d 00 00 00       	jmpq   ffffffff80100c8f <cprintf+0x32f>
ffffffff80100c72:	48 8b 85 28 ff ff ff 	mov    -0xd8(%rbp),%rax
ffffffff80100c79:	48 8b 48 08          	mov    0x8(%rax),%rcx
ffffffff80100c7d:	48 89 ca             	mov    %rcx,%rdx
ffffffff80100c80:	48 83 c1 08          	add    $0x8,%rcx
ffffffff80100c84:	48 89 48 08          	mov    %rcx,0x8(%rax)
ffffffff80100c88:	48 89 95 18 ff ff ff 	mov    %rdx,-0xe8(%rbp)
ffffffff80100c8f:	48 8b 85 18 ff ff ff 	mov    -0xe8(%rbp),%rax
ffffffff80100c96:	b9 10 00 00 00       	mov    $0x10,%ecx
ffffffff80100c9b:	31 d2                	xor    %edx,%edx
ffffffff80100c9d:	48 8b 38             	mov    (%rax),%rdi
ffffffff80100ca0:	be 10 00 00 00       	mov    $0x10,%esi
ffffffff80100ca5:	45 31 c0             	xor    %r8d,%r8d
ffffffff80100ca8:	89 95 14 ff ff ff    	mov    %edx,-0xec(%rbp)
ffffffff80100cae:	44 89 c2             	mov    %r8d,%edx
ffffffff80100cb1:	89 8d 10 ff ff ff    	mov    %ecx,-0xf0(%rbp)
ffffffff80100cb7:	e8 f4 02 00 00       	callq  ffffffff80100fb0 <printint64>
ffffffff80100cbc:	e9 8b 00 00 00       	jmpq   ffffffff80100d4c <cprintf+0x3ec>
ffffffff80100cc1:	48 8d 45 c0          	lea    -0x40(%rbp),%rax
      else
        printint(va_arg(valist, int), 16, 0);
ffffffff80100cc5:	8b 4d c0             	mov    -0x40(%rbp),%ecx
ffffffff80100cc8:	83 f9 28             	cmp    $0x28,%ecx
ffffffff80100ccb:	48 89 85 08 ff ff ff 	mov    %rax,-0xf8(%rbp)
ffffffff80100cd2:	89 8d 04 ff ff ff    	mov    %ecx,-0xfc(%rbp)
ffffffff80100cd8:	0f 87 25 00 00 00    	ja     ffffffff80100d03 <cprintf+0x3a3>
ffffffff80100cde:	8b 85 04 ff ff ff    	mov    -0xfc(%rbp),%eax
ffffffff80100ce4:	48 63 c8             	movslq %eax,%rcx
ffffffff80100ce7:	48 8b 95 08 ff ff ff 	mov    -0xf8(%rbp),%rdx
ffffffff80100cee:	48 03 4a 10          	add    0x10(%rdx),%rcx
ffffffff80100cf2:	83 c0 08             	add    $0x8,%eax
ffffffff80100cf5:	89 02                	mov    %eax,(%rdx)
ffffffff80100cf7:	48 89 8d f8 fe ff ff 	mov    %rcx,-0x108(%rbp)
ffffffff80100cfe:	e9 1d 00 00 00       	jmpq   ffffffff80100d20 <cprintf+0x3c0>
ffffffff80100d03:	48 8b 85 08 ff ff ff 	mov    -0xf8(%rbp),%rax
ffffffff80100d0a:	48 8b 48 08          	mov    0x8(%rax),%rcx
ffffffff80100d0e:	48 89 ca             	mov    %rcx,%rdx
ffffffff80100d11:	48 83 c1 08          	add    $0x8,%rcx
ffffffff80100d15:	48 89 48 08          	mov    %rcx,0x8(%rax)
ffffffff80100d19:	48 89 95 f8 fe ff ff 	mov    %rdx,-0x108(%rbp)
ffffffff80100d20:	48 8b 85 f8 fe ff ff 	mov    -0x108(%rbp),%rax
ffffffff80100d27:	b9 10 00 00 00       	mov    $0x10,%ecx
ffffffff80100d2c:	31 d2                	xor    %edx,%edx
ffffffff80100d2e:	8b 38                	mov    (%rax),%edi
ffffffff80100d30:	be 10 00 00 00       	mov    $0x10,%esi
ffffffff80100d35:	45 31 c0             	xor    %r8d,%r8d
ffffffff80100d38:	89 95 f4 fe ff ff    	mov    %edx,-0x10c(%rbp)
ffffffff80100d3e:	44 89 c2             	mov    %r8d,%edx
ffffffff80100d41:	89 8d f0 fe ff ff    	mov    %ecx,-0x110(%rbp)
ffffffff80100d47:	e8 74 03 00 00       	callq  ffffffff801010c0 <printint>
      break;
ffffffff80100d4c:	e9 ea 00 00 00       	jmpq   ffffffff80100e3b <cprintf+0x4db>
ffffffff80100d51:	48 8d 45 c0          	lea    -0x40(%rbp),%rax
    case 's':
      if((s = (char*)va_arg(valist, char*)) == 0)
ffffffff80100d55:	8b 4d c0             	mov    -0x40(%rbp),%ecx
ffffffff80100d58:	83 f9 28             	cmp    $0x28,%ecx
ffffffff80100d5b:	48 89 85 e8 fe ff ff 	mov    %rax,-0x118(%rbp)
ffffffff80100d62:	89 8d e4 fe ff ff    	mov    %ecx,-0x11c(%rbp)
ffffffff80100d68:	0f 87 25 00 00 00    	ja     ffffffff80100d93 <cprintf+0x433>
ffffffff80100d6e:	8b 85 e4 fe ff ff    	mov    -0x11c(%rbp),%eax
ffffffff80100d74:	48 63 c8             	movslq %eax,%rcx
ffffffff80100d77:	48 8b 95 e8 fe ff ff 	mov    -0x118(%rbp),%rdx
ffffffff80100d7e:	48 03 4a 10          	add    0x10(%rdx),%rcx
ffffffff80100d82:	83 c0 08             	add    $0x8,%eax
ffffffff80100d85:	89 02                	mov    %eax,(%rdx)
ffffffff80100d87:	48 89 8d d8 fe ff ff 	mov    %rcx,-0x128(%rbp)
ffffffff80100d8e:	e9 1d 00 00 00       	jmpq   ffffffff80100db0 <cprintf+0x450>
ffffffff80100d93:	48 8b 85 e8 fe ff ff 	mov    -0x118(%rbp),%rax
ffffffff80100d9a:	48 8b 48 08          	mov    0x8(%rax),%rcx
ffffffff80100d9e:	48 89 ca             	mov    %rcx,%rdx
ffffffff80100da1:	48 83 c1 08          	add    $0x8,%rcx
ffffffff80100da5:	48 89 48 08          	mov    %rcx,0x8(%rax)
ffffffff80100da9:	48 89 95 d8 fe ff ff 	mov    %rdx,-0x128(%rbp)
ffffffff80100db0:	48 8b 85 d8 fe ff ff 	mov    -0x128(%rbp),%rax
ffffffff80100db7:	48 8b 00             	mov    (%rax),%rax
ffffffff80100dba:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
ffffffff80100dbe:	48 83 f8 00          	cmp    $0x0,%rax
ffffffff80100dc2:	0f 85 08 00 00 00    	jne    ffffffff80100dd0 <cprintf+0x470>
        s = "(null)";
ffffffff80100dc8:	48 c7 45 e0 59 fb 10 	movq   $0xffffffff8010fb59,-0x20(%rbp)
ffffffff80100dcf:	80 
      for(; *s; s++)
ffffffff80100dd0:	e9 00 00 00 00       	jmpq   ffffffff80100dd5 <cprintf+0x475>
ffffffff80100dd5:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
ffffffff80100dd9:	80 38 00             	cmpb   $0x0,(%rax)
ffffffff80100ddc:	0f 84 1d 00 00 00    	je     ffffffff80100dff <cprintf+0x49f>
        consputc(*s);
ffffffff80100de2:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
ffffffff80100de6:	0f be 38             	movsbl (%rax),%edi
ffffffff80100de9:	e8 32 01 00 00       	callq  ffffffff80100f20 <consputc>
      for(; *s; s++)
ffffffff80100dee:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
ffffffff80100df2:	48 83 c0 01          	add    $0x1,%rax
ffffffff80100df6:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
ffffffff80100dfa:	e9 d6 ff ff ff       	jmpq   ffffffff80100dd5 <cprintf+0x475>
      break;
ffffffff80100dff:	e9 37 00 00 00       	jmpq   ffffffff80100e3b <cprintf+0x4db>
ffffffff80100e04:	b8 25 00 00 00       	mov    $0x25,%eax
    case '%':
      consputc('%');
ffffffff80100e09:	bf 25 00 00 00       	mov    $0x25,%edi
ffffffff80100e0e:	89 85 d4 fe ff ff    	mov    %eax,-0x12c(%rbp)
ffffffff80100e14:	e8 07 01 00 00       	callq  ffffffff80100f20 <consputc>
      break;
ffffffff80100e19:	e9 1d 00 00 00       	jmpq   ffffffff80100e3b <cprintf+0x4db>
ffffffff80100e1e:	b8 25 00 00 00       	mov    $0x25,%eax
    default:
      // Print unknown % sequence to draw attention.
      consputc('%');
ffffffff80100e23:	bf 25 00 00 00       	mov    $0x25,%edi
ffffffff80100e28:	89 85 d0 fe ff ff    	mov    %eax,-0x130(%rbp)
ffffffff80100e2e:	e8 ed 00 00 00       	callq  ffffffff80100f20 <consputc>
      consputc(c);
ffffffff80100e33:	8b 7d f0             	mov    -0x10(%rbp),%edi
ffffffff80100e36:	e8 e5 00 00 00       	callq  ffffffff80100f20 <consputc>
      break;
    }
  }
ffffffff80100e3b:	e9 00 00 00 00       	jmpq   ffffffff80100e40 <cprintf+0x4e0>
  for(i = 0; (c = fmt[i] & 0xff) != 0; i++){
ffffffff80100e40:	8b 45 f4             	mov    -0xc(%rbp),%eax
ffffffff80100e43:	83 c0 01             	add    $0x1,%eax
ffffffff80100e46:	89 45 f4             	mov    %eax,-0xc(%rbp)
ffffffff80100e49:	e9 91 fb ff ff       	jmpq   ffffffff801009df <cprintf+0x7f>

  if(locking)
ffffffff80100e4e:	83 7d ec 00          	cmpl   $0x0,-0x14(%rbp)
ffffffff80100e52:	0f 84 0c 00 00 00    	je     ffffffff80100e64 <cprintf+0x504>
    release(&cons.lock);
ffffffff80100e58:	48 c7 c7 00 64 1f 83 	mov    $0xffffffff831f6400,%rdi
ffffffff80100e5f:	e8 9c 4b 00 00       	callq  ffffffff80105a00 <release>

  va_end(valist);
}
ffffffff80100e64:	48 81 c4 30 01 00 00 	add    $0x130,%rsp
ffffffff80100e6b:	5d                   	pop    %rbp
ffffffff80100e6c:	c3                   	retq   
ffffffff80100e6d:	0f 1f 00             	nopl   (%rax)

ffffffff80100e70 <panic>:

void
panic(char *s)
{
ffffffff80100e70:	55                   	push   %rbp
ffffffff80100e71:	48 89 e5             	mov    %rsp,%rbp
ffffffff80100e74:	48 83 ec 60          	sub    $0x60,%rsp
ffffffff80100e78:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  int i;
  uint64_t pcs[10];

  cli();
ffffffff80100e7c:	e8 2f 03 00 00       	callq  ffffffff801011b0 <cli>
  cons.locking = 0;
ffffffff80100e81:	c7 04 25 68 64 1f 83 	movl   $0x0,0xffffffff831f6468
ffffffff80100e88:	00 00 00 00 
  cprintf("cpu with apicid %d: panic: ", mycpu()->apicid);
ffffffff80100e8c:	e8 2f 03 00 00       	callq  ffffffff801011c0 <mycpu>
ffffffff80100e91:	0f b6 30             	movzbl (%rax),%esi
ffffffff80100e94:	48 c7 c7 60 fb 10 80 	mov    $0xffffffff8010fb60,%rdi
ffffffff80100e9b:	31 c9                	xor    %ecx,%ecx
ffffffff80100e9d:	88 ca                	mov    %cl,%dl
ffffffff80100e9f:	88 d0                	mov    %dl,%al
ffffffff80100ea1:	e8 ba fa ff ff       	callq  ffffffff80100960 <cprintf>
  cprintf(s);
ffffffff80100ea6:	48 8b 7d f8          	mov    -0x8(%rbp),%rdi
ffffffff80100eaa:	31 c9                	xor    %ecx,%ecx
ffffffff80100eac:	88 c8                	mov    %cl,%al
ffffffff80100eae:	e8 ad fa ff ff       	callq  ffffffff80100960 <cprintf>
  cprintf("\n");
ffffffff80100eb3:	48 c7 c7 2d fb 10 80 	mov    $0xffffffff8010fb2d,%rdi
ffffffff80100eba:	31 c9                	xor    %ecx,%ecx
ffffffff80100ebc:	88 c8                	mov    %cl,%al
ffffffff80100ebe:	e8 9d fa ff ff       	callq  ffffffff80100960 <cprintf>
ffffffff80100ec3:	48 8d 75 a0          	lea    -0x60(%rbp),%rsi
ffffffff80100ec7:	48 8d 7d f8          	lea    -0x8(%rbp),%rdi
  getcallerpcs(&s, pcs);
ffffffff80100ecb:	e8 70 4a 00 00       	callq  ffffffff80105940 <getcallerpcs>
  for(i=0; i<10; i++)
ffffffff80100ed0:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)
ffffffff80100ed7:	83 7d f4 0a          	cmpl   $0xa,-0xc(%rbp)
ffffffff80100edb:	0f 8d 29 00 00 00    	jge    ffffffff80100f0a <panic+0x9a>
    cprintf(" %p", pcs[i]);
ffffffff80100ee1:	48 63 45 f4          	movslq -0xc(%rbp),%rax
ffffffff80100ee5:	48 8b 74 c5 a0       	mov    -0x60(%rbp,%rax,8),%rsi
ffffffff80100eea:	48 c7 c7 7c fb 10 80 	mov    $0xffffffff8010fb7c,%rdi
ffffffff80100ef1:	31 c9                	xor    %ecx,%ecx
ffffffff80100ef3:	88 ca                	mov    %cl,%dl
ffffffff80100ef5:	88 d0                	mov    %dl,%al
ffffffff80100ef7:	e8 64 fa ff ff       	callq  ffffffff80100960 <cprintf>
  for(i=0; i<10; i++)
ffffffff80100efc:	8b 45 f4             	mov    -0xc(%rbp),%eax
ffffffff80100eff:	83 c0 01             	add    $0x1,%eax
ffffffff80100f02:	89 45 f4             	mov    %eax,-0xc(%rbp)
ffffffff80100f05:	e9 cd ff ff ff       	jmpq   ffffffff80100ed7 <panic+0x67>
  panicked = 1; // freeze other CPU
ffffffff80100f0a:	c7 04 25 70 64 1f 83 	movl   $0x1,0xffffffff831f6470
ffffffff80100f11:	01 00 00 00 
  for(;;)
ffffffff80100f15:	e9 fb ff ff ff       	jmpq   ffffffff80100f15 <panic+0xa5>
ffffffff80100f1a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)

ffffffff80100f20 <consputc>:
  crt[pos] = ' ' | 0x0700;
}

void
consputc(int c)
{
ffffffff80100f20:	55                   	push   %rbp
ffffffff80100f21:	48 89 e5             	mov    %rsp,%rbp
ffffffff80100f24:	48 83 ec 10          	sub    $0x10,%rsp
ffffffff80100f28:	89 7d fc             	mov    %edi,-0x4(%rbp)
  if(panicked){
ffffffff80100f2b:	8b 3c 25 70 64 1f 83 	mov    0xffffffff831f6470,%edi
ffffffff80100f32:	83 ff 00             	cmp    $0x0,%edi
ffffffff80100f35:	0f 84 0a 00 00 00    	je     ffffffff80100f45 <consputc+0x25>
    cli();
ffffffff80100f3b:	e8 70 02 00 00       	callq  ffffffff801011b0 <cli>
    for(;;)
ffffffff80100f40:	e9 fb ff ff ff       	jmpq   ffffffff80100f40 <consputc+0x20>
      ;
  }

  if(c == BACKSPACE){
ffffffff80100f45:	81 7d fc 00 01 00 00 	cmpl   $0x100,-0x4(%rbp)
ffffffff80100f4c:	0f 85 3b 00 00 00    	jne    ffffffff80100f8d <consputc+0x6d>
ffffffff80100f52:	b8 08 00 00 00       	mov    $0x8,%eax
    uartputc('\b'); uartputc(' '); uartputc('\b');
ffffffff80100f57:	bf 08 00 00 00       	mov    $0x8,%edi
ffffffff80100f5c:	89 45 f8             	mov    %eax,-0x8(%rbp)
ffffffff80100f5f:	e8 0c 9c 00 00       	callq  ffffffff8010ab70 <uartputc>
ffffffff80100f64:	b8 20 00 00 00       	mov    $0x20,%eax
ffffffff80100f69:	bf 20 00 00 00       	mov    $0x20,%edi
ffffffff80100f6e:	89 45 f4             	mov    %eax,-0xc(%rbp)
ffffffff80100f71:	e8 fa 9b 00 00       	callq  ffffffff8010ab70 <uartputc>
ffffffff80100f76:	b8 08 00 00 00       	mov    $0x8,%eax
ffffffff80100f7b:	bf 08 00 00 00       	mov    $0x8,%edi
ffffffff80100f80:	89 45 f0             	mov    %eax,-0x10(%rbp)
ffffffff80100f83:	e8 e8 9b 00 00       	callq  ffffffff8010ab70 <uartputc>
  } else
ffffffff80100f88:	e9 08 00 00 00       	jmpq   ffffffff80100f95 <consputc+0x75>
    uartputc(c);
ffffffff80100f8d:	8b 7d fc             	mov    -0x4(%rbp),%edi
ffffffff80100f90:	e8 db 9b 00 00       	callq  ffffffff8010ab70 <uartputc>
  cgaputc(c);
ffffffff80100f95:	8b 7d fc             	mov    -0x4(%rbp),%edi
ffffffff80100f98:	e8 b3 06 00 00       	callq  ffffffff80101650 <cgaputc>
}
ffffffff80100f9d:	48 83 c4 10          	add    $0x10,%rsp
ffffffff80100fa1:	5d                   	pop    %rbp
ffffffff80100fa2:	c3                   	retq   
ffffffff80100fa3:	66 66 66 66 2e 0f 1f 	data16 data16 data16 nopw %cs:0x0(%rax,%rax,1)
ffffffff80100faa:	84 00 00 00 00 00 

ffffffff80100fb0 <printint64>:
{
ffffffff80100fb0:	55                   	push   %rbp
ffffffff80100fb1:	48 89 e5             	mov    %rsp,%rbp
ffffffff80100fb4:	48 83 ec 50          	sub    $0x50,%rsp
ffffffff80100fb8:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
ffffffff80100fbc:	89 75 f4             	mov    %esi,-0xc(%rbp)
ffffffff80100fbf:	89 55 f0             	mov    %edx,-0x10(%rbp)
  if(sign && (sign = xx < 0))
ffffffff80100fc2:	83 7d f0 00          	cmpl   $0x0,-0x10(%rbp)
ffffffff80100fc6:	0f 84 31 00 00 00    	je     ffffffff80100ffd <printint64+0x4d>
ffffffff80100fcc:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
ffffffff80100fd1:	0f 9c c0             	setl   %al
ffffffff80100fd4:	88 c1                	mov    %al,%cl
ffffffff80100fd6:	80 e1 01             	and    $0x1,%cl
ffffffff80100fd9:	0f b6 d1             	movzbl %cl,%edx
ffffffff80100fdc:	89 55 f0             	mov    %edx,-0x10(%rbp)
ffffffff80100fdf:	a8 01                	test   $0x1,%al
ffffffff80100fe1:	0f 85 05 00 00 00    	jne    ffffffff80100fec <printint64+0x3c>
ffffffff80100fe7:	e9 11 00 00 00       	jmpq   ffffffff80100ffd <printint64+0x4d>
ffffffff80100fec:	31 c0                	xor    %eax,%eax
ffffffff80100fee:	89 c1                	mov    %eax,%ecx
    x = -xx;
ffffffff80100ff0:	48 2b 4d f8          	sub    -0x8(%rbp),%rcx
ffffffff80100ff4:	48 89 4d c0          	mov    %rcx,-0x40(%rbp)
ffffffff80100ff8:	e9 08 00 00 00       	jmpq   ffffffff80101005 <printint64+0x55>
    x = xx;
ffffffff80100ffd:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
ffffffff80101001:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
  i = 0;
ffffffff80101005:	c7 45 cc 00 00 00 00 	movl   $0x0,-0x34(%rbp)
    buf[i++] = digits[x % base];
ffffffff8010100c:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
ffffffff80101010:	48 63 4d f4          	movslq -0xc(%rbp),%rcx
ffffffff80101014:	31 d2                	xor    %edx,%edx
ffffffff80101016:	48 f7 f1             	div    %rcx
ffffffff80101019:	48 89 d0             	mov    %rdx,%rax
ffffffff8010101c:	48 8d 8a 00 10 12 80 	lea    -0x7fedf000(%rdx),%rcx
ffffffff80101023:	40 8a 31             	mov    (%rcx),%sil
ffffffff80101026:	8b 7d cc             	mov    -0x34(%rbp),%edi
ffffffff80101029:	41 89 f8             	mov    %edi,%r8d
ffffffff8010102c:	41 83 c0 01          	add    $0x1,%r8d
ffffffff80101030:	44 89 45 cc          	mov    %r8d,-0x34(%rbp)
ffffffff80101034:	48 63 cf             	movslq %edi,%rcx
ffffffff80101037:	40 88 74 0d d0       	mov    %sil,-0x30(%rbp,%rcx,1)
ffffffff8010103c:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
  }while((x /= base) != 0);
ffffffff80101040:	48 63 45 f4          	movslq -0xc(%rbp),%rax
ffffffff80101044:	48 8b 4d c0          	mov    -0x40(%rbp),%rcx
ffffffff80101048:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
ffffffff8010104c:	48 89 c8             	mov    %rcx,%rax
ffffffff8010104f:	31 d2                	xor    %edx,%edx
ffffffff80101051:	48 8b 4d b0          	mov    -0x50(%rbp),%rcx
ffffffff80101055:	48 f7 f1             	div    %rcx
ffffffff80101058:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
ffffffff8010105c:	48 83 f8 00          	cmp    $0x0,%rax
ffffffff80101060:	0f 85 a6 ff ff ff    	jne    ffffffff8010100c <printint64+0x5c>
  if(sign)
ffffffff80101066:	83 7d f0 00          	cmpl   $0x0,-0x10(%rbp)
ffffffff8010106a:	0f 84 13 00 00 00    	je     ffffffff80101083 <printint64+0xd3>
    buf[i++] = '-';
ffffffff80101070:	8b 45 cc             	mov    -0x34(%rbp),%eax
ffffffff80101073:	89 c1                	mov    %eax,%ecx
ffffffff80101075:	83 c1 01             	add    $0x1,%ecx
ffffffff80101078:	89 4d cc             	mov    %ecx,-0x34(%rbp)
ffffffff8010107b:	48 63 d0             	movslq %eax,%rdx
ffffffff8010107e:	c6 44 15 d0 2d       	movb   $0x2d,-0x30(%rbp,%rdx,1)
  while(--i >= 0)
ffffffff80101083:	e9 00 00 00 00       	jmpq   ffffffff80101088 <printint64+0xd8>
ffffffff80101088:	8b 45 cc             	mov    -0x34(%rbp),%eax
ffffffff8010108b:	83 c0 ff             	add    $0xffffffff,%eax
ffffffff8010108e:	89 45 cc             	mov    %eax,-0x34(%rbp)
ffffffff80101091:	83 f8 00             	cmp    $0x0,%eax
ffffffff80101094:	0f 8c 13 00 00 00    	jl     ffffffff801010ad <printint64+0xfd>
    consputc(buf[i]);
ffffffff8010109a:	48 63 45 cc          	movslq -0x34(%rbp),%rax
ffffffff8010109e:	0f be 7c 05 d0       	movsbl -0x30(%rbp,%rax,1),%edi
ffffffff801010a3:	e8 78 fe ff ff       	callq  ffffffff80100f20 <consputc>
  while(--i >= 0)
ffffffff801010a8:	e9 db ff ff ff       	jmpq   ffffffff80101088 <printint64+0xd8>
}
ffffffff801010ad:	48 83 c4 50          	add    $0x50,%rsp
ffffffff801010b1:	5d                   	pop    %rbp
ffffffff801010b2:	c3                   	retq   
ffffffff801010b3:	66 66 66 66 2e 0f 1f 	data16 data16 data16 nopw %cs:0x0(%rax,%rax,1)
ffffffff801010ba:	84 00 00 00 00 00 

ffffffff801010c0 <printint>:
{
ffffffff801010c0:	55                   	push   %rbp
ffffffff801010c1:	48 89 e5             	mov    %rsp,%rbp
ffffffff801010c4:	48 83 ec 30          	sub    $0x30,%rsp
ffffffff801010c8:	89 7d fc             	mov    %edi,-0x4(%rbp)
ffffffff801010cb:	89 75 f8             	mov    %esi,-0x8(%rbp)
ffffffff801010ce:	89 55 f4             	mov    %edx,-0xc(%rbp)
  if(sign && (sign = xx < 0))
ffffffff801010d1:	83 7d f4 00          	cmpl   $0x0,-0xc(%rbp)
ffffffff801010d5:	0f 84 2c 00 00 00    	je     ffffffff80101107 <printint+0x47>
ffffffff801010db:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
ffffffff801010df:	0f 9c c0             	setl   %al
ffffffff801010e2:	88 c1                	mov    %al,%cl
ffffffff801010e4:	80 e1 01             	and    $0x1,%cl
ffffffff801010e7:	0f b6 d1             	movzbl %cl,%edx
ffffffff801010ea:	89 55 f4             	mov    %edx,-0xc(%rbp)
ffffffff801010ed:	a8 01                	test   $0x1,%al
ffffffff801010ef:	0f 85 05 00 00 00    	jne    ffffffff801010fa <printint+0x3a>
ffffffff801010f5:	e9 0d 00 00 00       	jmpq   ffffffff80101107 <printint+0x47>
ffffffff801010fa:	31 c0                	xor    %eax,%eax
    x = -xx;
ffffffff801010fc:	2b 45 fc             	sub    -0x4(%rbp),%eax
ffffffff801010ff:	89 45 d8             	mov    %eax,-0x28(%rbp)
ffffffff80101102:	e9 06 00 00 00       	jmpq   ffffffff8010110d <printint+0x4d>
    x = xx;
ffffffff80101107:	8b 45 fc             	mov    -0x4(%rbp),%eax
ffffffff8010110a:	89 45 d8             	mov    %eax,-0x28(%rbp)
  i = 0;
ffffffff8010110d:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%rbp)
    buf[i++] = digits[x % base];
ffffffff80101114:	8b 45 d8             	mov    -0x28(%rbp),%eax
ffffffff80101117:	8b 4d f8             	mov    -0x8(%rbp),%ecx
ffffffff8010111a:	31 d2                	xor    %edx,%edx
ffffffff8010111c:	f7 f1                	div    %ecx
ffffffff8010111e:	89 d6                	mov    %edx,%esi
ffffffff80101120:	48 8d b6 20 10 12 80 	lea    -0x7fedefe0(%rsi),%rsi
ffffffff80101127:	40 8a 3e             	mov    (%rsi),%dil
ffffffff8010112a:	8b 45 dc             	mov    -0x24(%rbp),%eax
ffffffff8010112d:	89 c1                	mov    %eax,%ecx
ffffffff8010112f:	83 c1 01             	add    $0x1,%ecx
ffffffff80101132:	89 4d dc             	mov    %ecx,-0x24(%rbp)
ffffffff80101135:	48 63 f0             	movslq %eax,%rsi
ffffffff80101138:	40 88 7c 35 e0       	mov    %dil,-0x20(%rbp,%rsi,1)
  }while((x /= base) != 0);
ffffffff8010113d:	8b 45 f8             	mov    -0x8(%rbp),%eax
ffffffff80101140:	8b 4d d8             	mov    -0x28(%rbp),%ecx
ffffffff80101143:	89 45 d4             	mov    %eax,-0x2c(%rbp)
ffffffff80101146:	89 c8                	mov    %ecx,%eax
ffffffff80101148:	31 d2                	xor    %edx,%edx
ffffffff8010114a:	8b 4d d4             	mov    -0x2c(%rbp),%ecx
ffffffff8010114d:	f7 f1                	div    %ecx
ffffffff8010114f:	89 45 d8             	mov    %eax,-0x28(%rbp)
ffffffff80101152:	83 f8 00             	cmp    $0x0,%eax
ffffffff80101155:	0f 85 b9 ff ff ff    	jne    ffffffff80101114 <printint+0x54>
  if(sign)
ffffffff8010115b:	83 7d f4 00          	cmpl   $0x0,-0xc(%rbp)
ffffffff8010115f:	0f 84 13 00 00 00    	je     ffffffff80101178 <printint+0xb8>
    buf[i++] = '-';
ffffffff80101165:	8b 45 dc             	mov    -0x24(%rbp),%eax
ffffffff80101168:	89 c1                	mov    %eax,%ecx
ffffffff8010116a:	83 c1 01             	add    $0x1,%ecx
ffffffff8010116d:	89 4d dc             	mov    %ecx,-0x24(%rbp)
ffffffff80101170:	48 63 d0             	movslq %eax,%rdx
ffffffff80101173:	c6 44 15 e0 2d       	movb   $0x2d,-0x20(%rbp,%rdx,1)
  while(--i >= 0)
ffffffff80101178:	e9 00 00 00 00       	jmpq   ffffffff8010117d <printint+0xbd>
ffffffff8010117d:	8b 45 dc             	mov    -0x24(%rbp),%eax
ffffffff80101180:	83 c0 ff             	add    $0xffffffff,%eax
ffffffff80101183:	89 45 dc             	mov    %eax,-0x24(%rbp)
ffffffff80101186:	83 f8 00             	cmp    $0x0,%eax
ffffffff80101189:	0f 8c 13 00 00 00    	jl     ffffffff801011a2 <printint+0xe2>
    consputc(buf[i]);
ffffffff8010118f:	48 63 45 dc          	movslq -0x24(%rbp),%rax
ffffffff80101193:	0f be 7c 05 e0       	movsbl -0x20(%rbp,%rax,1),%edi
ffffffff80101198:	e8 83 fd ff ff       	callq  ffffffff80100f20 <consputc>
  while(--i >= 0)
ffffffff8010119d:	e9 db ff ff ff       	jmpq   ffffffff8010117d <printint+0xbd>
}
ffffffff801011a2:	48 83 c4 30          	add    $0x30,%rsp
ffffffff801011a6:	5d                   	pop    %rbp
ffffffff801011a7:	c3                   	retq   
ffffffff801011a8:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
ffffffff801011af:	00 

ffffffff801011b0 <cli>:
  asm volatile("movw %0, %%gs" : : "r" (v));
}

static inline void
cli(void)
{
ffffffff801011b0:	55                   	push   %rbp
ffffffff801011b1:	48 89 e5             	mov    %rsp,%rbp
  asm volatile("cli");
ffffffff801011b4:	fa                   	cli    
}
ffffffff801011b5:	5d                   	pop    %rbp
ffffffff801011b6:	c3                   	retq   
ffffffff801011b7:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
ffffffff801011be:	00 00 

ffffffff801011c0 <mycpu>:
// in thread libraries such as Linux pthreads.

// static inline struct cpu *
static struct cpu *
mycpu(void)
{
ffffffff801011c0:	55                   	push   %rbp
ffffffff801011c1:	48 89 e5             	mov    %rsp,%rbp

  // struct cpu* c = &cpus[cpunum()];
  // return c;

  // single-core for now
  return &cpus[0];
ffffffff801011c4:	48 c7 c0 e0 7b 1f 83 	mov    $0xffffffff831f7be0,%rax
ffffffff801011cb:	5d                   	pop    %rbp
ffffffff801011cc:	c3                   	retq   
ffffffff801011cd:	0f 1f 00             	nopl   (%rax)

ffffffff801011d0 <consoleintr>:

#define C(x)  ((x)-'@')  // Control-x

void
consoleintr(int (*getc)(void))
{
ffffffff801011d0:	55                   	push   %rbp
ffffffff801011d1:	48 89 e5             	mov    %rsp,%rbp
ffffffff801011d4:	48 83 ec 40          	sub    $0x40,%rsp
ffffffff801011d8:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  int c, doprocdump = 0;
ffffffff801011dc:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%rbp)

  acquire(&cons.lock);
ffffffff801011e3:	48 c7 c7 00 64 1f 83 	mov    $0xffffffff831f6400,%rdi
ffffffff801011ea:	e8 d1 45 00 00       	callq  ffffffff801057c0 <acquire>
  while((c = getc()) >= 0){
ffffffff801011ef:	ff 55 f8             	callq  *-0x8(%rbp)
ffffffff801011f2:	89 45 f4             	mov    %eax,-0xc(%rbp)
ffffffff801011f5:	83 f8 00             	cmp    $0x0,%eax
ffffffff801011f8:	0f 8c ed 01 00 00    	jl     ffffffff801013eb <consoleintr+0x21b>
    switch(c){
ffffffff801011fe:	8b 45 f4             	mov    -0xc(%rbp),%eax
ffffffff80101201:	89 c1                	mov    %eax,%ecx
ffffffff80101203:	83 e9 08             	sub    $0x8,%ecx
ffffffff80101206:	89 45 ec             	mov    %eax,-0x14(%rbp)
ffffffff80101209:	89 4d e8             	mov    %ecx,-0x18(%rbp)
ffffffff8010120c:	0f 84 cc 00 00 00    	je     ffffffff801012de <consoleintr+0x10e>
ffffffff80101212:	e9 00 00 00 00       	jmpq   ffffffff80101217 <consoleintr+0x47>
ffffffff80101217:	8b 45 ec             	mov    -0x14(%rbp),%eax
ffffffff8010121a:	83 e8 10             	sub    $0x10,%eax
ffffffff8010121d:	89 45 e4             	mov    %eax,-0x1c(%rbp)
ffffffff80101220:	0f 84 2d 00 00 00    	je     ffffffff80101253 <consoleintr+0x83>
ffffffff80101226:	e9 00 00 00 00       	jmpq   ffffffff8010122b <consoleintr+0x5b>
ffffffff8010122b:	8b 45 ec             	mov    -0x14(%rbp),%eax
ffffffff8010122e:	83 e8 15             	sub    $0x15,%eax
ffffffff80101231:	89 45 e0             	mov    %eax,-0x20(%rbp)
ffffffff80101234:	0f 84 25 00 00 00    	je     ffffffff8010125f <consoleintr+0x8f>
ffffffff8010123a:	e9 00 00 00 00       	jmpq   ffffffff8010123f <consoleintr+0x6f>
ffffffff8010123f:	8b 45 ec             	mov    -0x14(%rbp),%eax
ffffffff80101242:	83 e8 7f             	sub    $0x7f,%eax
ffffffff80101245:	89 45 dc             	mov    %eax,-0x24(%rbp)
ffffffff80101248:	0f 84 90 00 00 00    	je     ffffffff801012de <consoleintr+0x10e>
ffffffff8010124e:	e9 c8 00 00 00       	jmpq   ffffffff8010131b <consoleintr+0x14b>
    case C('P'):  // Process listing.
      // procdump() locks cons.lock indirectly; invoke later
      doprocdump = 1;
ffffffff80101253:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%rbp)
      break;
ffffffff8010125a:	e9 87 01 00 00       	jmpq   ffffffff801013e6 <consoleintr+0x216>
    case C('U'):  // Kill line.
      while(input.e != input.w &&
ffffffff8010125f:	e9 00 00 00 00       	jmpq   ffffffff80101264 <consoleintr+0x94>
ffffffff80101264:	31 c0                	xor    %eax,%eax
ffffffff80101266:	88 c1                	mov    %al,%cl
ffffffff80101268:	8b 04 25 34 66 1f 83 	mov    0xffffffff831f6634,%eax
ffffffff8010126f:	8b 14 25 30 66 1f 83 	mov    0xffffffff831f6630,%edx
ffffffff80101276:	39 d0                	cmp    %edx,%eax
ffffffff80101278:	88 4d db             	mov    %cl,-0x25(%rbp)
ffffffff8010127b:	0f 84 21 00 00 00    	je     ffffffff801012a2 <consoleintr+0xd2>
            input.buf[(input.e-1) % INPUT_BUF] != '\n'){
ffffffff80101281:	8b 04 25 34 66 1f 83 	mov    0xffffffff831f6634,%eax
ffffffff80101288:	ff c8                	dec    %eax
ffffffff8010128a:	83 e0 7f             	and    $0x7f,%eax
ffffffff8010128d:	89 c1                	mov    %eax,%ecx
ffffffff8010128f:	48 8d 89 ac 65 1f 83 	lea    -0x7ce09a54(%rcx),%rcx
ffffffff80101296:	0f be 01             	movsbl (%rcx),%eax
ffffffff80101299:	83 f8 0a             	cmp    $0xa,%eax
ffffffff8010129c:	0f 95 c2             	setne  %dl
ffffffff8010129f:	88 55 db             	mov    %dl,-0x25(%rbp)
ffffffff801012a2:	8a 45 db             	mov    -0x25(%rbp),%al
      while(input.e != input.w &&
ffffffff801012a5:	a8 01                	test   $0x1,%al
ffffffff801012a7:	0f 85 05 00 00 00    	jne    ffffffff801012b2 <consoleintr+0xe2>
ffffffff801012ad:	e9 27 00 00 00       	jmpq   ffffffff801012d9 <consoleintr+0x109>
ffffffff801012b2:	b8 00 01 00 00       	mov    $0x100,%eax
        input.e--;
ffffffff801012b7:	8b 0c 25 34 66 1f 83 	mov    0xffffffff831f6634,%ecx
ffffffff801012be:	ff c9                	dec    %ecx
ffffffff801012c0:	89 0c 25 34 66 1f 83 	mov    %ecx,0xffffffff831f6634
        consputc(BACKSPACE);
ffffffff801012c7:	bf 00 01 00 00       	mov    $0x100,%edi
ffffffff801012cc:	89 45 d4             	mov    %eax,-0x2c(%rbp)
ffffffff801012cf:	e8 4c fc ff ff       	callq  ffffffff80100f20 <consputc>
      while(input.e != input.w &&
ffffffff801012d4:	e9 8b ff ff ff       	jmpq   ffffffff80101264 <consoleintr+0x94>
      }
      break;
ffffffff801012d9:	e9 08 01 00 00       	jmpq   ffffffff801013e6 <consoleintr+0x216>
    case C('H'): case '\x7f':  // Backspace
      if(input.e != input.w){
ffffffff801012de:	8b 04 25 34 66 1f 83 	mov    0xffffffff831f6634,%eax
ffffffff801012e5:	8b 0c 25 30 66 1f 83 	mov    0xffffffff831f6630,%ecx
ffffffff801012ec:	39 c8                	cmp    %ecx,%eax
ffffffff801012ee:	0f 84 22 00 00 00    	je     ffffffff80101316 <consoleintr+0x146>
ffffffff801012f4:	b8 00 01 00 00       	mov    $0x100,%eax
        input.e--;
ffffffff801012f9:	8b 0c 25 34 66 1f 83 	mov    0xffffffff831f6634,%ecx
ffffffff80101300:	ff c9                	dec    %ecx
ffffffff80101302:	89 0c 25 34 66 1f 83 	mov    %ecx,0xffffffff831f6634
        consputc(BACKSPACE);
ffffffff80101309:	bf 00 01 00 00       	mov    $0x100,%edi
ffffffff8010130e:	89 45 d0             	mov    %eax,-0x30(%rbp)
ffffffff80101311:	e8 0a fc ff ff       	callq  ffffffff80100f20 <consputc>
      }
      break;
ffffffff80101316:	e9 cb 00 00 00       	jmpq   ffffffff801013e6 <consoleintr+0x216>
    default:
      if(c != 0 && input.e-input.r < INPUT_BUF){
ffffffff8010131b:	83 7d f4 00          	cmpl   $0x0,-0xc(%rbp)
ffffffff8010131f:	0f 84 bc 00 00 00    	je     ffffffff801013e1 <consoleintr+0x211>
ffffffff80101325:	8b 04 25 34 66 1f 83 	mov    0xffffffff831f6634,%eax
ffffffff8010132c:	8b 0c 25 2c 66 1f 83 	mov    0xffffffff831f662c,%ecx
ffffffff80101333:	29 c8                	sub    %ecx,%eax
ffffffff80101335:	3d 80 00 00 00       	cmp    $0x80,%eax
ffffffff8010133a:	0f 83 a1 00 00 00    	jae    ffffffff801013e1 <consoleintr+0x211>
        c = (c == '\r') ? '\n' : c;
ffffffff80101340:	83 7d f4 0d          	cmpl   $0xd,-0xc(%rbp)
ffffffff80101344:	0f 85 0d 00 00 00    	jne    ffffffff80101357 <consoleintr+0x187>
ffffffff8010134a:	b8 0a 00 00 00       	mov    $0xa,%eax
ffffffff8010134f:	89 45 cc             	mov    %eax,-0x34(%rbp)
ffffffff80101352:	e9 06 00 00 00       	jmpq   ffffffff8010135d <consoleintr+0x18d>
ffffffff80101357:	8b 45 f4             	mov    -0xc(%rbp),%eax
ffffffff8010135a:	89 45 cc             	mov    %eax,-0x34(%rbp)
ffffffff8010135d:	8b 45 cc             	mov    -0x34(%rbp),%eax
ffffffff80101360:	89 45 f4             	mov    %eax,-0xc(%rbp)
        input.buf[input.e++ % INPUT_BUF] = c;
ffffffff80101363:	8a 4d f4             	mov    -0xc(%rbp),%cl
ffffffff80101366:	8b 04 25 34 66 1f 83 	mov    0xffffffff831f6634,%eax
ffffffff8010136d:	89 c2                	mov    %eax,%edx
ffffffff8010136f:	89 d0                	mov    %edx,%eax
ffffffff80101371:	89 c6                	mov    %eax,%esi
ffffffff80101373:	ff c6                	inc    %esi
ffffffff80101375:	89 34 25 34 66 1f 83 	mov    %esi,0xffffffff831f6634
ffffffff8010137c:	83 e0 7f             	and    $0x7f,%eax
ffffffff8010137f:	89 c2                	mov    %eax,%edx
ffffffff80101381:	48 8d 92 ac 65 1f 83 	lea    -0x7ce09a54(%rdx),%rdx
ffffffff80101388:	88 0a                	mov    %cl,(%rdx)
        consputc(c);
ffffffff8010138a:	8b 7d f4             	mov    -0xc(%rbp),%edi
ffffffff8010138d:	e8 8e fb ff ff       	callq  ffffffff80100f20 <consputc>
        if(c == '\n' || c == C('D') || input.e == input.r+INPUT_BUF){
ffffffff80101392:	83 7d f4 0a          	cmpl   $0xa,-0xc(%rbp)
ffffffff80101396:	0f 84 26 00 00 00    	je     ffffffff801013c2 <consoleintr+0x1f2>
ffffffff8010139c:	83 7d f4 04          	cmpl   $0x4,-0xc(%rbp)
ffffffff801013a0:	0f 84 1c 00 00 00    	je     ffffffff801013c2 <consoleintr+0x1f2>
ffffffff801013a6:	8b 04 25 34 66 1f 83 	mov    0xffffffff831f6634,%eax
ffffffff801013ad:	8b 0c 25 2c 66 1f 83 	mov    0xffffffff831f662c,%ecx
ffffffff801013b4:	81 c1 80 00 00 00    	add    $0x80,%ecx
ffffffff801013ba:	39 c8                	cmp    %ecx,%eax
ffffffff801013bc:	0f 85 1a 00 00 00    	jne    ffffffff801013dc <consoleintr+0x20c>
          input.w = input.e;
ffffffff801013c2:	8b 04 25 34 66 1f 83 	mov    0xffffffff831f6634,%eax
ffffffff801013c9:	89 04 25 30 66 1f 83 	mov    %eax,0xffffffff831f6630
          wakeup(&input.r);
ffffffff801013d0:	48 c7 c7 2c 66 1f 83 	mov    $0xffffffff831f662c,%rdi
ffffffff801013d7:	e8 f4 72 00 00       	callq  ffffffff801086d0 <wakeup>
        }
      }
ffffffff801013dc:	e9 00 00 00 00       	jmpq   ffffffff801013e1 <consoleintr+0x211>
      break;
ffffffff801013e1:	e9 00 00 00 00       	jmpq   ffffffff801013e6 <consoleintr+0x216>
  while((c = getc()) >= 0){
ffffffff801013e6:	e9 04 fe ff ff       	jmpq   ffffffff801011ef <consoleintr+0x1f>
    }
  }
  release(&cons.lock);
ffffffff801013eb:	48 c7 c7 00 64 1f 83 	mov    $0xffffffff831f6400,%rdi
ffffffff801013f2:	e8 09 46 00 00       	callq  ffffffff80105a00 <release>
  if(doprocdump) {
ffffffff801013f7:	83 7d f0 00          	cmpl   $0x0,-0x10(%rbp)
ffffffff801013fb:	0f 84 05 00 00 00    	je     ffffffff80101406 <consoleintr+0x236>
    procdump();  // now call procdump() wo. cons.lock held
ffffffff80101401:	e8 da 73 00 00       	callq  ffffffff801087e0 <procdump>
  }
}
ffffffff80101406:	48 83 c4 40          	add    $0x40,%rsp
ffffffff8010140a:	5d                   	pop    %rbp
ffffffff8010140b:	c3                   	retq   
ffffffff8010140c:	0f 1f 40 00          	nopl   0x0(%rax)

ffffffff80101410 <consoleread>:

int
consoleread(struct inode *ip, char *dst, int n)
{
ffffffff80101410:	55                   	push   %rbp
ffffffff80101411:	48 89 e5             	mov    %rsp,%rbp
ffffffff80101414:	48 83 ec 30          	sub    $0x30,%rsp
ffffffff80101418:	48 89 7d f0          	mov    %rdi,-0x10(%rbp)
ffffffff8010141c:	48 89 75 e8          	mov    %rsi,-0x18(%rbp)
ffffffff80101420:	89 55 e4             	mov    %edx,-0x1c(%rbp)
  uint target;
  int c;

  target = n;
ffffffff80101423:	8b 55 e4             	mov    -0x1c(%rbp),%edx
ffffffff80101426:	89 55 e0             	mov    %edx,-0x20(%rbp)
  acquire(&cons.lock);
ffffffff80101429:	48 c7 c7 00 64 1f 83 	mov    $0xffffffff831f6400,%rdi
ffffffff80101430:	e8 8b 43 00 00       	callq  ffffffff801057c0 <acquire>
  while(n > 0){
ffffffff80101435:	83 7d e4 00          	cmpl   $0x0,-0x1c(%rbp)
ffffffff80101439:	0f 8e e3 00 00 00    	jle    ffffffff80101522 <consoleread+0x112>
    while(input.r == input.w){
ffffffff8010143f:	e9 00 00 00 00       	jmpq   ffffffff80101444 <consoleread+0x34>
ffffffff80101444:	8b 04 25 2c 66 1f 83 	mov    0xffffffff831f662c,%eax
ffffffff8010144b:	8b 0c 25 30 66 1f 83 	mov    0xffffffff831f6630,%ecx
ffffffff80101452:	39 c8                	cmp    %ecx,%eax
ffffffff80101454:	0f 85 42 00 00 00    	jne    ffffffff8010149c <consoleread+0x8c>
      if(myproc()->killed){
ffffffff8010145a:	e8 e1 00 00 00       	callq  ffffffff80101540 <myproc>
ffffffff8010145f:	83 b8 28 01 00 00 00 	cmpl   $0x0,0x128(%rax)
ffffffff80101466:	0f 84 18 00 00 00    	je     ffffffff80101484 <consoleread+0x74>
        release(&cons.lock);
ffffffff8010146c:	48 c7 c7 00 64 1f 83 	mov    $0xffffffff831f6400,%rdi
ffffffff80101473:	e8 88 45 00 00       	callq  ffffffff80105a00 <release>
        return -1;
ffffffff80101478:	c7 45 fc ff ff ff ff 	movl   $0xffffffff,-0x4(%rbp)
ffffffff8010147f:	e9 b3 00 00 00       	jmpq   ffffffff80101537 <consoleread+0x127>
      }
      sleep(&input.r, &cons.lock);
ffffffff80101484:	48 c7 c6 00 64 1f 83 	mov    $0xffffffff831f6400,%rsi
ffffffff8010148b:	48 c7 c7 2c 66 1f 83 	mov    $0xffffffff831f662c,%rdi
ffffffff80101492:	e8 89 6f 00 00       	callq  ffffffff80108420 <sleep>
    while(input.r == input.w){
ffffffff80101497:	e9 a8 ff ff ff       	jmpq   ffffffff80101444 <consoleread+0x34>
    }
    c = input.buf[input.r++ % INPUT_BUF];
ffffffff8010149c:	8b 04 25 2c 66 1f 83 	mov    0xffffffff831f662c,%eax
ffffffff801014a3:	89 c1                	mov    %eax,%ecx
ffffffff801014a5:	89 c8                	mov    %ecx,%eax
ffffffff801014a7:	89 c2                	mov    %eax,%edx
ffffffff801014a9:	ff c2                	inc    %edx
ffffffff801014ab:	89 14 25 2c 66 1f 83 	mov    %edx,0xffffffff831f662c
ffffffff801014b2:	83 e0 7f             	and    $0x7f,%eax
ffffffff801014b5:	89 c1                	mov    %eax,%ecx
ffffffff801014b7:	48 8d 89 ac 65 1f 83 	lea    -0x7ce09a54(%rcx),%rcx
ffffffff801014be:	0f be 01             	movsbl (%rcx),%eax
ffffffff801014c1:	89 45 dc             	mov    %eax,-0x24(%rbp)
    if(c == C('D')){  // EOF
ffffffff801014c4:	83 7d dc 04          	cmpl   $0x4,-0x24(%rbp)
ffffffff801014c8:	0f 85 21 00 00 00    	jne    ffffffff801014ef <consoleread+0xdf>
      if(n < target){
ffffffff801014ce:	8b 45 e4             	mov    -0x1c(%rbp),%eax
ffffffff801014d1:	3b 45 e0             	cmp    -0x20(%rbp),%eax
ffffffff801014d4:	0f 83 10 00 00 00    	jae    ffffffff801014ea <consoleread+0xda>
        // Save ^D for next time, to make sure
        // caller gets a 0-byte result.
        input.r--;
ffffffff801014da:	8b 04 25 2c 66 1f 83 	mov    0xffffffff831f662c,%eax
ffffffff801014e1:	ff c8                	dec    %eax
ffffffff801014e3:	89 04 25 2c 66 1f 83 	mov    %eax,0xffffffff831f662c
      }
      break;
ffffffff801014ea:	e9 33 00 00 00       	jmpq   ffffffff80101522 <consoleread+0x112>
    }
    *dst++ = c;
ffffffff801014ef:	8b 45 dc             	mov    -0x24(%rbp),%eax
ffffffff801014f2:	88 c1                	mov    %al,%cl
ffffffff801014f4:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
ffffffff801014f8:	48 89 d6             	mov    %rdx,%rsi
ffffffff801014fb:	48 83 c6 01          	add    $0x1,%rsi
ffffffff801014ff:	48 89 75 e8          	mov    %rsi,-0x18(%rbp)
ffffffff80101503:	88 0a                	mov    %cl,(%rdx)
    --n;
ffffffff80101505:	8b 45 e4             	mov    -0x1c(%rbp),%eax
ffffffff80101508:	83 c0 ff             	add    $0xffffffff,%eax
ffffffff8010150b:	89 45 e4             	mov    %eax,-0x1c(%rbp)
    if(c == '\n')
ffffffff8010150e:	83 7d dc 0a          	cmpl   $0xa,-0x24(%rbp)
ffffffff80101512:	0f 85 05 00 00 00    	jne    ffffffff8010151d <consoleread+0x10d>
      break;
ffffffff80101518:	e9 05 00 00 00       	jmpq   ffffffff80101522 <consoleread+0x112>
  while(n > 0){
ffffffff8010151d:	e9 13 ff ff ff       	jmpq   ffffffff80101435 <consoleread+0x25>
  }
  release(&cons.lock);
ffffffff80101522:	48 c7 c7 00 64 1f 83 	mov    $0xffffffff831f6400,%rdi
ffffffff80101529:	e8 d2 44 00 00       	callq  ffffffff80105a00 <release>

  return target - n;
ffffffff8010152e:	8b 45 e0             	mov    -0x20(%rbp),%eax
ffffffff80101531:	2b 45 e4             	sub    -0x1c(%rbp),%eax
ffffffff80101534:	89 45 fc             	mov    %eax,-0x4(%rbp)
}
ffffffff80101537:	8b 45 fc             	mov    -0x4(%rbp),%eax
ffffffff8010153a:	48 83 c4 30          	add    $0x30,%rsp
ffffffff8010153e:	5d                   	pop    %rbp
ffffffff8010153f:	c3                   	retq   

ffffffff80101540 <myproc>:
}

static inline struct proc *
myproc(void)
{
ffffffff80101540:	55                   	push   %rbp
ffffffff80101541:	48 89 e5             	mov    %rsp,%rbp
  // uint64_t val;
  // __asm volatile("movq %%gs:8, %0" : "=r" (val));
  // return (struct proc *)val;
  return mycpu()->proc;
ffffffff80101544:	e8 77 fc ff ff       	callq  ffffffff801011c0 <mycpu>
ffffffff80101549:	48 8b 80 d0 00 00 00 	mov    0xd0(%rax),%rax
ffffffff80101550:	5d                   	pop    %rbp
ffffffff80101551:	c3                   	retq   
ffffffff80101552:	66 66 66 66 66 2e 0f 	data16 data16 data16 data16 nopw %cs:0x0(%rax,%rax,1)
ffffffff80101559:	1f 84 00 00 00 00 00 

ffffffff80101560 <consolewrite>:

int
consolewrite(struct inode *ip, char *buf, int n)
{
ffffffff80101560:	55                   	push   %rbp
ffffffff80101561:	48 89 e5             	mov    %rsp,%rbp
ffffffff80101564:	48 83 ec 20          	sub    $0x20,%rsp
ffffffff80101568:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
ffffffff8010156c:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
ffffffff80101570:	89 55 ec             	mov    %edx,-0x14(%rbp)
  int i;

  acquire(&cons.lock);
ffffffff80101573:	48 c7 c7 00 64 1f 83 	mov    $0xffffffff831f6400,%rdi
ffffffff8010157a:	e8 41 42 00 00       	callq  ffffffff801057c0 <acquire>
  for(i = 0; i < n; i++)
ffffffff8010157f:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%rbp)
ffffffff80101586:	8b 45 e8             	mov    -0x18(%rbp),%eax
ffffffff80101589:	3b 45 ec             	cmp    -0x14(%rbp),%eax
ffffffff8010158c:	0f 8d 27 00 00 00    	jge    ffffffff801015b9 <consolewrite+0x59>
    consputc(buf[i] & 0xff);
ffffffff80101592:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
ffffffff80101596:	48 63 4d e8          	movslq -0x18(%rbp),%rcx
ffffffff8010159a:	0f be 14 08          	movsbl (%rax,%rcx,1),%edx
ffffffff8010159e:	81 e2 ff 00 00 00    	and    $0xff,%edx
ffffffff801015a4:	89 d7                	mov    %edx,%edi
ffffffff801015a6:	e8 75 f9 ff ff       	callq  ffffffff80100f20 <consputc>
  for(i = 0; i < n; i++)
ffffffff801015ab:	8b 45 e8             	mov    -0x18(%rbp),%eax
ffffffff801015ae:	83 c0 01             	add    $0x1,%eax
ffffffff801015b1:	89 45 e8             	mov    %eax,-0x18(%rbp)
ffffffff801015b4:	e9 cd ff ff ff       	jmpq   ffffffff80101586 <consolewrite+0x26>
  release(&cons.lock);
ffffffff801015b9:	48 c7 c7 00 64 1f 83 	mov    $0xffffffff831f6400,%rdi
ffffffff801015c0:	e8 3b 44 00 00       	callq  ffffffff80105a00 <release>

  return n;
ffffffff801015c5:	8b 45 ec             	mov    -0x14(%rbp),%eax
ffffffff801015c8:	48 83 c4 20          	add    $0x20,%rsp
ffffffff801015cc:	5d                   	pop    %rbp
ffffffff801015cd:	c3                   	retq   
ffffffff801015ce:	66 90                	xchg   %ax,%ax

ffffffff801015d0 <consoleinit>:
}

void
consoleinit(void)
{
ffffffff801015d0:	55                   	push   %rbp
ffffffff801015d1:	48 89 e5             	mov    %rsp,%rbp
ffffffff801015d4:	48 83 ec 10          	sub    $0x10,%rsp
ffffffff801015d8:	b8 01 00 00 00       	mov    $0x1,%eax
  initlock(&cons.lock, "console");
ffffffff801015dd:	48 c7 c7 00 64 1f 83 	mov    $0xffffffff831f6400,%rdi
ffffffff801015e4:	48 c7 c6 80 fb 10 80 	mov    $0xffffffff8010fb80,%rsi
ffffffff801015eb:	89 45 fc             	mov    %eax,-0x4(%rbp)
ffffffff801015ee:	e8 8d 41 00 00       	callq  ffffffff80105780 <initlock>

  devsw[CONSOLE].write = consolewrite;
ffffffff801015f3:	48 c7 04 25 d8 54 20 	movq   $0xffffffff80101560,0xffffffff832054d8
ffffffff801015fa:	83 60 15 10 80 
  devsw[CONSOLE].read = consoleread;
ffffffff801015ff:	48 c7 04 25 d0 54 20 	movq   $0xffffffff80101410,0xffffffff832054d0
ffffffff80101606:	83 10 14 10 80 

  cons.locking = 1;
ffffffff8010160b:	c7 04 25 68 64 1f 83 	movl   $0x1,0xffffffff831f6468
ffffffff80101612:	01 00 00 00 

  picenable(IRQ_KBD);
ffffffff80101616:	bf 01 00 00 00       	mov    $0x1,%edi
ffffffff8010161b:	e8 80 5c 00 00       	callq  ffffffff801072a0 <picenable>
ffffffff80101620:	b8 01 00 00 00       	mov    $0x1,%eax
ffffffff80101625:	31 ff                	xor    %edi,%edi
  ioapicenable(IRQ_KBD, 0);
ffffffff80101627:	b9 01 00 00 00       	mov    $0x1,%ecx
ffffffff8010162c:	31 f6                	xor    %esi,%esi
ffffffff8010162e:	89 7d f8             	mov    %edi,-0x8(%rbp)
ffffffff80101631:	89 cf                	mov    %ecx,%edi
ffffffff80101633:	89 45 f4             	mov    %eax,-0xc(%rbp)
ffffffff80101636:	e8 65 90 00 00       	callq  ffffffff8010a6a0 <ioapicenable>
}
ffffffff8010163b:	48 83 c4 10          	add    $0x10,%rsp
ffffffff8010163f:	5d                   	pop    %rbp
ffffffff80101640:	c3                   	retq   
ffffffff80101641:	66 66 66 66 66 66 2e 	data16 data16 data16 data16 data16 nopw %cs:0x0(%rax,%rax,1)
ffffffff80101648:	0f 1f 84 00 00 00 00 
ffffffff8010164f:	00 

ffffffff80101650 <cgaputc>:
{
ffffffff80101650:	55                   	push   %rbp
ffffffff80101651:	48 89 e5             	mov    %rsp,%rbp
ffffffff80101654:	48 83 ec 50          	sub    $0x50,%rsp
ffffffff80101658:	b8 d4 03 00 00       	mov    $0x3d4,%eax
ffffffff8010165d:	b9 0e 00 00 00       	mov    $0xe,%ecx
ffffffff80101662:	89 7d fc             	mov    %edi,-0x4(%rbp)
  outb(CRTPORT, 14);
ffffffff80101665:	bf d4 03 00 00       	mov    $0x3d4,%edi
ffffffff8010166a:	be 0e 00 00 00       	mov    $0xe,%esi
ffffffff8010166f:	89 4d f4             	mov    %ecx,-0xc(%rbp)
ffffffff80101672:	89 45 f0             	mov    %eax,-0x10(%rbp)
ffffffff80101675:	e8 e6 01 00 00       	callq  ffffffff80101860 <outb>
ffffffff8010167a:	b8 d5 03 00 00       	mov    $0x3d5,%eax
  pos = inb(CRTPORT+1) << 8;
ffffffff8010167f:	bf d5 03 00 00       	mov    $0x3d5,%edi
ffffffff80101684:	89 45 ec             	mov    %eax,-0x14(%rbp)
ffffffff80101687:	e8 04 02 00 00       	callq  ffffffff80101890 <inb>
ffffffff8010168c:	b9 d4 03 00 00       	mov    $0x3d4,%ecx
ffffffff80101691:	be 0f 00 00 00       	mov    $0xf,%esi
ffffffff80101696:	0f b6 f8             	movzbl %al,%edi
ffffffff80101699:	c1 e7 08             	shl    $0x8,%edi
ffffffff8010169c:	89 7d f8             	mov    %edi,-0x8(%rbp)
  outb(CRTPORT, 15);
ffffffff8010169f:	bf d4 03 00 00       	mov    $0x3d4,%edi
ffffffff801016a4:	ba 0f 00 00 00       	mov    $0xf,%edx
ffffffff801016a9:	89 75 e8             	mov    %esi,-0x18(%rbp)
ffffffff801016ac:	89 d6                	mov    %edx,%esi
ffffffff801016ae:	89 4d e4             	mov    %ecx,-0x1c(%rbp)
ffffffff801016b1:	e8 aa 01 00 00       	callq  ffffffff80101860 <outb>
ffffffff801016b6:	b9 d5 03 00 00       	mov    $0x3d5,%ecx
  pos |= inb(CRTPORT+1);
ffffffff801016bb:	bf d5 03 00 00       	mov    $0x3d5,%edi
ffffffff801016c0:	89 4d e0             	mov    %ecx,-0x20(%rbp)
ffffffff801016c3:	e8 c8 01 00 00       	callq  ffffffff80101890 <inb>
ffffffff801016c8:	0f b6 c8             	movzbl %al,%ecx
ffffffff801016cb:	0b 4d f8             	or     -0x8(%rbp),%ecx
ffffffff801016ce:	89 4d f8             	mov    %ecx,-0x8(%rbp)
  if(c == '\n')
ffffffff801016d1:	83 7d fc 0a          	cmpl   $0xa,-0x4(%rbp)
ffffffff801016d5:	0f 85 20 00 00 00    	jne    ffffffff801016fb <cgaputc+0xab>
ffffffff801016db:	b8 50 00 00 00       	mov    $0x50,%eax
    pos += 80 - pos%80;
ffffffff801016e0:	8b 4d f8             	mov    -0x8(%rbp),%ecx
ffffffff801016e3:	89 45 dc             	mov    %eax,-0x24(%rbp)
ffffffff801016e6:	89 c8                	mov    %ecx,%eax
ffffffff801016e8:	99                   	cltd   
ffffffff801016e9:	8b 4d dc             	mov    -0x24(%rbp),%ecx
ffffffff801016ec:	f7 f9                	idiv   %ecx
ffffffff801016ee:	29 d1                	sub    %edx,%ecx
ffffffff801016f0:	03 4d f8             	add    -0x8(%rbp),%ecx
ffffffff801016f3:	89 4d f8             	mov    %ecx,-0x8(%rbp)
ffffffff801016f6:	e9 50 00 00 00       	jmpq   ffffffff8010174b <cgaputc+0xfb>
  else if(c == BACKSPACE){
ffffffff801016fb:	81 7d fc 00 01 00 00 	cmpl   $0x100,-0x4(%rbp)
ffffffff80101702:	0f 85 18 00 00 00    	jne    ffffffff80101720 <cgaputc+0xd0>
    if(pos > 0) --pos;
ffffffff80101708:	83 7d f8 00          	cmpl   $0x0,-0x8(%rbp)
ffffffff8010170c:	0f 8e 09 00 00 00    	jle    ffffffff8010171b <cgaputc+0xcb>
ffffffff80101712:	8b 45 f8             	mov    -0x8(%rbp),%eax
ffffffff80101715:	83 c0 ff             	add    $0xffffffff,%eax
ffffffff80101718:	89 45 f8             	mov    %eax,-0x8(%rbp)
  } else
ffffffff8010171b:	e9 26 00 00 00       	jmpq   ffffffff80101746 <cgaputc+0xf6>
    crt[pos++] = (c&0xff) | 0x0700;  // black on white
ffffffff80101720:	0f b6 45 fc          	movzbl -0x4(%rbp),%eax
ffffffff80101724:	0d 00 07 00 00       	or     $0x700,%eax
ffffffff80101729:	66 89 c1             	mov    %ax,%cx
ffffffff8010172c:	48 8b 14 25 38 10 12 	mov    0xffffffff80121038,%rdx
ffffffff80101733:	80 
ffffffff80101734:	8b 45 f8             	mov    -0x8(%rbp),%eax
ffffffff80101737:	89 c6                	mov    %eax,%esi
ffffffff80101739:	83 c6 01             	add    $0x1,%esi
ffffffff8010173c:	89 75 f8             	mov    %esi,-0x8(%rbp)
ffffffff8010173f:	48 63 f8             	movslq %eax,%rdi
ffffffff80101742:	66 89 0c 7a          	mov    %cx,(%rdx,%rdi,2)
ffffffff80101746:	e9 00 00 00 00       	jmpq   ffffffff8010174b <cgaputc+0xfb>
  if(pos < 0 || pos > 25*80)
ffffffff8010174b:	83 7d f8 00          	cmpl   $0x0,-0x8(%rbp)
ffffffff8010174f:	0f 8c 0d 00 00 00    	jl     ffffffff80101762 <cgaputc+0x112>
ffffffff80101755:	81 7d f8 d0 07 00 00 	cmpl   $0x7d0,-0x8(%rbp)
ffffffff8010175c:	0f 8e 0c 00 00 00    	jle    ffffffff8010176e <cgaputc+0x11e>
    panic("pos under/overflow");
ffffffff80101762:	48 c7 c7 88 fb 10 80 	mov    $0xffffffff8010fb88,%rdi
ffffffff80101769:	e8 02 f7 ff ff       	callq  ffffffff80100e70 <panic>
ffffffff8010176e:	b8 50 00 00 00       	mov    $0x50,%eax
  if((pos/80) >= 24){  // Scroll up.
ffffffff80101773:	8b 4d f8             	mov    -0x8(%rbp),%ecx
ffffffff80101776:	89 45 d8             	mov    %eax,-0x28(%rbp)
ffffffff80101779:	89 c8                	mov    %ecx,%eax
ffffffff8010177b:	99                   	cltd   
ffffffff8010177c:	8b 4d d8             	mov    -0x28(%rbp),%ecx
ffffffff8010177f:	f7 f9                	idiv   %ecx
ffffffff80101781:	83 f8 18             	cmp    $0x18,%eax
ffffffff80101784:	0f 8c 73 00 00 00    	jl     ffffffff801017fd <cgaputc+0x1ad>
ffffffff8010178a:	31 c0                	xor    %eax,%eax
ffffffff8010178c:	b9 80 07 00 00       	mov    $0x780,%ecx
    memmove(crt, crt+80, sizeof(crt[0])*23*80);
ffffffff80101791:	48 8b 14 25 38 10 12 	mov    0xffffffff80121038,%rdx
ffffffff80101798:	80 
ffffffff80101799:	48 89 d6             	mov    %rdx,%rsi
ffffffff8010179c:	48 81 c6 a0 00 00 00 	add    $0xa0,%rsi
ffffffff801017a3:	bf 60 0e 00 00       	mov    $0xe60,%edi
ffffffff801017a8:	89 7d d4             	mov    %edi,-0x2c(%rbp)
ffffffff801017ab:	48 89 d7             	mov    %rdx,%rdi
ffffffff801017ae:	8b 55 d4             	mov    -0x2c(%rbp),%edx
ffffffff801017b1:	89 45 d0             	mov    %eax,-0x30(%rbp)
ffffffff801017b4:	89 4d cc             	mov    %ecx,-0x34(%rbp)
ffffffff801017b7:	e8 d4 98 00 00       	callq  ffffffff8010b090 <memmove>
    pos -= 80;
ffffffff801017bc:	8b 4d f8             	mov    -0x8(%rbp),%ecx
ffffffff801017bf:	83 c1 b0             	add    $0xffffffb0,%ecx
ffffffff801017c2:	89 4d f8             	mov    %ecx,-0x8(%rbp)
    memset(crt+pos, 0, sizeof(crt[0])*(24*80 - pos));
ffffffff801017c5:	48 8b 34 25 38 10 12 	mov    0xffffffff80121038,%rsi
ffffffff801017cc:	80 
ffffffff801017cd:	48 63 7d f8          	movslq -0x8(%rbp),%rdi
ffffffff801017d1:	48 c1 e7 01          	shl    $0x1,%rdi
ffffffff801017d5:	48 01 fe             	add    %rdi,%rsi
ffffffff801017d8:	8b 4d cc             	mov    -0x34(%rbp),%ecx
ffffffff801017db:	2b 4d f8             	sub    -0x8(%rbp),%ecx
ffffffff801017de:	48 63 f9             	movslq %ecx,%rdi
ffffffff801017e1:	48 c1 e7 01          	shl    $0x1,%rdi
ffffffff801017e5:	89 f9                	mov    %edi,%ecx
ffffffff801017e7:	31 d2                	xor    %edx,%edx
ffffffff801017e9:	48 89 f7             	mov    %rsi,%rdi
ffffffff801017ec:	89 d6                	mov    %edx,%esi
ffffffff801017ee:	89 ca                	mov    %ecx,%edx
ffffffff801017f0:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
ffffffff801017f4:	e8 07 97 00 00       	callq  ffffffff8010af00 <memset>
ffffffff801017f9:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
ffffffff801017fd:	b8 d4 03 00 00       	mov    $0x3d4,%eax
  outb(CRTPORT, 14);
ffffffff80101802:	be 0e 00 00 00       	mov    $0xe,%esi
ffffffff80101807:	89 c7                	mov    %eax,%edi
ffffffff80101809:	89 45 b4             	mov    %eax,-0x4c(%rbp)
ffffffff8010180c:	e8 4f 00 00 00       	callq  ffffffff80101860 <outb>
  outb(CRTPORT+1, pos>>8);
ffffffff80101811:	8b 45 f8             	mov    -0x8(%rbp),%eax
ffffffff80101814:	88 e1                	mov    %ah,%cl
ffffffff80101816:	0f b6 f1             	movzbl %cl,%esi
ffffffff80101819:	b8 d5 03 00 00       	mov    $0x3d5,%eax
ffffffff8010181e:	89 c7                	mov    %eax,%edi
ffffffff80101820:	89 45 b0             	mov    %eax,-0x50(%rbp)
ffffffff80101823:	e8 38 00 00 00       	callq  ffffffff80101860 <outb>
  outb(CRTPORT, 15);
ffffffff80101828:	be 0f 00 00 00       	mov    $0xf,%esi
ffffffff8010182d:	8b 7d b4             	mov    -0x4c(%rbp),%edi
ffffffff80101830:	e8 2b 00 00 00       	callq  ffffffff80101860 <outb>
  outb(CRTPORT+1, pos);
ffffffff80101835:	0f b6 75 f8          	movzbl -0x8(%rbp),%esi
ffffffff80101839:	8b 7d b0             	mov    -0x50(%rbp),%edi
ffffffff8010183c:	e8 1f 00 00 00       	callq  ffffffff80101860 <outb>
  crt[pos] = ' ' | 0x0700;
ffffffff80101841:	48 8b 14 25 38 10 12 	mov    0xffffffff80121038,%rdx
ffffffff80101848:	80 
ffffffff80101849:	4c 63 45 f8          	movslq -0x8(%rbp),%r8
ffffffff8010184d:	66 42 c7 04 42 20 07 	movw   $0x720,(%rdx,%r8,2)
}
ffffffff80101854:	48 83 c4 50          	add    $0x50,%rsp
ffffffff80101858:	5d                   	pop    %rbp
ffffffff80101859:	c3                   	retq   
ffffffff8010185a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)

ffffffff80101860 <outb>:
{
ffffffff80101860:	55                   	push   %rbp
ffffffff80101861:	48 89 e5             	mov    %rsp,%rbp
ffffffff80101864:	48 83 ec 04          	sub    $0x4,%rsp
ffffffff80101868:	40 88 f0             	mov    %sil,%al
ffffffff8010186b:	66 89 f9             	mov    %di,%cx
ffffffff8010186e:	66 89 4d fe          	mov    %cx,-0x2(%rbp)
ffffffff80101872:	88 45 fd             	mov    %al,-0x3(%rbp)
  asm volatile("out %0,%1" : : "a" (data), "d" (port));
ffffffff80101875:	8a 45 fd             	mov    -0x3(%rbp),%al
ffffffff80101878:	66 8b 55 fe          	mov    -0x2(%rbp),%dx
ffffffff8010187c:	ee                   	out    %al,(%dx)
}
ffffffff8010187d:	48 83 c4 04          	add    $0x4,%rsp
ffffffff80101881:	5d                   	pop    %rbp
ffffffff80101882:	c3                   	retq   
ffffffff80101883:	66 66 66 66 2e 0f 1f 	data16 data16 data16 nopw %cs:0x0(%rax,%rax,1)
ffffffff8010188a:	84 00 00 00 00 00 

ffffffff80101890 <inb>:
{
ffffffff80101890:	55                   	push   %rbp
ffffffff80101891:	48 89 e5             	mov    %rsp,%rbp
ffffffff80101894:	48 83 ec 04          	sub    $0x4,%rsp
ffffffff80101898:	66 89 f8             	mov    %di,%ax
ffffffff8010189b:	66 89 45 fe          	mov    %ax,-0x2(%rbp)
  asm volatile("in %1,%0" : "=a" (data) : "d" (port));
ffffffff8010189f:	66 8b 55 fe          	mov    -0x2(%rbp),%dx
ffffffff801018a3:	ec                   	in     (%dx),%al
ffffffff801018a4:	88 45 fd             	mov    %al,-0x3(%rbp)
  return data;
ffffffff801018a7:	0f b6 45 fd          	movzbl -0x3(%rbp),%eax
ffffffff801018ab:	48 83 c4 04          	add    $0x4,%rsp
ffffffff801018af:	5d                   	pop    %rbp
ffffffff801018b0:	c3                   	retq   
ffffffff801018b1:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
ffffffff801018b8:	00 00 00 
ffffffff801018bb:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

ffffffff801018c0 <lapicinit>:
}
//PAGEBREAK!

void
lapicinit(void)
{
ffffffff801018c0:	55                   	push   %rbp
ffffffff801018c1:	48 89 e5             	mov    %rsp,%rbp
  if(!lapic)
ffffffff801018c4:	48 83 ec 50          	sub    $0x50,%rsp
ffffffff801018c8:	48 8b 04 25 38 66 1f 	mov    0xffffffff831f6638,%rax
ffffffff801018cf:	83 
ffffffff801018d0:	48 83 f8 00          	cmp    $0x0,%rax
ffffffff801018d4:	0f 85 05 00 00 00    	jne    ffffffff801018df <lapicinit+0x1f>
    return;
ffffffff801018da:	e9 74 01 00 00       	jmpq   ffffffff80101a53 <lapicinit+0x193>

  // Enable local APIC; set spurious interrupt vector.
  lapicw(SVR, ENABLE | (TRAP_IRQ0 + IRQ_SPURIOUS));
ffffffff801018df:	bf 3c 00 00 00       	mov    $0x3c,%edi
ffffffff801018e4:	be 3f 01 00 00       	mov    $0x13f,%esi
ffffffff801018e9:	e8 72 01 00 00       	callq  ffffffff80101a60 <lapicw>

  // The timer repeatedly counts down at bus frequency
  // from lapic[TICR] and then issues an interrupt.
  // If xk cared more about precise timekeeping,
  // TICR would be calibrated using an external time source.
  lapicw(TDCR, X1);
ffffffff801018ee:	bf f8 00 00 00       	mov    $0xf8,%edi
ffffffff801018f3:	be 0b 00 00 00       	mov    $0xb,%esi
ffffffff801018f8:	e8 63 01 00 00       	callq  ffffffff80101a60 <lapicw>
  lapicw(TIMER, PERIODIC | (TRAP_IRQ0 + IRQ_TIMER));
ffffffff801018fd:	bf c8 00 00 00       	mov    $0xc8,%edi
ffffffff80101902:	be 20 00 02 00       	mov    $0x20020,%esi
ffffffff80101907:	e8 54 01 00 00       	callq  ffffffff80101a60 <lapicw>
  lapicw(TICR, 10000000);
ffffffff8010190c:	bf e0 00 00 00       	mov    $0xe0,%edi
ffffffff80101911:	be 80 96 98 00       	mov    $0x989680,%esi
ffffffff80101916:	e8 45 01 00 00       	callq  ffffffff80101a60 <lapicw>

  // Disable logical interrupt lines.
  lapicw(LINT0, MASKED);
ffffffff8010191b:	bf d4 00 00 00       	mov    $0xd4,%edi
ffffffff80101920:	be 00 00 01 00       	mov    $0x10000,%esi
ffffffff80101925:	89 75 fc             	mov    %esi,-0x4(%rbp)
ffffffff80101928:	e8 33 01 00 00       	callq  ffffffff80101a60 <lapicw>
  lapicw(LINT1, MASKED);
ffffffff8010192d:	bf d8 00 00 00       	mov    $0xd8,%edi
ffffffff80101932:	8b 75 fc             	mov    -0x4(%rbp),%esi
ffffffff80101935:	e8 26 01 00 00       	callq  ffffffff80101a60 <lapicw>

  // Disable performance counter overflow interrupts
  // on machines that provide that interrupt entry.
  if(((lapic[VER]>>16) & 0xFF) >= 4)
ffffffff8010193a:	48 8b 04 25 38 66 1f 	mov    0xffffffff831f6638,%rax
ffffffff80101941:	83 
ffffffff80101942:	8b 70 30             	mov    0x30(%rax),%esi
ffffffff80101945:	c1 ee 10             	shr    $0x10,%esi
ffffffff80101948:	81 e6 ff 00 00 00    	and    $0xff,%esi
ffffffff8010194e:	83 fe 04             	cmp    $0x4,%esi
ffffffff80101951:	0f 82 1f 00 00 00    	jb     ffffffff80101976 <lapicinit+0xb6>
ffffffff80101957:	b8 d0 00 00 00       	mov    $0xd0,%eax
ffffffff8010195c:	b9 00 00 01 00       	mov    $0x10000,%ecx
    lapicw(PCINT, MASKED);
ffffffff80101961:	bf d0 00 00 00       	mov    $0xd0,%edi
ffffffff80101966:	be 00 00 01 00       	mov    $0x10000,%esi
ffffffff8010196b:	89 45 f8             	mov    %eax,-0x8(%rbp)
ffffffff8010196e:	89 4d f4             	mov    %ecx,-0xc(%rbp)
ffffffff80101971:	e8 ea 00 00 00       	callq  ffffffff80101a60 <lapicw>
ffffffff80101976:	b8 dc 00 00 00       	mov    $0xdc,%eax
ffffffff8010197b:	b9 33 00 00 00       	mov    $0x33,%ecx

  // Map error interrupt to IRQ_ERROR.
  lapicw(ERROR, TRAP_IRQ0 + IRQ_ERROR);
ffffffff80101980:	bf dc 00 00 00       	mov    $0xdc,%edi
ffffffff80101985:	be 33 00 00 00       	mov    $0x33,%esi
ffffffff8010198a:	89 45 f0             	mov    %eax,-0x10(%rbp)
ffffffff8010198d:	89 4d ec             	mov    %ecx,-0x14(%rbp)
ffffffff80101990:	e8 cb 00 00 00       	callq  ffffffff80101a60 <lapicw>
ffffffff80101995:	b8 a0 00 00 00       	mov    $0xa0,%eax
ffffffff8010199a:	31 c9                	xor    %ecx,%ecx

  // Clear error status register (requires back-to-back writes).
  lapicw(ESR, 0);
ffffffff8010199c:	bf a0 00 00 00       	mov    $0xa0,%edi
ffffffff801019a1:	31 f6                	xor    %esi,%esi
ffffffff801019a3:	89 45 e8             	mov    %eax,-0x18(%rbp)
ffffffff801019a6:	89 4d e4             	mov    %ecx,-0x1c(%rbp)
ffffffff801019a9:	e8 b2 00 00 00       	callq  ffffffff80101a60 <lapicw>
ffffffff801019ae:	b8 a0 00 00 00       	mov    $0xa0,%eax
ffffffff801019b3:	31 c9                	xor    %ecx,%ecx
  lapicw(ESR, 0);
ffffffff801019b5:	bf a0 00 00 00       	mov    $0xa0,%edi
ffffffff801019ba:	31 f6                	xor    %esi,%esi
ffffffff801019bc:	89 45 e0             	mov    %eax,-0x20(%rbp)
ffffffff801019bf:	89 4d dc             	mov    %ecx,-0x24(%rbp)
ffffffff801019c2:	e8 99 00 00 00       	callq  ffffffff80101a60 <lapicw>
ffffffff801019c7:	b8 2c 00 00 00       	mov    $0x2c,%eax
ffffffff801019cc:	31 c9                	xor    %ecx,%ecx

  // Ack any outstanding interrupts.
  lapicw(EOI, 0);
ffffffff801019ce:	bf 2c 00 00 00       	mov    $0x2c,%edi
ffffffff801019d3:	31 f6                	xor    %esi,%esi
ffffffff801019d5:	89 45 d8             	mov    %eax,-0x28(%rbp)
ffffffff801019d8:	89 4d d4             	mov    %ecx,-0x2c(%rbp)
ffffffff801019db:	e8 80 00 00 00       	callq  ffffffff80101a60 <lapicw>
ffffffff801019e0:	b8 c4 00 00 00       	mov    $0xc4,%eax
ffffffff801019e5:	31 c9                	xor    %ecx,%ecx

  // Send an Init Level De-Assert to synchronise arbitration ID's.
  lapicw(ICRHI, 0);
ffffffff801019e7:	bf c4 00 00 00       	mov    $0xc4,%edi
ffffffff801019ec:	31 f6                	xor    %esi,%esi
ffffffff801019ee:	89 45 d0             	mov    %eax,-0x30(%rbp)
ffffffff801019f1:	89 4d cc             	mov    %ecx,-0x34(%rbp)
ffffffff801019f4:	e8 67 00 00 00       	callq  ffffffff80101a60 <lapicw>
ffffffff801019f9:	b8 c0 00 00 00       	mov    $0xc0,%eax
ffffffff801019fe:	b9 00 85 08 00       	mov    $0x88500,%ecx
  lapicw(ICRLO, BCAST | INIT | LEVEL);
ffffffff80101a03:	bf c0 00 00 00       	mov    $0xc0,%edi
ffffffff80101a08:	be 00 85 08 00       	mov    $0x88500,%esi
ffffffff80101a0d:	89 45 c8             	mov    %eax,-0x38(%rbp)
ffffffff80101a10:	89 4d c4             	mov    %ecx,-0x3c(%rbp)
ffffffff80101a13:	e8 48 00 00 00       	callq  ffffffff80101a60 <lapicw>
  while(lapic[ICRLO] & DELIVS)
ffffffff80101a18:	48 8b 04 25 38 66 1f 	mov    0xffffffff831f6638,%rax
ffffffff80101a1f:	83 
ffffffff80101a20:	8b 88 00 03 00 00    	mov    0x300(%rax),%ecx
ffffffff80101a26:	81 e1 00 10 00 00    	and    $0x1000,%ecx
ffffffff80101a2c:	83 f9 00             	cmp    $0x0,%ecx
ffffffff80101a2f:	0f 84 05 00 00 00    	je     ffffffff80101a3a <lapicinit+0x17a>
ffffffff80101a35:	e9 de ff ff ff       	jmpq   ffffffff80101a18 <lapicinit+0x158>
ffffffff80101a3a:	b8 20 00 00 00       	mov    $0x20,%eax
ffffffff80101a3f:	31 c9                	xor    %ecx,%ecx
    ;

  // Enable interrupts on the APIC (but not on the processor).
  lapicw(TPR, 0);
ffffffff80101a41:	bf 20 00 00 00       	mov    $0x20,%edi
ffffffff80101a46:	31 f6                	xor    %esi,%esi
ffffffff80101a48:	89 45 c0             	mov    %eax,-0x40(%rbp)
ffffffff80101a4b:	89 4d bc             	mov    %ecx,-0x44(%rbp)
ffffffff80101a4e:	e8 0d 00 00 00       	callq  ffffffff80101a60 <lapicw>
}
ffffffff80101a53:	48 83 c4 50          	add    $0x50,%rsp
ffffffff80101a57:	5d                   	pop    %rbp
ffffffff80101a58:	c3                   	retq   
ffffffff80101a59:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)

ffffffff80101a60 <lapicw>:
{
ffffffff80101a60:	55                   	push   %rbp
ffffffff80101a61:	48 89 e5             	mov    %rsp,%rbp
ffffffff80101a64:	48 83 ec 0c          	sub    $0xc,%rsp
ffffffff80101a68:	89 7d fc             	mov    %edi,-0x4(%rbp)
ffffffff80101a6b:	89 75 f8             	mov    %esi,-0x8(%rbp)
  lapic[index] = value;
ffffffff80101a6e:	8b 75 f8             	mov    -0x8(%rbp),%esi
ffffffff80101a71:	48 8b 04 25 38 66 1f 	mov    0xffffffff831f6638,%rax
ffffffff80101a78:	83 
ffffffff80101a79:	48 63 4d fc          	movslq -0x4(%rbp),%rcx
ffffffff80101a7d:	89 34 88             	mov    %esi,(%rax,%rcx,4)
  lapic[ID];  // wait for write to finish, by reading
ffffffff80101a80:	48 8b 04 25 38 66 1f 	mov    0xffffffff831f6638,%rax
ffffffff80101a87:	83 
ffffffff80101a88:	8b 70 20             	mov    0x20(%rax),%esi
}
ffffffff80101a8b:	89 75 f4             	mov    %esi,-0xc(%rbp)
ffffffff80101a8e:	48 83 c4 0c          	add    $0xc,%rsp
ffffffff80101a92:	5d                   	pop    %rbp
ffffffff80101a93:	c3                   	retq   
ffffffff80101a94:	66 66 66 2e 0f 1f 84 	data16 data16 nopw %cs:0x0(%rax,%rax,1)
ffffffff80101a9b:	00 00 00 00 00 

ffffffff80101aa0 <cpunum>:

int
cpunum(void)
{
ffffffff80101aa0:	55                   	push   %rbp
ffffffff80101aa1:	48 89 e5             	mov    %rsp,%rbp
  // Cannot call cpu when interrupts are enabled:
  // result not guaranteed to last long enough to be used!
  // Would prefer to panic but even printing is chancy here:
  // almost everything, including cprintf and panic, calls cpu,
  // often indirectly through acquire and release.
  if(readeflags()&FLAGS_IF){
ffffffff80101aa4:	48 83 ec 10          	sub    $0x10,%rsp
ffffffff80101aa8:	e8 e3 00 00 00       	callq  ffffffff80101b90 <readeflags>
ffffffff80101aad:	48 25 00 02 00 00    	and    $0x200,%rax
ffffffff80101ab3:	48 83 f8 00          	cmp    $0x0,%rax
ffffffff80101ab7:	0f 84 36 00 00 00    	je     ffffffff80101af3 <cpunum+0x53>
    static int n;
    if(n++ == 0)
ffffffff80101abd:	8b 04 25 74 64 1f 83 	mov    0xffffffff831f6474,%eax
ffffffff80101ac4:	89 c1                	mov    %eax,%ecx
ffffffff80101ac6:	ff c1                	inc    %ecx
ffffffff80101ac8:	89 0c 25 74 64 1f 83 	mov    %ecx,0xffffffff831f6474
ffffffff80101acf:	83 f8 00             	cmp    $0x0,%eax
ffffffff80101ad2:	0f 85 16 00 00 00    	jne    ffffffff80101aee <cpunum+0x4e>
      cprintf("cpu called from %x with interrupts enabled\n",
        __builtin_return_address(0));
ffffffff80101ad8:	48 8b 75 08          	mov    0x8(%rbp),%rsi
      cprintf("cpu called from %x with interrupts enabled\n",
ffffffff80101adc:	48 c7 c7 9b fb 10 80 	mov    $0xffffffff8010fb9b,%rdi
ffffffff80101ae3:	31 c0                	xor    %eax,%eax
ffffffff80101ae5:	88 c1                	mov    %al,%cl
ffffffff80101ae7:	88 c8                	mov    %cl,%al
ffffffff80101ae9:	e8 72 ee ff ff       	callq  ffffffff80100960 <cprintf>
  }
ffffffff80101aee:	e9 00 00 00 00       	jmpq   ffffffff80101af3 <cpunum+0x53>

  if (!lapic)
ffffffff80101af3:	48 8b 04 25 38 66 1f 	mov    0xffffffff831f6638,%rax
ffffffff80101afa:	83 
ffffffff80101afb:	48 83 f8 00          	cmp    $0x0,%rax
ffffffff80101aff:	0f 85 0c 00 00 00    	jne    ffffffff80101b11 <cpunum+0x71>
    return 0;
ffffffff80101b05:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
ffffffff80101b0c:	e9 72 00 00 00       	jmpq   ffffffff80101b83 <cpunum+0xe3>

  apicid = lapic[ID] >> 24;
ffffffff80101b11:	48 8b 04 25 38 66 1f 	mov    0xffffffff831f6638,%rax
ffffffff80101b18:	83 
ffffffff80101b19:	8b 48 20             	mov    0x20(%rax),%ecx
ffffffff80101b1c:	c1 e9 18             	shr    $0x18,%ecx
ffffffff80101b1f:	89 4d f8             	mov    %ecx,-0x8(%rbp)
  for (i = 0; i < ncpu; ++i) {
ffffffff80101b22:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)
ffffffff80101b29:	8b 45 f4             	mov    -0xc(%rbp),%eax
ffffffff80101b2c:	8b 0c 25 a0 82 1f 83 	mov    0xffffffff831f82a0,%ecx
ffffffff80101b33:	39 c8                	cmp    %ecx,%eax
ffffffff80101b35:	0f 8d 3c 00 00 00    	jge    ffffffff80101b77 <cpunum+0xd7>
    if (cpus[i].apicid == apicid)
ffffffff80101b3b:	48 63 45 f4          	movslq -0xc(%rbp),%rax
ffffffff80101b3f:	48 69 c0 d8 00 00 00 	imul   $0xd8,%rax,%rax
ffffffff80101b46:	48 8d 80 e0 7b 1f 83 	lea    -0x7ce08420(%rax),%rax
ffffffff80101b4d:	0f b6 08             	movzbl (%rax),%ecx
ffffffff80101b50:	3b 4d f8             	cmp    -0x8(%rbp),%ecx
ffffffff80101b53:	0f 85 0b 00 00 00    	jne    ffffffff80101b64 <cpunum+0xc4>
      return i;
ffffffff80101b59:	8b 45 f4             	mov    -0xc(%rbp),%eax
ffffffff80101b5c:	89 45 fc             	mov    %eax,-0x4(%rbp)
ffffffff80101b5f:	e9 1f 00 00 00       	jmpq   ffffffff80101b83 <cpunum+0xe3>
  }
ffffffff80101b64:	e9 00 00 00 00       	jmpq   ffffffff80101b69 <cpunum+0xc9>
  for (i = 0; i < ncpu; ++i) {
ffffffff80101b69:	8b 45 f4             	mov    -0xc(%rbp),%eax
ffffffff80101b6c:	83 c0 01             	add    $0x1,%eax
ffffffff80101b6f:	89 45 f4             	mov    %eax,-0xc(%rbp)
ffffffff80101b72:	e9 b2 ff ff ff       	jmpq   ffffffff80101b29 <cpunum+0x89>
  panic("unknown apicid\n");
ffffffff80101b77:	48 c7 c7 c7 fb 10 80 	mov    $0xffffffff8010fbc7,%rdi
ffffffff80101b7e:	e8 ed f2 ff ff       	callq  ffffffff80100e70 <panic>
}
ffffffff80101b83:	8b 45 fc             	mov    -0x4(%rbp),%eax
ffffffff80101b86:	48 83 c4 10          	add    $0x10,%rsp
ffffffff80101b8a:	5d                   	pop    %rbp
ffffffff80101b8b:	c3                   	retq   
ffffffff80101b8c:	0f 1f 40 00          	nopl   0x0(%rax)

ffffffff80101b90 <readeflags>:
{
ffffffff80101b90:	55                   	push   %rbp
ffffffff80101b91:	48 89 e5             	mov    %rsp,%rbp
  asm volatile("pushf; pop %0" : "=r" (eflags));
ffffffff80101b94:	50                   	push   %rax
ffffffff80101b95:	9c                   	pushfq 
ffffffff80101b96:	58                   	pop    %rax
ffffffff80101b97:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  return eflags;
ffffffff80101b9b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
ffffffff80101b9f:	48 83 c4 08          	add    $0x8,%rsp
ffffffff80101ba3:	5d                   	pop    %rbp
ffffffff80101ba4:	c3                   	retq   
ffffffff80101ba5:	66 66 2e 0f 1f 84 00 	data16 nopw %cs:0x0(%rax,%rax,1)
ffffffff80101bac:	00 00 00 00 

ffffffff80101bb0 <lapiceoi>:

// Acknowledge interrupt.
void
lapiceoi(void)
{
ffffffff80101bb0:	55                   	push   %rbp
ffffffff80101bb1:	48 89 e5             	mov    %rsp,%rbp
  if(lapic)
ffffffff80101bb4:	48 83 ec 10          	sub    $0x10,%rsp
ffffffff80101bb8:	48 8b 04 25 38 66 1f 	mov    0xffffffff831f6638,%rax
ffffffff80101bbf:	83 
ffffffff80101bc0:	48 83 f8 00          	cmp    $0x0,%rax
ffffffff80101bc4:	0f 84 19 00 00 00    	je     ffffffff80101be3 <lapiceoi+0x33>
ffffffff80101bca:	b8 2c 00 00 00       	mov    $0x2c,%eax
ffffffff80101bcf:	31 c9                	xor    %ecx,%ecx
    lapicw(EOI, 0);
ffffffff80101bd1:	bf 2c 00 00 00       	mov    $0x2c,%edi
ffffffff80101bd6:	31 f6                	xor    %esi,%esi
ffffffff80101bd8:	89 45 fc             	mov    %eax,-0x4(%rbp)
ffffffff80101bdb:	89 4d f8             	mov    %ecx,-0x8(%rbp)
ffffffff80101bde:	e8 7d fe ff ff       	callq  ffffffff80101a60 <lapicw>
}
ffffffff80101be3:	48 83 c4 10          	add    $0x10,%rsp
ffffffff80101be7:	5d                   	pop    %rbp
ffffffff80101be8:	c3                   	retq   
ffffffff80101be9:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)

ffffffff80101bf0 <microdelay>:

// Spin for a given number of microseconds.
// On real hardware would want to tune this dynamically.
void
microdelay(int us)
{
ffffffff80101bf0:	55                   	push   %rbp
ffffffff80101bf1:	48 89 e5             	mov    %rsp,%rbp
ffffffff80101bf4:	48 83 ec 04          	sub    $0x4,%rsp
ffffffff80101bf8:	89 7d fc             	mov    %edi,-0x4(%rbp)
}
ffffffff80101bfb:	48 83 c4 04          	add    $0x4,%rsp
ffffffff80101bff:	5d                   	pop    %rbp
ffffffff80101c00:	c3                   	retq   
ffffffff80101c01:	66 66 66 66 66 66 2e 	data16 data16 data16 data16 data16 nopw %cs:0x0(%rax,%rax,1)
ffffffff80101c08:	0f 1f 84 00 00 00 00 
ffffffff80101c0f:	00 

ffffffff80101c10 <lapicstartap>:

// Start additional processor running entry code at addr.
// See Appendix B of MultiProcessor Specification.
void
lapicstartap(uchar apicid, uint addr)
{
ffffffff80101c10:	55                   	push   %rbp
ffffffff80101c11:	48 89 e5             	mov    %rsp,%rbp
ffffffff80101c14:	48 83 ec 50          	sub    $0x50,%rsp
ffffffff80101c18:	40 88 f8             	mov    %dil,%al
ffffffff80101c1b:	bf 70 00 00 00       	mov    $0x70,%edi
ffffffff80101c20:	b9 0f 00 00 00       	mov    $0xf,%ecx
ffffffff80101c25:	88 45 ff             	mov    %al,-0x1(%rbp)
ffffffff80101c28:	89 75 f8             	mov    %esi,-0x8(%rbp)
  ushort *wrv;

  // "The BSP must initialize CMOS shutdown code to 0AH
  // and the warm reset vector (DWORD based at 40:67) to point at
  // the AP startup code prior to the [universal startup algorithm]."
  outb(CMOS_PORT, 0xF);  // offset 0xF is shutdown code
ffffffff80101c2b:	be 70 00 00 00       	mov    $0x70,%esi
ffffffff80101c30:	ba 0f 00 00 00       	mov    $0xf,%edx
ffffffff80101c35:	89 7d e4             	mov    %edi,-0x1c(%rbp)
ffffffff80101c38:	89 f7                	mov    %esi,%edi
ffffffff80101c3a:	89 d6                	mov    %edx,%esi
ffffffff80101c3c:	89 4d e0             	mov    %ecx,-0x20(%rbp)
ffffffff80101c3f:	e8 4c 01 00 00       	callq  ffffffff80101d90 <outb>
ffffffff80101c44:	b9 71 00 00 00       	mov    $0x71,%ecx
ffffffff80101c49:	ba 0a 00 00 00       	mov    $0xa,%edx
  outb(CMOS_PORT+1, 0x0A);
ffffffff80101c4e:	bf 71 00 00 00       	mov    $0x71,%edi
ffffffff80101c53:	be 0a 00 00 00       	mov    $0xa,%esi
ffffffff80101c58:	89 4d dc             	mov    %ecx,-0x24(%rbp)
ffffffff80101c5b:	89 55 d8             	mov    %edx,-0x28(%rbp)
ffffffff80101c5e:	e8 2d 01 00 00       	callq  ffffffff80101d90 <outb>
ffffffff80101c63:	b9 c4 00 00 00       	mov    $0xc4,%ecx
ffffffff80101c68:	ba 67 04 00 00       	mov    $0x467,%edx
ffffffff80101c6d:	41 89 d0             	mov    %edx,%r8d
ffffffff80101c70:	49 81 c0 00 00 00 80 	add    $0xffffffff80000000,%r8
  wrv = (ushort*)P2V((0x40<<4 | 0x67));  // Warm reset vector
ffffffff80101c77:	4c 89 45 e8          	mov    %r8,-0x18(%rbp)
  wrv[0] = 0;
ffffffff80101c7b:	4c 8b 45 e8          	mov    -0x18(%rbp),%r8
ffffffff80101c7f:	66 41 c7 00 00 00    	movw   $0x0,(%r8)
  wrv[1] = addr >> 4;
ffffffff80101c85:	8b 55 f8             	mov    -0x8(%rbp),%edx
ffffffff80101c88:	c1 ea 04             	shr    $0x4,%edx
ffffffff80101c8b:	66 41 89 d1          	mov    %dx,%r9w
ffffffff80101c8f:	4c 8b 45 e8          	mov    -0x18(%rbp),%r8
ffffffff80101c93:	66 45 89 48 02       	mov    %r9w,0x2(%r8)

  // "Universal startup algorithm."
  // Send INIT (level-triggered) interrupt to reset other CPU.
  lapicw(ICRHI, apicid<<24);
ffffffff80101c98:	0f b6 55 ff          	movzbl -0x1(%rbp),%edx
ffffffff80101c9c:	c1 e2 18             	shl    $0x18,%edx
ffffffff80101c9f:	bf c4 00 00 00       	mov    $0xc4,%edi
ffffffff80101ca4:	89 d6                	mov    %edx,%esi
ffffffff80101ca6:	89 4d d4             	mov    %ecx,-0x2c(%rbp)
ffffffff80101ca9:	e8 b2 fd ff ff       	callq  ffffffff80101a60 <lapicw>
ffffffff80101cae:	b9 c0 00 00 00       	mov    $0xc0,%ecx
ffffffff80101cb3:	ba 00 c5 00 00       	mov    $0xc500,%edx
  lapicw(ICRLO, INIT | LEVEL | ASSERT);
ffffffff80101cb8:	bf c0 00 00 00       	mov    $0xc0,%edi
ffffffff80101cbd:	be 00 c5 00 00       	mov    $0xc500,%esi
ffffffff80101cc2:	89 4d d0             	mov    %ecx,-0x30(%rbp)
ffffffff80101cc5:	89 55 cc             	mov    %edx,-0x34(%rbp)
ffffffff80101cc8:	e8 93 fd ff ff       	callq  ffffffff80101a60 <lapicw>
ffffffff80101ccd:	b9 c8 00 00 00       	mov    $0xc8,%ecx
  microdelay(200);
ffffffff80101cd2:	bf c8 00 00 00       	mov    $0xc8,%edi
ffffffff80101cd7:	89 4d c8             	mov    %ecx,-0x38(%rbp)
ffffffff80101cda:	e8 11 ff ff ff       	callq  ffffffff80101bf0 <microdelay>
ffffffff80101cdf:	b9 c0 00 00 00       	mov    $0xc0,%ecx
ffffffff80101ce4:	ba 00 85 00 00       	mov    $0x8500,%edx
  lapicw(ICRLO, INIT | LEVEL);
ffffffff80101ce9:	bf c0 00 00 00       	mov    $0xc0,%edi
ffffffff80101cee:	be 00 85 00 00       	mov    $0x8500,%esi
ffffffff80101cf3:	89 4d c4             	mov    %ecx,-0x3c(%rbp)
ffffffff80101cf6:	89 55 c0             	mov    %edx,-0x40(%rbp)
ffffffff80101cf9:	e8 62 fd ff ff       	callq  ffffffff80101a60 <lapicw>
ffffffff80101cfe:	b9 64 00 00 00       	mov    $0x64,%ecx
  microdelay(100);    // should be 10ms, but too slow in Bochs!
ffffffff80101d03:	bf 64 00 00 00       	mov    $0x64,%edi
ffffffff80101d08:	89 4d bc             	mov    %ecx,-0x44(%rbp)
ffffffff80101d0b:	e8 e0 fe ff ff       	callq  ffffffff80101bf0 <microdelay>
  // Send startup IPI (twice!) to enter code.
  // Regular hardware is supposed to only accept a STARTUP
  // when it is in the halted state due to an INIT.  So the second
  // should be ignored, but it is part of the official Intel algorithm.
  // Bochs complains about the second one.  Too bad for Bochs.
  for(i = 0; i < 2; i++){
ffffffff80101d10:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)
ffffffff80101d17:	83 7d f4 02          	cmpl   $0x2,-0xc(%rbp)
ffffffff80101d1b:	0f 8d 5b 00 00 00    	jge    ffffffff80101d7c <lapicstartap+0x16c>
ffffffff80101d21:	b8 c4 00 00 00       	mov    $0xc4,%eax
    lapicw(ICRHI, apicid<<24);
ffffffff80101d26:	0f b6 4d ff          	movzbl -0x1(%rbp),%ecx
ffffffff80101d2a:	c1 e1 18             	shl    $0x18,%ecx
ffffffff80101d2d:	bf c4 00 00 00       	mov    $0xc4,%edi
ffffffff80101d32:	89 ce                	mov    %ecx,%esi
ffffffff80101d34:	89 45 b8             	mov    %eax,-0x48(%rbp)
ffffffff80101d37:	e8 24 fd ff ff       	callq  ffffffff80101a60 <lapicw>
ffffffff80101d3c:	b8 c0 00 00 00       	mov    $0xc0,%eax
    lapicw(ICRLO, STARTUP | (addr>>12));
ffffffff80101d41:	8b 4d f8             	mov    -0x8(%rbp),%ecx
ffffffff80101d44:	c1 e9 0c             	shr    $0xc,%ecx
ffffffff80101d47:	81 c9 00 06 00 00    	or     $0x600,%ecx
ffffffff80101d4d:	bf c0 00 00 00       	mov    $0xc0,%edi
ffffffff80101d52:	89 ce                	mov    %ecx,%esi
ffffffff80101d54:	89 45 b4             	mov    %eax,-0x4c(%rbp)
ffffffff80101d57:	e8 04 fd ff ff       	callq  ffffffff80101a60 <lapicw>
ffffffff80101d5c:	b8 c8 00 00 00       	mov    $0xc8,%eax
    microdelay(200);
ffffffff80101d61:	bf c8 00 00 00       	mov    $0xc8,%edi
ffffffff80101d66:	89 45 b0             	mov    %eax,-0x50(%rbp)
ffffffff80101d69:	e8 82 fe ff ff       	callq  ffffffff80101bf0 <microdelay>
  for(i = 0; i < 2; i++){
ffffffff80101d6e:	8b 45 f4             	mov    -0xc(%rbp),%eax
ffffffff80101d71:	83 c0 01             	add    $0x1,%eax
ffffffff80101d74:	89 45 f4             	mov    %eax,-0xc(%rbp)
ffffffff80101d77:	e9 9b ff ff ff       	jmpq   ffffffff80101d17 <lapicstartap+0x107>
  }
}
ffffffff80101d7c:	48 83 c4 50          	add    $0x50,%rsp
ffffffff80101d80:	5d                   	pop    %rbp
ffffffff80101d81:	c3                   	retq   
ffffffff80101d82:	66 66 66 66 66 2e 0f 	data16 data16 data16 data16 nopw %cs:0x0(%rax,%rax,1)
ffffffff80101d89:	1f 84 00 00 00 00 00 

ffffffff80101d90 <outb>:
{
ffffffff80101d90:	55                   	push   %rbp
ffffffff80101d91:	48 89 e5             	mov    %rsp,%rbp
ffffffff80101d94:	48 83 ec 04          	sub    $0x4,%rsp
ffffffff80101d98:	40 88 f0             	mov    %sil,%al
ffffffff80101d9b:	66 89 f9             	mov    %di,%cx
ffffffff80101d9e:	66 89 4d fe          	mov    %cx,-0x2(%rbp)
ffffffff80101da2:	88 45 fd             	mov    %al,-0x3(%rbp)
  asm volatile("out %0,%1" : : "a" (data), "d" (port));
ffffffff80101da5:	8a 45 fd             	mov    -0x3(%rbp),%al
ffffffff80101da8:	66 8b 55 fe          	mov    -0x2(%rbp),%dx
ffffffff80101dac:	ee                   	out    %al,(%dx)
}
ffffffff80101dad:	48 83 c4 04          	add    $0x4,%rsp
ffffffff80101db1:	5d                   	pop    %rbp
ffffffff80101db2:	c3                   	retq   
ffffffff80101db3:	66 66 66 66 2e 0f 1f 	data16 data16 data16 nopw %cs:0x0(%rax,%rax,1)
ffffffff80101dba:	84 00 00 00 00 00 

ffffffff80101dc0 <cmostime>:
  r->year   = cmos_read(YEAR);
}

// qemu seems to use 24-hour GWT and the values are BCD encoded
void cmostime(struct rtcdate *r)
{
ffffffff80101dc0:	55                   	push   %rbp
ffffffff80101dc1:	48 89 e5             	mov    %rsp,%rbp
ffffffff80101dc4:	48 83 ec 70          	sub    $0x70,%rsp
ffffffff80101dc8:	b8 0b 00 00 00       	mov    $0xb,%eax
ffffffff80101dcd:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  struct rtcdate t1, t2;
  int sb, bcd;

  sb = cmos_read(CMOS_STATB);
ffffffff80101dd1:	bf 0b 00 00 00       	mov    $0xb,%edi
ffffffff80101dd6:	89 45 bc             	mov    %eax,-0x44(%rbp)
ffffffff80101dd9:	e8 42 01 00 00       	callq  ffffffff80101f20 <cmos_read>
ffffffff80101dde:	89 45 c4             	mov    %eax,-0x3c(%rbp)

  bcd = (sb & (1 << 2)) == 0;
ffffffff80101de1:	8b 45 c4             	mov    -0x3c(%rbp),%eax
ffffffff80101de4:	83 e0 04             	and    $0x4,%eax
ffffffff80101de7:	83 f8 00             	cmp    $0x0,%eax
ffffffff80101dea:	0f 94 c1             	sete   %cl
ffffffff80101ded:	80 e1 01             	and    $0x1,%cl
ffffffff80101df0:	0f b6 c1             	movzbl %cl,%eax
ffffffff80101df3:	89 45 c0             	mov    %eax,-0x40(%rbp)
ffffffff80101df6:	48 8d 45 e0          	lea    -0x20(%rbp),%rax
ffffffff80101dfa:	48 8d 7d e0          	lea    -0x20(%rbp),%rdi

  // make sure CMOS doesn't modify time while we read it
  for(;;) {
    fill_rtcdate(&t1);
ffffffff80101dfe:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
ffffffff80101e02:	e8 79 01 00 00       	callq  ffffffff80101f80 <fill_rtcdate>
ffffffff80101e07:	b9 0a 00 00 00       	mov    $0xa,%ecx
    if(cmos_read(CMOS_STATA) & CMOS_UIP)
ffffffff80101e0c:	bf 0a 00 00 00       	mov    $0xa,%edi
ffffffff80101e11:	89 4d ac             	mov    %ecx,-0x54(%rbp)
ffffffff80101e14:	e8 07 01 00 00       	callq  ffffffff80101f20 <cmos_read>
ffffffff80101e19:	25 80 00 00 00       	and    $0x80,%eax
ffffffff80101e1e:	83 f8 00             	cmp    $0x0,%eax
ffffffff80101e21:	0f 84 05 00 00 00    	je     ffffffff80101e2c <cmostime+0x6c>
        continue;
ffffffff80101e27:	e9 ca ff ff ff       	jmpq   ffffffff80101df6 <cmostime+0x36>
ffffffff80101e2c:	48 8d 45 c8          	lea    -0x38(%rbp),%rax
ffffffff80101e30:	48 8d 7d c8          	lea    -0x38(%rbp),%rdi
    fill_rtcdate(&t2);
ffffffff80101e34:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
ffffffff80101e38:	e8 43 01 00 00       	callq  ffffffff80101f80 <fill_rtcdate>
ffffffff80101e3d:	b9 18 00 00 00       	mov    $0x18,%ecx
ffffffff80101e42:	48 8d 45 c8          	lea    -0x38(%rbp),%rax
ffffffff80101e46:	48 8d 7d e0          	lea    -0x20(%rbp),%rdi
    if(memcmp(&t1, &t2, sizeof(t1)) == 0)
ffffffff80101e4a:	ba 18 00 00 00       	mov    $0x18,%edx
ffffffff80101e4f:	48 89 c6             	mov    %rax,%rsi
ffffffff80101e52:	89 4d 9c             	mov    %ecx,-0x64(%rbp)
ffffffff80101e55:	e8 96 91 00 00       	callq  ffffffff8010aff0 <memcmp>
ffffffff80101e5a:	83 f8 00             	cmp    $0x0,%eax
ffffffff80101e5d:	0f 85 05 00 00 00    	jne    ffffffff80101e68 <cmostime+0xa8>
      break;
ffffffff80101e63:	e9 05 00 00 00       	jmpq   ffffffff80101e6d <cmostime+0xad>
  for(;;) {
ffffffff80101e68:	e9 89 ff ff ff       	jmpq   ffffffff80101df6 <cmostime+0x36>
  }

  // convert
  if(bcd) {
ffffffff80101e6d:	83 7d c0 00          	cmpl   $0x0,-0x40(%rbp)
ffffffff80101e71:	0f 84 78 00 00 00    	je     ffffffff80101eef <cmostime+0x12f>
#define    CONV(x)     (t1.x = ((t1.x >> 4) * 10) + (t1.x & 0xf))
    CONV(second);
ffffffff80101e77:	8b 45 e0             	mov    -0x20(%rbp),%eax
ffffffff80101e7a:	c1 e8 04             	shr    $0x4,%eax
ffffffff80101e7d:	6b c0 0a             	imul   $0xa,%eax,%eax
ffffffff80101e80:	8b 4d e0             	mov    -0x20(%rbp),%ecx
ffffffff80101e83:	83 e1 0f             	and    $0xf,%ecx
ffffffff80101e86:	01 c8                	add    %ecx,%eax
ffffffff80101e88:	89 45 e0             	mov    %eax,-0x20(%rbp)
    CONV(minute);
ffffffff80101e8b:	8b 45 e4             	mov    -0x1c(%rbp),%eax
ffffffff80101e8e:	c1 e8 04             	shr    $0x4,%eax
ffffffff80101e91:	6b c0 0a             	imul   $0xa,%eax,%eax
ffffffff80101e94:	8b 4d e4             	mov    -0x1c(%rbp),%ecx
ffffffff80101e97:	83 e1 0f             	and    $0xf,%ecx
ffffffff80101e9a:	01 c8                	add    %ecx,%eax
ffffffff80101e9c:	89 45 e4             	mov    %eax,-0x1c(%rbp)
    CONV(hour  );
ffffffff80101e9f:	8b 45 e8             	mov    -0x18(%rbp),%eax
ffffffff80101ea2:	c1 e8 04             	shr    $0x4,%eax
ffffffff80101ea5:	6b c0 0a             	imul   $0xa,%eax,%eax
ffffffff80101ea8:	8b 4d e8             	mov    -0x18(%rbp),%ecx
ffffffff80101eab:	83 e1 0f             	and    $0xf,%ecx
ffffffff80101eae:	01 c8                	add    %ecx,%eax
ffffffff80101eb0:	89 45 e8             	mov    %eax,-0x18(%rbp)
    CONV(day   );
ffffffff80101eb3:	8b 45 ec             	mov    -0x14(%rbp),%eax
ffffffff80101eb6:	c1 e8 04             	shr    $0x4,%eax
ffffffff80101eb9:	6b c0 0a             	imul   $0xa,%eax,%eax
ffffffff80101ebc:	8b 4d ec             	mov    -0x14(%rbp),%ecx
ffffffff80101ebf:	83 e1 0f             	and    $0xf,%ecx
ffffffff80101ec2:	01 c8                	add    %ecx,%eax
ffffffff80101ec4:	89 45 ec             	mov    %eax,-0x14(%rbp)
    CONV(month );
ffffffff80101ec7:	8b 45 f0             	mov    -0x10(%rbp),%eax
ffffffff80101eca:	c1 e8 04             	shr    $0x4,%eax
ffffffff80101ecd:	6b c0 0a             	imul   $0xa,%eax,%eax
ffffffff80101ed0:	8b 4d f0             	mov    -0x10(%rbp),%ecx
ffffffff80101ed3:	83 e1 0f             	and    $0xf,%ecx
ffffffff80101ed6:	01 c8                	add    %ecx,%eax
ffffffff80101ed8:	89 45 f0             	mov    %eax,-0x10(%rbp)
    CONV(year  );
ffffffff80101edb:	8b 45 f4             	mov    -0xc(%rbp),%eax
ffffffff80101ede:	c1 e8 04             	shr    $0x4,%eax
ffffffff80101ee1:	6b c0 0a             	imul   $0xa,%eax,%eax
ffffffff80101ee4:	8b 4d f4             	mov    -0xc(%rbp),%ecx
ffffffff80101ee7:	83 e1 0f             	and    $0xf,%ecx
ffffffff80101eea:	01 c8                	add    %ecx,%eax
ffffffff80101eec:	89 45 f4             	mov    %eax,-0xc(%rbp)
#undef     CONV
  }

  *r = t1;
ffffffff80101eef:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
ffffffff80101ef3:	48 8b 4d e0          	mov    -0x20(%rbp),%rcx
ffffffff80101ef7:	48 89 08             	mov    %rcx,(%rax)
ffffffff80101efa:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
ffffffff80101efe:	48 89 48 08          	mov    %rcx,0x8(%rax)
ffffffff80101f02:	48 8b 4d f0          	mov    -0x10(%rbp),%rcx
ffffffff80101f06:	48 89 48 10          	mov    %rcx,0x10(%rax)
  r->year += 2000;
ffffffff80101f0a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
ffffffff80101f0e:	8b 50 14             	mov    0x14(%rax),%edx
ffffffff80101f11:	81 c2 d0 07 00 00    	add    $0x7d0,%edx
ffffffff80101f17:	89 50 14             	mov    %edx,0x14(%rax)
}
ffffffff80101f1a:	48 83 c4 70          	add    $0x70,%rsp
ffffffff80101f1e:	5d                   	pop    %rbp
ffffffff80101f1f:	c3                   	retq   

ffffffff80101f20 <cmos_read>:
{
ffffffff80101f20:	55                   	push   %rbp
ffffffff80101f21:	48 89 e5             	mov    %rsp,%rbp
ffffffff80101f24:	48 83 ec 10          	sub    $0x10,%rsp
ffffffff80101f28:	b8 70 00 00 00       	mov    $0x70,%eax
ffffffff80101f2d:	89 7d fc             	mov    %edi,-0x4(%rbp)
  outb(CMOS_PORT,  reg);
ffffffff80101f30:	8b 7d fc             	mov    -0x4(%rbp),%edi
ffffffff80101f33:	40 88 f9             	mov    %dil,%cl
ffffffff80101f36:	0f b6 f1             	movzbl %cl,%esi
ffffffff80101f39:	bf 70 00 00 00       	mov    $0x70,%edi
ffffffff80101f3e:	89 45 f8             	mov    %eax,-0x8(%rbp)
ffffffff80101f41:	e8 4a fe ff ff       	callq  ffffffff80101d90 <outb>
ffffffff80101f46:	b8 c8 00 00 00       	mov    $0xc8,%eax
  microdelay(200);
ffffffff80101f4b:	bf c8 00 00 00       	mov    $0xc8,%edi
ffffffff80101f50:	89 45 f4             	mov    %eax,-0xc(%rbp)
ffffffff80101f53:	e8 98 fc ff ff       	callq  ffffffff80101bf0 <microdelay>
ffffffff80101f58:	b8 71 00 00 00       	mov    $0x71,%eax
  return inb(CMOS_RETURN);
ffffffff80101f5d:	bf 71 00 00 00       	mov    $0x71,%edi
ffffffff80101f62:	89 45 f0             	mov    %eax,-0x10(%rbp)
ffffffff80101f65:	e8 c6 00 00 00       	callq  ffffffff80102030 <inb>
ffffffff80101f6a:	0f b6 c0             	movzbl %al,%eax
ffffffff80101f6d:	48 83 c4 10          	add    $0x10,%rsp
ffffffff80101f71:	5d                   	pop    %rbp
ffffffff80101f72:	c3                   	retq   
ffffffff80101f73:	66 66 66 66 2e 0f 1f 	data16 data16 data16 nopw %cs:0x0(%rax,%rax,1)
ffffffff80101f7a:	84 00 00 00 00 00 

ffffffff80101f80 <fill_rtcdate>:
{
ffffffff80101f80:	55                   	push   %rbp
ffffffff80101f81:	48 89 e5             	mov    %rsp,%rbp
ffffffff80101f84:	48 83 ec 20          	sub    $0x20,%rsp
ffffffff80101f88:	31 c0                	xor    %eax,%eax
ffffffff80101f8a:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  r->second = cmos_read(SECS);
ffffffff80101f8e:	31 ff                	xor    %edi,%edi
ffffffff80101f90:	89 45 f4             	mov    %eax,-0xc(%rbp)
ffffffff80101f93:	e8 88 ff ff ff       	callq  ffffffff80101f20 <cmos_read>
ffffffff80101f98:	bf 02 00 00 00       	mov    $0x2,%edi
ffffffff80101f9d:	48 8b 4d f8          	mov    -0x8(%rbp),%rcx
ffffffff80101fa1:	89 01                	mov    %eax,(%rcx)
  r->minute = cmos_read(MINS);
ffffffff80101fa3:	b8 02 00 00 00       	mov    $0x2,%eax
ffffffff80101fa8:	89 7d f0             	mov    %edi,-0x10(%rbp)
ffffffff80101fab:	89 c7                	mov    %eax,%edi
ffffffff80101fad:	e8 6e ff ff ff       	callq  ffffffff80101f20 <cmos_read>
ffffffff80101fb2:	bf 04 00 00 00       	mov    $0x4,%edi
ffffffff80101fb7:	48 8b 4d f8          	mov    -0x8(%rbp),%rcx
ffffffff80101fbb:	89 41 04             	mov    %eax,0x4(%rcx)
  r->hour   = cmos_read(HOURS);
ffffffff80101fbe:	b8 04 00 00 00       	mov    $0x4,%eax
ffffffff80101fc3:	89 7d ec             	mov    %edi,-0x14(%rbp)
ffffffff80101fc6:	89 c7                	mov    %eax,%edi
ffffffff80101fc8:	e8 53 ff ff ff       	callq  ffffffff80101f20 <cmos_read>
ffffffff80101fcd:	bf 07 00 00 00       	mov    $0x7,%edi
ffffffff80101fd2:	48 8b 4d f8          	mov    -0x8(%rbp),%rcx
ffffffff80101fd6:	89 41 08             	mov    %eax,0x8(%rcx)
  r->day    = cmos_read(DAY);
ffffffff80101fd9:	b8 07 00 00 00       	mov    $0x7,%eax
ffffffff80101fde:	89 7d e8             	mov    %edi,-0x18(%rbp)
ffffffff80101fe1:	89 c7                	mov    %eax,%edi
ffffffff80101fe3:	e8 38 ff ff ff       	callq  ffffffff80101f20 <cmos_read>
ffffffff80101fe8:	bf 08 00 00 00       	mov    $0x8,%edi
ffffffff80101fed:	48 8b 4d f8          	mov    -0x8(%rbp),%rcx
ffffffff80101ff1:	89 41 0c             	mov    %eax,0xc(%rcx)
  r->month  = cmos_read(MONTH);
ffffffff80101ff4:	b8 08 00 00 00       	mov    $0x8,%eax
ffffffff80101ff9:	89 7d e4             	mov    %edi,-0x1c(%rbp)
ffffffff80101ffc:	89 c7                	mov    %eax,%edi
ffffffff80101ffe:	e8 1d ff ff ff       	callq  ffffffff80101f20 <cmos_read>
ffffffff80102003:	bf 09 00 00 00       	mov    $0x9,%edi
ffffffff80102008:	48 8b 4d f8          	mov    -0x8(%rbp),%rcx
ffffffff8010200c:	89 41 10             	mov    %eax,0x10(%rcx)
  r->year   = cmos_read(YEAR);
ffffffff8010200f:	b8 09 00 00 00       	mov    $0x9,%eax
ffffffff80102014:	89 7d e0             	mov    %edi,-0x20(%rbp)
ffffffff80102017:	89 c7                	mov    %eax,%edi
ffffffff80102019:	e8 02 ff ff ff       	callq  ffffffff80101f20 <cmos_read>
ffffffff8010201e:	48 8b 4d f8          	mov    -0x8(%rbp),%rcx
ffffffff80102022:	89 41 14             	mov    %eax,0x14(%rcx)
}
ffffffff80102025:	48 83 c4 20          	add    $0x20,%rsp
ffffffff80102029:	5d                   	pop    %rbp
ffffffff8010202a:	c3                   	retq   
ffffffff8010202b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

ffffffff80102030 <inb>:
{
ffffffff80102030:	55                   	push   %rbp
ffffffff80102031:	48 89 e5             	mov    %rsp,%rbp
ffffffff80102034:	48 83 ec 04          	sub    $0x4,%rsp
ffffffff80102038:	66 89 f8             	mov    %di,%ax
ffffffff8010203b:	66 89 45 fe          	mov    %ax,-0x2(%rbp)
  asm volatile("in %1,%0" : "=a" (data) : "d" (port));
ffffffff8010203f:	66 8b 55 fe          	mov    -0x2(%rbp),%dx
ffffffff80102043:	ec                   	in     (%dx),%al
ffffffff80102044:	88 45 fd             	mov    %al,-0x3(%rbp)
  return data;
ffffffff80102047:	0f b6 45 fd          	movzbl -0x3(%rbp),%eax
ffffffff8010204b:	48 83 c4 04          	add    $0x4,%rsp
ffffffff8010204f:	5d                   	pop    %rbp
ffffffff80102050:	c3                   	retq   
ffffffff80102051:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
ffffffff80102058:	00 00 00 
ffffffff8010205b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

ffffffff80102060 <e820_print>:
		break;
	}
}

void
e820_print() {
ffffffff80102060:	55                   	push   %rbp
ffffffff80102061:	48 89 e5             	mov    %rsp,%rbp
	uint64_t i;

	cprintf("E820: physical memory map [mem 0x%x-0x%x]\n",
		mmap_addr, mmap_addr + mmap_length - 1);
ffffffff80102064:	48 83 ec 10          	sub    $0x10,%rsp
ffffffff80102068:	8b 04 25 9c 65 1f 83 	mov    0xffffffff831f659c,%eax
ffffffff8010206f:	8b 0c 25 a4 65 1f 83 	mov    0xffffffff831f65a4,%ecx
ffffffff80102076:	89 ca                	mov    %ecx,%edx
ffffffff80102078:	89 c6                	mov    %eax,%esi
ffffffff8010207a:	8d 54 16 ff          	lea    -0x1(%rsi,%rdx,1),%edx
	cprintf("E820: physical memory map [mem 0x%x-0x%x]\n",
ffffffff8010207e:	48 c7 c7 d7 fb 10 80 	mov    $0xffffffff8010fbd7,%rdi
ffffffff80102085:	31 c9                	xor    %ecx,%ecx
ffffffff80102087:	41 88 c8             	mov    %cl,%r8b
ffffffff8010208a:	89 c6                	mov    %eax,%esi
ffffffff8010208c:	44 88 c0             	mov    %r8b,%al
ffffffff8010208f:	e8 cc e8 ff ff       	callq  ffffffff80100960 <cprintf>

	struct e820_entry *e = e820_map.entries;
ffffffff80102094:	48 c7 45 f0 44 66 1f 	movq   $0xffffffff831f6644,-0x10(%rbp)
ffffffff8010209b:	83 
  for (i = 0; i != e820_map.nr; ++i, ++e) {
ffffffff8010209c:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
ffffffff801020a3:	00 
ffffffff801020a4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
ffffffff801020a8:	8b 0c 25 40 66 1f 83 	mov    0xffffffff831f6640,%ecx
ffffffff801020af:	89 c9                	mov    %ecx,%ecx
ffffffff801020b1:	89 ca                	mov    %ecx,%edx
ffffffff801020b3:	48 39 d0             	cmp    %rdx,%rax
ffffffff801020b6:	0f 84 6c 00 00 00    	je     ffffffff80102128 <e820_print+0xc8>
		cprintf("  [mem 0x%x-0x%x] ",
			(uintptr_t)e->addr,
ffffffff801020bc:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
ffffffff801020c0:	48 8b 30             	mov    (%rax),%rsi
			(uintptr_t)(e->addr + e->len - 1));
ffffffff801020c3:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
ffffffff801020c7:	48 8b 00             	mov    (%rax),%rax
ffffffff801020ca:	48 8b 4d f0          	mov    -0x10(%rbp),%rcx
ffffffff801020ce:	48 03 41 08          	add    0x8(%rcx),%rax
ffffffff801020d2:	48 83 e8 01          	sub    $0x1,%rax
		cprintf("  [mem 0x%x-0x%x] ",
ffffffff801020d6:	48 c7 c7 02 fc 10 80 	mov    $0xffffffff8010fc02,%rdi
ffffffff801020dd:	31 d2                	xor    %edx,%edx
ffffffff801020df:	41 88 d0             	mov    %dl,%r8b
ffffffff801020e2:	48 89 c2             	mov    %rax,%rdx
ffffffff801020e5:	44 88 c0             	mov    %r8b,%al
ffffffff801020e8:	e8 73 e8 ff ff       	callq  ffffffff80100960 <cprintf>
		print_e820_map_type(e->type);
ffffffff801020ed:	48 8b 4d f0          	mov    -0x10(%rbp),%rcx
ffffffff801020f1:	8b 79 10             	mov    0x10(%rcx),%edi
ffffffff801020f4:	e8 37 00 00 00       	callq  ffffffff80102130 <print_e820_map_type>
		cprintf("\n");
ffffffff801020f9:	48 c7 c7 2d fb 10 80 	mov    $0xffffffff8010fb2d,%rdi
ffffffff80102100:	45 31 c9             	xor    %r9d,%r9d
ffffffff80102103:	44 88 c8             	mov    %r9b,%al
ffffffff80102106:	e8 55 e8 ff ff       	callq  ffffffff80100960 <cprintf>
  for (i = 0; i != e820_map.nr; ++i, ++e) {
ffffffff8010210b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
ffffffff8010210f:	48 83 c0 01          	add    $0x1,%rax
ffffffff80102113:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
ffffffff80102117:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
ffffffff8010211b:	48 83 c0 14          	add    $0x14,%rax
ffffffff8010211f:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
ffffffff80102123:	e9 7c ff ff ff       	jmpq   ffffffff801020a4 <e820_print+0x44>
  }
}
ffffffff80102128:	48 83 c4 10          	add    $0x10,%rsp
ffffffff8010212c:	5d                   	pop    %rbp
ffffffff8010212d:	c3                   	retq   
ffffffff8010212e:	66 90                	xchg   %ax,%ax

ffffffff80102130 <print_e820_map_type>:
print_e820_map_type(uint32_t type) {
ffffffff80102130:	55                   	push   %rbp
ffffffff80102131:	48 89 e5             	mov    %rsp,%rbp
ffffffff80102134:	48 83 ec 10          	sub    $0x10,%rsp
ffffffff80102138:	89 7d fc             	mov    %edi,-0x4(%rbp)
	switch (type) {
ffffffff8010213b:	8b 7d fc             	mov    -0x4(%rbp),%edi
ffffffff8010213e:	ff cf                	dec    %edi
ffffffff80102140:	83 ef 04             	sub    $0x4,%edi
ffffffff80102143:	89 7d f8             	mov    %edi,-0x8(%rbp)
ffffffff80102146:	0f 87 27 00 00 00    	ja     ffffffff80102173 <print_e820_map_type+0x43>
ffffffff8010214c:	e9 00 00 00 00       	jmpq   ffffffff80102151 <print_e820_map_type+0x21>
		cprintf((char *)e820_map_types[type - 1]);
ffffffff80102151:	8b 45 fc             	mov    -0x4(%rbp),%eax
ffffffff80102154:	ff c8                	dec    %eax
ffffffff80102156:	89 c1                	mov    %eax,%ecx
ffffffff80102158:	48 8d 0c cd 40 10 12 	lea    -0x7fedefc0(,%rcx,8),%rcx
ffffffff8010215f:	80 
ffffffff80102160:	48 8b 39             	mov    (%rcx),%rdi
ffffffff80102163:	31 c0                	xor    %eax,%eax
ffffffff80102165:	88 c2                	mov    %al,%dl
ffffffff80102167:	88 d0                	mov    %dl,%al
ffffffff80102169:	e8 f2 e7 ff ff       	callq  ffffffff80100960 <cprintf>
		break;
ffffffff8010216e:	e9 15 00 00 00       	jmpq   ffffffff80102188 <print_e820_map_type+0x58>
		cprintf("type %u", type);
ffffffff80102173:	8b 75 fc             	mov    -0x4(%rbp),%esi
ffffffff80102176:	48 c7 c7 26 fc 10 80 	mov    $0xffffffff8010fc26,%rdi
ffffffff8010217d:	31 c0                	xor    %eax,%eax
ffffffff8010217f:	88 c1                	mov    %al,%cl
ffffffff80102181:	88 c8                	mov    %cl,%al
ffffffff80102183:	e8 d8 e7 ff ff       	callq  ffffffff80100960 <cprintf>
}
ffffffff80102188:	48 83 c4 10          	add    $0x10,%rsp
ffffffff8010218c:	5d                   	pop    %rbp
ffffffff8010218d:	c3                   	retq   
ffffffff8010218e:	66 90                	xchg   %ax,%ax

ffffffff80102190 <e820_init>:

// This function may ONLY be used during initialization,
// before page_init().
void
e820_init(physaddr_t mbi_pa)
{
ffffffff80102190:	55                   	push   %rbp
ffffffff80102191:	48 89 e5             	mov    %rsp,%rbp
ffffffff80102194:	48 83 ec 30          	sub    $0x30,%rsp
ffffffff80102198:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	struct multiboot_info *mbi;
	uint64_t addr, addr_end, i;

	mbi = (struct multiboot_info *)mbi_pa;
ffffffff8010219c:	48 8b 7d f8          	mov    -0x8(%rbp),%rdi
ffffffff801021a0:	48 89 7d f0          	mov    %rdi,-0x10(%rbp)
	assert(mbi->flags & MULTIBOOT_INFO_MEM_MAP);
ffffffff801021a4:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
ffffffff801021a8:	8b 08                	mov    (%rax),%ecx
ffffffff801021aa:	83 e1 40             	and    $0x40,%ecx
ffffffff801021ad:	83 f9 00             	cmp    $0x0,%ecx
ffffffff801021b0:	0f 85 0c 00 00 00    	jne    ffffffff801021c2 <e820_init+0x32>
ffffffff801021b6:	48 c7 c7 15 fc 10 80 	mov    $0xffffffff8010fc15,%rdi
ffffffff801021bd:	e8 ae ec ff ff       	callq  ffffffff80100e70 <panic>
ffffffff801021c2:	e9 00 00 00 00       	jmpq   ffffffff801021c7 <e820_init+0x37>

	mmap_addr = mbi->mmap_addr;
ffffffff801021c7:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
ffffffff801021cb:	8b 48 30             	mov    0x30(%rax),%ecx
ffffffff801021ce:	89 0c 25 9c 65 1f 83 	mov    %ecx,0xffffffff831f659c
	mmap_length = mbi->mmap_length;
ffffffff801021d5:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
ffffffff801021d9:	8b 48 2c             	mov    0x2c(%rax),%ecx
ffffffff801021dc:	89 0c 25 a4 65 1f 83 	mov    %ecx,0xffffffff831f65a4

	addr = mbi->mmap_addr;
ffffffff801021e3:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
ffffffff801021e7:	8b 48 30             	mov    0x30(%rax),%ecx
ffffffff801021ea:	89 c8                	mov    %ecx,%eax
ffffffff801021ec:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	addr_end = mbi->mmap_addr + mbi->mmap_length;
ffffffff801021f0:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
ffffffff801021f4:	8b 48 30             	mov    0x30(%rax),%ecx
ffffffff801021f7:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
ffffffff801021fb:	03 48 2c             	add    0x2c(%rax),%ecx
ffffffff801021fe:	89 c9                	mov    %ecx,%ecx
ffffffff80102200:	89 c8                	mov    %ecx,%eax
ffffffff80102202:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
	for (i = 0; addr < addr_end; ++i) {
ffffffff80102206:	48 c7 45 d8 00 00 00 	movq   $0x0,-0x28(%rbp)
ffffffff8010220d:	00 
ffffffff8010220e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
ffffffff80102212:	48 3b 45 e0          	cmp    -0x20(%rbp),%rax
ffffffff80102216:	0f 83 b7 00 00 00    	jae    ffffffff801022d3 <e820_init+0x143>
		struct multiboot_mmap_entry *e;

		// Print memory mapping.
		assert(addr_end - addr >= sizeof(*e));
ffffffff8010221c:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
ffffffff80102220:	48 2b 45 e8          	sub    -0x18(%rbp),%rax
ffffffff80102224:	48 83 f8 18          	cmp    $0x18,%rax
ffffffff80102228:	0f 83 0c 00 00 00    	jae    ffffffff8010223a <e820_init+0xaa>
ffffffff8010222e:	48 c7 c7 15 fc 10 80 	mov    $0xffffffff8010fc15,%rdi
ffffffff80102235:	e8 36 ec ff ff       	callq  ffffffff80100e70 <panic>
ffffffff8010223a:	e9 00 00 00 00       	jmpq   ffffffff8010223f <e820_init+0xaf>
		e = (struct multiboot_mmap_entry *)addr;
ffffffff8010223f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
ffffffff80102243:	48 89 45 d0          	mov    %rax,-0x30(%rbp)

		// Save a copy.
		assert(i < E820_NR_MAX);
ffffffff80102247:	48 83 7d d8 40       	cmpq   $0x40,-0x28(%rbp)
ffffffff8010224c:	0f 82 0c 00 00 00    	jb     ffffffff8010225e <e820_init+0xce>
ffffffff80102252:	48 c7 c7 15 fc 10 80 	mov    $0xffffffff8010fc15,%rdi
ffffffff80102259:	e8 12 ec ff ff       	callq  ffffffff80100e70 <panic>
ffffffff8010225e:	e9 00 00 00 00       	jmpq   ffffffff80102263 <e820_init+0xd3>
		e820_map.entries[i].addr = e->addr;
ffffffff80102263:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
ffffffff80102267:	48 8b 40 04          	mov    0x4(%rax),%rax
ffffffff8010226b:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
ffffffff8010226f:	48 8d 0c 89          	lea    (%rcx,%rcx,4),%rcx
ffffffff80102273:	48 89 04 8d 44 66 1f 	mov    %rax,-0x7ce099bc(,%rcx,4)
ffffffff8010227a:	83 
		e820_map.entries[i].len = e->len;
ffffffff8010227b:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
ffffffff8010227f:	48 8b 40 0c          	mov    0xc(%rax),%rax
ffffffff80102283:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
ffffffff80102287:	48 8d 0c 89          	lea    (%rcx,%rcx,4),%rcx
ffffffff8010228b:	48 89 04 8d 4c 66 1f 	mov    %rax,-0x7ce099b4(,%rcx,4)
ffffffff80102292:	83 
		e820_map.entries[i].type = e->type;
ffffffff80102293:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
ffffffff80102297:	8b 50 14             	mov    0x14(%rax),%edx
ffffffff8010229a:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
ffffffff8010229e:	48 8d 04 80          	lea    (%rax,%rax,4),%rax
ffffffff801022a2:	48 8d 04 85 44 66 1f 	lea    -0x7ce099bc(,%rax,4),%rax
ffffffff801022a9:	83 
ffffffff801022aa:	89 50 10             	mov    %edx,0x10(%rax)

		addr += (e->size + 4);
ffffffff801022ad:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
ffffffff801022b1:	8b 10                	mov    (%rax),%edx
ffffffff801022b3:	83 c2 04             	add    $0x4,%edx
ffffffff801022b6:	89 d2                	mov    %edx,%edx
ffffffff801022b8:	89 d0                	mov    %edx,%eax
ffffffff801022ba:	48 03 45 e8          	add    -0x18(%rbp),%rax
ffffffff801022be:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
	for (i = 0; addr < addr_end; ++i) {
ffffffff801022c2:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
ffffffff801022c6:	48 83 c0 01          	add    $0x1,%rax
ffffffff801022ca:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
ffffffff801022ce:	e9 3b ff ff ff       	jmpq   ffffffff8010220e <e820_init+0x7e>
	}
	e820_map.nr = i;
ffffffff801022d3:	8b 45 d8             	mov    -0x28(%rbp),%eax
ffffffff801022d6:	89 04 25 40 66 1f 83 	mov    %eax,0xffffffff831f6640
}
ffffffff801022dd:	48 83 c4 30          	add    $0x30,%rsp
ffffffff801022e1:	5d                   	pop    %rbp
ffffffff801022e2:	c3                   	retq   
ffffffff801022e3:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
ffffffff801022ea:	00 00 00 
ffffffff801022ed:	0f 1f 00             	nopl   (%rax)

ffffffff801022f0 <seginit>:

// Set up CPU's kernel segment descriptors.
// Run once on entry on each CPU.
void
seginit(void)
{
ffffffff801022f0:	55                   	push   %rbp
ffffffff801022f1:	48 89 e5             	mov    %rsp,%rbp
ffffffff801022f4:	41 57                	push   %r15
ffffffff801022f6:	41 56                	push   %r14
ffffffff801022f8:	41 55                	push   %r13
ffffffff801022fa:	41 54                	push   %r12
ffffffff801022fc:	53                   	push   %rbx
ffffffff801022fd:	48 81 ec 08 01 00 00 	sub    $0x108,%rsp
ffffffff80102304:	b8 40 00 00 00       	mov    $0x40,%eax
ffffffff80102309:	48 b9 ff ff ff ff ff 	movabs $0xffffffffffffff,%rcx
ffffffff80102310:	ff ff 00 
ffffffff80102313:	48 ba ff ff ff ff ff 	movabs $0xff7fffffffffffff,%rdx
ffffffff8010231a:	ff 7f ff 
ffffffff8010231d:	48 be ff ff ff ff ff 	movabs $0xffbfffffffffffff,%rsi
ffffffff80102324:	ff bf ff 
ffffffff80102327:	48 bf ff ff ff ff ff 	movabs $0xffdfffffffffffff,%rdi
ffffffff8010232e:	ff df ff 
ffffffff80102331:	49 b8 ff ff ff ff ff 	movabs $0xffefffffffffffff,%r8
ffffffff80102338:	ff ef ff 
ffffffff8010233b:	49 b9 ff ff ff ff ff 	movabs $0xfff0ffffffffffff,%r9
ffffffff80102342:	ff f0 ff 
ffffffff80102345:	49 ba 00 00 00 00 00 	movabs $0x800000000000,%r10
ffffffff8010234c:	80 00 00 
ffffffff8010234f:	49 bb ff ff ff ff ff 	movabs $0xffff7fffffffffff,%r11
ffffffff80102356:	7f ff ff 
ffffffff80102359:	48 bb 00 00 00 00 00 	movabs $0x600000000000,%rbx
ffffffff80102360:	60 00 00 
ffffffff80102363:	49 be ff ff ff ff ff 	movabs $0xffff9fffffffffff,%r14
ffffffff8010236a:	9f ff ff 
ffffffff8010236d:	49 bf ff ff ff ff ff 	movabs $0xffffefffffffffff,%r15
ffffffff80102374:	ef ff ff 
ffffffff80102377:	49 bc 00 00 00 00 00 	movabs $0x90000000000,%r12
ffffffff8010237e:	09 00 00 
ffffffff80102381:	49 bd ff ff ff ff ff 	movabs $0xfffff0ffffffffff,%r13
ffffffff80102388:	f0 ff ff 
ffffffff8010238b:	48 89 4d 80          	mov    %rcx,-0x80(%rbp)
ffffffff8010238f:	48 b9 ff ff ff ff 00 	movabs $0xffffff00ffffffff,%rcx
ffffffff80102396:	ff ff ff 
ffffffff80102399:	48 89 8d 78 ff ff ff 	mov    %rcx,-0x88(%rbp)
ffffffff801023a0:	48 b9 ff ff 00 00 ff 	movabs $0xffffffff0000ffff,%rcx
ffffffff801023a7:	ff ff ff 
ffffffff801023aa:	48 89 8d 70 ff ff ff 	mov    %rcx,-0x90(%rbp)
ffffffff801023b1:	48 b9 00 00 00 00 00 	movabs $0x100000000000,%rcx
ffffffff801023b8:	10 00 00 
ffffffff801023bb:	48 89 8d 68 ff ff ff 	mov    %rcx,-0x98(%rbp)
ffffffff801023c2:	48 b9 00 00 00 00 00 	movabs $0x20000000000,%rcx
ffffffff801023c9:	02 00 00 
ffffffff801023cc:	48 89 8d 60 ff ff ff 	mov    %rcx,-0xa0(%rbp)
ffffffff801023d3:	48 b9 00 00 00 00 00 	movabs $0x20000000000000,%rcx
ffffffff801023da:	00 20 00 
ffffffff801023dd:	48 89 8d 58 ff ff ff 	mov    %rcx,-0xa8(%rbp)
ffffffff801023e4:	48 b9 00 00 00 00 00 	movabs $0x80000000000,%rcx
ffffffff801023eb:	08 00 00 
  struct cpu *c = &cpus[cpunum()];
ffffffff801023ee:	89 85 54 ff ff ff    	mov    %eax,-0xac(%rbp)
ffffffff801023f4:	48 89 8d 48 ff ff ff 	mov    %rcx,-0xb8(%rbp)
ffffffff801023fb:	48 89 95 40 ff ff ff 	mov    %rdx,-0xc0(%rbp)
ffffffff80102402:	48 89 b5 38 ff ff ff 	mov    %rsi,-0xc8(%rbp)
ffffffff80102409:	48 89 bd 30 ff ff ff 	mov    %rdi,-0xd0(%rbp)
ffffffff80102410:	4c 89 85 28 ff ff ff 	mov    %r8,-0xd8(%rbp)
ffffffff80102417:	4c 89 8d 20 ff ff ff 	mov    %r9,-0xe0(%rbp)
ffffffff8010241e:	4c 89 95 18 ff ff ff 	mov    %r10,-0xe8(%rbp)
ffffffff80102425:	4c 89 9d 10 ff ff ff 	mov    %r11,-0xf0(%rbp)
ffffffff8010242c:	48 89 9d 08 ff ff ff 	mov    %rbx,-0xf8(%rbp)
ffffffff80102433:	4c 89 b5 00 ff ff ff 	mov    %r14,-0x100(%rbp)
ffffffff8010243a:	4c 89 bd f8 fe ff ff 	mov    %r15,-0x108(%rbp)
ffffffff80102441:	4c 89 a5 f0 fe ff ff 	mov    %r12,-0x110(%rbp)
ffffffff80102448:	4c 89 ad e8 fe ff ff 	mov    %r13,-0x118(%rbp)
ffffffff8010244f:	e8 4c f6 ff ff       	callq  ffffffff80101aa0 <cpunum>
ffffffff80102454:	48 63 c8             	movslq %eax,%rcx
ffffffff80102457:	48 69 c9 d8 00 00 00 	imul   $0xd8,%rcx,%rcx
ffffffff8010245e:	48 8d 89 e0 7b 1f 83 	lea    -0x7ce08420(%rcx),%rcx
ffffffff80102465:	48 89 4d d0          	mov    %rcx,-0x30(%rbp)

  uint64_t *gdt;
  uint *tss;
  uint64_t addr;

  gdt = (uint64_t*)c->gdt;
ffffffff80102469:	48 8b 4d d0          	mov    -0x30(%rbp),%rcx
ffffffff8010246d:	48 83 c1 78          	add    $0x78,%rcx
ffffffff80102471:	48 89 4d c8          	mov    %rcx,-0x38(%rbp)
  tss = (uint*) &(c->ts);
ffffffff80102475:	48 8b 4d d0          	mov    -0x30(%rbp),%rcx
ffffffff80102479:	48 83 c1 10          	add    $0x10,%rcx
ffffffff8010247d:	48 89 4d c0          	mov    %rcx,-0x40(%rbp)
  tss[16] = 0x00680000; // IO Map Base = End of TSS
ffffffff80102481:	48 8b 4d c0          	mov    -0x40(%rbp),%rcx
ffffffff80102485:	c7 41 40 00 00 68 00 	movl   $0x680000,0x40(%rcx)

  addr = (uint64_t) tss;
ffffffff8010248c:	48 8b 4d c0          	mov    -0x40(%rbp),%rcx
ffffffff80102490:	48 89 4d b8          	mov    %rcx,-0x48(%rbp)
  gdt[0] = 0; // first entry is 0
ffffffff80102494:	48 8b 4d c8          	mov    -0x38(%rbp),%rcx
ffffffff80102498:	48 c7 01 00 00 00 00 	movq   $0x0,(%rcx)
  c->gdt[SEG_KCODE] = SEG64(STA_X, 0, 0, 1, 0);
ffffffff8010249f:	48 8b 4d d0          	mov    -0x30(%rbp),%rcx
ffffffff801024a3:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
ffffffff801024a7:	48 81 e2 00 00 ff ff 	and    $0xffffffffffff0000,%rdx
ffffffff801024ae:	48 89 55 b0          	mov    %rdx,-0x50(%rbp)
ffffffff801024b2:	48 8b 95 70 ff ff ff 	mov    -0x90(%rbp),%rdx
ffffffff801024b9:	48 23 55 b0          	and    -0x50(%rbp),%rdx
ffffffff801024bd:	48 89 55 b0          	mov    %rdx,-0x50(%rbp)
ffffffff801024c1:	48 8b 95 78 ff ff ff 	mov    -0x88(%rbp),%rdx
ffffffff801024c8:	48 23 55 b0          	and    -0x50(%rbp),%rdx
ffffffff801024cc:	48 89 55 b0          	mov    %rdx,-0x50(%rbp)
ffffffff801024d0:	48 8b 95 e8 fe ff ff 	mov    -0x118(%rbp),%rdx
ffffffff801024d7:	48 23 55 b0          	and    -0x50(%rbp),%rdx
ffffffff801024db:	48 8b b5 48 ff ff ff 	mov    -0xb8(%rbp),%rsi
ffffffff801024e2:	48 09 f2             	or     %rsi,%rdx
ffffffff801024e5:	48 89 55 b0          	mov    %rdx,-0x50(%rbp)
ffffffff801024e9:	48 8b 95 f8 fe ff ff 	mov    -0x108(%rbp),%rdx
ffffffff801024f0:	48 23 55 b0          	and    -0x50(%rbp),%rdx
ffffffff801024f4:	48 8b bd 68 ff ff ff 	mov    -0x98(%rbp),%rdi
ffffffff801024fb:	48 09 fa             	or     %rdi,%rdx
ffffffff801024fe:	48 89 55 b0          	mov    %rdx,-0x50(%rbp)
ffffffff80102502:	48 8b 95 00 ff ff ff 	mov    -0x100(%rbp),%rdx
ffffffff80102509:	48 23 55 b0          	and    -0x50(%rbp),%rdx
ffffffff8010250d:	48 89 55 b0          	mov    %rdx,-0x50(%rbp)
ffffffff80102511:	48 8b 95 10 ff ff ff 	mov    -0xf0(%rbp),%rdx
ffffffff80102518:	48 23 55 b0          	and    -0x50(%rbp),%rdx
ffffffff8010251c:	4c 8b 85 18 ff ff ff 	mov    -0xe8(%rbp),%r8
ffffffff80102523:	4c 09 c2             	or     %r8,%rdx
ffffffff80102526:	48 89 55 b0          	mov    %rdx,-0x50(%rbp)
ffffffff8010252a:	48 8b 95 20 ff ff ff 	mov    -0xe0(%rbp),%rdx
ffffffff80102531:	48 23 55 b0          	and    -0x50(%rbp),%rdx
ffffffff80102535:	48 89 55 b0          	mov    %rdx,-0x50(%rbp)
ffffffff80102539:	48 8b 95 28 ff ff ff 	mov    -0xd8(%rbp),%rdx
ffffffff80102540:	48 23 55 b0          	and    -0x50(%rbp),%rdx
ffffffff80102544:	48 89 55 b0          	mov    %rdx,-0x50(%rbp)
ffffffff80102548:	48 8b 95 30 ff ff ff 	mov    -0xd0(%rbp),%rdx
ffffffff8010254f:	48 23 55 b0          	and    -0x50(%rbp),%rdx
ffffffff80102553:	4c 8b 8d 58 ff ff ff 	mov    -0xa8(%rbp),%r9
ffffffff8010255a:	4c 09 ca             	or     %r9,%rdx
ffffffff8010255d:	48 89 55 b0          	mov    %rdx,-0x50(%rbp)
ffffffff80102561:	48 8b 95 38 ff ff ff 	mov    -0xc8(%rbp),%rdx
ffffffff80102568:	48 23 55 b0          	and    -0x50(%rbp),%rdx
ffffffff8010256c:	48 89 55 b0          	mov    %rdx,-0x50(%rbp)
ffffffff80102570:	48 8b 95 40 ff ff ff 	mov    -0xc0(%rbp),%rdx
ffffffff80102577:	48 23 55 b0          	and    -0x50(%rbp),%rdx
ffffffff8010257b:	48 89 55 b0          	mov    %rdx,-0x50(%rbp)
ffffffff8010257f:	48 8b 55 80          	mov    -0x80(%rbp),%rdx
ffffffff80102583:	48 23 55 b0          	and    -0x50(%rbp),%rdx
ffffffff80102587:	48 89 55 b0          	mov    %rdx,-0x50(%rbp)
ffffffff8010258b:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
ffffffff8010258f:	48 89 91 80 00 00 00 	mov    %rdx,0x80(%rcx)
  c->gdt[SEG_KDATA] = SEG64(STA_W, 0, 0, 0, 0);
ffffffff80102596:	48 8b 4d d0          	mov    -0x30(%rbp),%rcx
ffffffff8010259a:	48 8b 55 a8          	mov    -0x58(%rbp),%rdx
ffffffff8010259e:	48 81 e2 00 00 ff ff 	and    $0xffffffffffff0000,%rdx
ffffffff801025a5:	48 89 55 a8          	mov    %rdx,-0x58(%rbp)
ffffffff801025a9:	48 8b 95 70 ff ff ff 	mov    -0x90(%rbp),%rdx
ffffffff801025b0:	48 23 55 a8          	and    -0x58(%rbp),%rdx
ffffffff801025b4:	48 89 55 a8          	mov    %rdx,-0x58(%rbp)
ffffffff801025b8:	48 8b 95 78 ff ff ff 	mov    -0x88(%rbp),%rdx
ffffffff801025bf:	48 23 55 a8          	and    -0x58(%rbp),%rdx
ffffffff801025c3:	48 89 55 a8          	mov    %rdx,-0x58(%rbp)
ffffffff801025c7:	48 8b 95 e8 fe ff ff 	mov    -0x118(%rbp),%rdx
ffffffff801025ce:	48 23 55 a8          	and    -0x58(%rbp),%rdx
ffffffff801025d2:	4c 8b 95 60 ff ff ff 	mov    -0xa0(%rbp),%r10
ffffffff801025d9:	4c 09 d2             	or     %r10,%rdx
ffffffff801025dc:	48 89 55 a8          	mov    %rdx,-0x58(%rbp)
ffffffff801025e0:	48 8b 95 f8 fe ff ff 	mov    -0x108(%rbp),%rdx
ffffffff801025e7:	48 23 55 a8          	and    -0x58(%rbp),%rdx
ffffffff801025eb:	48 09 fa             	or     %rdi,%rdx
ffffffff801025ee:	48 89 55 a8          	mov    %rdx,-0x58(%rbp)
ffffffff801025f2:	48 8b 95 00 ff ff ff 	mov    -0x100(%rbp),%rdx
ffffffff801025f9:	48 23 55 a8          	and    -0x58(%rbp),%rdx
ffffffff801025fd:	48 89 55 a8          	mov    %rdx,-0x58(%rbp)
ffffffff80102601:	48 8b 95 10 ff ff ff 	mov    -0xf0(%rbp),%rdx
ffffffff80102608:	48 23 55 a8          	and    -0x58(%rbp),%rdx
ffffffff8010260c:	4c 09 c2             	or     %r8,%rdx
ffffffff8010260f:	48 89 55 a8          	mov    %rdx,-0x58(%rbp)
ffffffff80102613:	48 8b 95 20 ff ff ff 	mov    -0xe0(%rbp),%rdx
ffffffff8010261a:	48 23 55 a8          	and    -0x58(%rbp),%rdx
ffffffff8010261e:	48 89 55 a8          	mov    %rdx,-0x58(%rbp)
ffffffff80102622:	48 8b 95 28 ff ff ff 	mov    -0xd8(%rbp),%rdx
ffffffff80102629:	48 23 55 a8          	and    -0x58(%rbp),%rdx
ffffffff8010262d:	48 89 55 a8          	mov    %rdx,-0x58(%rbp)
ffffffff80102631:	48 8b 95 30 ff ff ff 	mov    -0xd0(%rbp),%rdx
ffffffff80102638:	48 23 55 a8          	and    -0x58(%rbp),%rdx
ffffffff8010263c:	48 89 55 a8          	mov    %rdx,-0x58(%rbp)
ffffffff80102640:	48 8b 95 38 ff ff ff 	mov    -0xc8(%rbp),%rdx
ffffffff80102647:	48 23 55 a8          	and    -0x58(%rbp),%rdx
ffffffff8010264b:	48 89 55 a8          	mov    %rdx,-0x58(%rbp)
ffffffff8010264f:	48 8b 95 40 ff ff ff 	mov    -0xc0(%rbp),%rdx
ffffffff80102656:	48 23 55 a8          	and    -0x58(%rbp),%rdx
ffffffff8010265a:	48 89 55 a8          	mov    %rdx,-0x58(%rbp)
ffffffff8010265e:	48 8b 55 80          	mov    -0x80(%rbp),%rdx
ffffffff80102662:	48 23 55 a8          	and    -0x58(%rbp),%rdx
ffffffff80102666:	48 89 55 a8          	mov    %rdx,-0x58(%rbp)
ffffffff8010266a:	48 8b 55 a8          	mov    -0x58(%rbp),%rdx
ffffffff8010266e:	48 89 91 88 00 00 00 	mov    %rdx,0x88(%rcx)
  c->gdt[SEG_KCPU]  = SEG64(STA_W, &c->cpu, 8, 0, 0);
ffffffff80102675:	48 8b 4d d0          	mov    -0x30(%rbp),%rcx
ffffffff80102679:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
ffffffff8010267d:	48 81 e2 00 00 ff ff 	and    $0xffffffffffff0000,%rdx
ffffffff80102684:	48 89 55 a0          	mov    %rdx,-0x60(%rbp)
ffffffff80102688:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
ffffffff8010268c:	48 81 c2 c8 00 00 00 	add    $0xc8,%rdx
ffffffff80102693:	48 81 e2 ff ff 00 00 	and    $0xffff,%rdx
ffffffff8010269a:	89 d0                	mov    %edx,%eax
ffffffff8010269c:	89 c0                	mov    %eax,%eax
ffffffff8010269e:	89 c2                	mov    %eax,%edx
ffffffff801026a0:	4c 8b 5d a0          	mov    -0x60(%rbp),%r11
ffffffff801026a4:	48 81 e2 ff ff 00 00 	and    $0xffff,%rdx
ffffffff801026ab:	48 c1 e2 10          	shl    $0x10,%rdx
ffffffff801026af:	48 8b 9d 70 ff ff ff 	mov    -0x90(%rbp),%rbx
ffffffff801026b6:	49 21 db             	and    %rbx,%r11
ffffffff801026b9:	49 09 d3             	or     %rdx,%r11
ffffffff801026bc:	4c 89 5d a0          	mov    %r11,-0x60(%rbp)
ffffffff801026c0:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
ffffffff801026c4:	48 81 c2 c8 00 00 00 	add    $0xc8,%rdx
ffffffff801026cb:	48 c1 ea 10          	shr    $0x10,%rdx
ffffffff801026cf:	48 81 e2 ff 00 00 00 	and    $0xff,%rdx
ffffffff801026d6:	89 d0                	mov    %edx,%eax
ffffffff801026d8:	89 c0                	mov    %eax,%eax
ffffffff801026da:	89 c2                	mov    %eax,%edx
ffffffff801026dc:	4c 8b 5d a0          	mov    -0x60(%rbp),%r11
ffffffff801026e0:	48 81 e2 ff 00 00 00 	and    $0xff,%rdx
ffffffff801026e7:	48 c1 e2 20          	shl    $0x20,%rdx
ffffffff801026eb:	4c 8b b5 78 ff ff ff 	mov    -0x88(%rbp),%r14
ffffffff801026f2:	4d 21 f3             	and    %r14,%r11
ffffffff801026f5:	49 09 d3             	or     %rdx,%r11
ffffffff801026f8:	4c 89 5d a0          	mov    %r11,-0x60(%rbp)
ffffffff801026fc:	48 8b 95 e8 fe ff ff 	mov    -0x118(%rbp),%rdx
ffffffff80102703:	48 23 55 a0          	and    -0x60(%rbp),%rdx
ffffffff80102707:	4c 09 d2             	or     %r10,%rdx
ffffffff8010270a:	48 89 55 a0          	mov    %rdx,-0x60(%rbp)
ffffffff8010270e:	48 8b 95 f8 fe ff ff 	mov    -0x108(%rbp),%rdx
ffffffff80102715:	48 23 55 a0          	and    -0x60(%rbp),%rdx
ffffffff80102719:	48 09 fa             	or     %rdi,%rdx
ffffffff8010271c:	48 89 55 a0          	mov    %rdx,-0x60(%rbp)
ffffffff80102720:	48 8b 95 00 ff ff ff 	mov    -0x100(%rbp),%rdx
ffffffff80102727:	48 23 55 a0          	and    -0x60(%rbp),%rdx
ffffffff8010272b:	48 89 55 a0          	mov    %rdx,-0x60(%rbp)
ffffffff8010272f:	48 8b 95 10 ff ff ff 	mov    -0xf0(%rbp),%rdx
ffffffff80102736:	48 23 55 a0          	and    -0x60(%rbp),%rdx
ffffffff8010273a:	4c 09 c2             	or     %r8,%rdx
ffffffff8010273d:	48 89 55 a0          	mov    %rdx,-0x60(%rbp)
ffffffff80102741:	48 8b 95 20 ff ff ff 	mov    -0xe0(%rbp),%rdx
ffffffff80102748:	48 23 55 a0          	and    -0x60(%rbp),%rdx
ffffffff8010274c:	48 89 55 a0          	mov    %rdx,-0x60(%rbp)
ffffffff80102750:	48 8b 95 28 ff ff ff 	mov    -0xd8(%rbp),%rdx
ffffffff80102757:	48 23 55 a0          	and    -0x60(%rbp),%rdx
ffffffff8010275b:	48 89 55 a0          	mov    %rdx,-0x60(%rbp)
ffffffff8010275f:	48 8b 95 30 ff ff ff 	mov    -0xd0(%rbp),%rdx
ffffffff80102766:	48 23 55 a0          	and    -0x60(%rbp),%rdx
ffffffff8010276a:	48 89 55 a0          	mov    %rdx,-0x60(%rbp)
ffffffff8010276e:	48 8b 95 38 ff ff ff 	mov    -0xc8(%rbp),%rdx
ffffffff80102775:	48 23 55 a0          	and    -0x60(%rbp),%rdx
ffffffff80102779:	48 89 55 a0          	mov    %rdx,-0x60(%rbp)
ffffffff8010277d:	48 8b 95 40 ff ff ff 	mov    -0xc0(%rbp),%rdx
ffffffff80102784:	48 23 55 a0          	and    -0x60(%rbp),%rdx
ffffffff80102788:	48 89 55 a0          	mov    %rdx,-0x60(%rbp)
ffffffff8010278c:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
ffffffff80102790:	48 81 c2 c8 00 00 00 	add    $0xc8,%rdx
ffffffff80102797:	48 c1 ea 18          	shr    $0x18,%rdx
ffffffff8010279b:	89 d0                	mov    %edx,%eax
ffffffff8010279d:	89 c0                	mov    %eax,%eax
ffffffff8010279f:	89 c2                	mov    %eax,%edx
ffffffff801027a1:	4c 8b 5d a0          	mov    -0x60(%rbp),%r11
ffffffff801027a5:	48 81 e2 ff 00 00 00 	and    $0xff,%rdx
ffffffff801027ac:	48 c1 e2 38          	shl    $0x38,%rdx
ffffffff801027b0:	4c 8b 7d 80          	mov    -0x80(%rbp),%r15
ffffffff801027b4:	4d 21 fb             	and    %r15,%r11
ffffffff801027b7:	49 09 d3             	or     %rdx,%r11
ffffffff801027ba:	4c 89 5d a0          	mov    %r11,-0x60(%rbp)
ffffffff801027be:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
ffffffff801027c2:	48 89 91 90 00 00 00 	mov    %rdx,0x90(%rcx)
  c->gdt[SEG_UCODE] = SEG64(STA_X, 0, 0, 1, DPL_USER);
ffffffff801027c9:	48 8b 4d d0          	mov    -0x30(%rbp),%rcx
ffffffff801027cd:	48 8b 55 98          	mov    -0x68(%rbp),%rdx
ffffffff801027d1:	48 81 e2 00 00 ff ff 	and    $0xffffffffffff0000,%rdx
ffffffff801027d8:	48 89 55 98          	mov    %rdx,-0x68(%rbp)
ffffffff801027dc:	48 23 5d 98          	and    -0x68(%rbp),%rbx
ffffffff801027e0:	48 89 5d 98          	mov    %rbx,-0x68(%rbp)
ffffffff801027e4:	4c 23 75 98          	and    -0x68(%rbp),%r14
ffffffff801027e8:	4c 89 75 98          	mov    %r14,-0x68(%rbp)
ffffffff801027ec:	48 8b 95 e8 fe ff ff 	mov    -0x118(%rbp),%rdx
ffffffff801027f3:	48 23 55 98          	and    -0x68(%rbp),%rdx
ffffffff801027f7:	48 09 f2             	or     %rsi,%rdx
ffffffff801027fa:	48 89 55 98          	mov    %rdx,-0x68(%rbp)
ffffffff801027fe:	48 8b 95 f8 fe ff ff 	mov    -0x108(%rbp),%rdx
ffffffff80102805:	48 23 55 98          	and    -0x68(%rbp),%rdx
ffffffff80102809:	48 09 fa             	or     %rdi,%rdx
ffffffff8010280c:	48 89 55 98          	mov    %rdx,-0x68(%rbp)
ffffffff80102810:	48 8b 95 00 ff ff ff 	mov    -0x100(%rbp),%rdx
ffffffff80102817:	48 23 55 98          	and    -0x68(%rbp),%rdx
ffffffff8010281b:	4c 8b 9d 08 ff ff ff 	mov    -0xf8(%rbp),%r11
ffffffff80102822:	4c 09 da             	or     %r11,%rdx
ffffffff80102825:	48 89 55 98          	mov    %rdx,-0x68(%rbp)
ffffffff80102829:	48 8b 95 10 ff ff ff 	mov    -0xf0(%rbp),%rdx
ffffffff80102830:	48 23 55 98          	and    -0x68(%rbp),%rdx
ffffffff80102834:	4c 09 c2             	or     %r8,%rdx
ffffffff80102837:	48 89 55 98          	mov    %rdx,-0x68(%rbp)
ffffffff8010283b:	48 8b 95 20 ff ff ff 	mov    -0xe0(%rbp),%rdx
ffffffff80102842:	48 23 55 98          	and    -0x68(%rbp),%rdx
ffffffff80102846:	48 89 55 98          	mov    %rdx,-0x68(%rbp)
ffffffff8010284a:	48 8b 95 28 ff ff ff 	mov    -0xd8(%rbp),%rdx
ffffffff80102851:	48 23 55 98          	and    -0x68(%rbp),%rdx
ffffffff80102855:	48 89 55 98          	mov    %rdx,-0x68(%rbp)
ffffffff80102859:	48 8b 95 30 ff ff ff 	mov    -0xd0(%rbp),%rdx
ffffffff80102860:	48 23 55 98          	and    -0x68(%rbp),%rdx
ffffffff80102864:	4c 09 ca             	or     %r9,%rdx
ffffffff80102867:	48 89 55 98          	mov    %rdx,-0x68(%rbp)
ffffffff8010286b:	48 8b 95 38 ff ff ff 	mov    -0xc8(%rbp),%rdx
ffffffff80102872:	48 23 55 98          	and    -0x68(%rbp),%rdx
ffffffff80102876:	48 89 55 98          	mov    %rdx,-0x68(%rbp)
ffffffff8010287a:	48 8b 95 40 ff ff ff 	mov    -0xc0(%rbp),%rdx
ffffffff80102881:	48 23 55 98          	and    -0x68(%rbp),%rdx
ffffffff80102885:	48 89 55 98          	mov    %rdx,-0x68(%rbp)
ffffffff80102889:	4c 23 7d 98          	and    -0x68(%rbp),%r15
ffffffff8010288d:	4c 89 7d 98          	mov    %r15,-0x68(%rbp)
ffffffff80102891:	48 8b 55 98          	mov    -0x68(%rbp),%rdx
ffffffff80102895:	48 89 91 98 00 00 00 	mov    %rdx,0x98(%rcx)
  c->gdt[SEG_UDATA] = SEG64(STA_W, 0, 0, 0, DPL_USER);
ffffffff8010289c:	48 8b 4d d0          	mov    -0x30(%rbp),%rcx
ffffffff801028a0:	48 8b 55 90          	mov    -0x70(%rbp),%rdx
ffffffff801028a4:	48 81 e2 00 00 ff ff 	and    $0xffffffffffff0000,%rdx
ffffffff801028ab:	48 89 55 90          	mov    %rdx,-0x70(%rbp)
ffffffff801028af:	48 8b 95 70 ff ff ff 	mov    -0x90(%rbp),%rdx
ffffffff801028b6:	48 23 55 90          	and    -0x70(%rbp),%rdx
ffffffff801028ba:	48 89 55 90          	mov    %rdx,-0x70(%rbp)
ffffffff801028be:	48 8b 95 78 ff ff ff 	mov    -0x88(%rbp),%rdx
ffffffff801028c5:	48 23 55 90          	and    -0x70(%rbp),%rdx
ffffffff801028c9:	48 89 55 90          	mov    %rdx,-0x70(%rbp)
ffffffff801028cd:	48 8b 95 e8 fe ff ff 	mov    -0x118(%rbp),%rdx
ffffffff801028d4:	48 23 55 90          	and    -0x70(%rbp),%rdx
ffffffff801028d8:	4c 09 d2             	or     %r10,%rdx
ffffffff801028db:	48 89 55 90          	mov    %rdx,-0x70(%rbp)
ffffffff801028df:	48 8b 95 f8 fe ff ff 	mov    -0x108(%rbp),%rdx
ffffffff801028e6:	48 23 55 90          	and    -0x70(%rbp),%rdx
ffffffff801028ea:	48 09 fa             	or     %rdi,%rdx
ffffffff801028ed:	48 89 55 90          	mov    %rdx,-0x70(%rbp)
ffffffff801028f1:	48 8b 95 00 ff ff ff 	mov    -0x100(%rbp),%rdx
ffffffff801028f8:	48 23 55 90          	and    -0x70(%rbp),%rdx
ffffffff801028fc:	4c 09 da             	or     %r11,%rdx
ffffffff801028ff:	48 89 55 90          	mov    %rdx,-0x70(%rbp)
ffffffff80102903:	48 8b 95 10 ff ff ff 	mov    -0xf0(%rbp),%rdx
ffffffff8010290a:	48 23 55 90          	and    -0x70(%rbp),%rdx
ffffffff8010290e:	4c 09 c2             	or     %r8,%rdx
ffffffff80102911:	48 89 55 90          	mov    %rdx,-0x70(%rbp)
ffffffff80102915:	48 8b 95 20 ff ff ff 	mov    -0xe0(%rbp),%rdx
ffffffff8010291c:	48 23 55 90          	and    -0x70(%rbp),%rdx
ffffffff80102920:	48 89 55 90          	mov    %rdx,-0x70(%rbp)
ffffffff80102924:	48 8b 95 28 ff ff ff 	mov    -0xd8(%rbp),%rdx
ffffffff8010292b:	48 23 55 90          	and    -0x70(%rbp),%rdx
ffffffff8010292f:	48 89 55 90          	mov    %rdx,-0x70(%rbp)
ffffffff80102933:	48 8b 95 30 ff ff ff 	mov    -0xd0(%rbp),%rdx
ffffffff8010293a:	48 23 55 90          	and    -0x70(%rbp),%rdx
ffffffff8010293e:	48 89 55 90          	mov    %rdx,-0x70(%rbp)
ffffffff80102942:	48 8b 95 38 ff ff ff 	mov    -0xc8(%rbp),%rdx
ffffffff80102949:	48 23 55 90          	and    -0x70(%rbp),%rdx
ffffffff8010294d:	48 89 55 90          	mov    %rdx,-0x70(%rbp)
ffffffff80102951:	48 8b 95 40 ff ff ff 	mov    -0xc0(%rbp),%rdx
ffffffff80102958:	48 23 55 90          	and    -0x70(%rbp),%rdx
ffffffff8010295c:	48 89 55 90          	mov    %rdx,-0x70(%rbp)
ffffffff80102960:	48 8b 55 80          	mov    -0x80(%rbp),%rdx
ffffffff80102964:	48 23 55 90          	and    -0x70(%rbp),%rdx
ffffffff80102968:	48 89 55 90          	mov    %rdx,-0x70(%rbp)
ffffffff8010296c:	48 8b 55 90          	mov    -0x70(%rbp),%rdx
ffffffff80102970:	48 89 91 a0 00 00 00 	mov    %rdx,0xa0(%rcx)
  c->gdt[SEG_TSS] = SEG16(STS_T64A, addr, sizeof(struct tss), DPL_USER);
ffffffff80102977:	48 8b 4d d0          	mov    -0x30(%rbp),%rcx
ffffffff8010297b:	48 8b 55 88          	mov    -0x78(%rbp),%rdx
ffffffff8010297f:	48 81 e2 00 00 ff ff 	and    $0xffffffffffff0000,%rdx
ffffffff80102986:	48 83 ca 68          	or     $0x68,%rdx
ffffffff8010298a:	48 89 55 88          	mov    %rdx,-0x78(%rbp)
ffffffff8010298e:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
ffffffff80102992:	89 d0                	mov    %edx,%eax
ffffffff80102994:	25 ff ff 00 00       	and    $0xffff,%eax
ffffffff80102999:	89 c0                	mov    %eax,%eax
ffffffff8010299b:	89 c2                	mov    %eax,%edx
ffffffff8010299d:	48 8b 5d 88          	mov    -0x78(%rbp),%rbx
ffffffff801029a1:	48 81 e2 ff ff 00 00 	and    $0xffff,%rdx
ffffffff801029a8:	48 c1 e2 10          	shl    $0x10,%rdx
ffffffff801029ac:	4c 8b b5 70 ff ff ff 	mov    -0x90(%rbp),%r14
ffffffff801029b3:	4c 21 f3             	and    %r14,%rbx
ffffffff801029b6:	48 09 d3             	or     %rdx,%rbx
ffffffff801029b9:	48 89 5d 88          	mov    %rbx,-0x78(%rbp)
ffffffff801029bd:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
ffffffff801029c1:	89 d0                	mov    %edx,%eax
ffffffff801029c3:	c1 e8 10             	shr    $0x10,%eax
ffffffff801029c6:	25 ff 00 00 00       	and    $0xff,%eax
ffffffff801029cb:	89 c0                	mov    %eax,%eax
ffffffff801029cd:	89 c2                	mov    %eax,%edx
ffffffff801029cf:	48 8b 5d 88          	mov    -0x78(%rbp),%rbx
ffffffff801029d3:	48 81 e2 ff 00 00 00 	and    $0xff,%rdx
ffffffff801029da:	48 c1 e2 20          	shl    $0x20,%rdx
ffffffff801029de:	4c 8b bd 78 ff ff ff 	mov    -0x88(%rbp),%r15
ffffffff801029e5:	4c 21 fb             	and    %r15,%rbx
ffffffff801029e8:	48 09 d3             	or     %rdx,%rbx
ffffffff801029eb:	48 89 5d 88          	mov    %rbx,-0x78(%rbp)
ffffffff801029ef:	48 8b 95 e8 fe ff ff 	mov    -0x118(%rbp),%rdx
ffffffff801029f6:	48 23 55 88          	and    -0x78(%rbp),%rdx
ffffffff801029fa:	48 8b 9d f0 fe ff ff 	mov    -0x110(%rbp),%rbx
ffffffff80102a01:	48 09 da             	or     %rbx,%rdx
ffffffff80102a04:	48 89 55 88          	mov    %rdx,-0x78(%rbp)
ffffffff80102a08:	48 8b 95 f8 fe ff ff 	mov    -0x108(%rbp),%rdx
ffffffff80102a0f:	48 23 55 88          	and    -0x78(%rbp),%rdx
ffffffff80102a13:	48 89 55 88          	mov    %rdx,-0x78(%rbp)
ffffffff80102a17:	48 8b 95 00 ff ff ff 	mov    -0x100(%rbp),%rdx
ffffffff80102a1e:	48 23 55 88          	and    -0x78(%rbp),%rdx
ffffffff80102a22:	4c 09 da             	or     %r11,%rdx
ffffffff80102a25:	48 89 55 88          	mov    %rdx,-0x78(%rbp)
ffffffff80102a29:	48 8b 95 10 ff ff ff 	mov    -0xf0(%rbp),%rdx
ffffffff80102a30:	48 23 55 88          	and    -0x78(%rbp),%rdx
ffffffff80102a34:	4c 09 c2             	or     %r8,%rdx
ffffffff80102a37:	48 89 55 88          	mov    %rdx,-0x78(%rbp)
ffffffff80102a3b:	48 8b 95 20 ff ff ff 	mov    -0xe0(%rbp),%rdx
ffffffff80102a42:	48 23 55 88          	and    -0x78(%rbp),%rdx
ffffffff80102a46:	48 89 55 88          	mov    %rdx,-0x78(%rbp)
ffffffff80102a4a:	48 8b 95 28 ff ff ff 	mov    -0xd8(%rbp),%rdx
ffffffff80102a51:	48 23 55 88          	and    -0x78(%rbp),%rdx
ffffffff80102a55:	48 89 55 88          	mov    %rdx,-0x78(%rbp)
ffffffff80102a59:	48 8b 95 30 ff ff ff 	mov    -0xd0(%rbp),%rdx
ffffffff80102a60:	48 23 55 88          	and    -0x78(%rbp),%rdx
ffffffff80102a64:	48 89 55 88          	mov    %rdx,-0x78(%rbp)
ffffffff80102a68:	48 8b 95 38 ff ff ff 	mov    -0xc8(%rbp),%rdx
ffffffff80102a6f:	48 23 55 88          	and    -0x78(%rbp),%rdx
ffffffff80102a73:	48 89 55 88          	mov    %rdx,-0x78(%rbp)
ffffffff80102a77:	48 8b 95 40 ff ff ff 	mov    -0xc0(%rbp),%rdx
ffffffff80102a7e:	48 23 55 88          	and    -0x78(%rbp),%rdx
ffffffff80102a82:	48 89 55 88          	mov    %rdx,-0x78(%rbp)
ffffffff80102a86:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
ffffffff80102a8a:	89 d0                	mov    %edx,%eax
ffffffff80102a8c:	c1 e8 18             	shr    $0x18,%eax
ffffffff80102a8f:	89 c0                	mov    %eax,%eax
ffffffff80102a91:	89 c2                	mov    %eax,%edx
ffffffff80102a93:	4c 8b 65 88          	mov    -0x78(%rbp),%r12
ffffffff80102a97:	48 81 e2 ff 00 00 00 	and    $0xff,%rdx
ffffffff80102a9e:	48 c1 e2 38          	shl    $0x38,%rdx
ffffffff80102aa2:	4c 8b 6d 80          	mov    -0x80(%rbp),%r13
ffffffff80102aa6:	4d 21 ec             	and    %r13,%r12
ffffffff80102aa9:	49 09 d4             	or     %rdx,%r12
ffffffff80102aac:	4c 89 65 88          	mov    %r12,-0x78(%rbp)
ffffffff80102ab0:	48 8b 55 88          	mov    -0x78(%rbp),%rdx
ffffffff80102ab4:	48 89 91 a8 00 00 00 	mov    %rdx,0xa8(%rcx)
  gdt[SEG_TSS+1] = (addr >> 32);
ffffffff80102abb:	48 8b 4d b8          	mov    -0x48(%rbp),%rcx
ffffffff80102abf:	48 c1 e9 20          	shr    $0x20,%rcx
ffffffff80102ac3:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
ffffffff80102ac7:	48 89 4a 38          	mov    %rcx,0x38(%rdx)

  lgdt((void*) gdt, 8 * sizeof(uint64_t));
ffffffff80102acb:	48 8b 4d c8          	mov    -0x38(%rbp),%rcx
ffffffff80102acf:	be 40 00 00 00       	mov    $0x40,%esi
ffffffff80102ad4:	48 89 cf             	mov    %rcx,%rdi
ffffffff80102ad7:	e8 a4 00 00 00       	callq  ffffffff80102b80 <lgdt>
ffffffff80102adc:	b8 30 00 00 00       	mov    $0x30,%eax
  ltr(SEG_TSS << 3);
ffffffff80102ae1:	bf 30 00 00 00       	mov    $0x30,%edi
ffffffff80102ae6:	89 85 e4 fe ff ff    	mov    %eax,-0x11c(%rbp)
ffffffff80102aec:	e8 ff 00 00 00       	callq  ffffffff80102bf0 <ltr>
ffffffff80102af1:	b8 18 00 00 00       	mov    $0x18,%eax

  loadgs(SEG_KCPU << 3);
ffffffff80102af6:	bf 18 00 00 00       	mov    $0x18,%edi
ffffffff80102afb:	89 85 e0 fe ff ff    	mov    %eax,-0x120(%rbp)
ffffffff80102b01:	e8 0a 01 00 00       	callq  ffffffff80102c10 <loadgs>
ffffffff80102b06:	b8 01 01 00 c0       	mov    $0xc0000101,%eax
  wrmsr(MSR_IA32_GS_BASE, (uint64_t)&c->cpu);
ffffffff80102b0b:	48 8b 4d d0          	mov    -0x30(%rbp),%rcx
ffffffff80102b0f:	48 81 c1 c8 00 00 00 	add    $0xc8,%rcx
ffffffff80102b16:	bf 01 01 00 c0       	mov    $0xc0000101,%edi
ffffffff80102b1b:	48 89 ce             	mov    %rcx,%rsi
ffffffff80102b1e:	89 85 dc fe ff ff    	mov    %eax,-0x124(%rbp)
ffffffff80102b24:	e8 07 01 00 00       	callq  ffffffff80102c30 <wrmsr>
ffffffff80102b29:	b8 02 01 00 c0       	mov    $0xc0000102,%eax
  wrmsr(MSR_IA32_KERNEL_GS_BASE, (uint64_t)&c->cpu);
ffffffff80102b2e:	48 8b 4d d0          	mov    -0x30(%rbp),%rcx
ffffffff80102b32:	48 81 c1 c8 00 00 00 	add    $0xc8,%rcx
ffffffff80102b39:	bf 02 01 00 c0       	mov    $0xc0000102,%edi
ffffffff80102b3e:	48 89 ce             	mov    %rcx,%rsi
ffffffff80102b41:	89 85 d8 fe ff ff    	mov    %eax,-0x128(%rbp)
ffffffff80102b47:	e8 e4 00 00 00       	callq  ffffffff80102c30 <wrmsr>

  // Initialize cpu-local storage.
  c->cpu = c;
ffffffff80102b4c:	48 8b 4d d0          	mov    -0x30(%rbp),%rcx
ffffffff80102b50:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
ffffffff80102b54:	48 89 8a c8 00 00 00 	mov    %rcx,0xc8(%rdx)
  c->proc = 0;
ffffffff80102b5b:	48 8b 4d d0          	mov    -0x30(%rbp),%rcx
ffffffff80102b5f:	48 c7 81 d0 00 00 00 	movq   $0x0,0xd0(%rcx)
ffffffff80102b66:	00 00 00 00 
};
ffffffff80102b6a:	48 81 c4 08 01 00 00 	add    $0x108,%rsp
ffffffff80102b71:	5b                   	pop    %rbx
ffffffff80102b72:	41 5c                	pop    %r12
ffffffff80102b74:	41 5d                	pop    %r13
ffffffff80102b76:	41 5e                	pop    %r14
ffffffff80102b78:	41 5f                	pop    %r15
ffffffff80102b7a:	5d                   	pop    %rbp
ffffffff80102b7b:	c3                   	retq   
ffffffff80102b7c:	0f 1f 40 00          	nopl   0x0(%rax)

ffffffff80102b80 <lgdt>:
{
ffffffff80102b80:	55                   	push   %rbp
ffffffff80102b81:	48 89 e5             	mov    %rsp,%rbp
ffffffff80102b84:	48 83 ec 18          	sub    $0x18,%rsp
ffffffff80102b88:	48 8d 45 ea          	lea    -0x16(%rbp),%rax
ffffffff80102b8c:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
ffffffff80102b90:	89 75 f4             	mov    %esi,-0xc(%rbp)
  pd[0] = size-1;
ffffffff80102b93:	8b 75 f4             	mov    -0xc(%rbp),%esi
ffffffff80102b96:	83 ee 01             	sub    $0x1,%esi
ffffffff80102b99:	66 89 f1             	mov    %si,%cx
ffffffff80102b9c:	66 89 4d ea          	mov    %cx,-0x16(%rbp)
  pd[1] = (uint64_t)p;
ffffffff80102ba0:	48 8b 7d f8          	mov    -0x8(%rbp),%rdi
ffffffff80102ba4:	66 89 f9             	mov    %di,%cx
ffffffff80102ba7:	66 89 4d ec          	mov    %cx,-0x14(%rbp)
  pd[2] = (uint64_t)p >> 16;
ffffffff80102bab:	48 8b 7d f8          	mov    -0x8(%rbp),%rdi
ffffffff80102baf:	48 c1 ef 10          	shr    $0x10,%rdi
ffffffff80102bb3:	66 89 f9             	mov    %di,%cx
ffffffff80102bb6:	66 89 4d ee          	mov    %cx,-0x12(%rbp)
  pd[3] = (uint64_t)p >> 32;
ffffffff80102bba:	48 8b 7d f8          	mov    -0x8(%rbp),%rdi
ffffffff80102bbe:	48 c1 ef 20          	shr    $0x20,%rdi
ffffffff80102bc2:	66 89 f9             	mov    %di,%cx
ffffffff80102bc5:	66 89 4d f0          	mov    %cx,-0x10(%rbp)
  pd[4] = (uint64_t)p >> 48;
ffffffff80102bc9:	48 8b 7d f8          	mov    -0x8(%rbp),%rdi
ffffffff80102bcd:	48 c1 ef 30          	shr    $0x30,%rdi
ffffffff80102bd1:	66 89 f9             	mov    %di,%cx
ffffffff80102bd4:	66 89 4d f2          	mov    %cx,-0xe(%rbp)
  asm volatile("lgdt (%0)" : : "r" (pd));
ffffffff80102bd8:	0f 01 10             	lgdt   (%rax)
}
ffffffff80102bdb:	48 83 c4 18          	add    $0x18,%rsp
ffffffff80102bdf:	5d                   	pop    %rbp
ffffffff80102be0:	c3                   	retq   
ffffffff80102be1:	66 66 66 66 66 66 2e 	data16 data16 data16 data16 data16 nopw %cs:0x0(%rax,%rax,1)
ffffffff80102be8:	0f 1f 84 00 00 00 00 
ffffffff80102bef:	00 

ffffffff80102bf0 <ltr>:
{
ffffffff80102bf0:	55                   	push   %rbp
ffffffff80102bf1:	48 89 e5             	mov    %rsp,%rbp
ffffffff80102bf4:	48 83 ec 02          	sub    $0x2,%rsp
ffffffff80102bf8:	66 89 f8             	mov    %di,%ax
ffffffff80102bfb:	66 89 45 fe          	mov    %ax,-0x2(%rbp)
  asm volatile("ltr %0" : : "r" (sel));
ffffffff80102bff:	66 8b 45 fe          	mov    -0x2(%rbp),%ax
ffffffff80102c03:	0f 00 d8             	ltr    %ax
}
ffffffff80102c06:	48 83 c4 02          	add    $0x2,%rsp
ffffffff80102c0a:	5d                   	pop    %rbp
ffffffff80102c0b:	c3                   	retq   
ffffffff80102c0c:	0f 1f 40 00          	nopl   0x0(%rax)

ffffffff80102c10 <loadgs>:
{
ffffffff80102c10:	55                   	push   %rbp
ffffffff80102c11:	48 89 e5             	mov    %rsp,%rbp
ffffffff80102c14:	48 83 ec 02          	sub    $0x2,%rsp
ffffffff80102c18:	66 89 f8             	mov    %di,%ax
ffffffff80102c1b:	66 89 45 fe          	mov    %ax,-0x2(%rbp)
  asm volatile("movw %0, %%gs" : : "r" (v));
ffffffff80102c1f:	66 8b 45 fe          	mov    -0x2(%rbp),%ax
ffffffff80102c23:	8e e8                	mov    %eax,%gs
}
ffffffff80102c25:	48 83 c4 02          	add    $0x2,%rsp
ffffffff80102c29:	5d                   	pop    %rbp
ffffffff80102c2a:	c3                   	retq   
ffffffff80102c2b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

ffffffff80102c30 <wrmsr>:
  asm volatile ("rdmsr" : "=a" (lo), "=d" (hi) : "c" (msr));
  return lo | ((uint64_t)hi << 32);
}

static inline void wrmsr(uint32_t msr, uint64_t val)
{
ffffffff80102c30:	55                   	push   %rbp
ffffffff80102c31:	48 89 e5             	mov    %rsp,%rbp
ffffffff80102c34:	48 83 ec 18          	sub    $0x18,%rsp
ffffffff80102c38:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
ffffffff80102c3d:	89 c1                	mov    %eax,%ecx
ffffffff80102c3f:	89 7d fc             	mov    %edi,-0x4(%rbp)
ffffffff80102c42:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  uint32_t lo = val & 0xffffffff, hi = val >> 32;
ffffffff80102c46:	48 23 4d f0          	and    -0x10(%rbp),%rcx
ffffffff80102c4a:	89 c8                	mov    %ecx,%eax
ffffffff80102c4c:	89 45 ec             	mov    %eax,-0x14(%rbp)
ffffffff80102c4f:	48 8b 4d f0          	mov    -0x10(%rbp),%rcx
ffffffff80102c53:	48 c1 e9 20          	shr    $0x20,%rcx
ffffffff80102c57:	89 c8                	mov    %ecx,%eax
ffffffff80102c59:	89 45 e8             	mov    %eax,-0x18(%rbp)

  asm volatile ("wrmsr"
          : : "c" (msr), "a" (lo), "d" (hi)
ffffffff80102c5c:	8b 4d fc             	mov    -0x4(%rbp),%ecx
ffffffff80102c5f:	8b 45 ec             	mov    -0x14(%rbp),%eax
ffffffff80102c62:	8b 55 e8             	mov    -0x18(%rbp),%edx
  asm volatile ("wrmsr"
ffffffff80102c65:	0f 30                	wrmsr  
          : "memory");
}
ffffffff80102c67:	48 83 c4 18          	add    $0x18,%rsp
ffffffff80102c6b:	5d                   	pop    %rbp
ffffffff80102c6c:	c3                   	retq   
ffffffff80102c6d:	0f 1f 00             	nopl   (%rax)

ffffffff80102c70 <walkpml4>:
// Return the address of the PTE in page table pgdir
// that corresponds to virtual address va.  If alloc!=0,
// create any required page table pages.
pte_t *
walkpml4(pml4e_t *pml4, const void *va, int alloc)
{
ffffffff80102c70:	55                   	push   %rbp
ffffffff80102c71:	48 89 e5             	mov    %rsp,%rbp
ffffffff80102c74:	48 81 ec 70 01 00 00 	sub    $0x170,%rsp
ffffffff80102c7b:	48 89 7d f0          	mov    %rdi,-0x10(%rbp)
ffffffff80102c7f:	48 89 75 e8          	mov    %rsi,-0x18(%rbp)
ffffffff80102c83:	89 55 e4             	mov    %edx,-0x1c(%rbp)
  pml4e_t *pml4e;
  pdpte_t *pdpt, *pdpte;
  pde_t *pgdir, *pde;
  pte_t *pgtab;

  pml4e = &pml4[PML4_INDEX(va)];
ffffffff80102c86:	48 8b 75 f0          	mov    -0x10(%rbp),%rsi
ffffffff80102c8a:	48 8b 7d e8          	mov    -0x18(%rbp),%rdi
ffffffff80102c8e:	48 c1 ef 27          	shr    $0x27,%rdi
ffffffff80102c92:	48 81 e7 ff 01 00 00 	and    $0x1ff,%rdi
ffffffff80102c99:	48 c1 e7 03          	shl    $0x3,%rdi
ffffffff80102c9d:	48 01 fe             	add    %rdi,%rsi
ffffffff80102ca0:	48 89 75 d8          	mov    %rsi,-0x28(%rbp)

  if (*pml4e & PTE_P) {
ffffffff80102ca4:	48 8b 75 d8          	mov    -0x28(%rbp),%rsi
ffffffff80102ca8:	48 8b 36             	mov    (%rsi),%rsi
ffffffff80102cab:	48 83 e6 01          	and    $0x1,%rsi
ffffffff80102caf:	48 83 fe 00          	cmp    $0x0,%rsi
ffffffff80102cb3:	0f 84 14 01 00 00    	je     ffffffff80102dcd <walkpml4+0x15d>
    pdpt = (pdpte_t*)P2V(PDPT_ADDR(*pml4e));
ffffffff80102cb9:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
ffffffff80102cbd:	48 8b 00             	mov    (%rax),%rax
ffffffff80102cc0:	c7 45 ac 33 00 00 00 	movl   $0x33,-0x54(%rbp)
ffffffff80102cc7:	c7 45 a8 0c 00 00 00 	movl   $0xc,-0x58(%rbp)
ffffffff80102cce:	8b 4d ac             	mov    -0x54(%rbp),%ecx
ffffffff80102cd1:	3b 4d a8             	cmp    -0x58(%rbp),%ecx
ffffffff80102cd4:	48 89 85 38 ff ff ff 	mov    %rax,-0xc8(%rbp)
ffffffff80102cdb:	0f 8c 0e 00 00 00    	jl     ffffffff80102cef <walkpml4+0x7f>
ffffffff80102ce1:	8b 45 ac             	mov    -0x54(%rbp),%eax
ffffffff80102ce4:	89 85 34 ff ff ff    	mov    %eax,-0xcc(%rbp)
ffffffff80102cea:	e9 09 00 00 00       	jmpq   ffffffff80102cf8 <walkpml4+0x88>
ffffffff80102cef:	8b 45 a8             	mov    -0x58(%rbp),%eax
ffffffff80102cf2:	89 85 34 ff ff ff    	mov    %eax,-0xcc(%rbp)
ffffffff80102cf8:	8b 85 34 ff ff ff    	mov    -0xcc(%rbp),%eax
ffffffff80102cfe:	89 45 a4             	mov    %eax,-0x5c(%rbp)
ffffffff80102d01:	8b 45 a4             	mov    -0x5c(%rbp),%eax
ffffffff80102d04:	c7 45 a0 33 00 00 00 	movl   $0x33,-0x60(%rbp)
ffffffff80102d0b:	c7 45 9c 0c 00 00 00 	movl   $0xc,-0x64(%rbp)
ffffffff80102d12:	8b 4d a0             	mov    -0x60(%rbp),%ecx
ffffffff80102d15:	3b 4d 9c             	cmp    -0x64(%rbp),%ecx
ffffffff80102d18:	89 85 30 ff ff ff    	mov    %eax,-0xd0(%rbp)
ffffffff80102d1e:	0f 8f 0e 00 00 00    	jg     ffffffff80102d32 <walkpml4+0xc2>
ffffffff80102d24:	8b 45 a0             	mov    -0x60(%rbp),%eax
ffffffff80102d27:	89 85 2c ff ff ff    	mov    %eax,-0xd4(%rbp)
ffffffff80102d2d:	e9 09 00 00 00       	jmpq   ffffffff80102d3b <walkpml4+0xcb>
ffffffff80102d32:	8b 45 9c             	mov    -0x64(%rbp),%eax
ffffffff80102d35:	89 85 2c ff ff ff    	mov    %eax,-0xd4(%rbp)
ffffffff80102d3b:	8b 85 2c ff ff ff    	mov    -0xd4(%rbp),%eax
ffffffff80102d41:	b9 01 00 00 00       	mov    $0x1,%ecx
ffffffff80102d46:	89 ca                	mov    %ecx,%edx
ffffffff80102d48:	89 45 98             	mov    %eax,-0x68(%rbp)
ffffffff80102d4b:	8b 85 30 ff ff ff    	mov    -0xd0(%rbp),%eax
ffffffff80102d51:	2b 45 98             	sub    -0x68(%rbp),%eax
ffffffff80102d54:	89 c0                	mov    %eax,%eax
ffffffff80102d56:	89 c1                	mov    %eax,%ecx
ffffffff80102d58:	48 d3 e2             	shl    %cl,%rdx
ffffffff80102d5b:	48 c1 e2 01          	shl    $0x1,%rdx
ffffffff80102d5f:	48 83 ea 01          	sub    $0x1,%rdx
ffffffff80102d63:	c7 45 94 33 00 00 00 	movl   $0x33,-0x6c(%rbp)
ffffffff80102d6a:	c7 45 90 0c 00 00 00 	movl   $0xc,-0x70(%rbp)
ffffffff80102d71:	8b 45 94             	mov    -0x6c(%rbp),%eax
ffffffff80102d74:	3b 45 90             	cmp    -0x70(%rbp),%eax
ffffffff80102d77:	48 89 95 20 ff ff ff 	mov    %rdx,-0xe0(%rbp)
ffffffff80102d7e:	0f 8f 0e 00 00 00    	jg     ffffffff80102d92 <walkpml4+0x122>
ffffffff80102d84:	8b 45 94             	mov    -0x6c(%rbp),%eax
ffffffff80102d87:	89 85 1c ff ff ff    	mov    %eax,-0xe4(%rbp)
ffffffff80102d8d:	e9 09 00 00 00       	jmpq   ffffffff80102d9b <walkpml4+0x12b>
ffffffff80102d92:	8b 45 90             	mov    -0x70(%rbp),%eax
ffffffff80102d95:	89 85 1c ff ff ff    	mov    %eax,-0xe4(%rbp)
ffffffff80102d9b:	8b 85 1c ff ff ff    	mov    -0xe4(%rbp),%eax
ffffffff80102da1:	89 45 8c             	mov    %eax,-0x74(%rbp)
ffffffff80102da4:	8b 45 8c             	mov    -0x74(%rbp),%eax
ffffffff80102da7:	89 c1                	mov    %eax,%ecx
ffffffff80102da9:	48 8b 95 20 ff ff ff 	mov    -0xe0(%rbp),%rdx
ffffffff80102db0:	48 d3 e2             	shl    %cl,%rdx
ffffffff80102db3:	48 8b b5 38 ff ff ff 	mov    -0xc8(%rbp),%rsi
ffffffff80102dba:	48 21 d6             	and    %rdx,%rsi
ffffffff80102dbd:	48 81 c6 00 00 00 80 	add    $0xffffffff80000000,%rsi
ffffffff80102dc4:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  } else {
ffffffff80102dc8:	e9 81 00 00 00       	jmpq   ffffffff80102e4e <walkpml4+0x1de>
    if(!alloc || (pdpt = (pdpte_t*)kalloc()) == 0)
ffffffff80102dcd:	83 7d e4 00          	cmpl   $0x0,-0x1c(%rbp)
ffffffff80102dd1:	0f 84 13 00 00 00    	je     ffffffff80102dea <walkpml4+0x17a>
ffffffff80102dd7:	e8 a4 d9 ff ff       	callq  ffffffff80100780 <kalloc>
ffffffff80102ddc:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
ffffffff80102de0:	48 83 f8 00          	cmp    $0x0,%rax
ffffffff80102de4:	0f 85 0d 00 00 00    	jne    ffffffff80102df7 <walkpml4+0x187>
      return 0;
ffffffff80102dea:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
ffffffff80102df1:	00 
ffffffff80102df2:	e9 7d 04 00 00       	jmpq   ffffffff80103274 <walkpml4+0x604>
ffffffff80102df7:	31 c0                	xor    %eax,%eax
ffffffff80102df9:	b9 00 10 00 00       	mov    $0x1000,%ecx
    memset(pdpt, 0, PGSIZE);
ffffffff80102dfe:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
ffffffff80102e02:	31 f6                	xor    %esi,%esi
ffffffff80102e04:	bf 00 10 00 00       	mov    $0x1000,%edi
ffffffff80102e09:	89 bd 18 ff ff ff    	mov    %edi,-0xe8(%rbp)
ffffffff80102e0f:	48 89 d7             	mov    %rdx,%rdi
ffffffff80102e12:	8b 95 18 ff ff ff    	mov    -0xe8(%rbp),%edx
ffffffff80102e18:	89 85 14 ff ff ff    	mov    %eax,-0xec(%rbp)
ffffffff80102e1e:	89 8d 10 ff ff ff    	mov    %ecx,-0xf0(%rbp)
ffffffff80102e24:	e8 d7 80 00 00       	callq  ffffffff8010af00 <memset>
    *pml4e = V2P(pdpt) | PTE_P | PTE_W | PTE_U;
ffffffff80102e29:	48 8b 7d d0          	mov    -0x30(%rbp),%rdi
ffffffff80102e2d:	48 81 ef 00 00 00 80 	sub    $0xffffffff80000000,%rdi
ffffffff80102e34:	48 83 cf 01          	or     $0x1,%rdi
ffffffff80102e38:	48 83 cf 02          	or     $0x2,%rdi
ffffffff80102e3c:	48 83 cf 04          	or     $0x4,%rdi
ffffffff80102e40:	4c 8b 45 d8          	mov    -0x28(%rbp),%r8
ffffffff80102e44:	49 89 38             	mov    %rdi,(%r8)
ffffffff80102e47:	48 89 85 08 ff ff ff 	mov    %rax,-0xf8(%rbp)
  }

  pdpte = &pdpt[PDPT_INDEX(va)];
ffffffff80102e4e:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
ffffffff80102e52:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
ffffffff80102e56:	48 c1 e9 1e          	shr    $0x1e,%rcx
ffffffff80102e5a:	48 81 e1 ff 01 00 00 	and    $0x1ff,%rcx
ffffffff80102e61:	48 c1 e1 03          	shl    $0x3,%rcx
ffffffff80102e65:	48 01 c8             	add    %rcx,%rax
ffffffff80102e68:	48 89 45 c8          	mov    %rax,-0x38(%rbp)

  if (*pdpte & PTE_P) {
ffffffff80102e6c:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
ffffffff80102e70:	48 8b 00             	mov    (%rax),%rax
ffffffff80102e73:	48 83 e0 01          	and    $0x1,%rax
ffffffff80102e77:	48 83 f8 00          	cmp    $0x0,%rax
ffffffff80102e7b:	0f 84 44 01 00 00    	je     ffffffff80102fc5 <walkpml4+0x355>
    pgdir = (pde_t*)P2V(PDE_ADDR(*pdpte));
ffffffff80102e81:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
ffffffff80102e85:	48 8b 00             	mov    (%rax),%rax
ffffffff80102e88:	c7 45 88 33 00 00 00 	movl   $0x33,-0x78(%rbp)
ffffffff80102e8f:	c7 45 84 0c 00 00 00 	movl   $0xc,-0x7c(%rbp)
ffffffff80102e96:	8b 4d 88             	mov    -0x78(%rbp),%ecx
ffffffff80102e99:	3b 4d 84             	cmp    -0x7c(%rbp),%ecx
ffffffff80102e9c:	48 89 85 00 ff ff ff 	mov    %rax,-0x100(%rbp)
ffffffff80102ea3:	0f 8c 0e 00 00 00    	jl     ffffffff80102eb7 <walkpml4+0x247>
ffffffff80102ea9:	8b 45 88             	mov    -0x78(%rbp),%eax
ffffffff80102eac:	89 85 fc fe ff ff    	mov    %eax,-0x104(%rbp)
ffffffff80102eb2:	e9 09 00 00 00       	jmpq   ffffffff80102ec0 <walkpml4+0x250>
ffffffff80102eb7:	8b 45 84             	mov    -0x7c(%rbp),%eax
ffffffff80102eba:	89 85 fc fe ff ff    	mov    %eax,-0x104(%rbp)
ffffffff80102ec0:	8b 85 fc fe ff ff    	mov    -0x104(%rbp),%eax
ffffffff80102ec6:	89 45 80             	mov    %eax,-0x80(%rbp)
ffffffff80102ec9:	8b 45 80             	mov    -0x80(%rbp),%eax
ffffffff80102ecc:	c7 85 7c ff ff ff 33 	movl   $0x33,-0x84(%rbp)
ffffffff80102ed3:	00 00 00 
ffffffff80102ed6:	c7 85 78 ff ff ff 0c 	movl   $0xc,-0x88(%rbp)
ffffffff80102edd:	00 00 00 
ffffffff80102ee0:	8b 8d 7c ff ff ff    	mov    -0x84(%rbp),%ecx
ffffffff80102ee6:	3b 8d 78 ff ff ff    	cmp    -0x88(%rbp),%ecx
ffffffff80102eec:	89 85 f8 fe ff ff    	mov    %eax,-0x108(%rbp)
ffffffff80102ef2:	0f 8f 11 00 00 00    	jg     ffffffff80102f09 <walkpml4+0x299>
ffffffff80102ef8:	8b 85 7c ff ff ff    	mov    -0x84(%rbp),%eax
ffffffff80102efe:	89 85 f4 fe ff ff    	mov    %eax,-0x10c(%rbp)
ffffffff80102f04:	e9 0c 00 00 00       	jmpq   ffffffff80102f15 <walkpml4+0x2a5>
ffffffff80102f09:	8b 85 78 ff ff ff    	mov    -0x88(%rbp),%eax
ffffffff80102f0f:	89 85 f4 fe ff ff    	mov    %eax,-0x10c(%rbp)
ffffffff80102f15:	8b 85 f4 fe ff ff    	mov    -0x10c(%rbp),%eax
ffffffff80102f1b:	b9 01 00 00 00       	mov    $0x1,%ecx
ffffffff80102f20:	89 ca                	mov    %ecx,%edx
ffffffff80102f22:	89 85 74 ff ff ff    	mov    %eax,-0x8c(%rbp)
ffffffff80102f28:	8b 85 f8 fe ff ff    	mov    -0x108(%rbp),%eax
ffffffff80102f2e:	2b 85 74 ff ff ff    	sub    -0x8c(%rbp),%eax
ffffffff80102f34:	89 c0                	mov    %eax,%eax
ffffffff80102f36:	89 c1                	mov    %eax,%ecx
ffffffff80102f38:	48 d3 e2             	shl    %cl,%rdx
ffffffff80102f3b:	48 c1 e2 01          	shl    $0x1,%rdx
ffffffff80102f3f:	48 83 ea 01          	sub    $0x1,%rdx
ffffffff80102f43:	c7 85 70 ff ff ff 33 	movl   $0x33,-0x90(%rbp)
ffffffff80102f4a:	00 00 00 
ffffffff80102f4d:	c7 85 6c ff ff ff 0c 	movl   $0xc,-0x94(%rbp)
ffffffff80102f54:	00 00 00 
ffffffff80102f57:	8b 85 70 ff ff ff    	mov    -0x90(%rbp),%eax
ffffffff80102f5d:	3b 85 6c ff ff ff    	cmp    -0x94(%rbp),%eax
ffffffff80102f63:	48 89 95 e8 fe ff ff 	mov    %rdx,-0x118(%rbp)
ffffffff80102f6a:	0f 8f 11 00 00 00    	jg     ffffffff80102f81 <walkpml4+0x311>
ffffffff80102f70:	8b 85 70 ff ff ff    	mov    -0x90(%rbp),%eax
ffffffff80102f76:	89 85 e4 fe ff ff    	mov    %eax,-0x11c(%rbp)
ffffffff80102f7c:	e9 0c 00 00 00       	jmpq   ffffffff80102f8d <walkpml4+0x31d>
ffffffff80102f81:	8b 85 6c ff ff ff    	mov    -0x94(%rbp),%eax
ffffffff80102f87:	89 85 e4 fe ff ff    	mov    %eax,-0x11c(%rbp)
ffffffff80102f8d:	8b 85 e4 fe ff ff    	mov    -0x11c(%rbp),%eax
ffffffff80102f93:	89 85 68 ff ff ff    	mov    %eax,-0x98(%rbp)
ffffffff80102f99:	8b 85 68 ff ff ff    	mov    -0x98(%rbp),%eax
ffffffff80102f9f:	89 c1                	mov    %eax,%ecx
ffffffff80102fa1:	48 8b 95 e8 fe ff ff 	mov    -0x118(%rbp),%rdx
ffffffff80102fa8:	48 d3 e2             	shl    %cl,%rdx
ffffffff80102fab:	48 8b b5 00 ff ff ff 	mov    -0x100(%rbp),%rsi
ffffffff80102fb2:	48 21 d6             	and    %rdx,%rsi
ffffffff80102fb5:	48 81 c6 00 00 00 80 	add    $0xffffffff80000000,%rsi
ffffffff80102fbc:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
  } else {
ffffffff80102fc0:	e9 81 00 00 00       	jmpq   ffffffff80103046 <walkpml4+0x3d6>
    if(!alloc || (pgdir = (pde_t*)kalloc()) == 0)
ffffffff80102fc5:	83 7d e4 00          	cmpl   $0x0,-0x1c(%rbp)
ffffffff80102fc9:	0f 84 13 00 00 00    	je     ffffffff80102fe2 <walkpml4+0x372>
ffffffff80102fcf:	e8 ac d7 ff ff       	callq  ffffffff80100780 <kalloc>
ffffffff80102fd4:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
ffffffff80102fd8:	48 83 f8 00          	cmp    $0x0,%rax
ffffffff80102fdc:	0f 85 0d 00 00 00    	jne    ffffffff80102fef <walkpml4+0x37f>
      return 0;
ffffffff80102fe2:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
ffffffff80102fe9:	00 
ffffffff80102fea:	e9 85 02 00 00       	jmpq   ffffffff80103274 <walkpml4+0x604>
ffffffff80102fef:	31 c0                	xor    %eax,%eax
ffffffff80102ff1:	b9 00 10 00 00       	mov    $0x1000,%ecx
    memset(pgdir, 0, PGSIZE);
ffffffff80102ff6:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
ffffffff80102ffa:	31 f6                	xor    %esi,%esi
ffffffff80102ffc:	bf 00 10 00 00       	mov    $0x1000,%edi
ffffffff80103001:	89 bd e0 fe ff ff    	mov    %edi,-0x120(%rbp)
ffffffff80103007:	48 89 d7             	mov    %rdx,%rdi
ffffffff8010300a:	8b 95 e0 fe ff ff    	mov    -0x120(%rbp),%edx
ffffffff80103010:	89 85 dc fe ff ff    	mov    %eax,-0x124(%rbp)
ffffffff80103016:	89 8d d8 fe ff ff    	mov    %ecx,-0x128(%rbp)
ffffffff8010301c:	e8 df 7e 00 00       	callq  ffffffff8010af00 <memset>
    *pdpte = V2P(pgdir) | PTE_P | PTE_W | PTE_U;
ffffffff80103021:	48 8b 7d c0          	mov    -0x40(%rbp),%rdi
ffffffff80103025:	48 81 ef 00 00 00 80 	sub    $0xffffffff80000000,%rdi
ffffffff8010302c:	48 83 cf 01          	or     $0x1,%rdi
ffffffff80103030:	48 83 cf 02          	or     $0x2,%rdi
ffffffff80103034:	48 83 cf 04          	or     $0x4,%rdi
ffffffff80103038:	4c 8b 45 c8          	mov    -0x38(%rbp),%r8
ffffffff8010303c:	49 89 38             	mov    %rdi,(%r8)
ffffffff8010303f:	48 89 85 d0 fe ff ff 	mov    %rax,-0x130(%rbp)
  }

  pde = &pgdir[PD_INDEX(va)];
ffffffff80103046:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
ffffffff8010304a:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
ffffffff8010304e:	48 c1 e9 15          	shr    $0x15,%rcx
ffffffff80103052:	48 81 e1 ff 01 00 00 	and    $0x1ff,%rcx
ffffffff80103059:	48 c1 e1 03          	shl    $0x3,%rcx
ffffffff8010305d:	48 01 c8             	add    %rcx,%rax
ffffffff80103060:	48 89 45 b8          	mov    %rax,-0x48(%rbp)

  if (*pde & PTE_P) {
ffffffff80103064:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
ffffffff80103068:	48 8b 00             	mov    (%rax),%rax
ffffffff8010306b:	48 83 e0 01          	and    $0x1,%rax
ffffffff8010306f:	48 83 f8 00          	cmp    $0x0,%rax
ffffffff80103073:	0f 84 5c 01 00 00    	je     ffffffff801031d5 <walkpml4+0x565>
    pgtab = (pte_t*)P2V(PTE_ADDR(*pde));
ffffffff80103079:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
ffffffff8010307d:	48 8b 00             	mov    (%rax),%rax
ffffffff80103080:	c7 85 64 ff ff ff 33 	movl   $0x33,-0x9c(%rbp)
ffffffff80103087:	00 00 00 
ffffffff8010308a:	c7 85 60 ff ff ff 0c 	movl   $0xc,-0xa0(%rbp)
ffffffff80103091:	00 00 00 
ffffffff80103094:	8b 8d 64 ff ff ff    	mov    -0x9c(%rbp),%ecx
ffffffff8010309a:	3b 8d 60 ff ff ff    	cmp    -0xa0(%rbp),%ecx
ffffffff801030a0:	48 89 85 c8 fe ff ff 	mov    %rax,-0x138(%rbp)
ffffffff801030a7:	0f 8c 11 00 00 00    	jl     ffffffff801030be <walkpml4+0x44e>
ffffffff801030ad:	8b 85 64 ff ff ff    	mov    -0x9c(%rbp),%eax
ffffffff801030b3:	89 85 c4 fe ff ff    	mov    %eax,-0x13c(%rbp)
ffffffff801030b9:	e9 0c 00 00 00       	jmpq   ffffffff801030ca <walkpml4+0x45a>
ffffffff801030be:	8b 85 60 ff ff ff    	mov    -0xa0(%rbp),%eax
ffffffff801030c4:	89 85 c4 fe ff ff    	mov    %eax,-0x13c(%rbp)
ffffffff801030ca:	8b 85 c4 fe ff ff    	mov    -0x13c(%rbp),%eax
ffffffff801030d0:	89 85 5c ff ff ff    	mov    %eax,-0xa4(%rbp)
ffffffff801030d6:	8b 85 5c ff ff ff    	mov    -0xa4(%rbp),%eax
ffffffff801030dc:	c7 85 58 ff ff ff 33 	movl   $0x33,-0xa8(%rbp)
ffffffff801030e3:	00 00 00 
ffffffff801030e6:	c7 85 54 ff ff ff 0c 	movl   $0xc,-0xac(%rbp)
ffffffff801030ed:	00 00 00 
ffffffff801030f0:	8b 8d 58 ff ff ff    	mov    -0xa8(%rbp),%ecx
ffffffff801030f6:	3b 8d 54 ff ff ff    	cmp    -0xac(%rbp),%ecx
ffffffff801030fc:	89 85 c0 fe ff ff    	mov    %eax,-0x140(%rbp)
ffffffff80103102:	0f 8f 11 00 00 00    	jg     ffffffff80103119 <walkpml4+0x4a9>
ffffffff80103108:	8b 85 58 ff ff ff    	mov    -0xa8(%rbp),%eax
ffffffff8010310e:	89 85 bc fe ff ff    	mov    %eax,-0x144(%rbp)
ffffffff80103114:	e9 0c 00 00 00       	jmpq   ffffffff80103125 <walkpml4+0x4b5>
ffffffff80103119:	8b 85 54 ff ff ff    	mov    -0xac(%rbp),%eax
ffffffff8010311f:	89 85 bc fe ff ff    	mov    %eax,-0x144(%rbp)
ffffffff80103125:	8b 85 bc fe ff ff    	mov    -0x144(%rbp),%eax
ffffffff8010312b:	b9 01 00 00 00       	mov    $0x1,%ecx
ffffffff80103130:	89 ca                	mov    %ecx,%edx
ffffffff80103132:	89 85 50 ff ff ff    	mov    %eax,-0xb0(%rbp)
ffffffff80103138:	8b 85 c0 fe ff ff    	mov    -0x140(%rbp),%eax
ffffffff8010313e:	2b 85 50 ff ff ff    	sub    -0xb0(%rbp),%eax
ffffffff80103144:	89 c0                	mov    %eax,%eax
ffffffff80103146:	89 c1                	mov    %eax,%ecx
ffffffff80103148:	48 d3 e2             	shl    %cl,%rdx
ffffffff8010314b:	48 c1 e2 01          	shl    $0x1,%rdx
ffffffff8010314f:	48 83 ea 01          	sub    $0x1,%rdx
ffffffff80103153:	c7 85 4c ff ff ff 33 	movl   $0x33,-0xb4(%rbp)
ffffffff8010315a:	00 00 00 
ffffffff8010315d:	c7 85 48 ff ff ff 0c 	movl   $0xc,-0xb8(%rbp)
ffffffff80103164:	00 00 00 
ffffffff80103167:	8b 85 4c ff ff ff    	mov    -0xb4(%rbp),%eax
ffffffff8010316d:	3b 85 48 ff ff ff    	cmp    -0xb8(%rbp),%eax
ffffffff80103173:	48 89 95 b0 fe ff ff 	mov    %rdx,-0x150(%rbp)
ffffffff8010317a:	0f 8f 11 00 00 00    	jg     ffffffff80103191 <walkpml4+0x521>
ffffffff80103180:	8b 85 4c ff ff ff    	mov    -0xb4(%rbp),%eax
ffffffff80103186:	89 85 ac fe ff ff    	mov    %eax,-0x154(%rbp)
ffffffff8010318c:	e9 0c 00 00 00       	jmpq   ffffffff8010319d <walkpml4+0x52d>
ffffffff80103191:	8b 85 48 ff ff ff    	mov    -0xb8(%rbp),%eax
ffffffff80103197:	89 85 ac fe ff ff    	mov    %eax,-0x154(%rbp)
ffffffff8010319d:	8b 85 ac fe ff ff    	mov    -0x154(%rbp),%eax
ffffffff801031a3:	89 85 44 ff ff ff    	mov    %eax,-0xbc(%rbp)
ffffffff801031a9:	8b 85 44 ff ff ff    	mov    -0xbc(%rbp),%eax
ffffffff801031af:	89 c1                	mov    %eax,%ecx
ffffffff801031b1:	48 8b 95 b0 fe ff ff 	mov    -0x150(%rbp),%rdx
ffffffff801031b8:	48 d3 e2             	shl    %cl,%rdx
ffffffff801031bb:	48 8b b5 c8 fe ff ff 	mov    -0x138(%rbp),%rsi
ffffffff801031c2:	48 21 d6             	and    %rdx,%rsi
ffffffff801031c5:	48 81 c6 00 00 00 80 	add    $0xffffffff80000000,%rsi
ffffffff801031cc:	48 89 75 b0          	mov    %rsi,-0x50(%rbp)
  } else {
ffffffff801031d0:	e9 81 00 00 00       	jmpq   ffffffff80103256 <walkpml4+0x5e6>
    if(!alloc || (pgtab = (pte_t*)kalloc()) == 0)
ffffffff801031d5:	83 7d e4 00          	cmpl   $0x0,-0x1c(%rbp)
ffffffff801031d9:	0f 84 13 00 00 00    	je     ffffffff801031f2 <walkpml4+0x582>
ffffffff801031df:	e8 9c d5 ff ff       	callq  ffffffff80100780 <kalloc>
ffffffff801031e4:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
ffffffff801031e8:	48 83 f8 00          	cmp    $0x0,%rax
ffffffff801031ec:	0f 85 0d 00 00 00    	jne    ffffffff801031ff <walkpml4+0x58f>
      return 0;
ffffffff801031f2:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
ffffffff801031f9:	00 
ffffffff801031fa:	e9 75 00 00 00       	jmpq   ffffffff80103274 <walkpml4+0x604>
ffffffff801031ff:	31 c0                	xor    %eax,%eax
ffffffff80103201:	b9 00 10 00 00       	mov    $0x1000,%ecx
    memset(pgtab, 0, PGSIZE);
ffffffff80103206:	48 8b 55 b0          	mov    -0x50(%rbp),%rdx
ffffffff8010320a:	31 f6                	xor    %esi,%esi
ffffffff8010320c:	bf 00 10 00 00       	mov    $0x1000,%edi
ffffffff80103211:	89 bd a8 fe ff ff    	mov    %edi,-0x158(%rbp)
ffffffff80103217:	48 89 d7             	mov    %rdx,%rdi
ffffffff8010321a:	8b 95 a8 fe ff ff    	mov    -0x158(%rbp),%edx
ffffffff80103220:	89 85 a4 fe ff ff    	mov    %eax,-0x15c(%rbp)
ffffffff80103226:	89 8d a0 fe ff ff    	mov    %ecx,-0x160(%rbp)
ffffffff8010322c:	e8 cf 7c 00 00       	callq  ffffffff8010af00 <memset>
    *pde = V2P(pgtab) | PTE_P | PTE_W | PTE_U;
ffffffff80103231:	48 8b 7d b0          	mov    -0x50(%rbp),%rdi
ffffffff80103235:	48 81 ef 00 00 00 80 	sub    $0xffffffff80000000,%rdi
ffffffff8010323c:	48 83 cf 01          	or     $0x1,%rdi
ffffffff80103240:	48 83 cf 02          	or     $0x2,%rdi
ffffffff80103244:	48 83 cf 04          	or     $0x4,%rdi
ffffffff80103248:	4c 8b 45 b8          	mov    -0x48(%rbp),%r8
ffffffff8010324c:	49 89 38             	mov    %rdi,(%r8)
ffffffff8010324f:	48 89 85 98 fe ff ff 	mov    %rax,-0x168(%rbp)
  }

  return &pgtab[PT_INDEX(va)];
ffffffff80103256:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
ffffffff8010325a:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
ffffffff8010325e:	48 c1 e9 0c          	shr    $0xc,%rcx
ffffffff80103262:	48 81 e1 ff 01 00 00 	and    $0x1ff,%rcx
ffffffff80103269:	48 c1 e1 03          	shl    $0x3,%rcx
ffffffff8010326d:	48 01 c8             	add    %rcx,%rax
ffffffff80103270:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
}
ffffffff80103274:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
ffffffff80103278:	48 81 c4 70 01 00 00 	add    $0x170,%rsp
ffffffff8010327f:	5d                   	pop    %rbp
ffffffff80103280:	c3                   	retq   
ffffffff80103281:	66 66 66 66 66 66 2e 	data16 data16 data16 data16 data16 nopw %cs:0x0(%rax,%rax,1)
ffffffff80103288:	0f 1f 84 00 00 00 00 
ffffffff8010328f:	00 

ffffffff80103290 <mappages>:
// Create PTEs for virtual addresses starting at va that refer to
// physical addresses starting at pa. va and size might not
// be page-aligned.
int
mappages(pml4e_t *pml4, uint64_t virt_pn, int num_page, uint64_t phy_pn, int perm, int pid)
{
ffffffff80103290:	55                   	push   %rbp
ffffffff80103291:	48 89 e5             	mov    %rsp,%rbp
ffffffff80103294:	48 83 ec 40          	sub    $0x40,%rsp
ffffffff80103298:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
ffffffff8010329c:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
ffffffff801032a0:	89 55 ec             	mov    %edx,-0x14(%rbp)
ffffffff801032a3:	48 89 4d e0          	mov    %rcx,-0x20(%rbp)
ffffffff801032a7:	44 89 45 dc          	mov    %r8d,-0x24(%rbp)
ffffffff801032ab:	44 89 4d d8          	mov    %r9d,-0x28(%rbp)
  pte_t *pte;
  int i;

  for(i=0;i<num_page;i++){
ffffffff801032af:	c7 45 cc 00 00 00 00 	movl   $0x0,-0x34(%rbp)
ffffffff801032b6:	8b 45 cc             	mov    -0x34(%rbp),%eax
ffffffff801032b9:	3b 45 ec             	cmp    -0x14(%rbp),%eax
ffffffff801032bc:	0f 8d ba 00 00 00    	jge    ffffffff8010337c <mappages+0xec>
ffffffff801032c2:	b8 01 00 00 00       	mov    $0x1,%eax
    if((pte = walkpml4(pml4, (char*)(virt_pn << PT_SHIFT), 1)) == 0) {
ffffffff801032c7:	48 8b 7d f8          	mov    -0x8(%rbp),%rdi
ffffffff801032cb:	48 8b 4d f0          	mov    -0x10(%rbp),%rcx
ffffffff801032cf:	48 c1 e1 0c          	shl    $0xc,%rcx
ffffffff801032d3:	ba 01 00 00 00       	mov    $0x1,%edx
ffffffff801032d8:	48 89 ce             	mov    %rcx,%rsi
ffffffff801032db:	89 45 c8             	mov    %eax,-0x38(%rbp)
ffffffff801032de:	e8 8d f9 ff ff       	callq  ffffffff80102c70 <walkpml4>
ffffffff801032e3:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
ffffffff801032e7:	48 83 f8 00          	cmp    $0x0,%rax
ffffffff801032eb:	0f 85 0c 00 00 00    	jne    ffffffff801032fd <mappages+0x6d>
      panic("not enough memory");
ffffffff801032f1:	48 c7 c7 ea 06 11 80 	mov    $0xffffffff801106ea,%rdi
ffffffff801032f8:	e8 73 db ff ff       	callq  ffffffff80100e70 <panic>
      return -1;
    }
    if(*pte & PTE_P)
ffffffff801032fd:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
ffffffff80103301:	48 8b 00             	mov    (%rax),%rax
ffffffff80103304:	48 83 e0 01          	and    $0x1,%rax
ffffffff80103308:	48 83 f8 00          	cmp    $0x0,%rax
ffffffff8010330c:	0f 84 0c 00 00 00    	je     ffffffff8010331e <mappages+0x8e>
      panic("remap");
ffffffff80103312:	48 c7 c7 64 fc 10 80 	mov    $0xffffffff8010fc64,%rdi
ffffffff80103319:	e8 52 db ff ff       	callq  ffffffff80100e70 <panic>
    *pte = PTE(phy_pn << PT_SHIFT, perm | PTE_P);
ffffffff8010331e:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
ffffffff80103322:	48 c1 e0 0c          	shl    $0xc,%rax
ffffffff80103326:	48 63 4d dc          	movslq -0x24(%rbp),%rcx
ffffffff8010332a:	48 83 c9 01          	or     $0x1,%rcx
ffffffff8010332e:	48 09 c8             	or     %rcx,%rax
ffffffff80103331:	48 8b 4d d0          	mov    -0x30(%rbp),%rcx
ffffffff80103335:	48 89 01             	mov    %rax,(%rcx)

    add_phy_mem_map(pid, virt_pn << PT_SHIFT, phy_pn << PT_SHIFT);
ffffffff80103338:	8b 7d d8             	mov    -0x28(%rbp),%edi
ffffffff8010333b:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
ffffffff8010333f:	48 c1 e0 0c          	shl    $0xc,%rax
ffffffff80103343:	48 8b 4d e0          	mov    -0x20(%rbp),%rcx
ffffffff80103347:	48 c1 e1 0c          	shl    $0xc,%rcx
ffffffff8010334b:	48 89 c6             	mov    %rax,%rsi
ffffffff8010334e:	48 89 ca             	mov    %rcx,%rdx
ffffffff80103351:	e8 8a d3 ff ff       	callq  ffffffff801006e0 <add_phy_mem_map>

    virt_pn ++;
ffffffff80103356:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
ffffffff8010335a:	48 83 c0 01          	add    $0x1,%rax
ffffffff8010335e:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
    phy_pn ++;
ffffffff80103362:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
ffffffff80103366:	48 83 c0 01          	add    $0x1,%rax
ffffffff8010336a:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  for(i=0;i<num_page;i++){
ffffffff8010336e:	8b 45 cc             	mov    -0x34(%rbp),%eax
ffffffff80103371:	83 c0 01             	add    $0x1,%eax
ffffffff80103374:	89 45 cc             	mov    %eax,-0x34(%rbp)
ffffffff80103377:	e9 3a ff ff ff       	jmpq   ffffffff801032b6 <mappages+0x26>
ffffffff8010337c:	31 c0                	xor    %eax,%eax
  }
  return 0;
ffffffff8010337e:	48 83 c4 40          	add    $0x40,%rsp
ffffffff80103382:	5d                   	pop    %rbp
ffffffff80103383:	c3                   	retq   
ffffffff80103384:	66 66 66 2e 0f 1f 84 	data16 data16 nopw %cs:0x0(%rax,%rax,1)
ffffffff8010338b:	00 00 00 00 00 

ffffffff80103390 <setupkvm>:
}

// Set up kernel part of a page table.
pml4e_t*
setupkvm(void)
{
ffffffff80103390:	55                   	push   %rbp
ffffffff80103391:	48 89 e5             	mov    %rsp,%rbp
  pml4e_t *pml4;
  struct kmap *k;

  if((pml4 = (pml4e_t*)kalloc()) == 0)
ffffffff80103394:	48 81 ec e0 00 00 00 	sub    $0xe0,%rsp
ffffffff8010339b:	e8 e0 d3 ff ff       	callq  ffffffff80100780 <kalloc>
ffffffff801033a0:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
ffffffff801033a4:	48 83 f8 00          	cmp    $0x0,%rax
ffffffff801033a8:	0f 85 0d 00 00 00    	jne    ffffffff801033bb <setupkvm+0x2b>
    return 0;
ffffffff801033ae:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
ffffffff801033b5:	00 
ffffffff801033b6:	e9 bf 01 00 00       	jmpq   ffffffff8010357a <setupkvm+0x1ea>
ffffffff801033bb:	48 8d 85 60 ff ff ff 	lea    -0xa0(%rbp),%rax
ffffffff801033c2:	48 b9 00 00 00 00 01 	movabs $0x100000000,%rcx
ffffffff801033c9:	00 00 00 
ffffffff801033cc:	ba 00 00 00 fe       	mov    $0xfe000000,%edx
ffffffff801033d1:	89 d6                	mov    %edx,%esi
ffffffff801033d3:	48 c7 c7 00 00 00 fe 	mov    $0xfffffffffe000000,%rdi
  memset(pml4, 0, PGSIZE);
ffffffff801033da:	4c 8b 45 f0          	mov    -0x10(%rbp),%r8
ffffffff801033de:	31 d2                	xor    %edx,%edx
ffffffff801033e0:	41 b9 00 10 00 00    	mov    $0x1000,%r9d
ffffffff801033e6:	48 89 bd 58 ff ff ff 	mov    %rdi,-0xa8(%rbp)
ffffffff801033ed:	4c 89 c7             	mov    %r8,%rdi
ffffffff801033f0:	48 89 b5 50 ff ff ff 	mov    %rsi,-0xb0(%rbp)
ffffffff801033f7:	89 d6                	mov    %edx,%esi
ffffffff801033f9:	44 89 ca             	mov    %r9d,%edx
ffffffff801033fc:	48 89 85 48 ff ff ff 	mov    %rax,-0xb8(%rbp)
ffffffff80103403:	48 89 8d 40 ff ff ff 	mov    %rcx,-0xc0(%rbp)
ffffffff8010340a:	e8 f1 7a 00 00       	callq  ffffffff8010af00 <memset>
    void *virt;
    uint64_t phys_start;
    uint64_t phys_end;
    int perm;
  } kmap[] = {
    { (void*)KERNBASE, 0,             EXTMEM,    PTE_W}, // I/O space
ffffffff8010340f:	48 c7 85 60 ff ff ff 	movq   $0xffffffff80000000,-0xa0(%rbp)
ffffffff80103416:	00 00 00 80 
ffffffff8010341a:	48 c7 85 68 ff ff ff 	movq   $0x0,-0x98(%rbp)
ffffffff80103421:	00 00 00 00 
ffffffff80103425:	48 c7 85 70 ff ff ff 	movq   $0x100000,-0x90(%rbp)
ffffffff8010342c:	00 00 10 00 
ffffffff80103430:	c7 85 78 ff ff ff 02 	movl   $0x2,-0x88(%rbp)
ffffffff80103437:	00 00 00 
    { (void*)KERNLINK, V2P(KERNLINK), V2P(data), 0},     // kern text+rodata
ffffffff8010343a:	48 c7 45 80 00 00 10 	movq   $0xffffffff80100000,-0x80(%rbp)
ffffffff80103441:	80 
ffffffff80103442:	48 c7 45 88 00 00 10 	movq   $0x100000,-0x78(%rbp)
ffffffff80103449:	00 
    { (void*)KERNBASE, 0,             EXTMEM,    PTE_W}, // I/O space
ffffffff8010344a:	ba 00 00 00 80       	mov    $0x80000000,%edx
ffffffff8010344f:	89 d1                	mov    %edx,%ecx
ffffffff80103451:	48 8d 89 00 30 11 80 	lea    -0x7feed000(%rcx),%rcx
    { (void*)KERNLINK, V2P(KERNLINK), V2P(data), 0},     // kern text+rodata
ffffffff80103458:	48 89 4d 90          	mov    %rcx,-0x70(%rbp)
ffffffff8010345c:	c7 45 98 00 00 00 00 	movl   $0x0,-0x68(%rbp)
    { (void*)data,     V2P(data),     (uint64_t) npages * PGSIZE,   PTE_W}, // kern data+memory
ffffffff80103463:	48 c7 45 a0 00 30 11 	movq   $0xffffffff80113000,-0x60(%rbp)
ffffffff8010346a:	80 
ffffffff8010346b:	48 89 4d a8          	mov    %rcx,-0x58(%rbp)
ffffffff8010346f:	8b 14 25 e0 63 1f 83 	mov    0xffffffff831f63e0,%edx
ffffffff80103476:	48 63 ca             	movslq %edx,%rcx
ffffffff80103479:	48 c1 e1 0c          	shl    $0xc,%rcx
ffffffff8010347d:	48 89 4d b0          	mov    %rcx,-0x50(%rbp)
ffffffff80103481:	c7 45 b8 02 00 00 00 	movl   $0x2,-0x48(%rbp)
    { (void*)DEVSPACE, 0xFE000000,    0x100000000,         PTE_W}, // more devices
ffffffff80103488:	48 8b 8d 58 ff ff ff 	mov    -0xa8(%rbp),%rcx
ffffffff8010348f:	48 89 4d c0          	mov    %rcx,-0x40(%rbp)
ffffffff80103493:	48 8b bd 50 ff ff ff 	mov    -0xb0(%rbp),%rdi
ffffffff8010349a:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
ffffffff8010349e:	4c 8b 85 40 ff ff ff 	mov    -0xc0(%rbp),%r8
ffffffff801034a5:	4c 89 45 d0          	mov    %r8,-0x30(%rbp)
ffffffff801034a9:	c7 45 d8 02 00 00 00 	movl   $0x2,-0x28(%rbp)
  };

  for(k = kmap; k < &kmap[NELEM(kmap)]; k++)
ffffffff801034b0:	4c 8b 95 48 ff ff ff 	mov    -0xb8(%rbp),%r10
ffffffff801034b7:	4c 89 55 e8          	mov    %r10,-0x18(%rbp)
ffffffff801034bb:	48 89 85 38 ff ff ff 	mov    %rax,-0xc8(%rbp)
ffffffff801034c2:	48 8d 85 60 ff ff ff 	lea    -0xa0(%rbp),%rax
ffffffff801034c9:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
ffffffff801034cd:	48 05 80 00 00 00    	add    $0x80,%rax
ffffffff801034d3:	48 39 c1             	cmp    %rax,%rcx
ffffffff801034d6:	0f 83 96 00 00 00    	jae    ffffffff80103572 <setupkvm+0x1e2>
ffffffff801034dc:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    if(mappages(pml4, (uint64_t)(k->virt) >> PT_SHIFT, (k->phys_end - k->phys_start) >> PT_SHIFT, k->phys_start >> PT_SHIFT, k->perm, -1) < 0)
ffffffff801034e1:	48 8b 7d f0          	mov    -0x10(%rbp),%rdi
ffffffff801034e5:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
ffffffff801034e9:	48 8b 09             	mov    (%rcx),%rcx
ffffffff801034ec:	48 c1 e9 0c          	shr    $0xc,%rcx
ffffffff801034f0:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
ffffffff801034f4:	48 8b 52 10          	mov    0x10(%rdx),%rdx
ffffffff801034f8:	48 8b 75 e8          	mov    -0x18(%rbp),%rsi
ffffffff801034fc:	48 2b 56 08          	sub    0x8(%rsi),%rdx
ffffffff80103500:	48 c1 ea 0c          	shr    $0xc,%rdx
ffffffff80103504:	41 89 d0             	mov    %edx,%r8d
ffffffff80103507:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
ffffffff8010350b:	48 8b 52 08          	mov    0x8(%rdx),%rdx
ffffffff8010350f:	48 c1 ea 0c          	shr    $0xc,%rdx
ffffffff80103513:	48 8b 75 e8          	mov    -0x18(%rbp),%rsi
ffffffff80103517:	44 8b 4e 18          	mov    0x18(%rsi),%r9d
ffffffff8010351b:	41 ba ff ff ff ff    	mov    $0xffffffff,%r10d
ffffffff80103521:	48 89 ce             	mov    %rcx,%rsi
ffffffff80103524:	48 89 95 30 ff ff ff 	mov    %rdx,-0xd0(%rbp)
ffffffff8010352b:	44 89 c2             	mov    %r8d,%edx
ffffffff8010352e:	48 8b 8d 30 ff ff ff 	mov    -0xd0(%rbp),%rcx
ffffffff80103535:	45 89 c8             	mov    %r9d,%r8d
ffffffff80103538:	45 89 d1             	mov    %r10d,%r9d
ffffffff8010353b:	89 85 2c ff ff ff    	mov    %eax,-0xd4(%rbp)
ffffffff80103541:	e8 4a fd ff ff       	callq  ffffffff80103290 <mappages>
ffffffff80103546:	83 f8 00             	cmp    $0x0,%eax
ffffffff80103549:	0f 8d 0d 00 00 00    	jge    ffffffff8010355c <setupkvm+0x1cc>
      return 0;
ffffffff8010354f:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
ffffffff80103556:	00 
ffffffff80103557:	e9 1e 00 00 00       	jmpq   ffffffff8010357a <setupkvm+0x1ea>
    if(mappages(pml4, (uint64_t)(k->virt) >> PT_SHIFT, (k->phys_end - k->phys_start) >> PT_SHIFT, k->phys_start >> PT_SHIFT, k->perm, -1) < 0)
ffffffff8010355c:	e9 00 00 00 00       	jmpq   ffffffff80103561 <setupkvm+0x1d1>
  for(k = kmap; k < &kmap[NELEM(kmap)]; k++)
ffffffff80103561:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
ffffffff80103565:	48 83 c0 20          	add    $0x20,%rax
ffffffff80103569:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
ffffffff8010356d:	e9 50 ff ff ff       	jmpq   ffffffff801034c2 <setupkvm+0x132>
  return pml4;
ffffffff80103572:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
ffffffff80103576:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
}
ffffffff8010357a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
ffffffff8010357e:	48 81 c4 e0 00 00 00 	add    $0xe0,%rsp
ffffffff80103585:	5d                   	pop    %rbp
ffffffff80103586:	c3                   	retq   
ffffffff80103587:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
ffffffff8010358e:	00 00 

ffffffff80103590 <kvmalloc>:

void
kvmalloc(void)
{
ffffffff80103590:	55                   	push   %rbp
ffffffff80103591:	48 89 e5             	mov    %rsp,%rbp
  kpml4 = setupkvm();
ffffffff80103594:	e8 f7 fd ff ff       	callq  ffffffff80103390 <setupkvm>
ffffffff80103599:	48 89 04 25 48 6b 1f 	mov    %rax,0xffffffff831f6b48
ffffffff801035a0:	83 
  switchkvm();
ffffffff801035a1:	e8 0a 00 00 00       	callq  ffffffff801035b0 <switchkvm>
}
ffffffff801035a6:	5d                   	pop    %rbp
ffffffff801035a7:	c3                   	retq   
ffffffff801035a8:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
ffffffff801035af:	00 

ffffffff801035b0 <switchkvm>:

// Switch h/w page table register to the kernel-only page table,
// for when no process is running.
void
switchkvm(void)
{
ffffffff801035b0:	55                   	push   %rbp
ffffffff801035b1:	48 89 e5             	mov    %rsp,%rbp
  lcr3(V2P(kpml4));   // switch to the kernel page table
ffffffff801035b4:	48 8b 04 25 48 6b 1f 	mov    0xffffffff831f6b48,%rax
ffffffff801035bb:	83 
ffffffff801035bc:	48 2d 00 00 00 80    	sub    $0xffffffff80000000,%rax
ffffffff801035c2:	48 89 c7             	mov    %rax,%rdi
ffffffff801035c5:	e8 06 00 00 00       	callq  ffffffff801035d0 <lcr3>
}
ffffffff801035ca:	5d                   	pop    %rbp
ffffffff801035cb:	c3                   	retq   
ffffffff801035cc:	0f 1f 40 00          	nopl   0x0(%rax)

ffffffff801035d0 <lcr3>:
{
ffffffff801035d0:	55                   	push   %rbp
ffffffff801035d1:	48 89 e5             	mov    %rsp,%rbp
ffffffff801035d4:	50                   	push   %rax
ffffffff801035d5:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  asm volatile("mov %0,%%cr3" : : "r" (val));
ffffffff801035d9:	48 8b 7d f8          	mov    -0x8(%rbp),%rdi
ffffffff801035dd:	0f 22 df             	mov    %rdi,%cr3
}
ffffffff801035e0:	48 83 c4 08          	add    $0x8,%rsp
ffffffff801035e4:	5d                   	pop    %rbp
ffffffff801035e5:	c3                   	retq   
ffffffff801035e6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
ffffffff801035ed:	00 00 00 

ffffffff801035f0 <switchuvm>:

// Switch TSS and h/w page table to correspond to process p.
void
switchuvm(struct proc *p)
{
ffffffff801035f0:	55                   	push   %rbp
ffffffff801035f1:	48 89 e5             	mov    %rsp,%rbp
ffffffff801035f4:	48 83 ec 10          	sub    $0x10,%rsp
ffffffff801035f8:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  if(p == 0)
ffffffff801035fc:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
ffffffff80103601:	0f 85 0c 00 00 00    	jne    ffffffff80103613 <switchuvm+0x23>
    panic("switchuvm: no process");
ffffffff80103607:	48 c7 c7 6a fc 10 80 	mov    $0xffffffff8010fc6a,%rdi
ffffffff8010360e:	e8 5d d8 ff ff       	callq  ffffffff80100e70 <panic>
  if(p->kstack == 0)
ffffffff80103613:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
ffffffff80103617:	48 83 b8 f8 00 00 00 	cmpq   $0x0,0xf8(%rax)
ffffffff8010361e:	00 
ffffffff8010361f:	0f 85 0c 00 00 00    	jne    ffffffff80103631 <switchuvm+0x41>
    panic("switchuvm: no kstack");
ffffffff80103625:	48 c7 c7 80 fc 10 80 	mov    $0xffffffff8010fc80,%rdi
ffffffff8010362c:	e8 3f d8 ff ff       	callq  ffffffff80100e70 <panic>
  if(p->pml4 == 0)
ffffffff80103631:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
ffffffff80103635:	48 83 38 00          	cmpq   $0x0,(%rax)
ffffffff80103639:	0f 85 0c 00 00 00    	jne    ffffffff8010364b <switchuvm+0x5b>
    panic("switchuvm: no pml4");
ffffffff8010363f:	48 c7 c7 95 fc 10 80 	mov    $0xffffffff8010fc95,%rdi
ffffffff80103646:	e8 25 d8 ff ff       	callq  ffffffff80100e70 <panic>

  pushcli();
ffffffff8010364b:	e8 00 22 00 00       	callq  ffffffff80105850 <pushcli>
  mycpu()->ts.rsp0 = (uint64_t)p->kstack + KSTACKSIZE;
ffffffff80103650:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
ffffffff80103654:	48 8b 80 f8 00 00 00 	mov    0xf8(%rax),%rax
ffffffff8010365b:	48 05 00 10 00 00    	add    $0x1000,%rax
ffffffff80103661:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
ffffffff80103665:	e8 36 00 00 00       	callq  ffffffff801036a0 <mycpu>
ffffffff8010366a:	48 8b 4d f0          	mov    -0x10(%rbp),%rcx
ffffffff8010366e:	48 89 48 14          	mov    %rcx,0x14(%rax)
  lcr3(V2P(p->pml4));  // switch to process's address space
ffffffff80103672:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
ffffffff80103676:	48 8b 00             	mov    (%rax),%rax
ffffffff80103679:	48 2d 00 00 00 80    	sub    $0xffffffff80000000,%rax
ffffffff8010367f:	48 89 c7             	mov    %rax,%rdi
ffffffff80103682:	e8 49 ff ff ff       	callq  ffffffff801035d0 <lcr3>
  popcli();
ffffffff80103687:	e8 d4 23 00 00       	callq  ffffffff80105a60 <popcli>
}
ffffffff8010368c:	48 83 c4 10          	add    $0x10,%rsp
ffffffff80103690:	5d                   	pop    %rbp
ffffffff80103691:	c3                   	retq   
ffffffff80103692:	66 66 66 66 66 2e 0f 	data16 data16 data16 data16 nopw %cs:0x0(%rax,%rax,1)
ffffffff80103699:	1f 84 00 00 00 00 00 

ffffffff801036a0 <mycpu>:
{
ffffffff801036a0:	55                   	push   %rbp
ffffffff801036a1:	48 89 e5             	mov    %rsp,%rbp
  return &cpus[0];
ffffffff801036a4:	48 c7 c0 e0 7b 1f 83 	mov    $0xffffffff831f7be0,%rax
ffffffff801036ab:	5d                   	pop    %rbp
ffffffff801036ac:	c3                   	retq   
ffffffff801036ad:	0f 1f 00             	nopl   (%rax)

ffffffff801036b0 <inituvm>:

// Load the initcode into address 0 of pgdir.
// sz must be less than a page.
void
inituvm(pml4e_t *pml4, char *init, int sz, int pid)
{
ffffffff801036b0:	55                   	push   %rbp
ffffffff801036b1:	48 89 e5             	mov    %rsp,%rbp
ffffffff801036b4:	48 81 ec b0 00 00 00 	sub    $0xb0,%rsp
ffffffff801036bb:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
ffffffff801036bf:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
ffffffff801036c3:	89 55 ec             	mov    %edx,-0x14(%rbp)
ffffffff801036c6:	89 4d e8             	mov    %ecx,-0x18(%rbp)
  char *mem;
  uint64_t i;
  pte_t * pte;

  if(sz >= 10 * PGSIZE)
ffffffff801036c9:	81 7d ec 00 a0 00 00 	cmpl   $0xa000,-0x14(%rbp)
ffffffff801036d0:	0f 8c 0c 00 00 00    	jl     ffffffff801036e2 <inituvm+0x32>
    panic("inituvm: more than ten pages");
ffffffff801036d6:	48 c7 c7 a8 fc 10 80 	mov    $0xffffffff8010fca8,%rdi
ffffffff801036dd:	e8 8e d7 ff ff       	callq  ffffffff80100e70 <panic>

  i = 0;
ffffffff801036e2:	48 c7 45 d8 00 00 00 	movq   $0x0,-0x28(%rbp)
ffffffff801036e9:	00 
  while (sz > 0) {
ffffffff801036ea:	83 7d ec 00          	cmpl   $0x0,-0x14(%rbp)
ffffffff801036ee:	0f 8e 17 01 00 00    	jle    ffffffff8010380b <inituvm+0x15b>
    mem = kalloc();
ffffffff801036f4:	e8 87 d0 ff ff       	callq  ffffffff80100780 <kalloc>
ffffffff801036f9:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
    if (mem == 0)
ffffffff801036fd:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
ffffffff80103702:	0f 85 0c 00 00 00    	jne    ffffffff80103714 <inituvm+0x64>
      panic("inituvm: kalloc failure 1");
ffffffff80103708:	48 c7 c7 c5 fc 10 80 	mov    $0xffffffff8010fcc5,%rdi
ffffffff8010370f:	e8 5c d7 ff ff       	callq  ffffffff80100e70 <panic>
ffffffff80103714:	31 c0                	xor    %eax,%eax
ffffffff80103716:	b9 00 10 00 00       	mov    $0x1000,%ecx
    memset(mem, 0, PGSIZE);
ffffffff8010371b:	48 8b 7d e0          	mov    -0x20(%rbp),%rdi
ffffffff8010371f:	31 f6                	xor    %esi,%esi
ffffffff80103721:	ba 00 10 00 00       	mov    $0x1000,%edx
ffffffff80103726:	89 45 c0             	mov    %eax,-0x40(%rbp)
ffffffff80103729:	89 4d bc             	mov    %ecx,-0x44(%rbp)
ffffffff8010372c:	e8 cf 77 00 00       	callq  ffffffff8010af00 <memset>
ffffffff80103731:	b9 01 00 00 00       	mov    $0x1,%ecx
ffffffff80103736:	ba 06 00 00 00       	mov    $0x6,%edx

    if (mappages(pml4, i, 1, V2P(mem) >> PT_SHIFT, PTE_W|PTE_U, pid) < 0)
ffffffff8010373b:	48 8b 7d f8          	mov    -0x8(%rbp),%rdi
ffffffff8010373f:	48 8b 75 d8          	mov    -0x28(%rbp),%rsi
ffffffff80103743:	4c 8b 45 e0          	mov    -0x20(%rbp),%r8
ffffffff80103747:	49 81 e8 00 00 00 80 	sub    $0xffffffff80000000,%r8
ffffffff8010374e:	49 c1 e8 0c          	shr    $0xc,%r8
ffffffff80103752:	44 8b 4d e8          	mov    -0x18(%rbp),%r9d
ffffffff80103756:	41 ba 01 00 00 00    	mov    $0x1,%r10d
ffffffff8010375c:	41 bb 06 00 00 00    	mov    $0x6,%r11d
ffffffff80103762:	89 55 b8             	mov    %edx,-0x48(%rbp)
ffffffff80103765:	44 89 d2             	mov    %r10d,%edx
ffffffff80103768:	89 4d b4             	mov    %ecx,-0x4c(%rbp)
ffffffff8010376b:	4c 89 c1             	mov    %r8,%rcx
ffffffff8010376e:	45 89 d8             	mov    %r11d,%r8d
ffffffff80103771:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
ffffffff80103775:	e8 16 fb ff ff       	callq  ffffffff80103290 <mappages>
ffffffff8010377a:	83 f8 00             	cmp    $0x0,%eax
ffffffff8010377d:	0f 8d 0c 00 00 00    	jge    ffffffff8010378f <inituvm+0xdf>
      panic("inituvm :mappages failure 1");
ffffffff80103783:	48 c7 c7 df fc 10 80 	mov    $0xffffffff8010fcdf,%rdi
ffffffff8010378a:	e8 e1 d6 ff ff       	callq  ffffffff80100e70 <panic>
    memmove(mem, init + i * PGSIZE, min(sz, PGSIZE));
ffffffff8010378f:	48 8b 7d e0          	mov    -0x20(%rbp),%rdi
ffffffff80103793:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
ffffffff80103797:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
ffffffff8010379b:	48 c1 e1 0c          	shl    $0xc,%rcx
ffffffff8010379f:	48 01 c8             	add    %rcx,%rax
ffffffff801037a2:	8b 55 ec             	mov    -0x14(%rbp),%edx
ffffffff801037a5:	89 55 cc             	mov    %edx,-0x34(%rbp)
ffffffff801037a8:	c7 45 c8 00 10 00 00 	movl   $0x1000,-0x38(%rbp)
ffffffff801037af:	8b 55 cc             	mov    -0x34(%rbp),%edx
ffffffff801037b2:	3b 55 c8             	cmp    -0x38(%rbp),%edx
ffffffff801037b5:	48 89 7d a0          	mov    %rdi,-0x60(%rbp)
ffffffff801037b9:	48 89 45 98          	mov    %rax,-0x68(%rbp)
ffffffff801037bd:	0f 8f 0b 00 00 00    	jg     ffffffff801037ce <inituvm+0x11e>
ffffffff801037c3:	8b 45 cc             	mov    -0x34(%rbp),%eax
ffffffff801037c6:	89 45 94             	mov    %eax,-0x6c(%rbp)
ffffffff801037c9:	e9 06 00 00 00       	jmpq   ffffffff801037d4 <inituvm+0x124>
ffffffff801037ce:	8b 45 c8             	mov    -0x38(%rbp),%eax
ffffffff801037d1:	89 45 94             	mov    %eax,-0x6c(%rbp)
ffffffff801037d4:	8b 45 94             	mov    -0x6c(%rbp),%eax
ffffffff801037d7:	89 45 c4             	mov    %eax,-0x3c(%rbp)
ffffffff801037da:	8b 55 c4             	mov    -0x3c(%rbp),%edx
ffffffff801037dd:	48 8b 7d a0          	mov    -0x60(%rbp),%rdi
ffffffff801037e1:	48 8b 75 98          	mov    -0x68(%rbp),%rsi
ffffffff801037e5:	e8 a6 78 00 00       	callq  ffffffff8010b090 <memmove>

    i++;
ffffffff801037ea:	48 8b 75 d8          	mov    -0x28(%rbp),%rsi
ffffffff801037ee:	48 83 c6 01          	add    $0x1,%rsi
ffffffff801037f2:	48 89 75 d8          	mov    %rsi,-0x28(%rbp)
    sz -= PGSIZE;
ffffffff801037f6:	8b 55 ec             	mov    -0x14(%rbp),%edx
ffffffff801037f9:	81 ea 00 10 00 00    	sub    $0x1000,%edx
ffffffff801037ff:	89 55 ec             	mov    %edx,-0x14(%rbp)
  while (sz > 0) {
ffffffff80103802:	48 89 45 88          	mov    %rax,-0x78(%rbp)
ffffffff80103806:	e9 df fe ff ff       	jmpq   ffffffff801036ea <inituvm+0x3a>
  }

  // allocate the guard page
  mem = kalloc();
ffffffff8010380b:	e8 70 cf ff ff       	callq  ffffffff80100780 <kalloc>
ffffffff80103810:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  if (mem == 0)
ffffffff80103814:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
ffffffff80103819:	0f 85 0c 00 00 00    	jne    ffffffff8010382b <inituvm+0x17b>
    panic("inituvm: kalloc failure 2");
ffffffff8010381f:	48 c7 c7 fb fc 10 80 	mov    $0xffffffff8010fcfb,%rdi
ffffffff80103826:	e8 45 d6 ff ff       	callq  ffffffff80100e70 <panic>
ffffffff8010382b:	31 c0                	xor    %eax,%eax
ffffffff8010382d:	b9 00 10 00 00       	mov    $0x1000,%ecx
  memset(mem, 0, PGSIZE);
ffffffff80103832:	48 8b 7d e0          	mov    -0x20(%rbp),%rdi
ffffffff80103836:	31 f6                	xor    %esi,%esi
ffffffff80103838:	ba 00 10 00 00       	mov    $0x1000,%edx
ffffffff8010383d:	89 45 84             	mov    %eax,-0x7c(%rbp)
ffffffff80103840:	89 4d 80             	mov    %ecx,-0x80(%rbp)
ffffffff80103843:	e8 b8 76 00 00       	callq  ffffffff8010af00 <memset>
ffffffff80103848:	b9 01 00 00 00       	mov    $0x1,%ecx
ffffffff8010384d:	ba 06 00 00 00       	mov    $0x6,%edx
  if (mappages(pml4, i, 1, V2P(mem) >> PT_SHIFT, PTE_W|PTE_U, pid) < 0)
ffffffff80103852:	48 8b 7d f8          	mov    -0x8(%rbp),%rdi
ffffffff80103856:	48 8b 75 d8          	mov    -0x28(%rbp),%rsi
ffffffff8010385a:	4c 8b 45 e0          	mov    -0x20(%rbp),%r8
ffffffff8010385e:	49 81 e8 00 00 00 80 	sub    $0xffffffff80000000,%r8
ffffffff80103865:	49 c1 e8 0c          	shr    $0xc,%r8
ffffffff80103869:	44 8b 4d e8          	mov    -0x18(%rbp),%r9d
ffffffff8010386d:	41 ba 01 00 00 00    	mov    $0x1,%r10d
ffffffff80103873:	41 bb 06 00 00 00    	mov    $0x6,%r11d
ffffffff80103879:	89 95 7c ff ff ff    	mov    %edx,-0x84(%rbp)
ffffffff8010387f:	44 89 d2             	mov    %r10d,%edx
ffffffff80103882:	89 8d 78 ff ff ff    	mov    %ecx,-0x88(%rbp)
ffffffff80103888:	4c 89 c1             	mov    %r8,%rcx
ffffffff8010388b:	45 89 d8             	mov    %r11d,%r8d
ffffffff8010388e:	48 89 85 70 ff ff ff 	mov    %rax,-0x90(%rbp)
ffffffff80103895:	e8 f6 f9 ff ff       	callq  ffffffff80103290 <mappages>
ffffffff8010389a:	83 f8 00             	cmp    $0x0,%eax
ffffffff8010389d:	0f 8d 0c 00 00 00    	jge    ffffffff801038af <inituvm+0x1ff>
    panic("inituvm :mappages failure 2");
ffffffff801038a3:	48 c7 c7 15 fd 10 80 	mov    $0xffffffff8010fd15,%rdi
ffffffff801038aa:	e8 c1 d5 ff ff       	callq  ffffffff80100e70 <panic>
ffffffff801038af:	31 c0                	xor    %eax,%eax
  pte = walkpml4(pml4, (void*) (uint64_t)(i * PGSIZE), 0);
ffffffff801038b1:	48 8b 7d f8          	mov    -0x8(%rbp),%rdi
ffffffff801038b5:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
ffffffff801038b9:	48 c1 e1 0c          	shl    $0xc,%rcx
ffffffff801038bd:	31 d2                	xor    %edx,%edx
ffffffff801038bf:	48 89 ce             	mov    %rcx,%rsi
ffffffff801038c2:	89 85 6c ff ff ff    	mov    %eax,-0x94(%rbp)
ffffffff801038c8:	e8 a3 f3 ff ff       	callq  ffffffff80102c70 <walkpml4>
ffffffff801038cd:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
  *pte &= ~PTE_P;
ffffffff801038d1:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
ffffffff801038d5:	48 8b 08             	mov    (%rax),%rcx
ffffffff801038d8:	48 83 e1 fe          	and    $0xfffffffffffffffe,%rcx
ffffffff801038dc:	48 89 08             	mov    %rcx,(%rax)
  i ++;
ffffffff801038df:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
ffffffff801038e3:	48 83 c0 01          	add    $0x1,%rax
ffffffff801038e7:	48 89 45 d8          	mov    %rax,-0x28(%rbp)

  // allocate ustack
  mem = kalloc();
ffffffff801038eb:	e8 90 ce ff ff       	callq  ffffffff80100780 <kalloc>
ffffffff801038f0:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  if (mem == 0)
ffffffff801038f4:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
ffffffff801038f9:	0f 85 0c 00 00 00    	jne    ffffffff8010390b <inituvm+0x25b>
    panic("inituvm: kalloc failure 3");
ffffffff801038ff:	48 c7 c7 31 fd 10 80 	mov    $0xffffffff8010fd31,%rdi
ffffffff80103906:	e8 65 d5 ff ff       	callq  ffffffff80100e70 <panic>
ffffffff8010390b:	31 c0                	xor    %eax,%eax
ffffffff8010390d:	b9 00 10 00 00       	mov    $0x1000,%ecx
  memset(mem, 0, PGSIZE);
ffffffff80103912:	48 8b 7d e0          	mov    -0x20(%rbp),%rdi
ffffffff80103916:	31 f6                	xor    %esi,%esi
ffffffff80103918:	ba 00 10 00 00       	mov    $0x1000,%edx
ffffffff8010391d:	89 85 68 ff ff ff    	mov    %eax,-0x98(%rbp)
ffffffff80103923:	89 8d 64 ff ff ff    	mov    %ecx,-0x9c(%rbp)
ffffffff80103929:	e8 d2 75 00 00       	callq  ffffffff8010af00 <memset>
ffffffff8010392e:	b9 01 00 00 00       	mov    $0x1,%ecx
ffffffff80103933:	ba 06 00 00 00       	mov    $0x6,%edx
  if (mappages(pml4, i, 1, V2P(mem) >> PT_SHIFT, PTE_W|PTE_U, pid) < 0)
ffffffff80103938:	48 8b 7d f8          	mov    -0x8(%rbp),%rdi
ffffffff8010393c:	48 8b 75 d8          	mov    -0x28(%rbp),%rsi
ffffffff80103940:	4c 8b 45 e0          	mov    -0x20(%rbp),%r8
ffffffff80103944:	49 81 e8 00 00 00 80 	sub    $0xffffffff80000000,%r8
ffffffff8010394b:	49 c1 e8 0c          	shr    $0xc,%r8
ffffffff8010394f:	44 8b 4d e8          	mov    -0x18(%rbp),%r9d
ffffffff80103953:	41 ba 01 00 00 00    	mov    $0x1,%r10d
ffffffff80103959:	41 bb 06 00 00 00    	mov    $0x6,%r11d
ffffffff8010395f:	89 95 60 ff ff ff    	mov    %edx,-0xa0(%rbp)
ffffffff80103965:	44 89 d2             	mov    %r10d,%edx
ffffffff80103968:	89 8d 5c ff ff ff    	mov    %ecx,-0xa4(%rbp)
ffffffff8010396e:	4c 89 c1             	mov    %r8,%rcx
ffffffff80103971:	45 89 d8             	mov    %r11d,%r8d
ffffffff80103974:	48 89 85 50 ff ff ff 	mov    %rax,-0xb0(%rbp)
ffffffff8010397b:	e8 10 f9 ff ff       	callq  ffffffff80103290 <mappages>
ffffffff80103980:	83 f8 00             	cmp    $0x0,%eax
ffffffff80103983:	0f 8d 0c 00 00 00    	jge    ffffffff80103995 <inituvm+0x2e5>
    panic("inituvm :mappages failure 3");
ffffffff80103989:	48 c7 c7 4b fd 10 80 	mov    $0xffffffff8010fd4b,%rdi
ffffffff80103990:	e8 db d4 ff ff       	callq  ffffffff80100e70 <panic>
}
ffffffff80103995:	48 81 c4 b0 00 00 00 	add    $0xb0,%rsp
ffffffff8010399c:	5d                   	pop    %rbp
ffffffff8010399d:	c3                   	retq   
ffffffff8010399e:	66 90                	xchg   %ax,%ax

ffffffff801039a0 <loaduvm>:

// Load a program segment into pgdir.  addr must be page-aligned
// and the pages from addr to addr+sz must already be mapped.
int
loaduvm(pml4e_t *pml4, char *addr, struct inode *ip, uint offset, uint sz)
{
ffffffff801039a0:	55                   	push   %rbp
ffffffff801039a1:	48 89 e5             	mov    %rsp,%rbp
ffffffff801039a4:	48 81 ec a0 00 00 00 	sub    $0xa0,%rsp
ffffffff801039ab:	48 89 7d f0          	mov    %rdi,-0x10(%rbp)
ffffffff801039af:	48 89 75 e8          	mov    %rsi,-0x18(%rbp)
ffffffff801039b3:	48 89 55 e0          	mov    %rdx,-0x20(%rbp)
ffffffff801039b7:	89 4d dc             	mov    %ecx,-0x24(%rbp)
ffffffff801039ba:	44 89 45 d8          	mov    %r8d,-0x28(%rbp)
  uint64_t i, pa, n;
  pte_t *pte;

  if((uint64_t) addr % PGSIZE != 0)
ffffffff801039be:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
ffffffff801039c2:	48 81 e2 ff 0f 00 00 	and    $0xfff,%rdx
ffffffff801039c9:	48 83 fa 00          	cmp    $0x0,%rdx
ffffffff801039cd:	0f 84 0c 00 00 00    	je     ffffffff801039df <loaduvm+0x3f>
    panic("loaduvm: addr must be page aligned");
ffffffff801039d3:	48 c7 c7 67 fd 10 80 	mov    $0xffffffff8010fd67,%rdi
ffffffff801039da:	e8 91 d4 ff ff       	callq  ffffffff80100e70 <panic>
  for(i = 0; i < sz; i += PGSIZE){
ffffffff801039df:	48 c7 45 d0 00 00 00 	movq   $0x0,-0x30(%rbp)
ffffffff801039e6:	00 
ffffffff801039e7:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
ffffffff801039eb:	8b 4d d8             	mov    -0x28(%rbp),%ecx
ffffffff801039ee:	89 ca                	mov    %ecx,%edx
ffffffff801039f0:	48 39 d0             	cmp    %rdx,%rax
ffffffff801039f3:	0f 83 be 01 00 00    	jae    ffffffff80103bb7 <loaduvm+0x217>
ffffffff801039f9:	31 c0                	xor    %eax,%eax
    if((pte = walkpml4(pml4, addr+i, 0)) == 0)
ffffffff801039fb:	48 8b 7d f0          	mov    -0x10(%rbp),%rdi
ffffffff801039ff:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
ffffffff80103a03:	48 03 4d d0          	add    -0x30(%rbp),%rcx
ffffffff80103a07:	31 d2                	xor    %edx,%edx
ffffffff80103a09:	48 89 ce             	mov    %rcx,%rsi
ffffffff80103a0c:	89 45 90             	mov    %eax,-0x70(%rbp)
ffffffff80103a0f:	e8 5c f2 ff ff       	callq  ffffffff80102c70 <walkpml4>
ffffffff80103a14:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
ffffffff80103a18:	48 83 f8 00          	cmp    $0x0,%rax
ffffffff80103a1c:	0f 85 0c 00 00 00    	jne    ffffffff80103a2e <loaduvm+0x8e>
      panic("loaduvm: address should exist");
ffffffff80103a22:	48 c7 c7 8a fd 10 80 	mov    $0xffffffff8010fd8a,%rdi
ffffffff80103a29:	e8 42 d4 ff ff       	callq  ffffffff80100e70 <panic>
    pa = PTE_ADDR(*pte);
ffffffff80103a2e:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
ffffffff80103a32:	48 8b 00             	mov    (%rax),%rax
ffffffff80103a35:	c7 45 b4 33 00 00 00 	movl   $0x33,-0x4c(%rbp)
ffffffff80103a3c:	c7 45 b0 0c 00 00 00 	movl   $0xc,-0x50(%rbp)
ffffffff80103a43:	8b 4d b4             	mov    -0x4c(%rbp),%ecx
ffffffff80103a46:	3b 4d b0             	cmp    -0x50(%rbp),%ecx
ffffffff80103a49:	48 89 45 88          	mov    %rax,-0x78(%rbp)
ffffffff80103a4d:	0f 8c 0b 00 00 00    	jl     ffffffff80103a5e <loaduvm+0xbe>
ffffffff80103a53:	8b 45 b4             	mov    -0x4c(%rbp),%eax
ffffffff80103a56:	89 45 84             	mov    %eax,-0x7c(%rbp)
ffffffff80103a59:	e9 06 00 00 00       	jmpq   ffffffff80103a64 <loaduvm+0xc4>
ffffffff80103a5e:	8b 45 b0             	mov    -0x50(%rbp),%eax
ffffffff80103a61:	89 45 84             	mov    %eax,-0x7c(%rbp)
ffffffff80103a64:	8b 45 84             	mov    -0x7c(%rbp),%eax
ffffffff80103a67:	89 45 ac             	mov    %eax,-0x54(%rbp)
ffffffff80103a6a:	8b 45 ac             	mov    -0x54(%rbp),%eax
ffffffff80103a6d:	c7 45 a8 33 00 00 00 	movl   $0x33,-0x58(%rbp)
ffffffff80103a74:	c7 45 a4 0c 00 00 00 	movl   $0xc,-0x5c(%rbp)
ffffffff80103a7b:	8b 4d a8             	mov    -0x58(%rbp),%ecx
ffffffff80103a7e:	3b 4d a4             	cmp    -0x5c(%rbp),%ecx
ffffffff80103a81:	89 45 80             	mov    %eax,-0x80(%rbp)
ffffffff80103a84:	0f 8f 0e 00 00 00    	jg     ffffffff80103a98 <loaduvm+0xf8>
ffffffff80103a8a:	8b 45 a8             	mov    -0x58(%rbp),%eax
ffffffff80103a8d:	89 85 7c ff ff ff    	mov    %eax,-0x84(%rbp)
ffffffff80103a93:	e9 09 00 00 00       	jmpq   ffffffff80103aa1 <loaduvm+0x101>
ffffffff80103a98:	8b 45 a4             	mov    -0x5c(%rbp),%eax
ffffffff80103a9b:	89 85 7c ff ff ff    	mov    %eax,-0x84(%rbp)
ffffffff80103aa1:	8b 85 7c ff ff ff    	mov    -0x84(%rbp),%eax
ffffffff80103aa7:	b9 01 00 00 00       	mov    $0x1,%ecx
ffffffff80103aac:	89 ca                	mov    %ecx,%edx
ffffffff80103aae:	89 45 a0             	mov    %eax,-0x60(%rbp)
ffffffff80103ab1:	8b 45 80             	mov    -0x80(%rbp),%eax
ffffffff80103ab4:	2b 45 a0             	sub    -0x60(%rbp),%eax
ffffffff80103ab7:	89 c0                	mov    %eax,%eax
ffffffff80103ab9:	89 c1                	mov    %eax,%ecx
ffffffff80103abb:	48 d3 e2             	shl    %cl,%rdx
ffffffff80103abe:	48 c1 e2 01          	shl    $0x1,%rdx
ffffffff80103ac2:	48 83 ea 01          	sub    $0x1,%rdx
ffffffff80103ac6:	c7 45 9c 33 00 00 00 	movl   $0x33,-0x64(%rbp)
ffffffff80103acd:	c7 45 98 0c 00 00 00 	movl   $0xc,-0x68(%rbp)
ffffffff80103ad4:	8b 45 9c             	mov    -0x64(%rbp),%eax
ffffffff80103ad7:	3b 45 98             	cmp    -0x68(%rbp),%eax
ffffffff80103ada:	48 89 95 70 ff ff ff 	mov    %rdx,-0x90(%rbp)
ffffffff80103ae1:	0f 8f 0e 00 00 00    	jg     ffffffff80103af5 <loaduvm+0x155>
ffffffff80103ae7:	8b 45 9c             	mov    -0x64(%rbp),%eax
ffffffff80103aea:	89 85 6c ff ff ff    	mov    %eax,-0x94(%rbp)
ffffffff80103af0:	e9 09 00 00 00       	jmpq   ffffffff80103afe <loaduvm+0x15e>
ffffffff80103af5:	8b 45 98             	mov    -0x68(%rbp),%eax
ffffffff80103af8:	89 85 6c ff ff ff    	mov    %eax,-0x94(%rbp)
ffffffff80103afe:	8b 85 6c ff ff ff    	mov    -0x94(%rbp),%eax
ffffffff80103b04:	89 45 94             	mov    %eax,-0x6c(%rbp)
ffffffff80103b07:	8b 45 94             	mov    -0x6c(%rbp),%eax
ffffffff80103b0a:	89 c1                	mov    %eax,%ecx
ffffffff80103b0c:	48 8b 95 70 ff ff ff 	mov    -0x90(%rbp),%rdx
ffffffff80103b13:	48 d3 e2             	shl    %cl,%rdx
ffffffff80103b16:	48 8b 75 88          	mov    -0x78(%rbp),%rsi
ffffffff80103b1a:	48 21 d6             	and    %rdx,%rsi
ffffffff80103b1d:	48 89 75 c8          	mov    %rsi,-0x38(%rbp)
    if(sz - i < PGSIZE)
ffffffff80103b21:	8b 45 d8             	mov    -0x28(%rbp),%eax
ffffffff80103b24:	89 c2                	mov    %eax,%edx
ffffffff80103b26:	48 2b 55 d0          	sub    -0x30(%rbp),%rdx
ffffffff80103b2a:	48 81 fa 00 10 00 00 	cmp    $0x1000,%rdx
ffffffff80103b31:	0f 83 12 00 00 00    	jae    ffffffff80103b49 <loaduvm+0x1a9>
      n = sz - i;
ffffffff80103b37:	8b 45 d8             	mov    -0x28(%rbp),%eax
ffffffff80103b3a:	89 c1                	mov    %eax,%ecx
ffffffff80103b3c:	48 2b 4d d0          	sub    -0x30(%rbp),%rcx
ffffffff80103b40:	48 89 4d c0          	mov    %rcx,-0x40(%rbp)
ffffffff80103b44:	e9 08 00 00 00       	jmpq   ffffffff80103b51 <loaduvm+0x1b1>
    else
      n = PGSIZE;
ffffffff80103b49:	48 c7 45 c0 00 10 00 	movq   $0x1000,-0x40(%rbp)
ffffffff80103b50:	00 
    if(readi(ip, P2V(pa), offset+i, n) != n)
ffffffff80103b51:	48 8b 7d e0          	mov    -0x20(%rbp),%rdi
ffffffff80103b55:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
ffffffff80103b59:	48 05 00 00 00 80    	add    $0xffffffff80000000,%rax
ffffffff80103b5f:	8b 4d dc             	mov    -0x24(%rbp),%ecx
ffffffff80103b62:	89 ca                	mov    %ecx,%edx
ffffffff80103b64:	48 03 55 d0          	add    -0x30(%rbp),%rdx
ffffffff80103b68:	89 d1                	mov    %edx,%ecx
ffffffff80103b6a:	48 8b 55 c0          	mov    -0x40(%rbp),%rdx
ffffffff80103b6e:	89 d6                	mov    %edx,%esi
ffffffff80103b70:	89 b5 68 ff ff ff    	mov    %esi,-0x98(%rbp)
ffffffff80103b76:	48 89 c6             	mov    %rax,%rsi
ffffffff80103b79:	89 ca                	mov    %ecx,%edx
ffffffff80103b7b:	8b 8d 68 ff ff ff    	mov    -0x98(%rbp),%ecx
ffffffff80103b81:	e8 4a 81 00 00       	callq  ffffffff8010bcd0 <readi>
ffffffff80103b86:	48 63 f0             	movslq %eax,%rsi
ffffffff80103b89:	48 3b 75 c0          	cmp    -0x40(%rbp),%rsi
ffffffff80103b8d:	0f 84 0c 00 00 00    	je     ffffffff80103b9f <loaduvm+0x1ff>
      return -1;
ffffffff80103b93:	c7 45 fc ff ff ff ff 	movl   $0xffffffff,-0x4(%rbp)
ffffffff80103b9a:	e9 1f 00 00 00       	jmpq   ffffffff80103bbe <loaduvm+0x21e>
  }
ffffffff80103b9f:	e9 00 00 00 00       	jmpq   ffffffff80103ba4 <loaduvm+0x204>
  for(i = 0; i < sz; i += PGSIZE){
ffffffff80103ba4:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
ffffffff80103ba8:	48 05 00 10 00 00    	add    $0x1000,%rax
ffffffff80103bae:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
ffffffff80103bb2:	e9 30 fe ff ff       	jmpq   ffffffff801039e7 <loaduvm+0x47>
  return 0;
ffffffff80103bb7:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
}
ffffffff80103bbe:	8b 45 fc             	mov    -0x4(%rbp),%eax
ffffffff80103bc1:	48 81 c4 a0 00 00 00 	add    $0xa0,%rsp
ffffffff80103bc8:	5d                   	pop    %rbp
ffffffff80103bc9:	c3                   	retq   
ffffffff80103bca:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)

ffffffff80103bd0 <initustack>:

// Remove guard page
void
initustack(pml4e_t *pml4, struct mem_region *ustack_region, int pid)
{
ffffffff80103bd0:	55                   	push   %rbp
ffffffff80103bd1:	48 89 e5             	mov    %rsp,%rbp
ffffffff80103bd4:	48 83 ec 50          	sub    $0x50,%rsp
ffffffff80103bd8:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
ffffffff80103bdc:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
ffffffff80103be0:	89 55 ec             	mov    %edx,-0x14(%rbp)
  char* mem_ustack; // *mem_guard
  // uint64_t guard = SZ_2G - 2 * PGSIZE;
  uint64_t ustack = SZ_2G - PGSIZE;
ffffffff80103be3:	48 c7 45 d8 00 f0 ff 	movq   $0x7ffff000,-0x28(%rbp)
ffffffff80103bea:	7f 
  //memset(mem_guard, 0, PGSIZE);
  //if(mappages(pml4, guard >> PT_SHIFT, 1, V2P(mem_guard) >> PT_SHIFT, PTE_W, pid) < 0){
  //  panic("initustack out of memory (2)\n");
  //}

  mem_ustack = kalloc();
ffffffff80103beb:	e8 90 cb ff ff       	callq  ffffffff80100780 <kalloc>
ffffffff80103bf0:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  if(mem_ustack == 0){
ffffffff80103bf4:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
ffffffff80103bf9:	0f 85 0c 00 00 00    	jne    ffffffff80103c0b <initustack+0x3b>
    panic("initustack out of memory (3)\n");
ffffffff80103bff:	48 c7 c7 a8 fd 10 80 	mov    $0xffffffff8010fda8,%rdi
ffffffff80103c06:	e8 65 d2 ff ff       	callq  ffffffff80100e70 <panic>
ffffffff80103c0b:	31 c0                	xor    %eax,%eax
ffffffff80103c0d:	b9 00 10 00 00       	mov    $0x1000,%ecx
  }
  memset(mem_ustack, 0, PGSIZE);
ffffffff80103c12:	48 8b 7d e0          	mov    -0x20(%rbp),%rdi
ffffffff80103c16:	31 f6                	xor    %esi,%esi
ffffffff80103c18:	ba 00 10 00 00       	mov    $0x1000,%edx
ffffffff80103c1d:	89 45 d4             	mov    %eax,-0x2c(%rbp)
ffffffff80103c20:	89 4d d0             	mov    %ecx,-0x30(%rbp)
ffffffff80103c23:	e8 d8 72 00 00       	callq  ffffffff8010af00 <memset>
ffffffff80103c28:	b9 01 00 00 00       	mov    $0x1,%ecx
ffffffff80103c2d:	ba 06 00 00 00       	mov    $0x6,%edx
  if(mappages(pml4, ustack >> PT_SHIFT, 1, V2P(mem_ustack) >> PT_SHIFT, PTE_W | PTE_U, pid) < 0){
ffffffff80103c32:	48 8b 7d f8          	mov    -0x8(%rbp),%rdi
ffffffff80103c36:	4c 8b 45 d8          	mov    -0x28(%rbp),%r8
ffffffff80103c3a:	49 c1 e8 0c          	shr    $0xc,%r8
ffffffff80103c3e:	4c 8b 4d e0          	mov    -0x20(%rbp),%r9
ffffffff80103c42:	49 81 e9 00 00 00 80 	sub    $0xffffffff80000000,%r9
ffffffff80103c49:	49 c1 e9 0c          	shr    $0xc,%r9
ffffffff80103c4d:	8b 75 ec             	mov    -0x14(%rbp),%esi
ffffffff80103c50:	41 ba 01 00 00 00    	mov    $0x1,%r10d
ffffffff80103c56:	41 bb 06 00 00 00    	mov    $0x6,%r11d
ffffffff80103c5c:	89 75 cc             	mov    %esi,-0x34(%rbp)
ffffffff80103c5f:	4c 89 c6             	mov    %r8,%rsi
ffffffff80103c62:	89 55 c8             	mov    %edx,-0x38(%rbp)
ffffffff80103c65:	44 89 d2             	mov    %r10d,%edx
ffffffff80103c68:	89 4d c4             	mov    %ecx,-0x3c(%rbp)
ffffffff80103c6b:	4c 89 c9             	mov    %r9,%rcx
ffffffff80103c6e:	45 89 d8             	mov    %r11d,%r8d
ffffffff80103c71:	44 8b 4d cc          	mov    -0x34(%rbp),%r9d
ffffffff80103c75:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
ffffffff80103c79:	e8 12 f6 ff ff       	callq  ffffffff80103290 <mappages>
ffffffff80103c7e:	83 f8 00             	cmp    $0x0,%eax
ffffffff80103c81:	0f 8d 0c 00 00 00    	jge    ffffffff80103c93 <initustack+0xc3>
    panic("initustack out of memory (4)\n");
ffffffff80103c87:	48 c7 c7 c6 fd 10 80 	mov    $0xffffffff8010fdc6,%rdi
ffffffff80103c8e:	e8 dd d1 ff ff       	callq  ffffffff80100e70 <panic>
  }

  ustack_region->start = (char*)ustack;
ffffffff80103c93:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
ffffffff80103c97:	48 8b 4d f0          	mov    -0x10(%rbp),%rcx
ffffffff80103c9b:	48 89 01             	mov    %rax,(%rcx)
  ustack_region->size = PGSIZE;
ffffffff80103c9e:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
ffffffff80103ca2:	48 c7 40 08 00 10 00 	movq   $0x1000,0x8(%rax)
ffffffff80103ca9:	00 
}
ffffffff80103caa:	48 83 c4 50          	add    $0x50,%rsp
ffffffff80103cae:	5d                   	pop    %rbp
ffffffff80103caf:	c3                   	retq   

ffffffff80103cb0 <allocuvm>:

// Allocate page tables and physical memory to grow process from oldsz to
// newsz, which need not be page aligned.  Returns new size or -1 on error.
int
allocuvm(pml4e_t *pml4, char* start, uint64_t oldsz, uint64_t newsz, int pid)
{
ffffffff80103cb0:	55                   	push   %rbp
ffffffff80103cb1:	48 89 e5             	mov    %rsp,%rbp
ffffffff80103cb4:	48 83 ec 70          	sub    $0x70,%rsp
ffffffff80103cb8:	48 89 7d f0          	mov    %rdi,-0x10(%rbp)
ffffffff80103cbc:	48 89 75 e8          	mov    %rsi,-0x18(%rbp)
ffffffff80103cc0:	48 89 55 e0          	mov    %rdx,-0x20(%rbp)
ffffffff80103cc4:	48 89 4d d8          	mov    %rcx,-0x28(%rbp)
ffffffff80103cc8:	44 89 45 d4          	mov    %r8d,-0x2c(%rbp)
  char *mem;
  uint64_t a;

  if(newsz >= KERNBASE)
ffffffff80103ccc:	48 81 7d d8 00 00 00 	cmpq   $0xffffffff80000000,-0x28(%rbp)
ffffffff80103cd3:	80 
ffffffff80103cd4:	0f 82 0c 00 00 00    	jb     ffffffff80103ce6 <allocuvm+0x36>
    return -1;
ffffffff80103cda:	c7 45 fc ff ff ff ff 	movl   $0xffffffff,-0x4(%rbp)
ffffffff80103ce1:	e9 7b 01 00 00       	jmpq   ffffffff80103e61 <allocuvm+0x1b1>
  if(newsz < oldsz)
ffffffff80103ce6:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
ffffffff80103cea:	48 3b 45 e0          	cmp    -0x20(%rbp),%rax
ffffffff80103cee:	0f 83 0e 00 00 00    	jae    ffffffff80103d02 <allocuvm+0x52>
    return oldsz;
ffffffff80103cf4:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
ffffffff80103cf8:	89 c1                	mov    %eax,%ecx
ffffffff80103cfa:	89 4d fc             	mov    %ecx,-0x4(%rbp)
ffffffff80103cfd:	e9 5f 01 00 00       	jmpq   ffffffff80103e61 <allocuvm+0x1b1>

  a = PGROUNDUP((uint64_t)start + oldsz);
ffffffff80103d02:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
ffffffff80103d06:	48 03 45 e0          	add    -0x20(%rbp),%rax
ffffffff80103d0a:	48 05 00 10 00 00    	add    $0x1000,%rax
ffffffff80103d10:	48 83 e8 01          	sub    $0x1,%rax
ffffffff80103d14:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
ffffffff80103d1a:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
  for(; a < (uint64_t)start + newsz; a += PGSIZE){
ffffffff80103d1e:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
ffffffff80103d22:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
ffffffff80103d26:	48 03 4d d8          	add    -0x28(%rbp),%rcx
ffffffff80103d2a:	48 39 c8             	cmp    %rcx,%rax
ffffffff80103d2d:	0f 83 25 01 00 00    	jae    ffffffff80103e58 <allocuvm+0x1a8>
    mem = kalloc();
ffffffff80103d33:	e8 48 ca ff ff       	callq  ffffffff80100780 <kalloc>
ffffffff80103d38:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
    if(mem == 0){
ffffffff80103d3c:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
ffffffff80103d41:	0f 85 3a 00 00 00    	jne    ffffffff80103d81 <allocuvm+0xd1>
      cprintf("allocuvm out of memory\n");
ffffffff80103d47:	48 c7 c7 e4 fd 10 80 	mov    $0xffffffff8010fde4,%rdi
ffffffff80103d4e:	31 c0                	xor    %eax,%eax
ffffffff80103d50:	88 c1                	mov    %al,%cl
ffffffff80103d52:	88 c8                	mov    %cl,%al
ffffffff80103d54:	e8 07 cc ff ff       	callq  ffffffff80100960 <cprintf>
      deallocuvm(pml4, start, newsz, oldsz, pid);
ffffffff80103d59:	48 8b 7d f0          	mov    -0x10(%rbp),%rdi
ffffffff80103d5d:	48 8b 75 e8          	mov    -0x18(%rbp),%rsi
ffffffff80103d61:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
ffffffff80103d65:	48 8b 4d e0          	mov    -0x20(%rbp),%rcx
ffffffff80103d69:	44 8b 45 d4          	mov    -0x2c(%rbp),%r8d
ffffffff80103d6d:	e8 fe 00 00 00       	callq  ffffffff80103e70 <deallocuvm>
      return -1;
ffffffff80103d72:	c7 45 fc ff ff ff ff 	movl   $0xffffffff,-0x4(%rbp)
ffffffff80103d79:	89 45 bc             	mov    %eax,-0x44(%rbp)
ffffffff80103d7c:	e9 e0 00 00 00       	jmpq   ffffffff80103e61 <allocuvm+0x1b1>
ffffffff80103d81:	31 c0                	xor    %eax,%eax
ffffffff80103d83:	b9 00 10 00 00       	mov    $0x1000,%ecx
    }
    memset(mem, 0, PGSIZE);
ffffffff80103d88:	48 8b 7d c8          	mov    -0x38(%rbp),%rdi
ffffffff80103d8c:	31 f6                	xor    %esi,%esi
ffffffff80103d8e:	ba 00 10 00 00       	mov    $0x1000,%edx
ffffffff80103d93:	89 45 b8             	mov    %eax,-0x48(%rbp)
ffffffff80103d96:	89 4d b4             	mov    %ecx,-0x4c(%rbp)
ffffffff80103d99:	e8 62 71 00 00       	callq  ffffffff8010af00 <memset>
ffffffff80103d9e:	b9 01 00 00 00       	mov    $0x1,%ecx
ffffffff80103da3:	ba 06 00 00 00       	mov    $0x6,%edx
    if(mappages(pml4, a >> PT_SHIFT, 1, V2P(mem) >> PT_SHIFT, PTE_W|PTE_U, pid) < 0){
ffffffff80103da8:	48 8b 7d f0          	mov    -0x10(%rbp),%rdi
ffffffff80103dac:	4c 8b 45 c0          	mov    -0x40(%rbp),%r8
ffffffff80103db0:	49 c1 e8 0c          	shr    $0xc,%r8
ffffffff80103db4:	4c 8b 4d c8          	mov    -0x38(%rbp),%r9
ffffffff80103db8:	49 81 e9 00 00 00 80 	sub    $0xffffffff80000000,%r9
ffffffff80103dbf:	49 c1 e9 0c          	shr    $0xc,%r9
ffffffff80103dc3:	8b 75 d4             	mov    -0x2c(%rbp),%esi
ffffffff80103dc6:	41 ba 01 00 00 00    	mov    $0x1,%r10d
ffffffff80103dcc:	41 bb 06 00 00 00    	mov    $0x6,%r11d
ffffffff80103dd2:	89 75 b0             	mov    %esi,-0x50(%rbp)
ffffffff80103dd5:	4c 89 c6             	mov    %r8,%rsi
ffffffff80103dd8:	89 55 ac             	mov    %edx,-0x54(%rbp)
ffffffff80103ddb:	44 89 d2             	mov    %r10d,%edx
ffffffff80103dde:	89 4d a8             	mov    %ecx,-0x58(%rbp)
ffffffff80103de1:	4c 89 c9             	mov    %r9,%rcx
ffffffff80103de4:	45 89 d8             	mov    %r11d,%r8d
ffffffff80103de7:	44 8b 4d b0          	mov    -0x50(%rbp),%r9d
ffffffff80103deb:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
ffffffff80103def:	e8 9c f4 ff ff       	callq  ffffffff80103290 <mappages>
ffffffff80103df4:	83 f8 00             	cmp    $0x0,%eax
ffffffff80103df7:	0f 8d 43 00 00 00    	jge    ffffffff80103e40 <allocuvm+0x190>
      cprintf("allocuvm out of memory (2)\n");
ffffffff80103dfd:	48 c7 c7 fc fd 10 80 	mov    $0xffffffff8010fdfc,%rdi
ffffffff80103e04:	31 c0                	xor    %eax,%eax
ffffffff80103e06:	88 c1                	mov    %al,%cl
ffffffff80103e08:	88 c8                	mov    %cl,%al
ffffffff80103e0a:	e8 51 cb ff ff       	callq  ffffffff80100960 <cprintf>
      deallocuvm(pml4, start, newsz, oldsz, pid);
ffffffff80103e0f:	48 8b 7d f0          	mov    -0x10(%rbp),%rdi
ffffffff80103e13:	48 8b 75 e8          	mov    -0x18(%rbp),%rsi
ffffffff80103e17:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
ffffffff80103e1b:	48 8b 4d e0          	mov    -0x20(%rbp),%rcx
ffffffff80103e1f:	44 8b 45 d4          	mov    -0x2c(%rbp),%r8d
ffffffff80103e23:	e8 48 00 00 00       	callq  ffffffff80103e70 <deallocuvm>
      kfree(mem);
ffffffff80103e28:	48 8b 7d c8          	mov    -0x38(%rbp),%rdi
ffffffff80103e2c:	89 45 9c             	mov    %eax,-0x64(%rbp)
ffffffff80103e2f:	e8 3c c7 ff ff       	callq  ffffffff80100570 <kfree>
      return -1;
ffffffff80103e34:	c7 45 fc ff ff ff ff 	movl   $0xffffffff,-0x4(%rbp)
ffffffff80103e3b:	e9 21 00 00 00       	jmpq   ffffffff80103e61 <allocuvm+0x1b1>
    }
  }
ffffffff80103e40:	e9 00 00 00 00       	jmpq   ffffffff80103e45 <allocuvm+0x195>
  for(; a < (uint64_t)start + newsz; a += PGSIZE){
ffffffff80103e45:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
ffffffff80103e49:	48 05 00 10 00 00    	add    $0x1000,%rax
ffffffff80103e4f:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
ffffffff80103e53:	e9 c6 fe ff ff       	jmpq   ffffffff80103d1e <allocuvm+0x6e>
  return newsz;
ffffffff80103e58:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
ffffffff80103e5c:	89 c1                	mov    %eax,%ecx
ffffffff80103e5e:	89 4d fc             	mov    %ecx,-0x4(%rbp)
}
ffffffff80103e61:	8b 45 fc             	mov    -0x4(%rbp),%eax
ffffffff80103e64:	48 83 c4 70          	add    $0x70,%rsp
ffffffff80103e68:	5d                   	pop    %rbp
ffffffff80103e69:	c3                   	retq   
ffffffff80103e6a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)

ffffffff80103e70 <deallocuvm>:
// newsz.  oldsz and newsz need not be page-aligned, nor does newsz
// need to be less than oldsz.  oldsz can be larger than the actual
// process size.  Returns the new process size.
int
deallocuvm(pml4e_t *pml4, char* start, uint64_t oldsz, uint64_t newsz, int pid)
{
ffffffff80103e70:	55                   	push   %rbp
ffffffff80103e71:	48 89 e5             	mov    %rsp,%rbp
ffffffff80103e74:	48 83 ec 30          	sub    $0x30,%rsp
ffffffff80103e78:	b8 01 00 00 00       	mov    $0x1,%eax
ffffffff80103e7d:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
ffffffff80103e81:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
ffffffff80103e85:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
ffffffff80103e89:	48 89 4d e0          	mov    %rcx,-0x20(%rbp)
ffffffff80103e8d:	44 89 45 dc          	mov    %r8d,-0x24(%rbp)
  return deallocuvm_ex(pml4, start, oldsz, newsz, pid, true);
ffffffff80103e91:	48 8b 7d f8          	mov    -0x8(%rbp),%rdi
ffffffff80103e95:	48 8b 75 f0          	mov    -0x10(%rbp),%rsi
ffffffff80103e99:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
ffffffff80103e9d:	48 8b 4d e0          	mov    -0x20(%rbp),%rcx
ffffffff80103ea1:	44 8b 45 dc          	mov    -0x24(%rbp),%r8d
ffffffff80103ea5:	41 b9 01 00 00 00    	mov    $0x1,%r9d
ffffffff80103eab:	89 45 d8             	mov    %eax,-0x28(%rbp)
ffffffff80103eae:	e8 cd 03 00 00       	callq  ffffffff80104280 <deallocuvm_ex>
ffffffff80103eb3:	48 83 c4 30          	add    $0x30,%rsp
ffffffff80103eb7:	5d                   	pop    %rbp
ffffffff80103eb8:	c3                   	retq   
ffffffff80103eb9:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)

ffffffff80103ec0 <find_next_possible_page>:
{
ffffffff80103ec0:	55                   	push   %rbp
ffffffff80103ec1:	48 89 e5             	mov    %rsp,%rbp
ffffffff80103ec4:	48 81 ec e0 00 00 00 	sub    $0xe0,%rsp
ffffffff80103ecb:	48 89 7d f0          	mov    %rdi,-0x10(%rbp)
ffffffff80103ecf:	48 89 75 e8          	mov    %rsi,-0x18(%rbp)
  pml4e = &pml4[PML4_INDEX(va)];
ffffffff80103ed3:	48 8b 75 f0          	mov    -0x10(%rbp),%rsi
ffffffff80103ed7:	48 8b 7d e8          	mov    -0x18(%rbp),%rdi
ffffffff80103edb:	48 c1 ef 27          	shr    $0x27,%rdi
ffffffff80103edf:	48 81 e7 ff 01 00 00 	and    $0x1ff,%rdi
ffffffff80103ee6:	48 c1 e7 03          	shl    $0x3,%rdi
ffffffff80103eea:	48 01 fe             	add    %rdi,%rsi
ffffffff80103eed:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  if (*pml4e & PTE_P) {
ffffffff80103ef1:	48 8b 75 e0          	mov    -0x20(%rbp),%rsi
ffffffff80103ef5:	48 8b 36             	mov    (%rsi),%rsi
ffffffff80103ef8:	48 83 e6 01          	and    $0x1,%rsi
ffffffff80103efc:	48 83 fe 00          	cmp    $0x0,%rsi
ffffffff80103f00:	0f 84 14 01 00 00    	je     ffffffff8010401a <find_next_possible_page+0x15a>
    pdpt = (pdpte_t*)P2V(PDPT_ADDR(*pml4e));
ffffffff80103f06:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
ffffffff80103f0a:	48 8b 00             	mov    (%rax),%rax
ffffffff80103f0d:	c7 45 bc 33 00 00 00 	movl   $0x33,-0x44(%rbp)
ffffffff80103f14:	c7 45 b8 0c 00 00 00 	movl   $0xc,-0x48(%rbp)
ffffffff80103f1b:	8b 4d bc             	mov    -0x44(%rbp),%ecx
ffffffff80103f1e:	3b 4d b8             	cmp    -0x48(%rbp),%ecx
ffffffff80103f21:	48 89 85 70 ff ff ff 	mov    %rax,-0x90(%rbp)
ffffffff80103f28:	0f 8c 0e 00 00 00    	jl     ffffffff80103f3c <find_next_possible_page+0x7c>
ffffffff80103f2e:	8b 45 bc             	mov    -0x44(%rbp),%eax
ffffffff80103f31:	89 85 6c ff ff ff    	mov    %eax,-0x94(%rbp)
ffffffff80103f37:	e9 09 00 00 00       	jmpq   ffffffff80103f45 <find_next_possible_page+0x85>
ffffffff80103f3c:	8b 45 b8             	mov    -0x48(%rbp),%eax
ffffffff80103f3f:	89 85 6c ff ff ff    	mov    %eax,-0x94(%rbp)
ffffffff80103f45:	8b 85 6c ff ff ff    	mov    -0x94(%rbp),%eax
ffffffff80103f4b:	89 45 b4             	mov    %eax,-0x4c(%rbp)
ffffffff80103f4e:	8b 45 b4             	mov    -0x4c(%rbp),%eax
ffffffff80103f51:	c7 45 b0 33 00 00 00 	movl   $0x33,-0x50(%rbp)
ffffffff80103f58:	c7 45 ac 0c 00 00 00 	movl   $0xc,-0x54(%rbp)
ffffffff80103f5f:	8b 4d b0             	mov    -0x50(%rbp),%ecx
ffffffff80103f62:	3b 4d ac             	cmp    -0x54(%rbp),%ecx
ffffffff80103f65:	89 85 68 ff ff ff    	mov    %eax,-0x98(%rbp)
ffffffff80103f6b:	0f 8f 0e 00 00 00    	jg     ffffffff80103f7f <find_next_possible_page+0xbf>
ffffffff80103f71:	8b 45 b0             	mov    -0x50(%rbp),%eax
ffffffff80103f74:	89 85 64 ff ff ff    	mov    %eax,-0x9c(%rbp)
ffffffff80103f7a:	e9 09 00 00 00       	jmpq   ffffffff80103f88 <find_next_possible_page+0xc8>
ffffffff80103f7f:	8b 45 ac             	mov    -0x54(%rbp),%eax
ffffffff80103f82:	89 85 64 ff ff ff    	mov    %eax,-0x9c(%rbp)
ffffffff80103f88:	8b 85 64 ff ff ff    	mov    -0x9c(%rbp),%eax
ffffffff80103f8e:	b9 01 00 00 00       	mov    $0x1,%ecx
ffffffff80103f93:	89 ca                	mov    %ecx,%edx
ffffffff80103f95:	89 45 a8             	mov    %eax,-0x58(%rbp)
ffffffff80103f98:	8b 85 68 ff ff ff    	mov    -0x98(%rbp),%eax
ffffffff80103f9e:	2b 45 a8             	sub    -0x58(%rbp),%eax
ffffffff80103fa1:	89 c0                	mov    %eax,%eax
ffffffff80103fa3:	89 c1                	mov    %eax,%ecx
ffffffff80103fa5:	48 d3 e2             	shl    %cl,%rdx
ffffffff80103fa8:	48 c1 e2 01          	shl    $0x1,%rdx
ffffffff80103fac:	48 83 ea 01          	sub    $0x1,%rdx
ffffffff80103fb0:	c7 45 a4 33 00 00 00 	movl   $0x33,-0x5c(%rbp)
ffffffff80103fb7:	c7 45 a0 0c 00 00 00 	movl   $0xc,-0x60(%rbp)
ffffffff80103fbe:	8b 45 a4             	mov    -0x5c(%rbp),%eax
ffffffff80103fc1:	3b 45 a0             	cmp    -0x60(%rbp),%eax
ffffffff80103fc4:	48 89 95 58 ff ff ff 	mov    %rdx,-0xa8(%rbp)
ffffffff80103fcb:	0f 8f 0e 00 00 00    	jg     ffffffff80103fdf <find_next_possible_page+0x11f>
ffffffff80103fd1:	8b 45 a4             	mov    -0x5c(%rbp),%eax
ffffffff80103fd4:	89 85 54 ff ff ff    	mov    %eax,-0xac(%rbp)
ffffffff80103fda:	e9 09 00 00 00       	jmpq   ffffffff80103fe8 <find_next_possible_page+0x128>
ffffffff80103fdf:	8b 45 a0             	mov    -0x60(%rbp),%eax
ffffffff80103fe2:	89 85 54 ff ff ff    	mov    %eax,-0xac(%rbp)
ffffffff80103fe8:	8b 85 54 ff ff ff    	mov    -0xac(%rbp),%eax
ffffffff80103fee:	89 45 9c             	mov    %eax,-0x64(%rbp)
ffffffff80103ff1:	8b 45 9c             	mov    -0x64(%rbp),%eax
ffffffff80103ff4:	89 c1                	mov    %eax,%ecx
ffffffff80103ff6:	48 8b 95 58 ff ff ff 	mov    -0xa8(%rbp),%rdx
ffffffff80103ffd:	48 d3 e2             	shl    %cl,%rdx
ffffffff80104000:	48 8b b5 70 ff ff ff 	mov    -0x90(%rbp),%rsi
ffffffff80104007:	48 21 d6             	and    %rdx,%rsi
ffffffff8010400a:	48 81 c6 00 00 00 80 	add    $0xffffffff80000000,%rsi
ffffffff80104011:	48 89 75 d8          	mov    %rsi,-0x28(%rbp)
  } else {
ffffffff80104015:	e9 25 00 00 00       	jmpq   ffffffff8010403f <find_next_possible_page+0x17f>
    return PGADDR(PML4_INDEX(va) + 1, 0, 0, 0, 0) - PGSIZE;
ffffffff8010401a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
ffffffff8010401e:	48 c1 e8 27          	shr    $0x27,%rax
ffffffff80104022:	48 25 ff 01 00 00    	and    $0x1ff,%rax
ffffffff80104028:	48 83 c0 01          	add    $0x1,%rax
ffffffff8010402c:	48 c1 e0 27          	shl    $0x27,%rax
ffffffff80104030:	48 2d 00 10 00 00    	sub    $0x1000,%rax
ffffffff80104036:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
ffffffff8010403a:	e9 26 02 00 00       	jmpq   ffffffff80104265 <find_next_possible_page+0x3a5>
  pdpte = &pdpt[PDPT_INDEX(va)];
ffffffff8010403f:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
ffffffff80104043:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
ffffffff80104047:	48 c1 e9 1e          	shr    $0x1e,%rcx
ffffffff8010404b:	48 81 e1 ff 01 00 00 	and    $0x1ff,%rcx
ffffffff80104052:	48 c1 e1 03          	shl    $0x3,%rcx
ffffffff80104056:	48 01 c8             	add    %rcx,%rax
ffffffff80104059:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
  if (*pdpte & PTE_P) {
ffffffff8010405d:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
ffffffff80104061:	48 8b 00             	mov    (%rax),%rax
ffffffff80104064:	48 83 e0 01          	and    $0x1,%rax
ffffffff80104068:	48 83 f8 00          	cmp    $0x0,%rax
ffffffff8010406c:	0f 84 23 01 00 00    	je     ffffffff80104195 <find_next_possible_page+0x2d5>
    pgdir = (pde_t*)P2V(PDE_ADDR(*pdpte));
ffffffff80104072:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
ffffffff80104076:	48 8b 00             	mov    (%rax),%rax
ffffffff80104079:	c7 45 98 33 00 00 00 	movl   $0x33,-0x68(%rbp)
ffffffff80104080:	c7 45 94 0c 00 00 00 	movl   $0xc,-0x6c(%rbp)
ffffffff80104087:	8b 4d 98             	mov    -0x68(%rbp),%ecx
ffffffff8010408a:	3b 4d 94             	cmp    -0x6c(%rbp),%ecx
ffffffff8010408d:	48 89 85 48 ff ff ff 	mov    %rax,-0xb8(%rbp)
ffffffff80104094:	0f 8c 0e 00 00 00    	jl     ffffffff801040a8 <find_next_possible_page+0x1e8>
ffffffff8010409a:	8b 45 98             	mov    -0x68(%rbp),%eax
ffffffff8010409d:	89 85 44 ff ff ff    	mov    %eax,-0xbc(%rbp)
ffffffff801040a3:	e9 09 00 00 00       	jmpq   ffffffff801040b1 <find_next_possible_page+0x1f1>
ffffffff801040a8:	8b 45 94             	mov    -0x6c(%rbp),%eax
ffffffff801040ab:	89 85 44 ff ff ff    	mov    %eax,-0xbc(%rbp)
ffffffff801040b1:	8b 85 44 ff ff ff    	mov    -0xbc(%rbp),%eax
ffffffff801040b7:	89 45 90             	mov    %eax,-0x70(%rbp)
ffffffff801040ba:	8b 45 90             	mov    -0x70(%rbp),%eax
ffffffff801040bd:	c7 45 8c 33 00 00 00 	movl   $0x33,-0x74(%rbp)
ffffffff801040c4:	c7 45 88 0c 00 00 00 	movl   $0xc,-0x78(%rbp)
ffffffff801040cb:	8b 4d 8c             	mov    -0x74(%rbp),%ecx
ffffffff801040ce:	3b 4d 88             	cmp    -0x78(%rbp),%ecx
ffffffff801040d1:	89 85 40 ff ff ff    	mov    %eax,-0xc0(%rbp)
ffffffff801040d7:	0f 8f 0e 00 00 00    	jg     ffffffff801040eb <find_next_possible_page+0x22b>
ffffffff801040dd:	8b 45 8c             	mov    -0x74(%rbp),%eax
ffffffff801040e0:	89 85 3c ff ff ff    	mov    %eax,-0xc4(%rbp)
ffffffff801040e6:	e9 09 00 00 00       	jmpq   ffffffff801040f4 <find_next_possible_page+0x234>
ffffffff801040eb:	8b 45 88             	mov    -0x78(%rbp),%eax
ffffffff801040ee:	89 85 3c ff ff ff    	mov    %eax,-0xc4(%rbp)
ffffffff801040f4:	8b 85 3c ff ff ff    	mov    -0xc4(%rbp),%eax
ffffffff801040fa:	b9 01 00 00 00       	mov    $0x1,%ecx
ffffffff801040ff:	89 ca                	mov    %ecx,%edx
ffffffff80104101:	89 45 84             	mov    %eax,-0x7c(%rbp)
ffffffff80104104:	8b 85 40 ff ff ff    	mov    -0xc0(%rbp),%eax
ffffffff8010410a:	2b 45 84             	sub    -0x7c(%rbp),%eax
ffffffff8010410d:	89 c0                	mov    %eax,%eax
ffffffff8010410f:	89 c1                	mov    %eax,%ecx
ffffffff80104111:	48 d3 e2             	shl    %cl,%rdx
ffffffff80104114:	48 c1 e2 01          	shl    $0x1,%rdx
ffffffff80104118:	48 83 ea 01          	sub    $0x1,%rdx
ffffffff8010411c:	c7 45 80 33 00 00 00 	movl   $0x33,-0x80(%rbp)
ffffffff80104123:	c7 85 7c ff ff ff 0c 	movl   $0xc,-0x84(%rbp)
ffffffff8010412a:	00 00 00 
ffffffff8010412d:	8b 45 80             	mov    -0x80(%rbp),%eax
ffffffff80104130:	3b 85 7c ff ff ff    	cmp    -0x84(%rbp),%eax
ffffffff80104136:	48 89 95 30 ff ff ff 	mov    %rdx,-0xd0(%rbp)
ffffffff8010413d:	0f 8f 0e 00 00 00    	jg     ffffffff80104151 <find_next_possible_page+0x291>
ffffffff80104143:	8b 45 80             	mov    -0x80(%rbp),%eax
ffffffff80104146:	89 85 2c ff ff ff    	mov    %eax,-0xd4(%rbp)
ffffffff8010414c:	e9 0c 00 00 00       	jmpq   ffffffff8010415d <find_next_possible_page+0x29d>
ffffffff80104151:	8b 85 7c ff ff ff    	mov    -0x84(%rbp),%eax
ffffffff80104157:	89 85 2c ff ff ff    	mov    %eax,-0xd4(%rbp)
ffffffff8010415d:	8b 85 2c ff ff ff    	mov    -0xd4(%rbp),%eax
ffffffff80104163:	89 85 78 ff ff ff    	mov    %eax,-0x88(%rbp)
ffffffff80104169:	8b 85 78 ff ff ff    	mov    -0x88(%rbp),%eax
ffffffff8010416f:	89 c1                	mov    %eax,%ecx
ffffffff80104171:	48 8b 95 30 ff ff ff 	mov    -0xd0(%rbp),%rdx
ffffffff80104178:	48 d3 e2             	shl    %cl,%rdx
ffffffff8010417b:	48 8b b5 48 ff ff ff 	mov    -0xb8(%rbp),%rsi
ffffffff80104182:	48 21 d6             	and    %rdx,%rsi
ffffffff80104185:	48 81 c6 00 00 00 80 	add    $0xffffffff80000000,%rsi
ffffffff8010418c:	48 89 75 c8          	mov    %rsi,-0x38(%rbp)
  } else {
ffffffff80104190:	e9 3b 00 00 00       	jmpq   ffffffff801041d0 <find_next_possible_page+0x310>
    return PGADDR(PML4_INDEX(va), PDPT_INDEX(va) + 1, 0, 0, 0) - PGSIZE;
ffffffff80104195:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
ffffffff80104199:	48 c1 e8 27          	shr    $0x27,%rax
ffffffff8010419d:	48 25 ff 01 00 00    	and    $0x1ff,%rax
ffffffff801041a3:	48 c1 e0 27          	shl    $0x27,%rax
ffffffff801041a7:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
ffffffff801041ab:	48 c1 e9 1e          	shr    $0x1e,%rcx
ffffffff801041af:	48 81 e1 ff 01 00 00 	and    $0x1ff,%rcx
ffffffff801041b6:	48 83 c1 01          	add    $0x1,%rcx
ffffffff801041ba:	48 c1 e1 1e          	shl    $0x1e,%rcx
ffffffff801041be:	48 09 c8             	or     %rcx,%rax
ffffffff801041c1:	48 2d 00 10 00 00    	sub    $0x1000,%rax
ffffffff801041c7:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
ffffffff801041cb:	e9 95 00 00 00       	jmpq   ffffffff80104265 <find_next_possible_page+0x3a5>
  pde = &pgdir[PD_INDEX(va)];
ffffffff801041d0:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
ffffffff801041d4:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
ffffffff801041d8:	48 c1 e9 15          	shr    $0x15,%rcx
ffffffff801041dc:	48 81 e1 ff 01 00 00 	and    $0x1ff,%rcx
ffffffff801041e3:	48 c1 e1 03          	shl    $0x3,%rcx
ffffffff801041e7:	48 01 c8             	add    %rcx,%rax
ffffffff801041ea:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
  if (*pde & PTE_P) {
ffffffff801041ee:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
ffffffff801041f2:	48 8b 00             	mov    (%rax),%rax
ffffffff801041f5:	48 83 e0 01          	and    $0x1,%rax
ffffffff801041f9:	48 83 f8 00          	cmp    $0x0,%rax
ffffffff801041fd:	0f 84 05 00 00 00    	je     ffffffff80104208 <find_next_possible_page+0x348>
  } else {
ffffffff80104203:	e9 51 00 00 00       	jmpq   ffffffff80104259 <find_next_possible_page+0x399>
    return PGADDR(PML4_INDEX(va), PDPT_INDEX(va), PD_INDEX(va) + 1, 0, 0) - PGSIZE;
ffffffff80104208:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
ffffffff8010420c:	48 c1 e8 27          	shr    $0x27,%rax
ffffffff80104210:	48 25 ff 01 00 00    	and    $0x1ff,%rax
ffffffff80104216:	48 c1 e0 27          	shl    $0x27,%rax
ffffffff8010421a:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
ffffffff8010421e:	48 c1 e9 1e          	shr    $0x1e,%rcx
ffffffff80104222:	48 81 e1 ff 01 00 00 	and    $0x1ff,%rcx
ffffffff80104229:	48 c1 e1 1e          	shl    $0x1e,%rcx
ffffffff8010422d:	48 09 c8             	or     %rcx,%rax
ffffffff80104230:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
ffffffff80104234:	48 c1 e9 15          	shr    $0x15,%rcx
ffffffff80104238:	48 81 e1 ff 01 00 00 	and    $0x1ff,%rcx
ffffffff8010423f:	48 83 c1 01          	add    $0x1,%rcx
ffffffff80104243:	48 c1 e1 15          	shl    $0x15,%rcx
ffffffff80104247:	48 09 c8             	or     %rcx,%rax
ffffffff8010424a:	48 2d 00 10 00 00    	sub    $0x1000,%rax
ffffffff80104250:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
ffffffff80104254:	e9 0c 00 00 00       	jmpq   ffffffff80104265 <find_next_possible_page+0x3a5>
  panic("level is not missing");
ffffffff80104259:	48 c7 c7 18 fe 10 80 	mov    $0xffffffff8010fe18,%rdi
ffffffff80104260:	e8 0b cc ff ff       	callq  ffffffff80100e70 <panic>
}
ffffffff80104265:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
ffffffff80104269:	48 81 c4 e0 00 00 00 	add    $0xe0,%rsp
ffffffff80104270:	5d                   	pop    %rbp
ffffffff80104271:	c3                   	retq   
ffffffff80104272:	66 66 66 66 66 2e 0f 	data16 data16 data16 data16 nopw %cs:0x0(%rax,%rax,1)
ffffffff80104279:	1f 84 00 00 00 00 00 

ffffffff80104280 <deallocuvm_ex>:
{
ffffffff80104280:	55                   	push   %rbp
ffffffff80104281:	48 89 e5             	mov    %rsp,%rbp
ffffffff80104284:	48 81 ec f0 00 00 00 	sub    $0xf0,%rsp
ffffffff8010428b:	44 88 c8             	mov    %r9b,%al
ffffffff8010428e:	48 89 7d f0          	mov    %rdi,-0x10(%rbp)
ffffffff80104292:	48 89 75 e8          	mov    %rsi,-0x18(%rbp)
ffffffff80104296:	48 89 55 e0          	mov    %rdx,-0x20(%rbp)
ffffffff8010429a:	48 89 4d d8          	mov    %rcx,-0x28(%rbp)
ffffffff8010429e:	44 89 45 d4          	mov    %r8d,-0x2c(%rbp)
ffffffff801042a2:	24 01                	and    $0x1,%al
ffffffff801042a4:	88 45 d3             	mov    %al,-0x2d(%rbp)
  if(newsz >= oldsz)
ffffffff801042a7:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
ffffffff801042ab:	48 3b 4d e0          	cmp    -0x20(%rbp),%rcx
ffffffff801042af:	0f 82 0e 00 00 00    	jb     ffffffff801042c3 <deallocuvm_ex+0x43>
    return oldsz;
ffffffff801042b5:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
ffffffff801042b9:	89 c1                	mov    %eax,%ecx
ffffffff801042bb:	89 4d fc             	mov    %ecx,-0x4(%rbp)
ffffffff801042be:	e9 70 03 00 00       	jmpq   ffffffff80104633 <deallocuvm_ex+0x3b3>
  a = PGROUNDUP((uint64_t)start + newsz);
ffffffff801042c3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
ffffffff801042c7:	48 03 45 d8          	add    -0x28(%rbp),%rax
ffffffff801042cb:	48 05 00 10 00 00    	add    $0x1000,%rax
ffffffff801042d1:	48 83 e8 01          	sub    $0x1,%rax
ffffffff801042d5:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
ffffffff801042db:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
  for(; a  < (uint64_t)start + oldsz; a += PGSIZE){
ffffffff801042df:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
ffffffff801042e3:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
ffffffff801042e7:	48 03 4d e0          	add    -0x20(%rbp),%rcx
ffffffff801042eb:	48 39 c8             	cmp    %rcx,%rax
ffffffff801042ee:	0f 83 29 03 00 00    	jae    ffffffff8010461d <deallocuvm_ex+0x39d>
ffffffff801042f4:	31 c0                	xor    %eax,%eax
    pte = walkpml4(pml4, (char*)a, 0);
ffffffff801042f6:	48 8b 7d f0          	mov    -0x10(%rbp),%rdi
ffffffff801042fa:	48 8b 75 c0          	mov    -0x40(%rbp),%rsi
ffffffff801042fe:	31 d2                	xor    %edx,%edx
ffffffff80104300:	89 85 64 ff ff ff    	mov    %eax,-0x9c(%rbp)
ffffffff80104306:	e8 65 e9 ff ff       	callq  ffffffff80102c70 <walkpml4>
ffffffff8010430b:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
    if(!pte) {
ffffffff8010430f:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
ffffffff80104314:	0f 85 16 00 00 00    	jne    ffffffff80104330 <deallocuvm_ex+0xb0>
      a = find_next_possible_page(pml4, a);
ffffffff8010431a:	48 8b 7d f0          	mov    -0x10(%rbp),%rdi
ffffffff8010431e:	48 8b 75 c0          	mov    -0x40(%rbp),%rsi
ffffffff80104322:	e8 99 fb ff ff       	callq  ffffffff80103ec0 <find_next_possible_page>
ffffffff80104327:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
    }
ffffffff8010432b:	e9 d5 02 00 00       	jmpq   ffffffff80104605 <deallocuvm_ex+0x385>
    else if (*pte & PTE_S) {
ffffffff80104330:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
ffffffff80104334:	48 8b 00             	mov    (%rax),%rax
ffffffff80104337:	48 25 00 02 00 00    	and    $0x200,%rax
ffffffff8010433d:	48 83 f8 00          	cmp    $0x0,%rax
ffffffff80104341:	0f 84 20 01 00 00    	je     ffffffff80104467 <deallocuvm_ex+0x1e7>
      decr_swap_entry_ref(PTE_ADDR(*pte) >> PT_SHIFT);
ffffffff80104347:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
ffffffff8010434b:	48 8b 00             	mov    (%rax),%rax
ffffffff8010434e:	c7 45 b4 33 00 00 00 	movl   $0x33,-0x4c(%rbp)
ffffffff80104355:	c7 45 b0 0c 00 00 00 	movl   $0xc,-0x50(%rbp)
ffffffff8010435c:	8b 4d b4             	mov    -0x4c(%rbp),%ecx
ffffffff8010435f:	3b 4d b0             	cmp    -0x50(%rbp),%ecx
ffffffff80104362:	48 89 85 58 ff ff ff 	mov    %rax,-0xa8(%rbp)
ffffffff80104369:	0f 8c 0e 00 00 00    	jl     ffffffff8010437d <deallocuvm_ex+0xfd>
ffffffff8010436f:	8b 45 b4             	mov    -0x4c(%rbp),%eax
ffffffff80104372:	89 85 54 ff ff ff    	mov    %eax,-0xac(%rbp)
ffffffff80104378:	e9 09 00 00 00       	jmpq   ffffffff80104386 <deallocuvm_ex+0x106>
ffffffff8010437d:	8b 45 b0             	mov    -0x50(%rbp),%eax
ffffffff80104380:	89 85 54 ff ff ff    	mov    %eax,-0xac(%rbp)
ffffffff80104386:	8b 85 54 ff ff ff    	mov    -0xac(%rbp),%eax
ffffffff8010438c:	89 45 ac             	mov    %eax,-0x54(%rbp)
ffffffff8010438f:	8b 45 ac             	mov    -0x54(%rbp),%eax
ffffffff80104392:	c7 45 a8 33 00 00 00 	movl   $0x33,-0x58(%rbp)
ffffffff80104399:	c7 45 a4 0c 00 00 00 	movl   $0xc,-0x5c(%rbp)
ffffffff801043a0:	8b 4d a8             	mov    -0x58(%rbp),%ecx
ffffffff801043a3:	3b 4d a4             	cmp    -0x5c(%rbp),%ecx
ffffffff801043a6:	89 85 50 ff ff ff    	mov    %eax,-0xb0(%rbp)
ffffffff801043ac:	0f 8f 0e 00 00 00    	jg     ffffffff801043c0 <deallocuvm_ex+0x140>
ffffffff801043b2:	8b 45 a8             	mov    -0x58(%rbp),%eax
ffffffff801043b5:	89 85 4c ff ff ff    	mov    %eax,-0xb4(%rbp)
ffffffff801043bb:	e9 09 00 00 00       	jmpq   ffffffff801043c9 <deallocuvm_ex+0x149>
ffffffff801043c0:	8b 45 a4             	mov    -0x5c(%rbp),%eax
ffffffff801043c3:	89 85 4c ff ff ff    	mov    %eax,-0xb4(%rbp)
ffffffff801043c9:	8b 85 4c ff ff ff    	mov    -0xb4(%rbp),%eax
ffffffff801043cf:	b9 01 00 00 00       	mov    $0x1,%ecx
ffffffff801043d4:	89 ca                	mov    %ecx,%edx
ffffffff801043d6:	89 45 a0             	mov    %eax,-0x60(%rbp)
ffffffff801043d9:	8b 85 50 ff ff ff    	mov    -0xb0(%rbp),%eax
ffffffff801043df:	2b 45 a0             	sub    -0x60(%rbp),%eax
ffffffff801043e2:	89 c0                	mov    %eax,%eax
ffffffff801043e4:	89 c1                	mov    %eax,%ecx
ffffffff801043e6:	48 d3 e2             	shl    %cl,%rdx
ffffffff801043e9:	48 c1 e2 01          	shl    $0x1,%rdx
ffffffff801043ed:	48 83 ea 01          	sub    $0x1,%rdx
ffffffff801043f1:	c7 45 9c 33 00 00 00 	movl   $0x33,-0x64(%rbp)
ffffffff801043f8:	c7 45 98 0c 00 00 00 	movl   $0xc,-0x68(%rbp)
ffffffff801043ff:	8b 45 9c             	mov    -0x64(%rbp),%eax
ffffffff80104402:	3b 45 98             	cmp    -0x68(%rbp),%eax
ffffffff80104405:	48 89 95 40 ff ff ff 	mov    %rdx,-0xc0(%rbp)
ffffffff8010440c:	0f 8f 0e 00 00 00    	jg     ffffffff80104420 <deallocuvm_ex+0x1a0>
ffffffff80104412:	8b 45 9c             	mov    -0x64(%rbp),%eax
ffffffff80104415:	89 85 3c ff ff ff    	mov    %eax,-0xc4(%rbp)
ffffffff8010441b:	e9 09 00 00 00       	jmpq   ffffffff80104429 <deallocuvm_ex+0x1a9>
ffffffff80104420:	8b 45 98             	mov    -0x68(%rbp),%eax
ffffffff80104423:	89 85 3c ff ff ff    	mov    %eax,-0xc4(%rbp)
ffffffff80104429:	8b 85 3c ff ff ff    	mov    -0xc4(%rbp),%eax
ffffffff8010442f:	89 45 94             	mov    %eax,-0x6c(%rbp)
ffffffff80104432:	8b 45 94             	mov    -0x6c(%rbp),%eax
ffffffff80104435:	89 c1                	mov    %eax,%ecx
ffffffff80104437:	48 8b 95 40 ff ff ff 	mov    -0xc0(%rbp),%rdx
ffffffff8010443e:	48 d3 e2             	shl    %cl,%rdx
ffffffff80104441:	48 8b b5 58 ff ff ff 	mov    -0xa8(%rbp),%rsi
ffffffff80104448:	48 21 d6             	and    %rdx,%rsi
ffffffff8010444b:	48 c1 ee 0c          	shr    $0xc,%rsi
ffffffff8010444f:	48 89 f7             	mov    %rsi,%rdi
ffffffff80104452:	e8 c9 a4 00 00       	callq  ffffffff8010e920 <decr_swap_entry_ref>
      *pte = 0;
ffffffff80104457:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
ffffffff8010445b:	48 c7 02 00 00 00 00 	movq   $0x0,(%rdx)
    }
ffffffff80104462:	e9 99 01 00 00       	jmpq   ffffffff80104600 <deallocuvm_ex+0x380>
    else if ((*pte & PTE_P) != 0){
ffffffff80104467:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
ffffffff8010446b:	48 8b 00             	mov    (%rax),%rax
ffffffff8010446e:	48 83 e0 01          	and    $0x1,%rax
ffffffff80104472:	48 83 f8 00          	cmp    $0x0,%rax
ffffffff80104476:	0f 84 7f 01 00 00    	je     ffffffff801045fb <deallocuvm_ex+0x37b>
      pa = PTE_ADDR(*pte);
ffffffff8010447c:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
ffffffff80104480:	48 8b 00             	mov    (%rax),%rax
ffffffff80104483:	c7 45 90 33 00 00 00 	movl   $0x33,-0x70(%rbp)
ffffffff8010448a:	c7 45 8c 0c 00 00 00 	movl   $0xc,-0x74(%rbp)
ffffffff80104491:	8b 4d 90             	mov    -0x70(%rbp),%ecx
ffffffff80104494:	3b 4d 8c             	cmp    -0x74(%rbp),%ecx
ffffffff80104497:	48 89 85 30 ff ff ff 	mov    %rax,-0xd0(%rbp)
ffffffff8010449e:	0f 8c 0e 00 00 00    	jl     ffffffff801044b2 <deallocuvm_ex+0x232>
ffffffff801044a4:	8b 45 90             	mov    -0x70(%rbp),%eax
ffffffff801044a7:	89 85 2c ff ff ff    	mov    %eax,-0xd4(%rbp)
ffffffff801044ad:	e9 09 00 00 00       	jmpq   ffffffff801044bb <deallocuvm_ex+0x23b>
ffffffff801044b2:	8b 45 8c             	mov    -0x74(%rbp),%eax
ffffffff801044b5:	89 85 2c ff ff ff    	mov    %eax,-0xd4(%rbp)
ffffffff801044bb:	8b 85 2c ff ff ff    	mov    -0xd4(%rbp),%eax
ffffffff801044c1:	89 45 88             	mov    %eax,-0x78(%rbp)
ffffffff801044c4:	8b 45 88             	mov    -0x78(%rbp),%eax
ffffffff801044c7:	c7 45 84 33 00 00 00 	movl   $0x33,-0x7c(%rbp)
ffffffff801044ce:	c7 45 80 0c 00 00 00 	movl   $0xc,-0x80(%rbp)
ffffffff801044d5:	8b 4d 84             	mov    -0x7c(%rbp),%ecx
ffffffff801044d8:	3b 4d 80             	cmp    -0x80(%rbp),%ecx
ffffffff801044db:	89 85 28 ff ff ff    	mov    %eax,-0xd8(%rbp)
ffffffff801044e1:	0f 8f 0e 00 00 00    	jg     ffffffff801044f5 <deallocuvm_ex+0x275>
ffffffff801044e7:	8b 45 84             	mov    -0x7c(%rbp),%eax
ffffffff801044ea:	89 85 24 ff ff ff    	mov    %eax,-0xdc(%rbp)
ffffffff801044f0:	e9 09 00 00 00       	jmpq   ffffffff801044fe <deallocuvm_ex+0x27e>
ffffffff801044f5:	8b 45 80             	mov    -0x80(%rbp),%eax
ffffffff801044f8:	89 85 24 ff ff ff    	mov    %eax,-0xdc(%rbp)
ffffffff801044fe:	8b 85 24 ff ff ff    	mov    -0xdc(%rbp),%eax
ffffffff80104504:	b9 01 00 00 00       	mov    $0x1,%ecx
ffffffff80104509:	89 ca                	mov    %ecx,%edx
ffffffff8010450b:	89 85 7c ff ff ff    	mov    %eax,-0x84(%rbp)
ffffffff80104511:	8b 85 28 ff ff ff    	mov    -0xd8(%rbp),%eax
ffffffff80104517:	2b 85 7c ff ff ff    	sub    -0x84(%rbp),%eax
ffffffff8010451d:	89 c0                	mov    %eax,%eax
ffffffff8010451f:	89 c1                	mov    %eax,%ecx
ffffffff80104521:	48 d3 e2             	shl    %cl,%rdx
ffffffff80104524:	48 c1 e2 01          	shl    $0x1,%rdx
ffffffff80104528:	48 83 ea 01          	sub    $0x1,%rdx
ffffffff8010452c:	c7 85 78 ff ff ff 33 	movl   $0x33,-0x88(%rbp)
ffffffff80104533:	00 00 00 
ffffffff80104536:	c7 85 74 ff ff ff 0c 	movl   $0xc,-0x8c(%rbp)
ffffffff8010453d:	00 00 00 
ffffffff80104540:	8b 85 78 ff ff ff    	mov    -0x88(%rbp),%eax
ffffffff80104546:	3b 85 74 ff ff ff    	cmp    -0x8c(%rbp),%eax
ffffffff8010454c:	48 89 95 18 ff ff ff 	mov    %rdx,-0xe8(%rbp)
ffffffff80104553:	0f 8f 11 00 00 00    	jg     ffffffff8010456a <deallocuvm_ex+0x2ea>
ffffffff80104559:	8b 85 78 ff ff ff    	mov    -0x88(%rbp),%eax
ffffffff8010455f:	89 85 14 ff ff ff    	mov    %eax,-0xec(%rbp)
ffffffff80104565:	e9 0c 00 00 00       	jmpq   ffffffff80104576 <deallocuvm_ex+0x2f6>
ffffffff8010456a:	8b 85 74 ff ff ff    	mov    -0x8c(%rbp),%eax
ffffffff80104570:	89 85 14 ff ff ff    	mov    %eax,-0xec(%rbp)
ffffffff80104576:	8b 85 14 ff ff ff    	mov    -0xec(%rbp),%eax
ffffffff8010457c:	89 85 70 ff ff ff    	mov    %eax,-0x90(%rbp)
ffffffff80104582:	8b 85 70 ff ff ff    	mov    -0x90(%rbp),%eax
ffffffff80104588:	89 c1                	mov    %eax,%ecx
ffffffff8010458a:	48 8b 95 18 ff ff ff 	mov    -0xe8(%rbp),%rdx
ffffffff80104591:	48 d3 e2             	shl    %cl,%rdx
ffffffff80104594:	48 8b b5 30 ff ff ff 	mov    -0xd0(%rbp),%rsi
ffffffff8010459b:	48 21 d6             	and    %rdx,%rsi
ffffffff8010459e:	48 89 75 b8          	mov    %rsi,-0x48(%rbp)
      if(pa == 0)
ffffffff801045a2:	48 83 7d b8 00       	cmpq   $0x0,-0x48(%rbp)
ffffffff801045a7:	0f 85 0c 00 00 00    	jne    ffffffff801045b9 <deallocuvm_ex+0x339>
        panic("kfree");
ffffffff801045ad:	48 c7 c7 c3 fa 10 80 	mov    $0xffffffff8010fac3,%rdi
ffffffff801045b4:	e8 b7 c8 ff ff       	callq  ffffffff80100e70 <panic>
      if (free_phys_mem) {
ffffffff801045b9:	f6 45 d3 01          	testb  $0x1,-0x2d(%rbp)
ffffffff801045bd:	0f 84 1d 00 00 00    	je     ffffffff801045e0 <deallocuvm_ex+0x360>
        char *v = P2V(pa);
ffffffff801045c3:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
ffffffff801045c7:	48 05 00 00 00 80    	add    $0xffffffff80000000,%rax
ffffffff801045cd:	48 89 85 68 ff ff ff 	mov    %rax,-0x98(%rbp)
        kfree(v);
ffffffff801045d4:	48 8b bd 68 ff ff ff 	mov    -0x98(%rbp),%rdi
ffffffff801045db:	e8 90 bf ff ff       	callq  ffffffff80100570 <kfree>
      *pte = 0;
ffffffff801045e0:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
ffffffff801045e4:	48 c7 00 00 00 00 00 	movq   $0x0,(%rax)
      remove_phy_mem_map(pid, a, pa);
ffffffff801045eb:	8b 7d d4             	mov    -0x2c(%rbp),%edi
ffffffff801045ee:	48 8b 75 c0          	mov    -0x40(%rbp),%rsi
ffffffff801045f2:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
ffffffff801045f6:	e8 35 c1 ff ff       	callq  ffffffff80100730 <remove_phy_mem_map>
ffffffff801045fb:	e9 00 00 00 00       	jmpq   ffffffff80104600 <deallocuvm_ex+0x380>
ffffffff80104600:	e9 00 00 00 00       	jmpq   ffffffff80104605 <deallocuvm_ex+0x385>
  }
ffffffff80104605:	e9 00 00 00 00       	jmpq   ffffffff8010460a <deallocuvm_ex+0x38a>
  for(; a  < (uint64_t)start + oldsz; a += PGSIZE){
ffffffff8010460a:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
ffffffff8010460e:	48 05 00 10 00 00    	add    $0x1000,%rax
ffffffff80104614:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
ffffffff80104618:	e9 c2 fc ff ff       	jmpq   ffffffff801042df <deallocuvm_ex+0x5f>
  switchuvm(myproc());
ffffffff8010461d:	e8 be 09 00 00       	callq  ffffffff80104fe0 <myproc>
ffffffff80104622:	48 89 c7             	mov    %rax,%rdi
ffffffff80104625:	e8 c6 ef ff ff       	callq  ffffffff801035f0 <switchuvm>
  return newsz;
ffffffff8010462a:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
ffffffff8010462e:	89 c1                	mov    %eax,%ecx
ffffffff80104630:	89 4d fc             	mov    %ecx,-0x4(%rbp)
}
ffffffff80104633:	8b 45 fc             	mov    -0x4(%rbp),%eax
ffffffff80104636:	48 81 c4 f0 00 00 00 	add    $0xf0,%rsp
ffffffff8010463d:	5d                   	pop    %rbp
ffffffff8010463e:	c3                   	retq   
ffffffff8010463f:	90                   	nop

ffffffff80104640 <unmapuvm>:
}

// Like deallocuvm but does not free the underlying physical memory.
int
unmapuvm(pml4e_t *pml4, char* start, uint64_t oldsz, uint64_t newsz, int pid)
{
ffffffff80104640:	55                   	push   %rbp
ffffffff80104641:	48 89 e5             	mov    %rsp,%rbp
ffffffff80104644:	48 83 ec 30          	sub    $0x30,%rsp
ffffffff80104648:	31 c0                	xor    %eax,%eax
ffffffff8010464a:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
ffffffff8010464e:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
ffffffff80104652:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
ffffffff80104656:	48 89 4d e0          	mov    %rcx,-0x20(%rbp)
ffffffff8010465a:	44 89 45 dc          	mov    %r8d,-0x24(%rbp)
  return deallocuvm_ex(pml4, start, oldsz, newsz, pid, false);
ffffffff8010465e:	48 8b 7d f8          	mov    -0x8(%rbp),%rdi
ffffffff80104662:	48 8b 75 f0          	mov    -0x10(%rbp),%rsi
ffffffff80104666:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
ffffffff8010466a:	48 8b 4d e0          	mov    -0x20(%rbp),%rcx
ffffffff8010466e:	44 8b 45 dc          	mov    -0x24(%rbp),%r8d
ffffffff80104672:	45 31 c9             	xor    %r9d,%r9d
ffffffff80104675:	89 45 d8             	mov    %eax,-0x28(%rbp)
ffffffff80104678:	e8 03 fc ff ff       	callq  ffffffff80104280 <deallocuvm_ex>
ffffffff8010467d:	48 83 c4 30          	add    $0x30,%rsp
ffffffff80104681:	5d                   	pop    %rbp
ffffffff80104682:	c3                   	retq   
ffffffff80104683:	66 66 66 66 2e 0f 1f 	data16 data16 data16 nopw %cs:0x0(%rax,%rax,1)
ffffffff8010468a:	84 00 00 00 00 00 

ffffffff80104690 <freevm_pgdir>:
}

void
freevm_pgdir(pde_t *pgdir)
{
ffffffff80104690:	55                   	push   %rbp
ffffffff80104691:	48 89 e5             	mov    %rsp,%rbp
ffffffff80104694:	48 83 ec 70          	sub    $0x70,%rsp
ffffffff80104698:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  uint i;
  for (i = 0; i < PTRS_PER_PD; i++) {
ffffffff8010469c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)
ffffffff801046a3:	8b 45 f4             	mov    -0xc(%rbp),%eax
ffffffff801046a6:	89 c1                	mov    %eax,%ecx
ffffffff801046a8:	48 81 f9 00 02 00 00 	cmp    $0x200,%rcx
ffffffff801046af:	0f 83 1f 01 00 00    	jae    ffffffff801047d4 <freevm_pgdir+0x144>
    if (pgdir[i] & PTE_P) {
ffffffff801046b5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
ffffffff801046b9:	8b 4d f4             	mov    -0xc(%rbp),%ecx
ffffffff801046bc:	89 ca                	mov    %ecx,%edx
ffffffff801046be:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
ffffffff801046c2:	48 83 e0 01          	and    $0x1,%rax
ffffffff801046c6:	48 83 f8 00          	cmp    $0x0,%rax
ffffffff801046ca:	0f 84 f1 00 00 00    	je     ffffffff801047c1 <freevm_pgdir+0x131>
      char *v = P2V(PTE_ADDR(pgdir[i]));
ffffffff801046d0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
ffffffff801046d4:	8b 4d f4             	mov    -0xc(%rbp),%ecx
ffffffff801046d7:	89 ca                	mov    %ecx,%edx
ffffffff801046d9:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
ffffffff801046dd:	c7 45 e4 33 00 00 00 	movl   $0x33,-0x1c(%rbp)
ffffffff801046e4:	c7 45 e0 0c 00 00 00 	movl   $0xc,-0x20(%rbp)
ffffffff801046eb:	8b 4d e4             	mov    -0x1c(%rbp),%ecx
ffffffff801046ee:	3b 4d e0             	cmp    -0x20(%rbp),%ecx
ffffffff801046f1:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
ffffffff801046f5:	0f 8c 0b 00 00 00    	jl     ffffffff80104706 <freevm_pgdir+0x76>
ffffffff801046fb:	8b 45 e4             	mov    -0x1c(%rbp),%eax
ffffffff801046fe:	89 45 b4             	mov    %eax,-0x4c(%rbp)
ffffffff80104701:	e9 06 00 00 00       	jmpq   ffffffff8010470c <freevm_pgdir+0x7c>
ffffffff80104706:	8b 45 e0             	mov    -0x20(%rbp),%eax
ffffffff80104709:	89 45 b4             	mov    %eax,-0x4c(%rbp)
ffffffff8010470c:	8b 45 b4             	mov    -0x4c(%rbp),%eax
ffffffff8010470f:	89 45 dc             	mov    %eax,-0x24(%rbp)
ffffffff80104712:	8b 45 dc             	mov    -0x24(%rbp),%eax
ffffffff80104715:	c7 45 d8 33 00 00 00 	movl   $0x33,-0x28(%rbp)
ffffffff8010471c:	c7 45 d4 0c 00 00 00 	movl   $0xc,-0x2c(%rbp)
ffffffff80104723:	8b 4d d8             	mov    -0x28(%rbp),%ecx
ffffffff80104726:	3b 4d d4             	cmp    -0x2c(%rbp),%ecx
ffffffff80104729:	89 45 b0             	mov    %eax,-0x50(%rbp)
ffffffff8010472c:	0f 8f 0b 00 00 00    	jg     ffffffff8010473d <freevm_pgdir+0xad>
ffffffff80104732:	8b 45 d8             	mov    -0x28(%rbp),%eax
ffffffff80104735:	89 45 ac             	mov    %eax,-0x54(%rbp)
ffffffff80104738:	e9 06 00 00 00       	jmpq   ffffffff80104743 <freevm_pgdir+0xb3>
ffffffff8010473d:	8b 45 d4             	mov    -0x2c(%rbp),%eax
ffffffff80104740:	89 45 ac             	mov    %eax,-0x54(%rbp)
ffffffff80104743:	8b 45 ac             	mov    -0x54(%rbp),%eax
ffffffff80104746:	b9 01 00 00 00       	mov    $0x1,%ecx
ffffffff8010474b:	89 ca                	mov    %ecx,%edx
ffffffff8010474d:	89 45 d0             	mov    %eax,-0x30(%rbp)
ffffffff80104750:	8b 45 b0             	mov    -0x50(%rbp),%eax
ffffffff80104753:	2b 45 d0             	sub    -0x30(%rbp),%eax
ffffffff80104756:	89 c0                	mov    %eax,%eax
ffffffff80104758:	89 c1                	mov    %eax,%ecx
ffffffff8010475a:	48 d3 e2             	shl    %cl,%rdx
ffffffff8010475d:	48 c1 e2 01          	shl    $0x1,%rdx
ffffffff80104761:	48 83 ea 01          	sub    $0x1,%rdx
ffffffff80104765:	c7 45 cc 33 00 00 00 	movl   $0x33,-0x34(%rbp)
ffffffff8010476c:	c7 45 c8 0c 00 00 00 	movl   $0xc,-0x38(%rbp)
ffffffff80104773:	8b 45 cc             	mov    -0x34(%rbp),%eax
ffffffff80104776:	3b 45 c8             	cmp    -0x38(%rbp),%eax
ffffffff80104779:	48 89 55 a0          	mov    %rdx,-0x60(%rbp)
ffffffff8010477d:	0f 8f 0b 00 00 00    	jg     ffffffff8010478e <freevm_pgdir+0xfe>
ffffffff80104783:	8b 45 cc             	mov    -0x34(%rbp),%eax
ffffffff80104786:	89 45 9c             	mov    %eax,-0x64(%rbp)
ffffffff80104789:	e9 06 00 00 00       	jmpq   ffffffff80104794 <freevm_pgdir+0x104>
ffffffff8010478e:	8b 45 c8             	mov    -0x38(%rbp),%eax
ffffffff80104791:	89 45 9c             	mov    %eax,-0x64(%rbp)
ffffffff80104794:	8b 45 9c             	mov    -0x64(%rbp),%eax
ffffffff80104797:	89 45 c4             	mov    %eax,-0x3c(%rbp)
ffffffff8010479a:	8b 45 c4             	mov    -0x3c(%rbp),%eax
ffffffff8010479d:	89 c1                	mov    %eax,%ecx
ffffffff8010479f:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
ffffffff801047a3:	48 d3 e2             	shl    %cl,%rdx
ffffffff801047a6:	48 8b 75 b8          	mov    -0x48(%rbp),%rsi
ffffffff801047aa:	48 21 d6             	and    %rdx,%rsi
ffffffff801047ad:	48 81 c6 00 00 00 80 	add    $0xffffffff80000000,%rsi
ffffffff801047b4:	48 89 75 e8          	mov    %rsi,-0x18(%rbp)
      kfree(v);
ffffffff801047b8:	48 8b 7d e8          	mov    -0x18(%rbp),%rdi
ffffffff801047bc:	e8 af bd ff ff       	callq  ffffffff80100570 <kfree>
    }
  }
ffffffff801047c1:	e9 00 00 00 00       	jmpq   ffffffff801047c6 <freevm_pgdir+0x136>
  for (i = 0; i < PTRS_PER_PD; i++) {
ffffffff801047c6:	8b 45 f4             	mov    -0xc(%rbp),%eax
ffffffff801047c9:	83 c0 01             	add    $0x1,%eax
ffffffff801047cc:	89 45 f4             	mov    %eax,-0xc(%rbp)
ffffffff801047cf:	e9 cf fe ff ff       	jmpq   ffffffff801046a3 <freevm_pgdir+0x13>
  kfree((char*) pgdir);
ffffffff801047d4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
ffffffff801047d8:	48 89 c7             	mov    %rax,%rdi
ffffffff801047db:	e8 90 bd ff ff       	callq  ffffffff80100570 <kfree>
}
ffffffff801047e0:	48 83 c4 70          	add    $0x70,%rsp
ffffffff801047e4:	5d                   	pop    %rbp
ffffffff801047e5:	c3                   	retq   
ffffffff801047e6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
ffffffff801047ed:	00 00 00 

ffffffff801047f0 <freevm_pdpt>:

void
freevm_pdpt(pdpte_t *pdpt)
{
ffffffff801047f0:	55                   	push   %rbp
ffffffff801047f1:	48 89 e5             	mov    %rsp,%rbp
ffffffff801047f4:	48 83 ec 70          	sub    $0x70,%rsp
ffffffff801047f8:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  uint i;
  for (i = 0; i < PTRS_PER_PDPT; i++) {
ffffffff801047fc:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)
ffffffff80104803:	8b 45 f4             	mov    -0xc(%rbp),%eax
ffffffff80104806:	89 c1                	mov    %eax,%ecx
ffffffff80104808:	48 81 f9 00 02 00 00 	cmp    $0x200,%rcx
ffffffff8010480f:	0f 83 1f 01 00 00    	jae    ffffffff80104934 <freevm_pdpt+0x144>
    if (pdpt[i] & PTE_P) {
ffffffff80104815:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
ffffffff80104819:	8b 4d f4             	mov    -0xc(%rbp),%ecx
ffffffff8010481c:	89 ca                	mov    %ecx,%edx
ffffffff8010481e:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
ffffffff80104822:	48 83 e0 01          	and    $0x1,%rax
ffffffff80104826:	48 83 f8 00          	cmp    $0x0,%rax
ffffffff8010482a:	0f 84 f1 00 00 00    	je     ffffffff80104921 <freevm_pdpt+0x131>
      pde_t *pgdir = P2V(PDE_ADDR(pdpt[i]));
ffffffff80104830:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
ffffffff80104834:	8b 4d f4             	mov    -0xc(%rbp),%ecx
ffffffff80104837:	89 ca                	mov    %ecx,%edx
ffffffff80104839:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
ffffffff8010483d:	c7 45 e4 33 00 00 00 	movl   $0x33,-0x1c(%rbp)
ffffffff80104844:	c7 45 e0 0c 00 00 00 	movl   $0xc,-0x20(%rbp)
ffffffff8010484b:	8b 4d e4             	mov    -0x1c(%rbp),%ecx
ffffffff8010484e:	3b 4d e0             	cmp    -0x20(%rbp),%ecx
ffffffff80104851:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
ffffffff80104855:	0f 8c 0b 00 00 00    	jl     ffffffff80104866 <freevm_pdpt+0x76>
ffffffff8010485b:	8b 45 e4             	mov    -0x1c(%rbp),%eax
ffffffff8010485e:	89 45 b4             	mov    %eax,-0x4c(%rbp)
ffffffff80104861:	e9 06 00 00 00       	jmpq   ffffffff8010486c <freevm_pdpt+0x7c>
ffffffff80104866:	8b 45 e0             	mov    -0x20(%rbp),%eax
ffffffff80104869:	89 45 b4             	mov    %eax,-0x4c(%rbp)
ffffffff8010486c:	8b 45 b4             	mov    -0x4c(%rbp),%eax
ffffffff8010486f:	89 45 dc             	mov    %eax,-0x24(%rbp)
ffffffff80104872:	8b 45 dc             	mov    -0x24(%rbp),%eax
ffffffff80104875:	c7 45 d8 33 00 00 00 	movl   $0x33,-0x28(%rbp)
ffffffff8010487c:	c7 45 d4 0c 00 00 00 	movl   $0xc,-0x2c(%rbp)
ffffffff80104883:	8b 4d d8             	mov    -0x28(%rbp),%ecx
ffffffff80104886:	3b 4d d4             	cmp    -0x2c(%rbp),%ecx
ffffffff80104889:	89 45 b0             	mov    %eax,-0x50(%rbp)
ffffffff8010488c:	0f 8f 0b 00 00 00    	jg     ffffffff8010489d <freevm_pdpt+0xad>
ffffffff80104892:	8b 45 d8             	mov    -0x28(%rbp),%eax
ffffffff80104895:	89 45 ac             	mov    %eax,-0x54(%rbp)
ffffffff80104898:	e9 06 00 00 00       	jmpq   ffffffff801048a3 <freevm_pdpt+0xb3>
ffffffff8010489d:	8b 45 d4             	mov    -0x2c(%rbp),%eax
ffffffff801048a0:	89 45 ac             	mov    %eax,-0x54(%rbp)
ffffffff801048a3:	8b 45 ac             	mov    -0x54(%rbp),%eax
ffffffff801048a6:	b9 01 00 00 00       	mov    $0x1,%ecx
ffffffff801048ab:	89 ca                	mov    %ecx,%edx
ffffffff801048ad:	89 45 d0             	mov    %eax,-0x30(%rbp)
ffffffff801048b0:	8b 45 b0             	mov    -0x50(%rbp),%eax
ffffffff801048b3:	2b 45 d0             	sub    -0x30(%rbp),%eax
ffffffff801048b6:	89 c0                	mov    %eax,%eax
ffffffff801048b8:	89 c1                	mov    %eax,%ecx
ffffffff801048ba:	48 d3 e2             	shl    %cl,%rdx
ffffffff801048bd:	48 c1 e2 01          	shl    $0x1,%rdx
ffffffff801048c1:	48 83 ea 01          	sub    $0x1,%rdx
ffffffff801048c5:	c7 45 cc 33 00 00 00 	movl   $0x33,-0x34(%rbp)
ffffffff801048cc:	c7 45 c8 0c 00 00 00 	movl   $0xc,-0x38(%rbp)
ffffffff801048d3:	8b 45 cc             	mov    -0x34(%rbp),%eax
ffffffff801048d6:	3b 45 c8             	cmp    -0x38(%rbp),%eax
ffffffff801048d9:	48 89 55 a0          	mov    %rdx,-0x60(%rbp)
ffffffff801048dd:	0f 8f 0b 00 00 00    	jg     ffffffff801048ee <freevm_pdpt+0xfe>
ffffffff801048e3:	8b 45 cc             	mov    -0x34(%rbp),%eax
ffffffff801048e6:	89 45 9c             	mov    %eax,-0x64(%rbp)
ffffffff801048e9:	e9 06 00 00 00       	jmpq   ffffffff801048f4 <freevm_pdpt+0x104>
ffffffff801048ee:	8b 45 c8             	mov    -0x38(%rbp),%eax
ffffffff801048f1:	89 45 9c             	mov    %eax,-0x64(%rbp)
ffffffff801048f4:	8b 45 9c             	mov    -0x64(%rbp),%eax
ffffffff801048f7:	89 45 c4             	mov    %eax,-0x3c(%rbp)
ffffffff801048fa:	8b 45 c4             	mov    -0x3c(%rbp),%eax
ffffffff801048fd:	89 c1                	mov    %eax,%ecx
ffffffff801048ff:	48 8b 55 a0          	mov    -0x60(%rbp),%rdx
ffffffff80104903:	48 d3 e2             	shl    %cl,%rdx
ffffffff80104906:	48 8b 75 b8          	mov    -0x48(%rbp),%rsi
ffffffff8010490a:	48 21 d6             	and    %rdx,%rsi
ffffffff8010490d:	48 81 c6 00 00 00 80 	add    $0xffffffff80000000,%rsi
ffffffff80104914:	48 89 75 e8          	mov    %rsi,-0x18(%rbp)
      freevm_pgdir(pgdir);
ffffffff80104918:	48 8b 7d e8          	mov    -0x18(%rbp),%rdi
ffffffff8010491c:	e8 6f fd ff ff       	callq  ffffffff80104690 <freevm_pgdir>
    }
  }
ffffffff80104921:	e9 00 00 00 00       	jmpq   ffffffff80104926 <freevm_pdpt+0x136>
  for (i = 0; i < PTRS_PER_PDPT; i++) {
ffffffff80104926:	8b 45 f4             	mov    -0xc(%rbp),%eax
ffffffff80104929:	83 c0 01             	add    $0x1,%eax
ffffffff8010492c:	89 45 f4             	mov    %eax,-0xc(%rbp)
ffffffff8010492f:	e9 cf fe ff ff       	jmpq   ffffffff80104803 <freevm_pdpt+0x13>
  kfree((char*) pdpt);
ffffffff80104934:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
ffffffff80104938:	48 89 c7             	mov    %rax,%rdi
ffffffff8010493b:	e8 30 bc ff ff       	callq  ffffffff80100570 <kfree>
}
ffffffff80104940:	48 83 c4 70          	add    $0x70,%rsp
ffffffff80104944:	5d                   	pop    %rbp
ffffffff80104945:	c3                   	retq   
ffffffff80104946:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
ffffffff8010494d:	00 00 00 

ffffffff80104950 <freevm>:

// Free a page table and all the physical memory pages
// in the user part.
void
freevm(pml4e_t *pml4, int pid)
{
ffffffff80104950:	55                   	push   %rbp
ffffffff80104951:	48 89 e5             	mov    %rsp,%rbp
ffffffff80104954:	48 81 ec 90 00 00 00 	sub    $0x90,%rsp
ffffffff8010495b:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
ffffffff8010495f:	89 75 f4             	mov    %esi,-0xc(%rbp)
  uint i;

  if(pml4 == 0)
ffffffff80104962:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
ffffffff80104967:	0f 85 0c 00 00 00    	jne    ffffffff80104979 <freevm+0x29>
    panic("freevm: no pml4");
ffffffff8010496d:	48 c7 c7 2d fe 10 80 	mov    $0xffffffff8010fe2d,%rdi
ffffffff80104974:	e8 f7 c4 ff ff       	callq  ffffffff80100e70 <panic>
ffffffff80104979:	31 c0                	xor    %eax,%eax
ffffffff8010497b:	89 c1                	mov    %eax,%ecx
ffffffff8010497d:	48 ba 00 00 00 00 01 	movabs $0x100000000,%rdx
ffffffff80104984:	00 00 00 

  deallocuvm(pml4, 0, SZ_4G, 0, pid);
ffffffff80104987:	48 8b 7d f8          	mov    -0x8(%rbp),%rdi
ffffffff8010498b:	44 8b 45 f4          	mov    -0xc(%rbp),%r8d
ffffffff8010498f:	31 c0                	xor    %eax,%eax
ffffffff80104991:	89 c6                	mov    %eax,%esi
ffffffff80104993:	49 b9 00 00 00 00 01 	movabs $0x100000000,%r9
ffffffff8010499a:	00 00 00 
ffffffff8010499d:	48 89 75 b8          	mov    %rsi,-0x48(%rbp)
ffffffff801049a1:	48 89 55 b0          	mov    %rdx,-0x50(%rbp)
ffffffff801049a5:	4c 89 ca             	mov    %r9,%rdx
ffffffff801049a8:	4c 8b 4d b8          	mov    -0x48(%rbp),%r9
ffffffff801049ac:	48 89 4d a8          	mov    %rcx,-0x58(%rbp)
ffffffff801049b0:	4c 89 c9             	mov    %r9,%rcx
ffffffff801049b3:	e8 b8 f4 ff ff       	callq  ffffffff80103e70 <deallocuvm>
  for(i = 0; i < PTRS_PER_PML4; i++){
ffffffff801049b8:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%rbp)
ffffffff801049bf:	89 45 a4             	mov    %eax,-0x5c(%rbp)
ffffffff801049c2:	8b 45 f0             	mov    -0x10(%rbp),%eax
ffffffff801049c5:	89 c1                	mov    %eax,%ecx
ffffffff801049c7:	48 81 f9 00 02 00 00 	cmp    $0x200,%rcx
ffffffff801049ce:	0f 83 28 01 00 00    	jae    ffffffff80104afc <freevm+0x1ac>
    if(pml4[i] & PTE_P){
ffffffff801049d4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
ffffffff801049d8:	8b 4d f0             	mov    -0x10(%rbp),%ecx
ffffffff801049db:	89 ca                	mov    %ecx,%edx
ffffffff801049dd:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
ffffffff801049e1:	48 83 e0 01          	and    $0x1,%rax
ffffffff801049e5:	48 83 f8 00          	cmp    $0x0,%rax
ffffffff801049e9:	0f 84 fa 00 00 00    	je     ffffffff80104ae9 <freevm+0x199>
      pdpte_t *pdpt = P2V(PDPT_ADDR(pml4[i]));
ffffffff801049ef:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
ffffffff801049f3:	8b 4d f0             	mov    -0x10(%rbp),%ecx
ffffffff801049f6:	89 ca                	mov    %ecx,%edx
ffffffff801049f8:	48 8b 04 d0          	mov    (%rax,%rdx,8),%rax
ffffffff801049fc:	c7 45 e4 33 00 00 00 	movl   $0x33,-0x1c(%rbp)
ffffffff80104a03:	c7 45 e0 0c 00 00 00 	movl   $0xc,-0x20(%rbp)
ffffffff80104a0a:	8b 4d e4             	mov    -0x1c(%rbp),%ecx
ffffffff80104a0d:	3b 4d e0             	cmp    -0x20(%rbp),%ecx
ffffffff80104a10:	48 89 45 98          	mov    %rax,-0x68(%rbp)
ffffffff80104a14:	0f 8c 0b 00 00 00    	jl     ffffffff80104a25 <freevm+0xd5>
ffffffff80104a1a:	8b 45 e4             	mov    -0x1c(%rbp),%eax
ffffffff80104a1d:	89 45 94             	mov    %eax,-0x6c(%rbp)
ffffffff80104a20:	e9 06 00 00 00       	jmpq   ffffffff80104a2b <freevm+0xdb>
ffffffff80104a25:	8b 45 e0             	mov    -0x20(%rbp),%eax
ffffffff80104a28:	89 45 94             	mov    %eax,-0x6c(%rbp)
ffffffff80104a2b:	8b 45 94             	mov    -0x6c(%rbp),%eax
ffffffff80104a2e:	89 45 dc             	mov    %eax,-0x24(%rbp)
ffffffff80104a31:	8b 45 dc             	mov    -0x24(%rbp),%eax
ffffffff80104a34:	c7 45 d8 33 00 00 00 	movl   $0x33,-0x28(%rbp)
ffffffff80104a3b:	c7 45 d4 0c 00 00 00 	movl   $0xc,-0x2c(%rbp)
ffffffff80104a42:	8b 4d d8             	mov    -0x28(%rbp),%ecx
ffffffff80104a45:	3b 4d d4             	cmp    -0x2c(%rbp),%ecx
ffffffff80104a48:	89 45 90             	mov    %eax,-0x70(%rbp)
ffffffff80104a4b:	0f 8f 0b 00 00 00    	jg     ffffffff80104a5c <freevm+0x10c>
ffffffff80104a51:	8b 45 d8             	mov    -0x28(%rbp),%eax
ffffffff80104a54:	89 45 8c             	mov    %eax,-0x74(%rbp)
ffffffff80104a57:	e9 06 00 00 00       	jmpq   ffffffff80104a62 <freevm+0x112>
ffffffff80104a5c:	8b 45 d4             	mov    -0x2c(%rbp),%eax
ffffffff80104a5f:	89 45 8c             	mov    %eax,-0x74(%rbp)
ffffffff80104a62:	8b 45 8c             	mov    -0x74(%rbp),%eax
ffffffff80104a65:	b9 01 00 00 00       	mov    $0x1,%ecx
ffffffff80104a6a:	89 ca                	mov    %ecx,%edx
ffffffff80104a6c:	89 45 d0             	mov    %eax,-0x30(%rbp)
ffffffff80104a6f:	8b 45 90             	mov    -0x70(%rbp),%eax
ffffffff80104a72:	2b 45 d0             	sub    -0x30(%rbp),%eax
ffffffff80104a75:	89 c0                	mov    %eax,%eax
ffffffff80104a77:	89 c1                	mov    %eax,%ecx
ffffffff80104a79:	48 d3 e2             	shl    %cl,%rdx
ffffffff80104a7c:	48 c1 e2 01          	shl    $0x1,%rdx
ffffffff80104a80:	48 83 ea 01          	sub    $0x1,%rdx
ffffffff80104a84:	c7 45 cc 33 00 00 00 	movl   $0x33,-0x34(%rbp)
ffffffff80104a8b:	c7 45 c8 0c 00 00 00 	movl   $0xc,-0x38(%rbp)
ffffffff80104a92:	8b 45 cc             	mov    -0x34(%rbp),%eax
ffffffff80104a95:	3b 45 c8             	cmp    -0x38(%rbp),%eax
ffffffff80104a98:	48 89 55 80          	mov    %rdx,-0x80(%rbp)
ffffffff80104a9c:	0f 8f 0e 00 00 00    	jg     ffffffff80104ab0 <freevm+0x160>
ffffffff80104aa2:	8b 45 cc             	mov    -0x34(%rbp),%eax
ffffffff80104aa5:	89 85 7c ff ff ff    	mov    %eax,-0x84(%rbp)
ffffffff80104aab:	e9 09 00 00 00       	jmpq   ffffffff80104ab9 <freevm+0x169>
ffffffff80104ab0:	8b 45 c8             	mov    -0x38(%rbp),%eax
ffffffff80104ab3:	89 85 7c ff ff ff    	mov    %eax,-0x84(%rbp)
ffffffff80104ab9:	8b 85 7c ff ff ff    	mov    -0x84(%rbp),%eax
ffffffff80104abf:	89 45 c4             	mov    %eax,-0x3c(%rbp)
ffffffff80104ac2:	8b 45 c4             	mov    -0x3c(%rbp),%eax
ffffffff80104ac5:	89 c1                	mov    %eax,%ecx
ffffffff80104ac7:	48 8b 55 80          	mov    -0x80(%rbp),%rdx
ffffffff80104acb:	48 d3 e2             	shl    %cl,%rdx
ffffffff80104ace:	48 8b 75 98          	mov    -0x68(%rbp),%rsi
ffffffff80104ad2:	48 21 d6             	and    %rdx,%rsi
ffffffff80104ad5:	48 81 c6 00 00 00 80 	add    $0xffffffff80000000,%rsi
ffffffff80104adc:	48 89 75 e8          	mov    %rsi,-0x18(%rbp)
      freevm_pdpt(pdpt);
ffffffff80104ae0:	48 8b 7d e8          	mov    -0x18(%rbp),%rdi
ffffffff80104ae4:	e8 07 fd ff ff       	callq  ffffffff801047f0 <freevm_pdpt>
    }
  }
ffffffff80104ae9:	e9 00 00 00 00       	jmpq   ffffffff80104aee <freevm+0x19e>
  for(i = 0; i < PTRS_PER_PML4; i++){
ffffffff80104aee:	8b 45 f0             	mov    -0x10(%rbp),%eax
ffffffff80104af1:	83 c0 01             	add    $0x1,%eax
ffffffff80104af4:	89 45 f0             	mov    %eax,-0x10(%rbp)
ffffffff80104af7:	e9 c6 fe ff ff       	jmpq   ffffffff801049c2 <freevm+0x72>
  kfree((char*)pml4);
ffffffff80104afc:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
ffffffff80104b00:	48 89 c7             	mov    %rax,%rdi
ffffffff80104b03:	e8 68 ba ff ff       	callq  ffffffff80100570 <kfree>
}
ffffffff80104b08:	48 81 c4 90 00 00 00 	add    $0x90,%rsp
ffffffff80104b0f:	5d                   	pop    %rbp
ffffffff80104b10:	c3                   	retq   
ffffffff80104b11:	66 66 66 66 66 66 2e 	data16 data16 data16 data16 data16 nopw %cs:0x0(%rax,%rax,1)
ffffffff80104b18:	0f 1f 84 00 00 00 00 
ffffffff80104b1f:	00 

ffffffff80104b20 <copy_mem_region>:

int
copy_mem_region(pml4e_t *oldpml4, pml4e_t *newpml4, struct mem_region *region, int newpid,
 bool shallow)
{
ffffffff80104b20:	55                   	push   %rbp
ffffffff80104b21:	48 89 e5             	mov    %rsp,%rbp
ffffffff80104b24:	48 81 ec 30 01 00 00 	sub    $0x130,%rsp
ffffffff80104b2b:	44 88 c0             	mov    %r8b,%al
ffffffff80104b2e:	48 89 7d f0          	mov    %rdi,-0x10(%rbp)
ffffffff80104b32:	48 89 75 e8          	mov    %rsi,-0x18(%rbp)
ffffffff80104b36:	48 89 55 e0          	mov    %rdx,-0x20(%rbp)
ffffffff80104b3a:	89 4d dc             	mov    %ecx,-0x24(%rbp)
ffffffff80104b3d:	24 01                	and    $0x1,%al
ffffffff80104b3f:	88 45 db             	mov    %al,-0x25(%rbp)
  pte_t *pte;
  uint64_t pa, i, flags;
  char *mem;

  uint64_t start = (uint64_t)region->start;
ffffffff80104b42:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
ffffffff80104b46:	48 8b 12             	mov    (%rdx),%rdx
ffffffff80104b49:	48 89 55 a8          	mov    %rdx,-0x58(%rbp)
  uint64_t end = (uint64_t)region->start + region->size;
ffffffff80104b4d:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
ffffffff80104b51:	48 8b 12             	mov    (%rdx),%rdx
ffffffff80104b54:	48 8b 75 e0          	mov    -0x20(%rbp),%rsi
ffffffff80104b58:	48 03 56 08          	add    0x8(%rsi),%rdx
ffffffff80104b5c:	48 89 55 a0          	mov    %rdx,-0x60(%rbp)
  for(i = start; i < end; i += PGSIZE){
ffffffff80104b60:	48 8b 55 a8          	mov    -0x58(%rbp),%rdx
ffffffff80104b64:	48 89 55 c0          	mov    %rdx,-0x40(%rbp)
ffffffff80104b68:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
ffffffff80104b6c:	48 3b 45 a0          	cmp    -0x60(%rbp),%rax
ffffffff80104b70:	0f 83 45 04 00 00    	jae    ffffffff80104fbb <copy_mem_region+0x49b>
ffffffff80104b76:	31 c0                	xor    %eax,%eax
    if((pte = walkpml4(oldpml4, (void *) i, 0)) == 0)
ffffffff80104b78:	48 8b 7d f0          	mov    -0x10(%rbp),%rdi
ffffffff80104b7c:	48 8b 75 c0          	mov    -0x40(%rbp),%rsi
ffffffff80104b80:	31 d2                	xor    %edx,%edx
ffffffff80104b82:	89 85 40 ff ff ff    	mov    %eax,-0xc0(%rbp)
ffffffff80104b88:	e8 e3 e0 ff ff       	callq  ffffffff80102c70 <walkpml4>
ffffffff80104b8d:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
ffffffff80104b91:	48 83 f8 00          	cmp    $0x0,%rax
ffffffff80104b95:	0f 85 0c 00 00 00    	jne    ffffffff80104ba7 <copy_mem_region+0x87>
      panic("copy_mem_region: pte should exist");
ffffffff80104b9b:	48 c7 c7 3d fe 10 80 	mov    $0xffffffff8010fe3d,%rdi
ffffffff80104ba2:	e8 c9 c2 ff ff       	callq  ffffffff80100e70 <panic>
    if(!(*pte & PTE_P))
ffffffff80104ba7:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
ffffffff80104bab:	48 8b 00             	mov    (%rax),%rax
ffffffff80104bae:	48 83 e0 01          	and    $0x1,%rax
ffffffff80104bb2:	48 83 f8 00          	cmp    $0x0,%rax
ffffffff80104bb6:	0f 85 0c 00 00 00    	jne    ffffffff80104bc8 <copy_mem_region+0xa8>
      panic("copy_mem_region: page not present");
ffffffff80104bbc:	48 c7 c7 5f fe 10 80 	mov    $0xffffffff8010fe5f,%rdi
ffffffff80104bc3:	e8 a8 c2 ff ff       	callq  ffffffff80100e70 <panic>
    pa = PTE_ADDR(*pte);
ffffffff80104bc8:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
ffffffff80104bcc:	48 8b 00             	mov    (%rax),%rax
ffffffff80104bcf:	c7 45 9c 33 00 00 00 	movl   $0x33,-0x64(%rbp)
ffffffff80104bd6:	c7 45 98 0c 00 00 00 	movl   $0xc,-0x68(%rbp)
ffffffff80104bdd:	8b 4d 9c             	mov    -0x64(%rbp),%ecx
ffffffff80104be0:	3b 4d 98             	cmp    -0x68(%rbp),%ecx
ffffffff80104be3:	48 89 85 38 ff ff ff 	mov    %rax,-0xc8(%rbp)
ffffffff80104bea:	0f 8c 0e 00 00 00    	jl     ffffffff80104bfe <copy_mem_region+0xde>
ffffffff80104bf0:	8b 45 9c             	mov    -0x64(%rbp),%eax
ffffffff80104bf3:	89 85 34 ff ff ff    	mov    %eax,-0xcc(%rbp)
ffffffff80104bf9:	e9 09 00 00 00       	jmpq   ffffffff80104c07 <copy_mem_region+0xe7>
ffffffff80104bfe:	8b 45 98             	mov    -0x68(%rbp),%eax
ffffffff80104c01:	89 85 34 ff ff ff    	mov    %eax,-0xcc(%rbp)
ffffffff80104c07:	8b 85 34 ff ff ff    	mov    -0xcc(%rbp),%eax
ffffffff80104c0d:	89 45 94             	mov    %eax,-0x6c(%rbp)
ffffffff80104c10:	8b 45 94             	mov    -0x6c(%rbp),%eax
ffffffff80104c13:	c7 45 90 33 00 00 00 	movl   $0x33,-0x70(%rbp)
ffffffff80104c1a:	c7 45 8c 0c 00 00 00 	movl   $0xc,-0x74(%rbp)
ffffffff80104c21:	8b 4d 90             	mov    -0x70(%rbp),%ecx
ffffffff80104c24:	3b 4d 8c             	cmp    -0x74(%rbp),%ecx
ffffffff80104c27:	89 85 30 ff ff ff    	mov    %eax,-0xd0(%rbp)
ffffffff80104c2d:	0f 8f 0e 00 00 00    	jg     ffffffff80104c41 <copy_mem_region+0x121>
ffffffff80104c33:	8b 45 90             	mov    -0x70(%rbp),%eax
ffffffff80104c36:	89 85 2c ff ff ff    	mov    %eax,-0xd4(%rbp)
ffffffff80104c3c:	e9 09 00 00 00       	jmpq   ffffffff80104c4a <copy_mem_region+0x12a>
ffffffff80104c41:	8b 45 8c             	mov    -0x74(%rbp),%eax
ffffffff80104c44:	89 85 2c ff ff ff    	mov    %eax,-0xd4(%rbp)
ffffffff80104c4a:	8b 85 2c ff ff ff    	mov    -0xd4(%rbp),%eax
ffffffff80104c50:	b9 01 00 00 00       	mov    $0x1,%ecx
ffffffff80104c55:	89 ca                	mov    %ecx,%edx
ffffffff80104c57:	89 45 88             	mov    %eax,-0x78(%rbp)
ffffffff80104c5a:	8b 85 30 ff ff ff    	mov    -0xd0(%rbp),%eax
ffffffff80104c60:	2b 45 88             	sub    -0x78(%rbp),%eax
ffffffff80104c63:	89 c0                	mov    %eax,%eax
ffffffff80104c65:	89 c1                	mov    %eax,%ecx
ffffffff80104c67:	48 d3 e2             	shl    %cl,%rdx
ffffffff80104c6a:	48 c1 e2 01          	shl    $0x1,%rdx
ffffffff80104c6e:	48 83 ea 01          	sub    $0x1,%rdx
ffffffff80104c72:	c7 45 84 33 00 00 00 	movl   $0x33,-0x7c(%rbp)
ffffffff80104c79:	c7 45 80 0c 00 00 00 	movl   $0xc,-0x80(%rbp)
ffffffff80104c80:	8b 45 84             	mov    -0x7c(%rbp),%eax
ffffffff80104c83:	3b 45 80             	cmp    -0x80(%rbp),%eax
ffffffff80104c86:	48 89 95 20 ff ff ff 	mov    %rdx,-0xe0(%rbp)
ffffffff80104c8d:	0f 8f 0e 00 00 00    	jg     ffffffff80104ca1 <copy_mem_region+0x181>
ffffffff80104c93:	8b 45 84             	mov    -0x7c(%rbp),%eax
ffffffff80104c96:	89 85 1c ff ff ff    	mov    %eax,-0xe4(%rbp)
ffffffff80104c9c:	e9 09 00 00 00       	jmpq   ffffffff80104caa <copy_mem_region+0x18a>
ffffffff80104ca1:	8b 45 80             	mov    -0x80(%rbp),%eax
ffffffff80104ca4:	89 85 1c ff ff ff    	mov    %eax,-0xe4(%rbp)
ffffffff80104caa:	8b 85 1c ff ff ff    	mov    -0xe4(%rbp),%eax
ffffffff80104cb0:	89 85 7c ff ff ff    	mov    %eax,-0x84(%rbp)
ffffffff80104cb6:	8b 85 7c ff ff ff    	mov    -0x84(%rbp),%eax
ffffffff80104cbc:	89 c1                	mov    %eax,%ecx
ffffffff80104cbe:	48 8b 95 20 ff ff ff 	mov    -0xe0(%rbp),%rdx
ffffffff80104cc5:	48 d3 e2             	shl    %cl,%rdx
ffffffff80104cc8:	48 8b b5 38 ff ff ff 	mov    -0xc8(%rbp),%rsi
ffffffff80104ccf:	48 21 d6             	and    %rdx,%rsi
ffffffff80104cd2:	48 89 75 c8          	mov    %rsi,-0x38(%rbp)
    flags = PTE_FLAGS(*pte);
ffffffff80104cd6:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
ffffffff80104cda:	48 8b 12             	mov    (%rdx),%rdx
ffffffff80104cdd:	48 81 e2 ff 0f 00 00 	and    $0xfff,%rdx
ffffffff80104ce4:	48 89 55 b8          	mov    %rdx,-0x48(%rbp)

    uint64_t phys_destination;

    if (shallow) {
ffffffff80104ce8:	f6 45 db 01          	testb  $0x1,-0x25(%rbp)
ffffffff80104cec:	0f 84 f1 01 00 00    	je     ffffffff80104ee3 <copy_mem_region+0x3c3>
      if (flags & PTE_S) {
ffffffff80104cf2:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
ffffffff80104cf6:	48 25 00 02 00 00    	and    $0x200,%rax
ffffffff80104cfc:	48 83 f8 00          	cmp    $0x0,%rax
ffffffff80104d00:	0f 84 93 01 00 00    	je     ffffffff80104e99 <copy_mem_region+0x379>
        uint64_t ppn = PTE_ADDR(*pte) >> PT_SHIFT;
ffffffff80104d06:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
ffffffff80104d0a:	48 8b 00             	mov    (%rax),%rax
ffffffff80104d0d:	c7 85 64 ff ff ff 33 	movl   $0x33,-0x9c(%rbp)
ffffffff80104d14:	00 00 00 
ffffffff80104d17:	c7 85 60 ff ff ff 0c 	movl   $0xc,-0xa0(%rbp)
ffffffff80104d1e:	00 00 00 
ffffffff80104d21:	8b 8d 64 ff ff ff    	mov    -0x9c(%rbp),%ecx
ffffffff80104d27:	3b 8d 60 ff ff ff    	cmp    -0xa0(%rbp),%ecx
ffffffff80104d2d:	48 89 85 10 ff ff ff 	mov    %rax,-0xf0(%rbp)
ffffffff80104d34:	0f 8c 11 00 00 00    	jl     ffffffff80104d4b <copy_mem_region+0x22b>
ffffffff80104d3a:	8b 85 64 ff ff ff    	mov    -0x9c(%rbp),%eax
ffffffff80104d40:	89 85 0c ff ff ff    	mov    %eax,-0xf4(%rbp)
ffffffff80104d46:	e9 0c 00 00 00       	jmpq   ffffffff80104d57 <copy_mem_region+0x237>
ffffffff80104d4b:	8b 85 60 ff ff ff    	mov    -0xa0(%rbp),%eax
ffffffff80104d51:	89 85 0c ff ff ff    	mov    %eax,-0xf4(%rbp)
ffffffff80104d57:	8b 85 0c ff ff ff    	mov    -0xf4(%rbp),%eax
ffffffff80104d5d:	89 85 5c ff ff ff    	mov    %eax,-0xa4(%rbp)
ffffffff80104d63:	8b 85 5c ff ff ff    	mov    -0xa4(%rbp),%eax
ffffffff80104d69:	c7 85 58 ff ff ff 33 	movl   $0x33,-0xa8(%rbp)
ffffffff80104d70:	00 00 00 
ffffffff80104d73:	c7 85 54 ff ff ff 0c 	movl   $0xc,-0xac(%rbp)
ffffffff80104d7a:	00 00 00 
ffffffff80104d7d:	8b 8d 58 ff ff ff    	mov    -0xa8(%rbp),%ecx
ffffffff80104d83:	3b 8d 54 ff ff ff    	cmp    -0xac(%rbp),%ecx
ffffffff80104d89:	89 85 08 ff ff ff    	mov    %eax,-0xf8(%rbp)
ffffffff80104d8f:	0f 8f 11 00 00 00    	jg     ffffffff80104da6 <copy_mem_region+0x286>
ffffffff80104d95:	8b 85 58 ff ff ff    	mov    -0xa8(%rbp),%eax
ffffffff80104d9b:	89 85 04 ff ff ff    	mov    %eax,-0xfc(%rbp)
ffffffff80104da1:	e9 0c 00 00 00       	jmpq   ffffffff80104db2 <copy_mem_region+0x292>
ffffffff80104da6:	8b 85 54 ff ff ff    	mov    -0xac(%rbp),%eax
ffffffff80104dac:	89 85 04 ff ff ff    	mov    %eax,-0xfc(%rbp)
ffffffff80104db2:	8b 85 04 ff ff ff    	mov    -0xfc(%rbp),%eax
ffffffff80104db8:	b9 01 00 00 00       	mov    $0x1,%ecx
ffffffff80104dbd:	89 ca                	mov    %ecx,%edx
ffffffff80104dbf:	89 85 50 ff ff ff    	mov    %eax,-0xb0(%rbp)
ffffffff80104dc5:	8b 85 08 ff ff ff    	mov    -0xf8(%rbp),%eax
ffffffff80104dcb:	2b 85 50 ff ff ff    	sub    -0xb0(%rbp),%eax
ffffffff80104dd1:	89 c0                	mov    %eax,%eax
ffffffff80104dd3:	89 c1                	mov    %eax,%ecx
ffffffff80104dd5:	48 d3 e2             	shl    %cl,%rdx
ffffffff80104dd8:	48 c1 e2 01          	shl    $0x1,%rdx
ffffffff80104ddc:	48 83 ea 01          	sub    $0x1,%rdx
ffffffff80104de0:	c7 85 4c ff ff ff 33 	movl   $0x33,-0xb4(%rbp)
ffffffff80104de7:	00 00 00 
ffffffff80104dea:	c7 85 48 ff ff ff 0c 	movl   $0xc,-0xb8(%rbp)
ffffffff80104df1:	00 00 00 
ffffffff80104df4:	8b 85 4c ff ff ff    	mov    -0xb4(%rbp),%eax
ffffffff80104dfa:	3b 85 48 ff ff ff    	cmp    -0xb8(%rbp),%eax
ffffffff80104e00:	48 89 95 f8 fe ff ff 	mov    %rdx,-0x108(%rbp)
ffffffff80104e07:	0f 8f 11 00 00 00    	jg     ffffffff80104e1e <copy_mem_region+0x2fe>
ffffffff80104e0d:	8b 85 4c ff ff ff    	mov    -0xb4(%rbp),%eax
ffffffff80104e13:	89 85 f4 fe ff ff    	mov    %eax,-0x10c(%rbp)
ffffffff80104e19:	e9 0c 00 00 00       	jmpq   ffffffff80104e2a <copy_mem_region+0x30a>
ffffffff80104e1e:	8b 85 48 ff ff ff    	mov    -0xb8(%rbp),%eax
ffffffff80104e24:	89 85 f4 fe ff ff    	mov    %eax,-0x10c(%rbp)
ffffffff80104e2a:	8b 85 f4 fe ff ff    	mov    -0x10c(%rbp),%eax
ffffffff80104e30:	b9 00 20 00 00       	mov    $0x2000,%ecx
ffffffff80104e35:	89 ca                	mov    %ecx,%edx
ffffffff80104e37:	89 85 44 ff ff ff    	mov    %eax,-0xbc(%rbp)
ffffffff80104e3d:	8b 85 44 ff ff ff    	mov    -0xbc(%rbp),%eax
ffffffff80104e43:	89 c1                	mov    %eax,%ecx
ffffffff80104e45:	48 8b b5 f8 fe ff ff 	mov    -0x108(%rbp),%rsi
ffffffff80104e4c:	48 d3 e6             	shl    %cl,%rsi
ffffffff80104e4f:	48 8b bd 10 ff ff ff 	mov    -0xf0(%rbp),%rdi
ffffffff80104e56:	48 21 f7             	and    %rsi,%rdi
ffffffff80104e59:	48 c1 ef 0c          	shr    $0xc,%rdi
ffffffff80104e5d:	48 89 bd 68 ff ff ff 	mov    %rdi,-0x98(%rbp)
        if (8192 < ppn) panic("invalid ppn");
ffffffff80104e64:	48 3b 95 68 ff ff ff 	cmp    -0x98(%rbp),%rdx
ffffffff80104e6b:	0f 83 0c 00 00 00    	jae    ffffffff80104e7d <copy_mem_region+0x35d>
ffffffff80104e71:	48 c7 c7 81 fe 10 80 	mov    $0xffffffff8010fe81,%rdi
ffffffff80104e78:	e8 f3 bf ff ff       	callq  ffffffff80100e70 <panic>
        incr_swap_entry_ref(ppn);
ffffffff80104e7d:	48 8b bd 68 ff ff ff 	mov    -0x98(%rbp),%rdi
ffffffff80104e84:	e8 37 9a 00 00       	callq  ffffffff8010e8c0 <incr_swap_entry_ref>
        phys_destination = pa;
ffffffff80104e89:	48 8b 7d c8          	mov    -0x38(%rbp),%rdi
ffffffff80104e8d:	48 89 bd 70 ff ff ff 	mov    %rdi,-0x90(%rbp)
      } else {
ffffffff80104e94:	e9 45 00 00 00       	jmpq   ffffffff80104ede <copy_mem_region+0x3be>
        flags &= ~PTE_W;
ffffffff80104e99:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
ffffffff80104e9d:	48 83 e0 fd          	and    $0xfffffffffffffffd,%rax
ffffffff80104ea1:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
        flags |= PTE_RO;
ffffffff80104ea5:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
ffffffff80104ea9:	48 0d 00 08 00 00    	or     $0x800,%rax
ffffffff80104eaf:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
        *pte = PTE(pa, flags);
ffffffff80104eb3:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
ffffffff80104eb7:	48 0b 45 b8          	or     -0x48(%rbp),%rax
ffffffff80104ebb:	48 8b 4d d0          	mov    -0x30(%rbp),%rcx
ffffffff80104ebf:	48 89 01             	mov    %rax,(%rcx)
        phys_destination = pa;
ffffffff80104ec2:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
ffffffff80104ec6:	48 89 85 70 ff ff ff 	mov    %rax,-0x90(%rbp)
        core_map_ref_increment(pa2page(pa));
ffffffff80104ecd:	48 8b 7d c8          	mov    -0x38(%rbp),%rdi
ffffffff80104ed1:	e8 7a b2 ff ff       	callq  ffffffff80100150 <pa2page>
ffffffff80104ed6:	48 89 c7             	mov    %rax,%rdi
ffffffff80104ed9:	e8 82 b4 ff ff       	callq  ffffffff80100360 <core_map_ref_increment>
      }
    } else {
ffffffff80104ede:	e9 5f 00 00 00       	jmpq   ffffffff80104f42 <copy_mem_region+0x422>
      if((mem = kalloc()) == 0) {
ffffffff80104ee3:	e8 98 b8 ff ff       	callq  ffffffff80100780 <kalloc>
ffffffff80104ee8:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
ffffffff80104eec:	48 83 f8 00          	cmp    $0x0,%rax
ffffffff80104ef0:	0f 85 0c 00 00 00    	jne    ffffffff80104f02 <copy_mem_region+0x3e2>
        return -1;
ffffffff80104ef6:	c7 45 fc ff ff ff ff 	movl   $0xffffffff,-0x4(%rbp)
ffffffff80104efd:	e9 cd 00 00 00       	jmpq   ffffffff80104fcf <copy_mem_region+0x4af>
ffffffff80104f02:	b8 00 10 00 00       	mov    $0x1000,%eax
      }

      memmove(mem, (char*)P2V(pa), PGSIZE);
ffffffff80104f07:	48 8b 7d b0          	mov    -0x50(%rbp),%rdi
ffffffff80104f0b:	48 8b 4d c8          	mov    -0x38(%rbp),%rcx
ffffffff80104f0f:	48 81 c1 00 00 00 80 	add    $0xffffffff80000000,%rcx
ffffffff80104f16:	ba 00 10 00 00       	mov    $0x1000,%edx
ffffffff80104f1b:	48 89 ce             	mov    %rcx,%rsi
ffffffff80104f1e:	89 85 f0 fe ff ff    	mov    %eax,-0x110(%rbp)
ffffffff80104f24:	e8 67 61 00 00       	callq  ffffffff8010b090 <memmove>
      phys_destination = V2P(mem);
ffffffff80104f29:	48 8b 4d b0          	mov    -0x50(%rbp),%rcx
ffffffff80104f2d:	48 81 e9 00 00 00 80 	sub    $0xffffffff80000000,%rcx
ffffffff80104f34:	48 89 8d 70 ff ff ff 	mov    %rcx,-0x90(%rbp)
ffffffff80104f3b:	48 89 85 e8 fe ff ff 	mov    %rax,-0x118(%rbp)
ffffffff80104f42:	b8 01 00 00 00       	mov    $0x1,%eax
    }

    if (mappages(newpml4, i >> PT_SHIFT, 1, phys_destination >> PT_SHIFT,
ffffffff80104f47:	48 8b 7d e8          	mov    -0x18(%rbp),%rdi
ffffffff80104f4b:	48 8b 4d c0          	mov    -0x40(%rbp),%rcx
ffffffff80104f4f:	48 c1 e9 0c          	shr    $0xc,%rcx
ffffffff80104f53:	48 8b 95 70 ff ff ff 	mov    -0x90(%rbp),%rdx
ffffffff80104f5a:	48 c1 ea 0c          	shr    $0xc,%rdx
          flags, newpid) < 0) {
ffffffff80104f5e:	48 8b 75 b8          	mov    -0x48(%rbp),%rsi
ffffffff80104f62:	41 89 f0             	mov    %esi,%r8d
ffffffff80104f65:	44 8b 4d dc          	mov    -0x24(%rbp),%r9d
    if (mappages(newpml4, i >> PT_SHIFT, 1, phys_destination >> PT_SHIFT,
ffffffff80104f69:	41 ba 01 00 00 00    	mov    $0x1,%r10d
ffffffff80104f6f:	48 89 ce             	mov    %rcx,%rsi
ffffffff80104f72:	48 89 95 e0 fe ff ff 	mov    %rdx,-0x120(%rbp)
ffffffff80104f79:	44 89 d2             	mov    %r10d,%edx
ffffffff80104f7c:	48 8b 8d e0 fe ff ff 	mov    -0x120(%rbp),%rcx
ffffffff80104f83:	89 85 dc fe ff ff    	mov    %eax,-0x124(%rbp)
ffffffff80104f89:	e8 02 e3 ff ff       	callq  ffffffff80103290 <mappages>
          flags, newpid) < 0) {
ffffffff80104f8e:	83 f8 00             	cmp    $0x0,%eax
    if (mappages(newpml4, i >> PT_SHIFT, 1, phys_destination >> PT_SHIFT,
ffffffff80104f91:	0f 8d 0c 00 00 00    	jge    ffffffff80104fa3 <copy_mem_region+0x483>
      return -1;
ffffffff80104f97:	c7 45 fc ff ff ff ff 	movl   $0xffffffff,-0x4(%rbp)
ffffffff80104f9e:	e9 2c 00 00 00       	jmpq   ffffffff80104fcf <copy_mem_region+0x4af>
    }
  }
ffffffff80104fa3:	e9 00 00 00 00       	jmpq   ffffffff80104fa8 <copy_mem_region+0x488>
  for(i = start; i < end; i += PGSIZE){
ffffffff80104fa8:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
ffffffff80104fac:	48 05 00 10 00 00    	add    $0x1000,%rax
ffffffff80104fb2:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
ffffffff80104fb6:	e9 ad fb ff ff       	jmpq   ffffffff80104b68 <copy_mem_region+0x48>
  switchuvm(myproc());
ffffffff80104fbb:	e8 20 00 00 00       	callq  ffffffff80104fe0 <myproc>
ffffffff80104fc0:	48 89 c7             	mov    %rax,%rdi
ffffffff80104fc3:	e8 28 e6 ff ff       	callq  ffffffff801035f0 <switchuvm>
  return 0;
ffffffff80104fc8:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
}
ffffffff80104fcf:	8b 45 fc             	mov    -0x4(%rbp),%eax
ffffffff80104fd2:	48 81 c4 30 01 00 00 	add    $0x130,%rsp
ffffffff80104fd9:	5d                   	pop    %rbp
ffffffff80104fda:	c3                   	retq   
ffffffff80104fdb:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

ffffffff80104fe0 <myproc>:
{
ffffffff80104fe0:	55                   	push   %rbp
ffffffff80104fe1:	48 89 e5             	mov    %rsp,%rbp
  return mycpu()->proc;
ffffffff80104fe4:	e8 b7 e6 ff ff       	callq  ffffffff801036a0 <mycpu>
ffffffff80104fe9:	48 8b 80 d0 00 00 00 	mov    0xd0(%rax),%rax
ffffffff80104ff0:	5d                   	pop    %rbp
ffffffff80104ff1:	c3                   	retq   
ffffffff80104ff2:	66 66 66 66 66 2e 0f 	data16 data16 data16 data16 nopw %cs:0x0(%rax,%rax,1)
ffffffff80104ff9:	1f 84 00 00 00 00 00 

ffffffff80105000 <copyuvm>:

// Given a parent process's page table, create a copy
// of it for a child.
pml4e_t*
copyuvm(pml4e_t *pml4, struct mem_region *mem_regions, int newpid)
{
ffffffff80105000:	55                   	push   %rbp
ffffffff80105001:	48 89 e5             	mov    %rsp,%rbp
ffffffff80105004:	48 83 ec 40          	sub    $0x40,%rsp
ffffffff80105008:	48 89 7d f0          	mov    %rdi,-0x10(%rbp)
ffffffff8010500c:	48 89 75 e8          	mov    %rsi,-0x18(%rbp)
ffffffff80105010:	89 55 e4             	mov    %edx,-0x1c(%rbp)
  pml4e_t *d;

  if((d = setupkvm()) == 0)
ffffffff80105013:	e8 78 e3 ff ff       	callq  ffffffff80103390 <setupkvm>
ffffffff80105018:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
ffffffff8010501c:	48 83 f8 00          	cmp    $0x0,%rax
ffffffff80105020:	0f 85 0d 00 00 00    	jne    ffffffff80105033 <copyuvm+0x33>
    return 0;
ffffffff80105026:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
ffffffff8010502d:	00 
ffffffff8010502e:	e9 b9 00 00 00       	jmpq   ffffffff801050ec <copyuvm+0xec>
ffffffff80105033:	31 c0                	xor    %eax,%eax

  if (copy_mem_region(pml4, d, &mem_regions[CODE], newpid, false) != 0) {
ffffffff80105035:	48 8b 7d f0          	mov    -0x10(%rbp),%rdi
ffffffff80105039:	48 8b 75 d8          	mov    -0x28(%rbp),%rsi
ffffffff8010503d:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
ffffffff80105041:	8b 4d e4             	mov    -0x1c(%rbp),%ecx
ffffffff80105044:	45 31 c0             	xor    %r8d,%r8d
ffffffff80105047:	89 45 d4             	mov    %eax,-0x2c(%rbp)
ffffffff8010504a:	e8 d1 fa ff ff       	callq  ffffffff80104b20 <copy_mem_region>
ffffffff8010504f:	83 f8 00             	cmp    $0x0,%eax
ffffffff80105052:	0f 84 05 00 00 00    	je     ffffffff8010505d <copyuvm+0x5d>
    goto bad;
ffffffff80105058:	e9 7b 00 00 00       	jmpq   ffffffff801050d8 <copyuvm+0xd8>
ffffffff8010505d:	31 c0                	xor    %eax,%eax
  }
  if (copy_mem_region(pml4, d, &mem_regions[HEAP], newpid, false) != 0) {
ffffffff8010505f:	48 8b 7d f0          	mov    -0x10(%rbp),%rdi
ffffffff80105063:	48 8b 75 d8          	mov    -0x28(%rbp),%rsi
ffffffff80105067:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
ffffffff8010506b:	48 83 c1 10          	add    $0x10,%rcx
ffffffff8010506f:	8b 55 e4             	mov    -0x1c(%rbp),%edx
ffffffff80105072:	45 31 c0             	xor    %r8d,%r8d
ffffffff80105075:	89 55 d0             	mov    %edx,-0x30(%rbp)
ffffffff80105078:	48 89 ca             	mov    %rcx,%rdx
ffffffff8010507b:	8b 4d d0             	mov    -0x30(%rbp),%ecx
ffffffff8010507e:	89 45 cc             	mov    %eax,-0x34(%rbp)
ffffffff80105081:	e8 9a fa ff ff       	callq  ffffffff80104b20 <copy_mem_region>
ffffffff80105086:	83 f8 00             	cmp    $0x0,%eax
ffffffff80105089:	0f 84 05 00 00 00    	je     ffffffff80105094 <copyuvm+0x94>
    goto bad;
ffffffff8010508f:	e9 44 00 00 00       	jmpq   ffffffff801050d8 <copyuvm+0xd8>
ffffffff80105094:	31 c0                	xor    %eax,%eax
  }
  if (copy_mem_region(pml4, d, &mem_regions[USTACK], newpid, false) != 0) {
ffffffff80105096:	48 8b 7d f0          	mov    -0x10(%rbp),%rdi
ffffffff8010509a:	48 8b 75 d8          	mov    -0x28(%rbp),%rsi
ffffffff8010509e:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
ffffffff801050a2:	48 83 c1 20          	add    $0x20,%rcx
ffffffff801050a6:	8b 55 e4             	mov    -0x1c(%rbp),%edx
ffffffff801050a9:	45 31 c0             	xor    %r8d,%r8d
ffffffff801050ac:	89 55 c8             	mov    %edx,-0x38(%rbp)
ffffffff801050af:	48 89 ca             	mov    %rcx,%rdx
ffffffff801050b2:	8b 4d c8             	mov    -0x38(%rbp),%ecx
ffffffff801050b5:	89 45 c4             	mov    %eax,-0x3c(%rbp)
ffffffff801050b8:	e8 63 fa ff ff       	callq  ffffffff80104b20 <copy_mem_region>
ffffffff801050bd:	83 f8 00             	cmp    $0x0,%eax
ffffffff801050c0:	0f 84 05 00 00 00    	je     ffffffff801050cb <copyuvm+0xcb>
    goto bad;
ffffffff801050c6:	e9 0d 00 00 00       	jmpq   ffffffff801050d8 <copyuvm+0xd8>
  }

  return d;
ffffffff801050cb:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
ffffffff801050cf:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
ffffffff801050d3:	e9 14 00 00 00       	jmpq   ffffffff801050ec <copyuvm+0xec>

bad:
  freevm(d, newpid);
ffffffff801050d8:	48 8b 7d d8          	mov    -0x28(%rbp),%rdi
ffffffff801050dc:	8b 75 e4             	mov    -0x1c(%rbp),%esi
ffffffff801050df:	e8 6c f8 ff ff       	callq  ffffffff80104950 <freevm>
  return 0;
ffffffff801050e4:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
ffffffff801050eb:	00 
}
ffffffff801050ec:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
ffffffff801050f0:	48 83 c4 40          	add    $0x40,%rsp
ffffffff801050f4:	5d                   	pop    %rbp
ffffffff801050f5:	c3                   	retq   
ffffffff801050f6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
ffffffff801050fd:	00 00 00 

ffffffff80105100 <copyuvm_shallow>:

// This is like copyuvm but for copy on write. It does a shallow copy so
// physical memory is shared, and the mappings are read-only.
pml4e_t*
copyuvm_shallow(pml4e_t *pml4, struct mem_region *mem_regions, int newpid)
{
ffffffff80105100:	55                   	push   %rbp
ffffffff80105101:	48 89 e5             	mov    %rsp,%rbp
ffffffff80105104:	48 83 ec 40          	sub    $0x40,%rsp
ffffffff80105108:	48 89 7d f0          	mov    %rdi,-0x10(%rbp)
ffffffff8010510c:	48 89 75 e8          	mov    %rsi,-0x18(%rbp)
ffffffff80105110:	89 55 e4             	mov    %edx,-0x1c(%rbp)
  pml4e_t *d;

  if((d = setupkvm()) == 0)
ffffffff80105113:	e8 78 e2 ff ff       	callq  ffffffff80103390 <setupkvm>
ffffffff80105118:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
ffffffff8010511c:	48 83 f8 00          	cmp    $0x0,%rax
ffffffff80105120:	0f 85 0d 00 00 00    	jne    ffffffff80105133 <copyuvm_shallow+0x33>
    return 0;
ffffffff80105126:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
ffffffff8010512d:	00 
ffffffff8010512e:	e9 cb 00 00 00       	jmpq   ffffffff801051fe <copyuvm_shallow+0xfe>
ffffffff80105133:	b8 01 00 00 00       	mov    $0x1,%eax

  if (copy_mem_region(pml4, d, &mem_regions[CODE], newpid, true) != 0) {
ffffffff80105138:	48 8b 7d f0          	mov    -0x10(%rbp),%rdi
ffffffff8010513c:	48 8b 75 d8          	mov    -0x28(%rbp),%rsi
ffffffff80105140:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
ffffffff80105144:	8b 4d e4             	mov    -0x1c(%rbp),%ecx
ffffffff80105147:	41 b8 01 00 00 00    	mov    $0x1,%r8d
ffffffff8010514d:	89 45 d4             	mov    %eax,-0x2c(%rbp)
ffffffff80105150:	e8 cb f9 ff ff       	callq  ffffffff80104b20 <copy_mem_region>
ffffffff80105155:	83 f8 00             	cmp    $0x0,%eax
ffffffff80105158:	0f 84 05 00 00 00    	je     ffffffff80105163 <copyuvm_shallow+0x63>
    goto bad;
ffffffff8010515e:	e9 87 00 00 00       	jmpq   ffffffff801051ea <copyuvm_shallow+0xea>
ffffffff80105163:	b8 01 00 00 00       	mov    $0x1,%eax
  }
  if (copy_mem_region(pml4, d, &mem_regions[HEAP], newpid, true) != 0) {
ffffffff80105168:	48 8b 7d f0          	mov    -0x10(%rbp),%rdi
ffffffff8010516c:	48 8b 75 d8          	mov    -0x28(%rbp),%rsi
ffffffff80105170:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
ffffffff80105174:	48 83 c1 10          	add    $0x10,%rcx
ffffffff80105178:	8b 55 e4             	mov    -0x1c(%rbp),%edx
ffffffff8010517b:	41 b8 01 00 00 00    	mov    $0x1,%r8d
ffffffff80105181:	89 55 d0             	mov    %edx,-0x30(%rbp)
ffffffff80105184:	48 89 ca             	mov    %rcx,%rdx
ffffffff80105187:	8b 4d d0             	mov    -0x30(%rbp),%ecx
ffffffff8010518a:	89 45 cc             	mov    %eax,-0x34(%rbp)
ffffffff8010518d:	e8 8e f9 ff ff       	callq  ffffffff80104b20 <copy_mem_region>
ffffffff80105192:	83 f8 00             	cmp    $0x0,%eax
ffffffff80105195:	0f 84 05 00 00 00    	je     ffffffff801051a0 <copyuvm_shallow+0xa0>
    goto bad;
ffffffff8010519b:	e9 4a 00 00 00       	jmpq   ffffffff801051ea <copyuvm_shallow+0xea>
ffffffff801051a0:	b8 01 00 00 00       	mov    $0x1,%eax
  }
  if (copy_mem_region(pml4, d, &mem_regions[USTACK], newpid, true) != 0) {
ffffffff801051a5:	48 8b 7d f0          	mov    -0x10(%rbp),%rdi
ffffffff801051a9:	48 8b 75 d8          	mov    -0x28(%rbp),%rsi
ffffffff801051ad:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
ffffffff801051b1:	48 83 c1 20          	add    $0x20,%rcx
ffffffff801051b5:	8b 55 e4             	mov    -0x1c(%rbp),%edx
ffffffff801051b8:	41 b8 01 00 00 00    	mov    $0x1,%r8d
ffffffff801051be:	89 55 c8             	mov    %edx,-0x38(%rbp)
ffffffff801051c1:	48 89 ca             	mov    %rcx,%rdx
ffffffff801051c4:	8b 4d c8             	mov    -0x38(%rbp),%ecx
ffffffff801051c7:	89 45 c4             	mov    %eax,-0x3c(%rbp)
ffffffff801051ca:	e8 51 f9 ff ff       	callq  ffffffff80104b20 <copy_mem_region>
ffffffff801051cf:	83 f8 00             	cmp    $0x0,%eax
ffffffff801051d2:	0f 84 05 00 00 00    	je     ffffffff801051dd <copyuvm_shallow+0xdd>
    goto bad;
ffffffff801051d8:	e9 0d 00 00 00       	jmpq   ffffffff801051ea <copyuvm_shallow+0xea>
  }

  return d;
ffffffff801051dd:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
ffffffff801051e1:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
ffffffff801051e5:	e9 14 00 00 00       	jmpq   ffffffff801051fe <copyuvm_shallow+0xfe>

bad:
  freevm(d, newpid);
ffffffff801051ea:	48 8b 7d d8          	mov    -0x28(%rbp),%rdi
ffffffff801051ee:	8b 75 e4             	mov    -0x1c(%rbp),%esi
ffffffff801051f1:	e8 5a f7 ff ff       	callq  ffffffff80104950 <freevm>
  return 0;
ffffffff801051f6:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
ffffffff801051fd:	00 
}
ffffffff801051fe:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
ffffffff80105202:	48 83 c4 40          	add    $0x40,%rsp
ffffffff80105206:	5d                   	pop    %rbp
ffffffff80105207:	c3                   	retq   
ffffffff80105208:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
ffffffff8010520f:	00 

ffffffff80105210 <uva2ka>:

//PAGEBREAK!
// Map user virtual address to kernel address.
char*
uva2ka(pml4e_t *pml4, char *uva)
{
ffffffff80105210:	55                   	push   %rbp
ffffffff80105211:	48 89 e5             	mov    %rsp,%rbp
ffffffff80105214:	48 83 ec 70          	sub    $0x70,%rsp
ffffffff80105218:	31 c0                	xor    %eax,%eax
ffffffff8010521a:	48 89 7d f0          	mov    %rdi,-0x10(%rbp)
ffffffff8010521e:	48 89 75 e8          	mov    %rsi,-0x18(%rbp)
  pte_t *pte;

  pte = walkpml4(pml4, uva, 0);
ffffffff80105222:	48 8b 7d f0          	mov    -0x10(%rbp),%rdi
ffffffff80105226:	48 8b 75 e8          	mov    -0x18(%rbp),%rsi
ffffffff8010522a:	31 d2                	xor    %edx,%edx
ffffffff8010522c:	89 45 b8             	mov    %eax,-0x48(%rbp)
ffffffff8010522f:	e8 3c da ff ff       	callq  ffffffff80102c70 <walkpml4>
ffffffff80105234:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  if((*pte & PTE_P) == 0)
ffffffff80105238:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
ffffffff8010523c:	48 8b 00             	mov    (%rax),%rax
ffffffff8010523f:	48 83 e0 01          	and    $0x1,%rax
ffffffff80105243:	48 83 f8 00          	cmp    $0x0,%rax
ffffffff80105247:	0f 85 0d 00 00 00    	jne    ffffffff8010525a <uva2ka+0x4a>
    return 0;
ffffffff8010524d:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
ffffffff80105254:	00 
ffffffff80105255:	e9 04 01 00 00       	jmpq   ffffffff8010535e <uva2ka+0x14e>
  if((*pte & PTE_U) == 0)
ffffffff8010525a:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
ffffffff8010525e:	48 8b 00             	mov    (%rax),%rax
ffffffff80105261:	48 83 e0 04          	and    $0x4,%rax
ffffffff80105265:	48 83 f8 00          	cmp    $0x0,%rax
ffffffff80105269:	0f 85 0d 00 00 00    	jne    ffffffff8010527c <uva2ka+0x6c>
    return 0;
ffffffff8010526f:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
ffffffff80105276:	00 
ffffffff80105277:	e9 e2 00 00 00       	jmpq   ffffffff8010535e <uva2ka+0x14e>
  return (char*)P2V(PTE_ADDR(*pte));
ffffffff8010527c:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
ffffffff80105280:	48 8b 00             	mov    (%rax),%rax
ffffffff80105283:	c7 45 dc 33 00 00 00 	movl   $0x33,-0x24(%rbp)
ffffffff8010528a:	c7 45 d8 0c 00 00 00 	movl   $0xc,-0x28(%rbp)
ffffffff80105291:	8b 4d dc             	mov    -0x24(%rbp),%ecx
ffffffff80105294:	3b 4d d8             	cmp    -0x28(%rbp),%ecx
ffffffff80105297:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
ffffffff8010529b:	0f 8c 0b 00 00 00    	jl     ffffffff801052ac <uva2ka+0x9c>
ffffffff801052a1:	8b 45 dc             	mov    -0x24(%rbp),%eax
ffffffff801052a4:	89 45 ac             	mov    %eax,-0x54(%rbp)
ffffffff801052a7:	e9 06 00 00 00       	jmpq   ffffffff801052b2 <uva2ka+0xa2>
ffffffff801052ac:	8b 45 d8             	mov    -0x28(%rbp),%eax
ffffffff801052af:	89 45 ac             	mov    %eax,-0x54(%rbp)
ffffffff801052b2:	8b 45 ac             	mov    -0x54(%rbp),%eax
ffffffff801052b5:	89 45 d4             	mov    %eax,-0x2c(%rbp)
ffffffff801052b8:	8b 45 d4             	mov    -0x2c(%rbp),%eax
ffffffff801052bb:	c7 45 d0 33 00 00 00 	movl   $0x33,-0x30(%rbp)
ffffffff801052c2:	c7 45 cc 0c 00 00 00 	movl   $0xc,-0x34(%rbp)
ffffffff801052c9:	8b 4d d0             	mov    -0x30(%rbp),%ecx
ffffffff801052cc:	3b 4d cc             	cmp    -0x34(%rbp),%ecx
ffffffff801052cf:	89 45 a8             	mov    %eax,-0x58(%rbp)
ffffffff801052d2:	0f 8f 0b 00 00 00    	jg     ffffffff801052e3 <uva2ka+0xd3>
ffffffff801052d8:	8b 45 d0             	mov    -0x30(%rbp),%eax
ffffffff801052db:	89 45 a4             	mov    %eax,-0x5c(%rbp)
ffffffff801052de:	e9 06 00 00 00       	jmpq   ffffffff801052e9 <uva2ka+0xd9>
ffffffff801052e3:	8b 45 cc             	mov    -0x34(%rbp),%eax
ffffffff801052e6:	89 45 a4             	mov    %eax,-0x5c(%rbp)
ffffffff801052e9:	8b 45 a4             	mov    -0x5c(%rbp),%eax
ffffffff801052ec:	b9 01 00 00 00       	mov    $0x1,%ecx
ffffffff801052f1:	89 ca                	mov    %ecx,%edx
ffffffff801052f3:	89 45 c8             	mov    %eax,-0x38(%rbp)
ffffffff801052f6:	8b 45 a8             	mov    -0x58(%rbp),%eax
ffffffff801052f9:	2b 45 c8             	sub    -0x38(%rbp),%eax
ffffffff801052fc:	89 c0                	mov    %eax,%eax
ffffffff801052fe:	89 c1                	mov    %eax,%ecx
ffffffff80105300:	48 d3 e2             	shl    %cl,%rdx
ffffffff80105303:	48 c1 e2 01          	shl    $0x1,%rdx
ffffffff80105307:	48 83 ea 01          	sub    $0x1,%rdx
ffffffff8010530b:	c7 45 c4 33 00 00 00 	movl   $0x33,-0x3c(%rbp)
ffffffff80105312:	c7 45 c0 0c 00 00 00 	movl   $0xc,-0x40(%rbp)
ffffffff80105319:	8b 45 c4             	mov    -0x3c(%rbp),%eax
ffffffff8010531c:	3b 45 c0             	cmp    -0x40(%rbp),%eax
ffffffff8010531f:	48 89 55 98          	mov    %rdx,-0x68(%rbp)
ffffffff80105323:	0f 8f 0b 00 00 00    	jg     ffffffff80105334 <uva2ka+0x124>
ffffffff80105329:	8b 45 c4             	mov    -0x3c(%rbp),%eax
ffffffff8010532c:	89 45 94             	mov    %eax,-0x6c(%rbp)
ffffffff8010532f:	e9 06 00 00 00       	jmpq   ffffffff8010533a <uva2ka+0x12a>
ffffffff80105334:	8b 45 c0             	mov    -0x40(%rbp),%eax
ffffffff80105337:	89 45 94             	mov    %eax,-0x6c(%rbp)
ffffffff8010533a:	8b 45 94             	mov    -0x6c(%rbp),%eax
ffffffff8010533d:	89 45 bc             	mov    %eax,-0x44(%rbp)
ffffffff80105340:	8b 45 bc             	mov    -0x44(%rbp),%eax
ffffffff80105343:	89 c1                	mov    %eax,%ecx
ffffffff80105345:	48 8b 55 98          	mov    -0x68(%rbp),%rdx
ffffffff80105349:	48 d3 e2             	shl    %cl,%rdx
ffffffff8010534c:	48 8b 75 b0          	mov    -0x50(%rbp),%rsi
ffffffff80105350:	48 21 d6             	and    %rdx,%rsi
ffffffff80105353:	48 81 c6 00 00 00 80 	add    $0xffffffff80000000,%rsi
ffffffff8010535a:	48 89 75 f8          	mov    %rsi,-0x8(%rbp)
}
ffffffff8010535e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
ffffffff80105362:	48 83 c4 70          	add    $0x70,%rsp
ffffffff80105366:	5d                   	pop    %rbp
ffffffff80105367:	c3                   	retq   
ffffffff80105368:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
ffffffff8010536f:	00 

ffffffff80105370 <copyout>:
// Copy len bytes from p to user address va in page table pgdir.
// Most useful when pgdir is not the current page table.
// uva2ka ensures this only works for PTE_U pages.
int
copyout(pml4e_t *pml4, uint64_t va, void *p, uint len)
{
ffffffff80105370:	55                   	push   %rbp
ffffffff80105371:	48 89 e5             	mov    %rsp,%rbp
ffffffff80105374:	48 83 ec 50          	sub    $0x50,%rsp
ffffffff80105378:	48 89 7d f0          	mov    %rdi,-0x10(%rbp)
ffffffff8010537c:	48 89 75 e8          	mov    %rsi,-0x18(%rbp)
ffffffff80105380:	48 89 55 e0          	mov    %rdx,-0x20(%rbp)
ffffffff80105384:	89 4d dc             	mov    %ecx,-0x24(%rbp)
  char *buf, *pa0;
  uint64_t n, va0;

  buf = (char*)p;
ffffffff80105387:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
ffffffff8010538b:	48 89 55 d0          	mov    %rdx,-0x30(%rbp)
  while(len > 0){
ffffffff8010538f:	83 7d dc 00          	cmpl   $0x0,-0x24(%rbp)
ffffffff80105393:	0f 86 bd 00 00 00    	jbe    ffffffff80105456 <copyout+0xe6>
    va0 = (uint64_t)PGROUNDDOWN(va);
ffffffff80105399:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
ffffffff8010539d:	48 25 00 f0 ff ff    	and    $0xfffffffffffff000,%rax
ffffffff801053a3:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
    pa0 = uva2ka(pml4, (char*)va0);
ffffffff801053a7:	48 8b 7d f0          	mov    -0x10(%rbp),%rdi
ffffffff801053ab:	48 8b 75 b8          	mov    -0x48(%rbp),%rsi
ffffffff801053af:	e8 5c fe ff ff       	callq  ffffffff80105210 <uva2ka>
ffffffff801053b4:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
    if(pa0 == 0)
ffffffff801053b8:	48 83 7d c8 00       	cmpq   $0x0,-0x38(%rbp)
ffffffff801053bd:	0f 85 0c 00 00 00    	jne    ffffffff801053cf <copyout+0x5f>
      return -1;
ffffffff801053c3:	c7 45 fc ff ff ff ff 	movl   $0xffffffff,-0x4(%rbp)
ffffffff801053ca:	e9 8e 00 00 00       	jmpq   ffffffff8010545d <copyout+0xed>
ffffffff801053cf:	b8 00 10 00 00       	mov    $0x1000,%eax
ffffffff801053d4:	89 c1                	mov    %eax,%ecx
    n = PGSIZE - (va - va0);
ffffffff801053d6:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
ffffffff801053da:	48 2b 55 b8          	sub    -0x48(%rbp),%rdx
ffffffff801053de:	48 29 d1             	sub    %rdx,%rcx
ffffffff801053e1:	48 89 4d c0          	mov    %rcx,-0x40(%rbp)
    if(n > len)
ffffffff801053e5:	48 8b 4d c0          	mov    -0x40(%rbp),%rcx
ffffffff801053e9:	8b 45 dc             	mov    -0x24(%rbp),%eax
ffffffff801053ec:	89 c2                	mov    %eax,%edx
ffffffff801053ee:	48 39 d1             	cmp    %rdx,%rcx
ffffffff801053f1:	0f 86 09 00 00 00    	jbe    ffffffff80105400 <copyout+0x90>
      n = len;
ffffffff801053f7:	8b 45 dc             	mov    -0x24(%rbp),%eax
ffffffff801053fa:	89 c1                	mov    %eax,%ecx
ffffffff801053fc:	48 89 4d c0          	mov    %rcx,-0x40(%rbp)
    memmove(pa0 + (va - va0), buf, n);
ffffffff80105400:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
ffffffff80105404:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
ffffffff80105408:	48 2b 4d b8          	sub    -0x48(%rbp),%rcx
ffffffff8010540c:	48 01 c8             	add    %rcx,%rax
ffffffff8010540f:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
ffffffff80105413:	48 8b 4d c0          	mov    -0x40(%rbp),%rcx
ffffffff80105417:	89 ca                	mov    %ecx,%edx
ffffffff80105419:	48 89 c7             	mov    %rax,%rdi
ffffffff8010541c:	e8 6f 5c 00 00       	callq  ffffffff8010b090 <memmove>
    len -= n;
ffffffff80105421:	48 8b 4d c0          	mov    -0x40(%rbp),%rcx
ffffffff80105425:	8b 55 dc             	mov    -0x24(%rbp),%edx
ffffffff80105428:	89 d6                	mov    %edx,%esi
ffffffff8010542a:	48 29 ce             	sub    %rcx,%rsi
ffffffff8010542d:	89 f2                	mov    %esi,%edx
ffffffff8010542f:	89 55 dc             	mov    %edx,-0x24(%rbp)
    buf += n;
ffffffff80105432:	48 8b 4d c0          	mov    -0x40(%rbp),%rcx
ffffffff80105436:	48 03 4d d0          	add    -0x30(%rbp),%rcx
ffffffff8010543a:	48 89 4d d0          	mov    %rcx,-0x30(%rbp)
    va = va0 + PGSIZE;
ffffffff8010543e:	48 8b 4d b8          	mov    -0x48(%rbp),%rcx
ffffffff80105442:	48 81 c1 00 10 00 00 	add    $0x1000,%rcx
ffffffff80105449:	48 89 4d e8          	mov    %rcx,-0x18(%rbp)
  while(len > 0){
ffffffff8010544d:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
ffffffff80105451:	e9 39 ff ff ff       	jmpq   ffffffff8010538f <copyout+0x1f>
  }
  return 0;
ffffffff80105456:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
}
ffffffff8010545d:	8b 45 fc             	mov    -0x4(%rbp),%eax
ffffffff80105460:	48 83 c4 50          	add    $0x50,%rsp
ffffffff80105464:	5d                   	pop    %rbp
ffffffff80105465:	c3                   	retq   
ffffffff80105466:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
ffffffff8010546d:	00 00 00 

ffffffff80105470 <copy_writable_page>:

// Used to make a writable copy of a page previously marked read-only during
// a copy-on-write fork.
void
copy_writable_page(struct proc* proc, uint64_t addr, pte_t* pte)
{
ffffffff80105470:	55                   	push   %rbp
ffffffff80105471:	48 89 e5             	mov    %rsp,%rbp
ffffffff80105474:	48 81 ec 90 00 00 00 	sub    $0x90,%rsp
ffffffff8010547b:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
ffffffff8010547f:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
ffffffff80105483:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  char* addr_kvirt = uva2ka(proc->pml4, (void*)addr);
ffffffff80105487:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
ffffffff8010548b:	48 8b 3a             	mov    (%rdx),%rdi
ffffffff8010548e:	48 8b 75 f0          	mov    -0x10(%rbp),%rsi
ffffffff80105492:	e8 79 fd ff ff       	callq  ffffffff80105210 <uva2ka>
ffffffff80105497:	48 89 45 e0          	mov    %rax,-0x20(%rbp)

  acquire_entry_lock();
ffffffff8010549b:	31 c9                	xor    %ecx,%ecx
ffffffff8010549d:	41 88 c8             	mov    %cl,%r8b
ffffffff801054a0:	44 88 c0             	mov    %r8b,%al
ffffffff801054a3:	e8 18 af ff ff       	callq  ffffffff801003c0 <acquire_entry_lock>
  struct core_map_entry* coremapentry =
   pa2page(V2P(addr_kvirt));
ffffffff801054a8:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
ffffffff801054ac:	48 81 ea 00 00 00 80 	sub    $0xffffffff80000000,%rdx
ffffffff801054b3:	48 89 d7             	mov    %rdx,%rdi
ffffffff801054b6:	e8 95 ac ff ff       	callq  ffffffff80100150 <pa2page>
  struct core_map_entry* coremapentry =
ffffffff801054bb:	48 89 45 d8          	mov    %rax,-0x28(%rbp)

  if (coremapentry->ref_count == 1) {
ffffffff801054bf:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
ffffffff801054c3:	0f b6 48 18          	movzbl 0x18(%rax),%ecx
ffffffff801054c7:	83 f9 01             	cmp    $0x1,%ecx
ffffffff801054ca:	0f 85 24 00 00 00    	jne    ffffffff801054f4 <copy_writable_page+0x84>
    // CASE: Sole owner of page; make it writable again.
    *pte |= PTE_W;
ffffffff801054d0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
ffffffff801054d4:	48 8b 08             	mov    (%rax),%rcx
ffffffff801054d7:	48 83 c9 02          	or     $0x2,%rcx
ffffffff801054db:	48 89 08             	mov    %rcx,(%rax)
    *pte &= ~PTE_RO;
ffffffff801054de:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
ffffffff801054e2:	48 8b 08             	mov    (%rax),%rcx
ffffffff801054e5:	48 81 e1 ff f7 ff ff 	and    $0xfffffffffffff7ff,%rcx
ffffffff801054ec:	48 89 08             	mov    %rcx,(%rax)
  } else {
ffffffff801054ef:	e9 5d 01 00 00       	jmpq   ffffffff80105651 <copy_writable_page+0x1e1>
    // CASE: >1 process using page; make a copy and update refcounts.

    char* newpage = kalloc();
ffffffff801054f4:	e8 87 b2 ff ff       	callq  ffffffff80100780 <kalloc>
ffffffff801054f9:	48 89 45 d0          	mov    %rax,-0x30(%rbp)

    if (newpage == 0) {
ffffffff801054fd:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
ffffffff80105502:	0f 85 0c 00 00 00    	jne    ffffffff80105514 <copy_writable_page+0xa4>
      panic("trap kalloc failed.");
ffffffff80105508:	48 c7 c7 8d fe 10 80 	mov    $0xffffffff8010fe8d,%rdi
ffffffff8010550f:	e8 5c b9 ff ff       	callq  ffffffff80100e70 <panic>
    }

    uint64_t pa = PTE_ADDR(*pte);
ffffffff80105514:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
ffffffff80105518:	48 8b 00             	mov    (%rax),%rax
ffffffff8010551b:	c7 45 c4 33 00 00 00 	movl   $0x33,-0x3c(%rbp)
ffffffff80105522:	c7 45 c0 0c 00 00 00 	movl   $0xc,-0x40(%rbp)
ffffffff80105529:	8b 4d c4             	mov    -0x3c(%rbp),%ecx
ffffffff8010552c:	3b 4d c0             	cmp    -0x40(%rbp),%ecx
ffffffff8010552f:	48 89 45 98          	mov    %rax,-0x68(%rbp)
ffffffff80105533:	0f 8c 0b 00 00 00    	jl     ffffffff80105544 <copy_writable_page+0xd4>
ffffffff80105539:	8b 45 c4             	mov    -0x3c(%rbp),%eax
ffffffff8010553c:	89 45 94             	mov    %eax,-0x6c(%rbp)
ffffffff8010553f:	e9 06 00 00 00       	jmpq   ffffffff8010554a <copy_writable_page+0xda>
ffffffff80105544:	8b 45 c0             	mov    -0x40(%rbp),%eax
ffffffff80105547:	89 45 94             	mov    %eax,-0x6c(%rbp)
ffffffff8010554a:	8b 45 94             	mov    -0x6c(%rbp),%eax
ffffffff8010554d:	89 45 bc             	mov    %eax,-0x44(%rbp)
ffffffff80105550:	8b 45 bc             	mov    -0x44(%rbp),%eax
ffffffff80105553:	c7 45 b8 33 00 00 00 	movl   $0x33,-0x48(%rbp)
ffffffff8010555a:	c7 45 b4 0c 00 00 00 	movl   $0xc,-0x4c(%rbp)
ffffffff80105561:	8b 4d b8             	mov    -0x48(%rbp),%ecx
ffffffff80105564:	3b 4d b4             	cmp    -0x4c(%rbp),%ecx
ffffffff80105567:	89 45 90             	mov    %eax,-0x70(%rbp)
ffffffff8010556a:	0f 8f 0b 00 00 00    	jg     ffffffff8010557b <copy_writable_page+0x10b>
ffffffff80105570:	8b 45 b8             	mov    -0x48(%rbp),%eax
ffffffff80105573:	89 45 8c             	mov    %eax,-0x74(%rbp)
ffffffff80105576:	e9 06 00 00 00       	jmpq   ffffffff80105581 <copy_writable_page+0x111>
ffffffff8010557b:	8b 45 b4             	mov    -0x4c(%rbp),%eax
ffffffff8010557e:	89 45 8c             	mov    %eax,-0x74(%rbp)
ffffffff80105581:	8b 45 8c             	mov    -0x74(%rbp),%eax
ffffffff80105584:	b9 01 00 00 00       	mov    $0x1,%ecx
ffffffff80105589:	89 ca                	mov    %ecx,%edx
ffffffff8010558b:	89 45 b0             	mov    %eax,-0x50(%rbp)
ffffffff8010558e:	8b 45 90             	mov    -0x70(%rbp),%eax
ffffffff80105591:	2b 45 b0             	sub    -0x50(%rbp),%eax
ffffffff80105594:	89 c0                	mov    %eax,%eax
ffffffff80105596:	89 c1                	mov    %eax,%ecx
ffffffff80105598:	48 d3 e2             	shl    %cl,%rdx
ffffffff8010559b:	48 c1 e2 01          	shl    $0x1,%rdx
ffffffff8010559f:	48 83 ea 01          	sub    $0x1,%rdx
ffffffff801055a3:	c7 45 ac 33 00 00 00 	movl   $0x33,-0x54(%rbp)
ffffffff801055aa:	c7 45 a8 0c 00 00 00 	movl   $0xc,-0x58(%rbp)
ffffffff801055b1:	8b 45 ac             	mov    -0x54(%rbp),%eax
ffffffff801055b4:	3b 45 a8             	cmp    -0x58(%rbp),%eax
ffffffff801055b7:	48 89 55 80          	mov    %rdx,-0x80(%rbp)
ffffffff801055bb:	0f 8f 0e 00 00 00    	jg     ffffffff801055cf <copy_writable_page+0x15f>
ffffffff801055c1:	8b 45 ac             	mov    -0x54(%rbp),%eax
ffffffff801055c4:	89 85 7c ff ff ff    	mov    %eax,-0x84(%rbp)
ffffffff801055ca:	e9 09 00 00 00       	jmpq   ffffffff801055d8 <copy_writable_page+0x168>
ffffffff801055cf:	8b 45 a8             	mov    -0x58(%rbp),%eax
ffffffff801055d2:	89 85 7c ff ff ff    	mov    %eax,-0x84(%rbp)
ffffffff801055d8:	8b 85 7c ff ff ff    	mov    -0x84(%rbp),%eax
ffffffff801055de:	b9 00 10 00 00       	mov    $0x1000,%ecx
ffffffff801055e3:	89 45 a4             	mov    %eax,-0x5c(%rbp)
ffffffff801055e6:	8b 45 a4             	mov    -0x5c(%rbp),%eax
ffffffff801055e9:	89 c2                	mov    %eax,%edx
ffffffff801055eb:	89 8d 78 ff ff ff    	mov    %ecx,-0x88(%rbp)
ffffffff801055f1:	48 89 d1             	mov    %rdx,%rcx
ffffffff801055f4:	48 8b 55 80          	mov    -0x80(%rbp),%rdx
ffffffff801055f8:	48 d3 e2             	shl    %cl,%rdx
ffffffff801055fb:	48 8b 75 98          	mov    -0x68(%rbp),%rsi
ffffffff801055ff:	48 21 d6             	and    %rdx,%rsi
ffffffff80105602:	48 89 75 c8          	mov    %rsi,-0x38(%rbp)
    memmove(newpage, (char*) P2V(pa), PGSIZE);
ffffffff80105606:	48 8b 7d d0          	mov    -0x30(%rbp),%rdi
ffffffff8010560a:	48 8b 55 c8          	mov    -0x38(%rbp),%rdx
ffffffff8010560e:	48 81 c2 00 00 00 80 	add    $0xffffffff80000000,%rdx
ffffffff80105615:	b8 00 10 00 00       	mov    $0x1000,%eax
ffffffff8010561a:	48 89 d6             	mov    %rdx,%rsi
ffffffff8010561d:	89 c2                	mov    %eax,%edx
ffffffff8010561f:	e8 6c 5a 00 00       	callq  ffffffff8010b090 <memmove>

    core_map_ref_decrement(coremapentry);
ffffffff80105624:	48 8b 7d d8          	mov    -0x28(%rbp),%rdi
ffffffff80105628:	48 89 85 70 ff ff ff 	mov    %rax,-0x90(%rbp)
ffffffff8010562f:	e8 4c ad ff ff       	callq  ffffffff80100380 <core_map_ref_decrement>

    *pte = V2P(newpage) | PTE_P | PTE_W | PTE_U;
ffffffff80105634:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
ffffffff80105638:	48 2d 00 00 00 80    	sub    $0xffffffff80000000,%rax
ffffffff8010563e:	48 83 c8 01          	or     $0x1,%rax
ffffffff80105642:	48 83 c8 02          	or     $0x2,%rax
ffffffff80105646:	48 83 c8 04          	or     $0x4,%rax
ffffffff8010564a:	48 8b 75 e8          	mov    -0x18(%rbp),%rsi
ffffffff8010564e:	48 89 06             	mov    %rax,(%rsi)
  }

  switchuvm(proc);
ffffffff80105651:	48 8b 7d f8          	mov    -0x8(%rbp),%rdi
ffffffff80105655:	e8 96 df ff ff       	callq  ffffffff801035f0 <switchuvm>
  release_entry_lock();
ffffffff8010565a:	31 c0                	xor    %eax,%eax
ffffffff8010565c:	88 c1                	mov    %al,%cl
ffffffff8010565e:	88 c8                	mov    %cl,%al
ffffffff80105660:	e8 7b ad ff ff       	callq  ffffffff801003e0 <release_entry_lock>
}
ffffffff80105665:	48 81 c4 90 00 00 00 	add    $0x90,%rsp
ffffffff8010566c:	5d                   	pop    %rbp
ffffffff8010566d:	c3                   	retq   
ffffffff8010566e:	66 90                	xchg   %ax,%ax

ffffffff80105670 <growstack>:

// Grows the current process' stack by one page.
void
growstack()
{
ffffffff80105670:	55                   	push   %rbp
ffffffff80105671:	48 89 e5             	mov    %rsp,%rbp
  struct proc* proc = myproc();
ffffffff80105674:	53                   	push   %rbx
ffffffff80105675:	48 83 ec 48          	sub    $0x48,%rsp
ffffffff80105679:	e8 62 f9 ff ff       	callq  ffffffff80104fe0 <myproc>
ffffffff8010567e:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  struct mem_region* stack = &proc->mem_regions[USTACK];
ffffffff80105682:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
ffffffff80105686:	48 83 c0 08          	add    $0x8,%rax
ffffffff8010568a:	48 83 c0 20          	add    $0x20,%rax
ffffffff8010568e:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  uint64_t page = ((uint64_t) stack->start) - PGSIZE;
ffffffff80105692:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
ffffffff80105696:	48 8b 00             	mov    (%rax),%rax
ffffffff80105699:	48 2d 00 10 00 00    	sub    $0x1000,%rax
ffffffff8010569f:	48 89 45 e0          	mov    %rax,-0x20(%rbp)

  char* mem_page = kalloc();
ffffffff801056a3:	e8 d8 b0 ff ff       	callq  ffffffff80100780 <kalloc>
ffffffff801056a8:	48 89 45 d8          	mov    %rax,-0x28(%rbp)

  if (mem_page == 0) {
ffffffff801056ac:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
ffffffff801056b1:	0f 85 0c 00 00 00    	jne    ffffffff801056c3 <growstack+0x53>
    panic("Stack out of space\n");
ffffffff801056b7:	48 c7 c7 a1 fe 10 80 	mov    $0xffffffff8010fea1,%rdi
ffffffff801056be:	e8 ad b7 ff ff       	callq  ffffffff80100e70 <panic>
ffffffff801056c3:	31 c0                	xor    %eax,%eax
ffffffff801056c5:	b9 00 10 00 00       	mov    $0x1000,%ecx
  }

  memset(mem_page, 0, PGSIZE);
ffffffff801056ca:	48 8b 7d d8          	mov    -0x28(%rbp),%rdi
ffffffff801056ce:	31 f6                	xor    %esi,%esi
ffffffff801056d0:	ba 00 10 00 00       	mov    $0x1000,%edx
ffffffff801056d5:	89 45 d4             	mov    %eax,-0x2c(%rbp)
ffffffff801056d8:	89 4d d0             	mov    %ecx,-0x30(%rbp)
ffffffff801056db:	e8 20 58 00 00       	callq  ffffffff8010af00 <memset>
ffffffff801056e0:	b9 01 00 00 00       	mov    $0x1,%ecx
ffffffff801056e5:	ba 06 00 00 00       	mov    $0x6,%edx

  if (mappages(proc->pml4, page >> PT_SHIFT, 1,
ffffffff801056ea:	48 8b 7d f0          	mov    -0x10(%rbp),%rdi
ffffffff801056ee:	48 8b 3f             	mov    (%rdi),%rdi
ffffffff801056f1:	4c 8b 45 e0          	mov    -0x20(%rbp),%r8
ffffffff801056f5:	49 c1 e8 0c          	shr    $0xc,%r8
        V2P(mem_page) >> PT_SHIFT, PTE_W | PTE_U, proc->pid) < 0) {
ffffffff801056f9:	4c 8b 4d d8          	mov    -0x28(%rbp),%r9
ffffffff801056fd:	49 81 e9 00 00 00 80 	sub    $0xffffffff80000000,%r9
ffffffff80105704:	49 c1 e9 0c          	shr    $0xc,%r9
ffffffff80105708:	4c 8b 55 f0          	mov    -0x10(%rbp),%r10
ffffffff8010570c:	41 8b b2 04 01 00 00 	mov    0x104(%r10),%esi
  if (mappages(proc->pml4, page >> PT_SHIFT, 1,
ffffffff80105713:	41 bb 01 00 00 00    	mov    $0x1,%r11d
ffffffff80105719:	bb 06 00 00 00       	mov    $0x6,%ebx
ffffffff8010571e:	89 75 cc             	mov    %esi,-0x34(%rbp)
ffffffff80105721:	4c 89 c6             	mov    %r8,%rsi
ffffffff80105724:	89 55 c8             	mov    %edx,-0x38(%rbp)
ffffffff80105727:	44 89 da             	mov    %r11d,%edx
ffffffff8010572a:	89 4d c4             	mov    %ecx,-0x3c(%rbp)
ffffffff8010572d:	4c 89 c9             	mov    %r9,%rcx
ffffffff80105730:	41 89 d8             	mov    %ebx,%r8d
ffffffff80105733:	44 8b 4d cc          	mov    -0x34(%rbp),%r9d
ffffffff80105737:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
ffffffff8010573b:	e8 50 db ff ff       	callq  ffffffff80103290 <mappages>
        V2P(mem_page) >> PT_SHIFT, PTE_W | PTE_U, proc->pid) < 0) {
ffffffff80105740:	83 f8 00             	cmp    $0x0,%eax
  if (mappages(proc->pml4, page >> PT_SHIFT, 1,
ffffffff80105743:	0f 8d 0c 00 00 00    	jge    ffffffff80105755 <growstack+0xe5>
    panic("Stack mapping went wrong\n");
ffffffff80105749:	48 c7 c7 b5 fe 10 80 	mov    $0xffffffff8010feb5,%rdi
ffffffff80105750:	e8 1b b7 ff ff       	callq  ffffffff80100e70 <panic>
  }

  // Assigned successfully
  // update the size of the stack
  stack->start -= PGSIZE;
ffffffff80105755:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
ffffffff80105759:	48 8b 08             	mov    (%rax),%rcx
ffffffff8010575c:	48 81 c1 00 f0 ff ff 	add    $0xfffffffffffff000,%rcx
ffffffff80105763:	48 89 08             	mov    %rcx,(%rax)
  stack->size += PGSIZE;
ffffffff80105766:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
ffffffff8010576a:	48 8b 48 08          	mov    0x8(%rax),%rcx
ffffffff8010576e:	48 81 c1 00 10 00 00 	add    $0x1000,%rcx
ffffffff80105775:	48 89 48 08          	mov    %rcx,0x8(%rax)
}
ffffffff80105779:	48 83 c4 48          	add    $0x48,%rsp
ffffffff8010577d:	5b                   	pop    %rbx
ffffffff8010577e:	5d                   	pop    %rbp
ffffffff8010577f:	c3                   	retq   

ffffffff80105780 <initlock>:
#include <spinlock.h>


void
initlock(struct spinlock *lk, char *name)
{
ffffffff80105780:	55                   	push   %rbp
ffffffff80105781:	48 89 e5             	mov    %rsp,%rbp
ffffffff80105784:	48 83 ec 10          	sub    $0x10,%rsp
ffffffff80105788:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
ffffffff8010578c:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  lk->name = name;
ffffffff80105790:	48 8b 75 f0          	mov    -0x10(%rbp),%rsi
ffffffff80105794:	48 8b 7d f8          	mov    -0x8(%rbp),%rdi
ffffffff80105798:	48 89 77 08          	mov    %rsi,0x8(%rdi)
  lk->locked = 0;
ffffffff8010579c:	48 8b 75 f8          	mov    -0x8(%rbp),%rsi
ffffffff801057a0:	c7 06 00 00 00 00    	movl   $0x0,(%rsi)
  lk->cpu = 0;
ffffffff801057a6:	48 8b 75 f8          	mov    -0x8(%rbp),%rsi
ffffffff801057aa:	48 c7 46 10 00 00 00 	movq   $0x0,0x10(%rsi)
ffffffff801057b1:	00 
}
ffffffff801057b2:	48 83 c4 10          	add    $0x10,%rsp
ffffffff801057b6:	5d                   	pop    %rbp
ffffffff801057b7:	c3                   	retq   
ffffffff801057b8:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
ffffffff801057bf:	00 

ffffffff801057c0 <acquire>:
// Loops (spins) until the lock is acquired.
// Holding a lock for a long time may cause
// other CPUs to waste time spinning to acquire it.
void
acquire(struct spinlock *lk)
{
ffffffff801057c0:	55                   	push   %rbp
ffffffff801057c1:	48 89 e5             	mov    %rsp,%rbp
ffffffff801057c4:	48 83 ec 10          	sub    $0x10,%rsp
ffffffff801057c8:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  pushcli(); // disable interrupts to avoid deadlock.
ffffffff801057cc:	e8 7f 00 00 00       	callq  ffffffff80105850 <pushcli>
  if(holding(lk))
ffffffff801057d1:	48 8b 7d f8          	mov    -0x8(%rbp),%rdi
ffffffff801057d5:	e8 d6 00 00 00       	callq  ffffffff801058b0 <holding>
ffffffff801057da:	83 f8 00             	cmp    $0x0,%eax
ffffffff801057dd:	0f 84 0c 00 00 00    	je     ffffffff801057ef <acquire+0x2f>
    panic("acquire");
ffffffff801057e3:	48 c7 c7 cf fe 10 80 	mov    $0xffffffff8010fecf,%rdi
ffffffff801057ea:	e8 81 b6 ff ff       	callq  ffffffff80100e70 <panic>

  // The xchg is atomic.
  while(xchg(&lk->locked, 1) != 0)
ffffffff801057ef:	e9 00 00 00 00       	jmpq   ffffffff801057f4 <acquire+0x34>
ffffffff801057f4:	b8 01 00 00 00       	mov    $0x1,%eax
ffffffff801057f9:	48 8b 7d f8          	mov    -0x8(%rbp),%rdi
ffffffff801057fd:	be 01 00 00 00       	mov    $0x1,%esi
ffffffff80105802:	89 45 f4             	mov    %eax,-0xc(%rbp)
ffffffff80105805:	e8 f6 00 00 00       	callq  ffffffff80105900 <xchg>
ffffffff8010580a:	83 f8 00             	cmp    $0x0,%eax
ffffffff8010580d:	0f 84 05 00 00 00    	je     ffffffff80105818 <acquire+0x58>
ffffffff80105813:	e9 dc ff ff ff       	jmpq   ffffffff801057f4 <acquire+0x34>
    ;

  // Tell the C compiler and the processor to not move loads or stores
  // past this point, to ensure that the critical section's memory
  // references happen after the lock is acquired.
  __sync_synchronize();
ffffffff80105818:	0f ae f0             	mfence 

  // Record info about lock acquisition for debugging.
  lk->cpu = mycpu();
ffffffff8010581b:	e8 10 01 00 00       	callq  ffffffff80105930 <mycpu>
ffffffff80105820:	48 8d 4d f8          	lea    -0x8(%rbp),%rcx
ffffffff80105824:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
ffffffff80105828:	48 89 42 10          	mov    %rax,0x10(%rdx)
  getcallerpcs(&lk, lk->pcs);
ffffffff8010582c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
ffffffff80105830:	48 83 c0 18          	add    $0x18,%rax
ffffffff80105834:	48 89 cf             	mov    %rcx,%rdi
ffffffff80105837:	48 89 c6             	mov    %rax,%rsi
ffffffff8010583a:	e8 01 01 00 00       	callq  ffffffff80105940 <getcallerpcs>
}
ffffffff8010583f:	48 83 c4 10          	add    $0x10,%rsp
ffffffff80105843:	5d                   	pop    %rbp
ffffffff80105844:	c3                   	retq   
ffffffff80105845:	66 66 2e 0f 1f 84 00 	data16 nopw %cs:0x0(%rax,%rax,1)
ffffffff8010584c:	00 00 00 00 

ffffffff80105850 <pushcli>:
// it takes two popcli to undo two pushcli.  Also, if interrupts
// are off, then pushcli, popcli leaves them off.

void
pushcli(void)
{
ffffffff80105850:	55                   	push   %rbp
ffffffff80105851:	48 89 e5             	mov    %rsp,%rbp
  int eflags;

  eflags = readeflags();
ffffffff80105854:	48 83 ec 10          	sub    $0x10,%rsp
ffffffff80105858:	e8 83 02 00 00       	callq  ffffffff80105ae0 <readeflags>
ffffffff8010585d:	89 c1                	mov    %eax,%ecx
ffffffff8010585f:	89 4d fc             	mov    %ecx,-0x4(%rbp)
  cli();
ffffffff80105862:	e8 99 02 00 00       	callq  ffffffff80105b00 <cli>
  if(mycpu()->ncli == 0)
ffffffff80105867:	e8 c4 00 00 00       	callq  ffffffff80105930 <mycpu>
ffffffff8010586c:	83 b8 bc 00 00 00 00 	cmpl   $0x0,0xbc(%rax)
ffffffff80105873:	0f 85 1d 00 00 00    	jne    ffffffff80105896 <pushcli+0x46>
    mycpu()->intena = eflags & FLAGS_IF;
ffffffff80105879:	48 63 45 fc          	movslq -0x4(%rbp),%rax
ffffffff8010587d:	48 25 00 02 00 00    	and    $0x200,%rax
ffffffff80105883:	89 c1                	mov    %eax,%ecx
ffffffff80105885:	89 4d f8             	mov    %ecx,-0x8(%rbp)
ffffffff80105888:	e8 a3 00 00 00       	callq  ffffffff80105930 <mycpu>
ffffffff8010588d:	8b 4d f8             	mov    -0x8(%rbp),%ecx
ffffffff80105890:	89 88 c0 00 00 00    	mov    %ecx,0xc0(%rax)
  mycpu()->ncli += 1;
ffffffff80105896:	e8 95 00 00 00       	callq  ffffffff80105930 <mycpu>
ffffffff8010589b:	8b 88 bc 00 00 00    	mov    0xbc(%rax),%ecx
ffffffff801058a1:	83 c1 01             	add    $0x1,%ecx
ffffffff801058a4:	89 88 bc 00 00 00    	mov    %ecx,0xbc(%rax)
}
ffffffff801058aa:	48 83 c4 10          	add    $0x10,%rsp
ffffffff801058ae:	5d                   	pop    %rbp
ffffffff801058af:	c3                   	retq   

ffffffff801058b0 <holding>:
{
ffffffff801058b0:	55                   	push   %rbp
ffffffff801058b1:	48 89 e5             	mov    %rsp,%rbp
ffffffff801058b4:	48 83 ec 20          	sub    $0x20,%rsp
ffffffff801058b8:	31 c0                	xor    %eax,%eax
ffffffff801058ba:	88 c1                	mov    %al,%cl
ffffffff801058bc:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  return lock->locked && lock->cpu == mycpu();
ffffffff801058c0:	48 8b 7d f8          	mov    -0x8(%rbp),%rdi
ffffffff801058c4:	83 3f 00             	cmpl   $0x0,(%rdi)
ffffffff801058c7:	88 4d f7             	mov    %cl,-0x9(%rbp)
ffffffff801058ca:	0f 84 1e 00 00 00    	je     ffffffff801058ee <holding+0x3e>
ffffffff801058d0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
ffffffff801058d4:	48 8b 40 10          	mov    0x10(%rax),%rax
ffffffff801058d8:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
ffffffff801058dc:	e8 4f 00 00 00       	callq  ffffffff80105930 <mycpu>
ffffffff801058e1:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
ffffffff801058e5:	48 39 c1             	cmp    %rax,%rcx
ffffffff801058e8:	0f 94 c2             	sete   %dl
ffffffff801058eb:	88 55 f7             	mov    %dl,-0x9(%rbp)
ffffffff801058ee:	8a 45 f7             	mov    -0x9(%rbp),%al
ffffffff801058f1:	24 01                	and    $0x1,%al
ffffffff801058f3:	0f b6 c0             	movzbl %al,%eax
ffffffff801058f6:	48 83 c4 20          	add    $0x20,%rsp
ffffffff801058fa:	5d                   	pop    %rbp
ffffffff801058fb:	c3                   	retq   
ffffffff801058fc:	0f 1f 40 00          	nopl   0x0(%rax)

ffffffff80105900 <xchg>:
{
ffffffff80105900:	55                   	push   %rbp
ffffffff80105901:	48 89 e5             	mov    %rsp,%rbp
ffffffff80105904:	48 83 ec 10          	sub    $0x10,%rsp
ffffffff80105908:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
ffffffff8010590c:	89 75 f4             	mov    %esi,-0xc(%rbp)
               "+m" (*addr), "=a" (result) :
ffffffff8010590f:	48 8b 7d f8          	mov    -0x8(%rbp),%rdi
               "1" (newval) :
ffffffff80105913:	8b 75 f4             	mov    -0xc(%rbp),%esi
  asm volatile("lock; xchgl %0, %1" :
ffffffff80105916:	89 f0                	mov    %esi,%eax
ffffffff80105918:	f0 87 07             	lock xchg %eax,(%rdi)
ffffffff8010591b:	89 45 f0             	mov    %eax,-0x10(%rbp)
  return result;
ffffffff8010591e:	8b 45 f0             	mov    -0x10(%rbp),%eax
ffffffff80105921:	48 83 c4 10          	add    $0x10,%rsp
ffffffff80105925:	5d                   	pop    %rbp
ffffffff80105926:	c3                   	retq   
ffffffff80105927:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
ffffffff8010592e:	00 00 

ffffffff80105930 <mycpu>:
{
ffffffff80105930:	55                   	push   %rbp
ffffffff80105931:	48 89 e5             	mov    %rsp,%rbp
  return &cpus[0];
ffffffff80105934:	48 c7 c0 e0 7b 1f 83 	mov    $0xffffffff831f7be0,%rax
ffffffff8010593b:	5d                   	pop    %rbp
ffffffff8010593c:	c3                   	retq   
ffffffff8010593d:	0f 1f 00             	nopl   (%rax)

ffffffff80105940 <getcallerpcs>:
{
ffffffff80105940:	55                   	push   %rbp
ffffffff80105941:	48 89 e5             	mov    %rsp,%rbp
ffffffff80105944:	48 83 ec 20          	sub    $0x20,%rsp
ffffffff80105948:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
ffffffff8010594c:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  asm volatile("mov %%rbp, %0" : "=r" (rbp));
ffffffff80105950:	48 89 ee             	mov    %rbp,%rsi
ffffffff80105953:	48 89 75 e8          	mov    %rsi,-0x18(%rbp)
  for(i = 0; i < 10; i++){
ffffffff80105957:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%rbp)
ffffffff8010595e:	83 7d e4 0a          	cmpl   $0xa,-0x1c(%rbp)
ffffffff80105962:	0f 8d 5f 00 00 00    	jge    ffffffff801059c7 <getcallerpcs+0x87>
    if(rbp == 0 || rbp < (uint64_t*)KERNBASE || rbp == (uint64_t*)0xffffffffffffffff)
ffffffff80105968:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
ffffffff8010596d:	0f 84 22 00 00 00    	je     ffffffff80105995 <getcallerpcs+0x55>
ffffffff80105973:	48 c7 c0 00 00 00 80 	mov    $0xffffffff80000000,%rax
ffffffff8010597a:	48 39 45 e8          	cmp    %rax,-0x18(%rbp)
ffffffff8010597e:	0f 82 11 00 00 00    	jb     ffffffff80105995 <getcallerpcs+0x55>
ffffffff80105984:	48 c7 c0 ff ff ff ff 	mov    $0xffffffffffffffff,%rax
ffffffff8010598b:	48 39 45 e8          	cmp    %rax,-0x18(%rbp)
ffffffff8010598f:	0f 85 05 00 00 00    	jne    ffffffff8010599a <getcallerpcs+0x5a>
      break;
ffffffff80105995:	e9 2d 00 00 00       	jmpq   ffffffff801059c7 <getcallerpcs+0x87>
    pcs[i] = rbp[1];     // saved %eip
ffffffff8010599a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
ffffffff8010599e:	48 8b 40 08          	mov    0x8(%rax),%rax
ffffffff801059a2:	48 8b 4d f0          	mov    -0x10(%rbp),%rcx
ffffffff801059a6:	48 63 55 e4          	movslq -0x1c(%rbp),%rdx
ffffffff801059aa:	48 89 04 d1          	mov    %rax,(%rcx,%rdx,8)
    rbp = (uint64_t*)rbp[0]; // saved %ebp
ffffffff801059ae:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
ffffffff801059b2:	48 8b 00             	mov    (%rax),%rax
ffffffff801059b5:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  for(i = 0; i < 10; i++){
ffffffff801059b9:	8b 45 e4             	mov    -0x1c(%rbp),%eax
ffffffff801059bc:	83 c0 01             	add    $0x1,%eax
ffffffff801059bf:	89 45 e4             	mov    %eax,-0x1c(%rbp)
ffffffff801059c2:	e9 97 ff ff ff       	jmpq   ffffffff8010595e <getcallerpcs+0x1e>
  for(; i < 10; i++)
ffffffff801059c7:	e9 00 00 00 00       	jmpq   ffffffff801059cc <getcallerpcs+0x8c>
ffffffff801059cc:	83 7d e4 0a          	cmpl   $0xa,-0x1c(%rbp)
ffffffff801059d0:	0f 8d 1e 00 00 00    	jge    ffffffff801059f4 <getcallerpcs+0xb4>
    pcs[i] = 0;
ffffffff801059d6:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
ffffffff801059da:	48 63 4d e4          	movslq -0x1c(%rbp),%rcx
ffffffff801059de:	48 c7 04 c8 00 00 00 	movq   $0x0,(%rax,%rcx,8)
ffffffff801059e5:	00 
  for(; i < 10; i++)
ffffffff801059e6:	8b 45 e4             	mov    -0x1c(%rbp),%eax
ffffffff801059e9:	83 c0 01             	add    $0x1,%eax
ffffffff801059ec:	89 45 e4             	mov    %eax,-0x1c(%rbp)
ffffffff801059ef:	e9 d8 ff ff ff       	jmpq   ffffffff801059cc <getcallerpcs+0x8c>
}
ffffffff801059f4:	48 83 c4 20          	add    $0x20,%rsp
ffffffff801059f8:	5d                   	pop    %rbp
ffffffff801059f9:	c3                   	retq   
ffffffff801059fa:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)

ffffffff80105a00 <release>:
{
ffffffff80105a00:	55                   	push   %rbp
ffffffff80105a01:	48 89 e5             	mov    %rsp,%rbp
ffffffff80105a04:	48 83 ec 10          	sub    $0x10,%rsp
ffffffff80105a08:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  if(!holding(lk))
ffffffff80105a0c:	48 8b 7d f8          	mov    -0x8(%rbp),%rdi
ffffffff80105a10:	e8 9b fe ff ff       	callq  ffffffff801058b0 <holding>
ffffffff80105a15:	83 f8 00             	cmp    $0x0,%eax
ffffffff80105a18:	0f 85 0c 00 00 00    	jne    ffffffff80105a2a <release+0x2a>
    panic("release");
ffffffff80105a1e:	48 c7 c7 d7 fe 10 80 	mov    $0xffffffff8010fed7,%rdi
ffffffff80105a25:	e8 46 b4 ff ff       	callq  ffffffff80100e70 <panic>
  lk->pcs[0] = 0;
ffffffff80105a2a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
ffffffff80105a2e:	48 c7 40 18 00 00 00 	movq   $0x0,0x18(%rax)
ffffffff80105a35:	00 
  lk->cpu = 0;
ffffffff80105a36:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
ffffffff80105a3a:	48 c7 40 10 00 00 00 	movq   $0x0,0x10(%rax)
ffffffff80105a41:	00 
  __sync_synchronize();
ffffffff80105a42:	0f ae f0             	mfence 
  asm volatile("movl $0, %0" : "+m" (lk->locked) : );
ffffffff80105a45:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
ffffffff80105a49:	c7 00 00 00 00 00    	movl   $0x0,(%rax)
  popcli();
ffffffff80105a4f:	e8 0c 00 00 00       	callq  ffffffff80105a60 <popcli>
}
ffffffff80105a54:	48 83 c4 10          	add    $0x10,%rsp
ffffffff80105a58:	5d                   	pop    %rbp
ffffffff80105a59:	c3                   	retq   
ffffffff80105a5a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)

ffffffff80105a60 <popcli>:

void
popcli(void)
{
ffffffff80105a60:	55                   	push   %rbp
ffffffff80105a61:	48 89 e5             	mov    %rsp,%rbp
  if(readeflags()&FLAGS_IF)
ffffffff80105a64:	e8 77 00 00 00       	callq  ffffffff80105ae0 <readeflags>
ffffffff80105a69:	48 25 00 02 00 00    	and    $0x200,%rax
ffffffff80105a6f:	48 83 f8 00          	cmp    $0x0,%rax
ffffffff80105a73:	0f 84 0c 00 00 00    	je     ffffffff80105a85 <popcli+0x25>
    panic("popcli - interruptible");
ffffffff80105a79:	48 c7 c7 df fe 10 80 	mov    $0xffffffff8010fedf,%rdi
ffffffff80105a80:	e8 eb b3 ff ff       	callq  ffffffff80100e70 <panic>
  if(--mycpu()->ncli < 0)
ffffffff80105a85:	e8 a6 fe ff ff       	callq  ffffffff80105930 <mycpu>
ffffffff80105a8a:	8b 88 bc 00 00 00    	mov    0xbc(%rax),%ecx
ffffffff80105a90:	83 c1 ff             	add    $0xffffffff,%ecx
ffffffff80105a93:	89 88 bc 00 00 00    	mov    %ecx,0xbc(%rax)
ffffffff80105a99:	83 f9 00             	cmp    $0x0,%ecx
ffffffff80105a9c:	0f 8d 0c 00 00 00    	jge    ffffffff80105aae <popcli+0x4e>
    panic("popcli");
ffffffff80105aa2:	48 c7 c7 f6 fe 10 80 	mov    $0xffffffff8010fef6,%rdi
ffffffff80105aa9:	e8 c2 b3 ff ff       	callq  ffffffff80100e70 <panic>
  if(mycpu()->ncli == 0 && mycpu()->intena)
ffffffff80105aae:	e8 7d fe ff ff       	callq  ffffffff80105930 <mycpu>
ffffffff80105ab3:	83 b8 bc 00 00 00 00 	cmpl   $0x0,0xbc(%rax)
ffffffff80105aba:	0f 85 17 00 00 00    	jne    ffffffff80105ad7 <popcli+0x77>
ffffffff80105ac0:	e8 6b fe ff ff       	callq  ffffffff80105930 <mycpu>
ffffffff80105ac5:	83 b8 c0 00 00 00 00 	cmpl   $0x0,0xc0(%rax)
ffffffff80105acc:	0f 84 05 00 00 00    	je     ffffffff80105ad7 <popcli+0x77>
    sti();
ffffffff80105ad2:	e8 39 00 00 00       	callq  ffffffff80105b10 <sti>
}
ffffffff80105ad7:	5d                   	pop    %rbp
ffffffff80105ad8:	c3                   	retq   
ffffffff80105ad9:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)

ffffffff80105ae0 <readeflags>:
{
ffffffff80105ae0:	55                   	push   %rbp
ffffffff80105ae1:	48 89 e5             	mov    %rsp,%rbp
  asm volatile("pushf; pop %0" : "=r" (eflags));
ffffffff80105ae4:	50                   	push   %rax
ffffffff80105ae5:	9c                   	pushfq 
ffffffff80105ae6:	58                   	pop    %rax
ffffffff80105ae7:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  return eflags;
ffffffff80105aeb:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
ffffffff80105aef:	48 83 c4 08          	add    $0x8,%rsp
ffffffff80105af3:	5d                   	pop    %rbp
ffffffff80105af4:	c3                   	retq   
ffffffff80105af5:	66 66 2e 0f 1f 84 00 	data16 nopw %cs:0x0(%rax,%rax,1)
ffffffff80105afc:	00 00 00 00 

ffffffff80105b00 <cli>:
{
ffffffff80105b00:	55                   	push   %rbp
ffffffff80105b01:	48 89 e5             	mov    %rsp,%rbp
  asm volatile("cli");
ffffffff80105b04:	fa                   	cli    
}
ffffffff80105b05:	5d                   	pop    %rbp
ffffffff80105b06:	c3                   	retq   
ffffffff80105b07:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
ffffffff80105b0e:	00 00 

ffffffff80105b10 <sti>:
{
ffffffff80105b10:	55                   	push   %rbp
ffffffff80105b11:	48 89 e5             	mov    %rsp,%rbp
  asm volatile("sti");
ffffffff80105b14:	fb                   	sti    
}
ffffffff80105b15:	5d                   	pop    %rbp
ffffffff80105b16:	c3                   	retq   
ffffffff80105b17:	90                   	nop

ffffffff80105b18 <vector0>:
.globl alltraps
.globl vector0
vector0:
  push $0
ffffffff80105b18:	6a 00                	pushq  $0x0
  push $0
ffffffff80105b1a:	6a 00                	pushq  $0x0
  jmp alltraps
ffffffff80105b1c:	e9 6b 0a 00 00       	jmpq   ffffffff8010658c <alltraps>

ffffffff80105b21 <vector1>:
.globl vector1
vector1:
  push $0
ffffffff80105b21:	6a 00                	pushq  $0x0
  push $1
ffffffff80105b23:	6a 01                	pushq  $0x1
  jmp alltraps
ffffffff80105b25:	e9 62 0a 00 00       	jmpq   ffffffff8010658c <alltraps>

ffffffff80105b2a <vector2>:
.globl vector2
vector2:
  push $0
ffffffff80105b2a:	6a 00                	pushq  $0x0
  push $2
ffffffff80105b2c:	6a 02                	pushq  $0x2
  jmp alltraps
ffffffff80105b2e:	e9 59 0a 00 00       	jmpq   ffffffff8010658c <alltraps>

ffffffff80105b33 <vector3>:
.globl vector3
vector3:
  push $0
ffffffff80105b33:	6a 00                	pushq  $0x0
  push $3
ffffffff80105b35:	6a 03                	pushq  $0x3
  jmp alltraps
ffffffff80105b37:	e9 50 0a 00 00       	jmpq   ffffffff8010658c <alltraps>

ffffffff80105b3c <vector4>:
.globl vector4
vector4:
  push $0
ffffffff80105b3c:	6a 00                	pushq  $0x0
  push $4
ffffffff80105b3e:	6a 04                	pushq  $0x4
  jmp alltraps
ffffffff80105b40:	e9 47 0a 00 00       	jmpq   ffffffff8010658c <alltraps>

ffffffff80105b45 <vector5>:
.globl vector5
vector5:
  push $0
ffffffff80105b45:	6a 00                	pushq  $0x0
  push $5
ffffffff80105b47:	6a 05                	pushq  $0x5
  jmp alltraps
ffffffff80105b49:	e9 3e 0a 00 00       	jmpq   ffffffff8010658c <alltraps>

ffffffff80105b4e <vector6>:
.globl vector6
vector6:
  push $0
ffffffff80105b4e:	6a 00                	pushq  $0x0
  push $6
ffffffff80105b50:	6a 06                	pushq  $0x6
  jmp alltraps
ffffffff80105b52:	e9 35 0a 00 00       	jmpq   ffffffff8010658c <alltraps>

ffffffff80105b57 <vector7>:
.globl vector7
vector7:
  push $0
ffffffff80105b57:	6a 00                	pushq  $0x0
  push $7
ffffffff80105b59:	6a 07                	pushq  $0x7
  jmp alltraps
ffffffff80105b5b:	e9 2c 0a 00 00       	jmpq   ffffffff8010658c <alltraps>

ffffffff80105b60 <vector8>:
.globl vector8
vector8:
  push $8
ffffffff80105b60:	6a 08                	pushq  $0x8
  jmp alltraps
ffffffff80105b62:	e9 25 0a 00 00       	jmpq   ffffffff8010658c <alltraps>

ffffffff80105b67 <vector9>:
.globl vector9
vector9:
  push $0
ffffffff80105b67:	6a 00                	pushq  $0x0
  push $9
ffffffff80105b69:	6a 09                	pushq  $0x9
  jmp alltraps
ffffffff80105b6b:	e9 1c 0a 00 00       	jmpq   ffffffff8010658c <alltraps>

ffffffff80105b70 <vector10>:
.globl vector10
vector10:
  push $10
ffffffff80105b70:	6a 0a                	pushq  $0xa
  jmp alltraps
ffffffff80105b72:	e9 15 0a 00 00       	jmpq   ffffffff8010658c <alltraps>

ffffffff80105b77 <vector11>:
.globl vector11
vector11:
  push $11
ffffffff80105b77:	6a 0b                	pushq  $0xb
  jmp alltraps
ffffffff80105b79:	e9 0e 0a 00 00       	jmpq   ffffffff8010658c <alltraps>

ffffffff80105b7e <vector12>:
.globl vector12
vector12:
  push $12
ffffffff80105b7e:	6a 0c                	pushq  $0xc
  jmp alltraps
ffffffff80105b80:	e9 07 0a 00 00       	jmpq   ffffffff8010658c <alltraps>

ffffffff80105b85 <vector13>:
.globl vector13
vector13:
  push $13
ffffffff80105b85:	6a 0d                	pushq  $0xd
  jmp alltraps
ffffffff80105b87:	e9 00 0a 00 00       	jmpq   ffffffff8010658c <alltraps>

ffffffff80105b8c <vector14>:
.globl vector14
vector14:
  push $14
ffffffff80105b8c:	6a 0e                	pushq  $0xe
  jmp alltraps
ffffffff80105b8e:	e9 f9 09 00 00       	jmpq   ffffffff8010658c <alltraps>

ffffffff80105b93 <vector15>:
.globl vector15
vector15:
  push $0
ffffffff80105b93:	6a 00                	pushq  $0x0
  push $15
ffffffff80105b95:	6a 0f                	pushq  $0xf
  jmp alltraps
ffffffff80105b97:	e9 f0 09 00 00       	jmpq   ffffffff8010658c <alltraps>

ffffffff80105b9c <vector16>:
.globl vector16
vector16:
  push $0
ffffffff80105b9c:	6a 00                	pushq  $0x0
  push $16
ffffffff80105b9e:	6a 10                	pushq  $0x10
  jmp alltraps
ffffffff80105ba0:	e9 e7 09 00 00       	jmpq   ffffffff8010658c <alltraps>

ffffffff80105ba5 <vector17>:
.globl vector17
vector17:
  push $17
ffffffff80105ba5:	6a 11                	pushq  $0x11
  jmp alltraps
ffffffff80105ba7:	e9 e0 09 00 00       	jmpq   ffffffff8010658c <alltraps>

ffffffff80105bac <vector18>:
.globl vector18
vector18:
  push $0
ffffffff80105bac:	6a 00                	pushq  $0x0
  push $18
ffffffff80105bae:	6a 12                	pushq  $0x12
  jmp alltraps
ffffffff80105bb0:	e9 d7 09 00 00       	jmpq   ffffffff8010658c <alltraps>

ffffffff80105bb5 <vector19>:
.globl vector19
vector19:
  push $0
ffffffff80105bb5:	6a 00                	pushq  $0x0
  push $19
ffffffff80105bb7:	6a 13                	pushq  $0x13
  jmp alltraps
ffffffff80105bb9:	e9 ce 09 00 00       	jmpq   ffffffff8010658c <alltraps>

ffffffff80105bbe <vector20>:
.globl vector20
vector20:
  push $0
ffffffff80105bbe:	6a 00                	pushq  $0x0
  push $20
ffffffff80105bc0:	6a 14                	pushq  $0x14
  jmp alltraps
ffffffff80105bc2:	e9 c5 09 00 00       	jmpq   ffffffff8010658c <alltraps>

ffffffff80105bc7 <vector21>:
.globl vector21
vector21:
  push $0
ffffffff80105bc7:	6a 00                	pushq  $0x0
  push $21
ffffffff80105bc9:	6a 15                	pushq  $0x15
  jmp alltraps
ffffffff80105bcb:	e9 bc 09 00 00       	jmpq   ffffffff8010658c <alltraps>

ffffffff80105bd0 <vector22>:
.globl vector22
vector22:
  push $0
ffffffff80105bd0:	6a 00                	pushq  $0x0
  push $22
ffffffff80105bd2:	6a 16                	pushq  $0x16
  jmp alltraps
ffffffff80105bd4:	e9 b3 09 00 00       	jmpq   ffffffff8010658c <alltraps>

ffffffff80105bd9 <vector23>:
.globl vector23
vector23:
  push $0
ffffffff80105bd9:	6a 00                	pushq  $0x0
  push $23
ffffffff80105bdb:	6a 17                	pushq  $0x17
  jmp alltraps
ffffffff80105bdd:	e9 aa 09 00 00       	jmpq   ffffffff8010658c <alltraps>

ffffffff80105be2 <vector24>:
.globl vector24
vector24:
  push $0
ffffffff80105be2:	6a 00                	pushq  $0x0
  push $24
ffffffff80105be4:	6a 18                	pushq  $0x18
  jmp alltraps
ffffffff80105be6:	e9 a1 09 00 00       	jmpq   ffffffff8010658c <alltraps>

ffffffff80105beb <vector25>:
.globl vector25
vector25:
  push $0
ffffffff80105beb:	6a 00                	pushq  $0x0
  push $25
ffffffff80105bed:	6a 19                	pushq  $0x19
  jmp alltraps
ffffffff80105bef:	e9 98 09 00 00       	jmpq   ffffffff8010658c <alltraps>

ffffffff80105bf4 <vector26>:
.globl vector26
vector26:
  push $0
ffffffff80105bf4:	6a 00                	pushq  $0x0
  push $26
ffffffff80105bf6:	6a 1a                	pushq  $0x1a
  jmp alltraps
ffffffff80105bf8:	e9 8f 09 00 00       	jmpq   ffffffff8010658c <alltraps>

ffffffff80105bfd <vector27>:
.globl vector27
vector27:
  push $0
ffffffff80105bfd:	6a 00                	pushq  $0x0
  push $27
ffffffff80105bff:	6a 1b                	pushq  $0x1b
  jmp alltraps
ffffffff80105c01:	e9 86 09 00 00       	jmpq   ffffffff8010658c <alltraps>

ffffffff80105c06 <vector28>:
.globl vector28
vector28:
  push $0
ffffffff80105c06:	6a 00                	pushq  $0x0
  push $28
ffffffff80105c08:	6a 1c                	pushq  $0x1c
  jmp alltraps
ffffffff80105c0a:	e9 7d 09 00 00       	jmpq   ffffffff8010658c <alltraps>

ffffffff80105c0f <vector29>:
.globl vector29
vector29:
  push $0
ffffffff80105c0f:	6a 00                	pushq  $0x0
  push $29
ffffffff80105c11:	6a 1d                	pushq  $0x1d
  jmp alltraps
ffffffff80105c13:	e9 74 09 00 00       	jmpq   ffffffff8010658c <alltraps>

ffffffff80105c18 <vector30>:
.globl vector30
vector30:
  push $0
ffffffff80105c18:	6a 00                	pushq  $0x0
  push $30
ffffffff80105c1a:	6a 1e                	pushq  $0x1e
  jmp alltraps
ffffffff80105c1c:	e9 6b 09 00 00       	jmpq   ffffffff8010658c <alltraps>

ffffffff80105c21 <vector31>:
.globl vector31
vector31:
  push $0
ffffffff80105c21:	6a 00                	pushq  $0x0
  push $31
ffffffff80105c23:	6a 1f                	pushq  $0x1f
  jmp alltraps
ffffffff80105c25:	e9 62 09 00 00       	jmpq   ffffffff8010658c <alltraps>

ffffffff80105c2a <vector32>:
.globl vector32
vector32:
  push $0
ffffffff80105c2a:	6a 00                	pushq  $0x0
  push $32
ffffffff80105c2c:	6a 20                	pushq  $0x20
  jmp alltraps
ffffffff80105c2e:	e9 59 09 00 00       	jmpq   ffffffff8010658c <alltraps>

ffffffff80105c33 <vector33>:
.globl vector33
vector33:
  push $0
ffffffff80105c33:	6a 00                	pushq  $0x0
  push $33
ffffffff80105c35:	6a 21                	pushq  $0x21
  jmp alltraps
ffffffff80105c37:	e9 50 09 00 00       	jmpq   ffffffff8010658c <alltraps>

ffffffff80105c3c <vector34>:
.globl vector34
vector34:
  push $0
ffffffff80105c3c:	6a 00                	pushq  $0x0
  push $34
ffffffff80105c3e:	6a 22                	pushq  $0x22
  jmp alltraps
ffffffff80105c40:	e9 47 09 00 00       	jmpq   ffffffff8010658c <alltraps>

ffffffff80105c45 <vector35>:
.globl vector35
vector35:
  push $0
ffffffff80105c45:	6a 00                	pushq  $0x0
  push $35
ffffffff80105c47:	6a 23                	pushq  $0x23
  jmp alltraps
ffffffff80105c49:	e9 3e 09 00 00       	jmpq   ffffffff8010658c <alltraps>

ffffffff80105c4e <vector36>:
.globl vector36
vector36:
  push $0
ffffffff80105c4e:	6a 00                	pushq  $0x0
  push $36
ffffffff80105c50:	6a 24                	pushq  $0x24
  jmp alltraps
ffffffff80105c52:	e9 35 09 00 00       	jmpq   ffffffff8010658c <alltraps>

ffffffff80105c57 <vector37>:
.globl vector37
vector37:
  push $0
ffffffff80105c57:	6a 00                	pushq  $0x0
  push $37
ffffffff80105c59:	6a 25                	pushq  $0x25
  jmp alltraps
ffffffff80105c5b:	e9 2c 09 00 00       	jmpq   ffffffff8010658c <alltraps>

ffffffff80105c60 <vector38>:
.globl vector38
vector38:
  push $0
ffffffff80105c60:	6a 00                	pushq  $0x0
  push $38
ffffffff80105c62:	6a 26                	pushq  $0x26
  jmp alltraps
ffffffff80105c64:	e9 23 09 00 00       	jmpq   ffffffff8010658c <alltraps>

ffffffff80105c69 <vector39>:
.globl vector39
vector39:
  push $0
ffffffff80105c69:	6a 00                	pushq  $0x0
  push $39
ffffffff80105c6b:	6a 27                	pushq  $0x27
  jmp alltraps
ffffffff80105c6d:	e9 1a 09 00 00       	jmpq   ffffffff8010658c <alltraps>

ffffffff80105c72 <vector40>:
.globl vector40
vector40:
  push $0
ffffffff80105c72:	6a 00                	pushq  $0x0
  push $40
ffffffff80105c74:	6a 28                	pushq  $0x28
  jmp alltraps
ffffffff80105c76:	e9 11 09 00 00       	jmpq   ffffffff8010658c <alltraps>

ffffffff80105c7b <vector41>:
.globl vector41
vector41:
  push $0
ffffffff80105c7b:	6a 00                	pushq  $0x0
  push $41
ffffffff80105c7d:	6a 29                	pushq  $0x29
  jmp alltraps
ffffffff80105c7f:	e9 08 09 00 00       	jmpq   ffffffff8010658c <alltraps>

ffffffff80105c84 <vector42>:
.globl vector42
vector42:
  push $0
ffffffff80105c84:	6a 00                	pushq  $0x0
  push $42
ffffffff80105c86:	6a 2a                	pushq  $0x2a
  jmp alltraps
ffffffff80105c88:	e9 ff 08 00 00       	jmpq   ffffffff8010658c <alltraps>

ffffffff80105c8d <vector43>:
.globl vector43
vector43:
  push $0
ffffffff80105c8d:	6a 00                	pushq  $0x0
  push $43
ffffffff80105c8f:	6a 2b                	pushq  $0x2b
  jmp alltraps
ffffffff80105c91:	e9 f6 08 00 00       	jmpq   ffffffff8010658c <alltraps>

ffffffff80105c96 <vector44>:
.globl vector44
vector44:
  push $0
ffffffff80105c96:	6a 00                	pushq  $0x0
  push $44
ffffffff80105c98:	6a 2c                	pushq  $0x2c
  jmp alltraps
ffffffff80105c9a:	e9 ed 08 00 00       	jmpq   ffffffff8010658c <alltraps>

ffffffff80105c9f <vector45>:
.globl vector45
vector45:
  push $0
ffffffff80105c9f:	6a 00                	pushq  $0x0
  push $45
ffffffff80105ca1:	6a 2d                	pushq  $0x2d
  jmp alltraps
ffffffff80105ca3:	e9 e4 08 00 00       	jmpq   ffffffff8010658c <alltraps>

ffffffff80105ca8 <vector46>:
.globl vector46
vector46:
  push $0
ffffffff80105ca8:	6a 00                	pushq  $0x0
  push $46
ffffffff80105caa:	6a 2e                	pushq  $0x2e
  jmp alltraps
ffffffff80105cac:	e9 db 08 00 00       	jmpq   ffffffff8010658c <alltraps>

ffffffff80105cb1 <vector47>:
.globl vector47
vector47:
  push $0
ffffffff80105cb1:	6a 00                	pushq  $0x0
  push $47
ffffffff80105cb3:	6a 2f                	pushq  $0x2f
  jmp alltraps
ffffffff80105cb5:	e9 d2 08 00 00       	jmpq   ffffffff8010658c <alltraps>

ffffffff80105cba <vector48>:
.globl vector48
vector48:
  push $0
ffffffff80105cba:	6a 00                	pushq  $0x0
  push $48
ffffffff80105cbc:	6a 30                	pushq  $0x30
  jmp alltraps
ffffffff80105cbe:	e9 c9 08 00 00       	jmpq   ffffffff8010658c <alltraps>

ffffffff80105cc3 <vector49>:
.globl vector49
vector49:
  push $0
ffffffff80105cc3:	6a 00                	pushq  $0x0
  push $49
ffffffff80105cc5:	6a 31                	pushq  $0x31
  jmp alltraps
ffffffff80105cc7:	e9 c0 08 00 00       	jmpq   ffffffff8010658c <alltraps>

ffffffff80105ccc <vector50>:
.globl vector50
vector50:
  push $0
ffffffff80105ccc:	6a 00                	pushq  $0x0
  push $50
ffffffff80105cce:	6a 32                	pushq  $0x32
  jmp alltraps
ffffffff80105cd0:	e9 b7 08 00 00       	jmpq   ffffffff8010658c <alltraps>

ffffffff80105cd5 <vector51>:
.globl vector51
vector51:
  push $0
ffffffff80105cd5:	6a 00                	pushq  $0x0
  push $51
ffffffff80105cd7:	6a 33                	pushq  $0x33
  jmp alltraps
ffffffff80105cd9:	e9 ae 08 00 00       	jmpq   ffffffff8010658c <alltraps>

ffffffff80105cde <vector52>:
.globl vector52
vector52:
  push $0
ffffffff80105cde:	6a 00                	pushq  $0x0
  push $52
ffffffff80105ce0:	6a 34                	pushq  $0x34
  jmp alltraps
ffffffff80105ce2:	e9 a5 08 00 00       	jmpq   ffffffff8010658c <alltraps>

ffffffff80105ce7 <vector53>:
.globl vector53
vector53:
  push $0
ffffffff80105ce7:	6a 00                	pushq  $0x0
  push $53
ffffffff80105ce9:	6a 35                	pushq  $0x35
  jmp alltraps
ffffffff80105ceb:	e9 9c 08 00 00       	jmpq   ffffffff8010658c <alltraps>

ffffffff80105cf0 <vector54>:
.globl vector54
vector54:
  push $0
ffffffff80105cf0:	6a 00                	pushq  $0x0
  push $54
ffffffff80105cf2:	6a 36                	pushq  $0x36
  jmp alltraps
ffffffff80105cf4:	e9 93 08 00 00       	jmpq   ffffffff8010658c <alltraps>

ffffffff80105cf9 <vector55>:
.globl vector55
vector55:
  push $0
ffffffff80105cf9:	6a 00                	pushq  $0x0
  push $55
ffffffff80105cfb:	6a 37                	pushq  $0x37
  jmp alltraps
ffffffff80105cfd:	e9 8a 08 00 00       	jmpq   ffffffff8010658c <alltraps>

ffffffff80105d02 <vector56>:
.globl vector56
vector56:
  push $0
ffffffff80105d02:	6a 00                	pushq  $0x0
  push $56
ffffffff80105d04:	6a 38                	pushq  $0x38
  jmp alltraps
ffffffff80105d06:	e9 81 08 00 00       	jmpq   ffffffff8010658c <alltraps>

ffffffff80105d0b <vector57>:
.globl vector57
vector57:
  push $0
ffffffff80105d0b:	6a 00                	pushq  $0x0
  push $57
ffffffff80105d0d:	6a 39                	pushq  $0x39
  jmp alltraps
ffffffff80105d0f:	e9 78 08 00 00       	jmpq   ffffffff8010658c <alltraps>

ffffffff80105d14 <vector58>:
.globl vector58
vector58:
  push $0
ffffffff80105d14:	6a 00                	pushq  $0x0
  push $58
ffffffff80105d16:	6a 3a                	pushq  $0x3a
  jmp alltraps
ffffffff80105d18:	e9 6f 08 00 00       	jmpq   ffffffff8010658c <alltraps>

ffffffff80105d1d <vector59>:
.globl vector59
vector59:
  push $0
ffffffff80105d1d:	6a 00                	pushq  $0x0
  push $59
ffffffff80105d1f:	6a 3b                	pushq  $0x3b
  jmp alltraps
ffffffff80105d21:	e9 66 08 00 00       	jmpq   ffffffff8010658c <alltraps>

ffffffff80105d26 <vector60>:
.globl vector60
vector60:
  push $0
ffffffff80105d26:	6a 00                	pushq  $0x0
  push $60
ffffffff80105d28:	6a 3c                	pushq  $0x3c
  jmp alltraps
ffffffff80105d2a:	e9 5d 08 00 00       	jmpq   ffffffff8010658c <alltraps>

ffffffff80105d2f <vector61>:
.globl vector61
vector61:
  push $0
ffffffff80105d2f:	6a 00                	pushq  $0x0
  push $61
ffffffff80105d31:	6a 3d                	pushq  $0x3d
  jmp alltraps
ffffffff80105d33:	e9 54 08 00 00       	jmpq   ffffffff8010658c <alltraps>

ffffffff80105d38 <vector62>:
.globl vector62
vector62:
  push $0
ffffffff80105d38:	6a 00                	pushq  $0x0
  push $62
ffffffff80105d3a:	6a 3e                	pushq  $0x3e
  jmp alltraps
ffffffff80105d3c:	e9 4b 08 00 00       	jmpq   ffffffff8010658c <alltraps>

ffffffff80105d41 <vector63>:
.globl vector63
vector63:
  push $0
ffffffff80105d41:	6a 00                	pushq  $0x0
  push $63
ffffffff80105d43:	6a 3f                	pushq  $0x3f
  jmp alltraps
ffffffff80105d45:	e9 42 08 00 00       	jmpq   ffffffff8010658c <alltraps>

ffffffff80105d4a <vector64>:
.globl vector64
vector64:
  push $0
ffffffff80105d4a:	6a 00                	pushq  $0x0
  push $64
ffffffff80105d4c:	6a 40                	pushq  $0x40
  jmp alltraps
ffffffff80105d4e:	e9 39 08 00 00       	jmpq   ffffffff8010658c <alltraps>

ffffffff80105d53 <vector65>:
.globl vector65
vector65:
  push $0
ffffffff80105d53:	6a 00                	pushq  $0x0
  push $65
ffffffff80105d55:	6a 41                	pushq  $0x41
  jmp alltraps
ffffffff80105d57:	e9 30 08 00 00       	jmpq   ffffffff8010658c <alltraps>

ffffffff80105d5c <vector66>:
.globl vector66
vector66:
  push $0
ffffffff80105d5c:	6a 00                	pushq  $0x0
  push $66
ffffffff80105d5e:	6a 42                	pushq  $0x42
  jmp alltraps
ffffffff80105d60:	e9 27 08 00 00       	jmpq   ffffffff8010658c <alltraps>

ffffffff80105d65 <vector67>:
.globl vector67
vector67:
  push $0
ffffffff80105d65:	6a 00                	pushq  $0x0
  push $67
ffffffff80105d67:	6a 43                	pushq  $0x43
  jmp alltraps
ffffffff80105d69:	e9 1e 08 00 00       	jmpq   ffffffff8010658c <alltraps>

ffffffff80105d6e <vector68>:
.globl vector68
vector68:
  push $0
ffffffff80105d6e:	6a 00                	pushq  $0x0
  push $68
ffffffff80105d70:	6a 44                	pushq  $0x44
  jmp alltraps
ffffffff80105d72:	e9 15 08 00 00       	jmpq   ffffffff8010658c <alltraps>

ffffffff80105d77 <vector69>:
.globl vector69
vector69:
  push $0
ffffffff80105d77:	6a 00                	pushq  $0x0
  push $69
ffffffff80105d79:	6a 45                	pushq  $0x45
  jmp alltraps
ffffffff80105d7b:	e9 0c 08 00 00       	jmpq   ffffffff8010658c <alltraps>

ffffffff80105d80 <vector70>:
.globl vector70
vector70:
  push $0
ffffffff80105d80:	6a 00                	pushq  $0x0
  push $70
ffffffff80105d82:	6a 46                	pushq  $0x46
  jmp alltraps
ffffffff80105d84:	e9 03 08 00 00       	jmpq   ffffffff8010658c <alltraps>

ffffffff80105d89 <vector71>:
.globl vector71
vector71:
  push $0
ffffffff80105d89:	6a 00                	pushq  $0x0
  push $71
ffffffff80105d8b:	6a 47                	pushq  $0x47
  jmp alltraps
ffffffff80105d8d:	e9 fa 07 00 00       	jmpq   ffffffff8010658c <alltraps>

ffffffff80105d92 <vector72>:
.globl vector72
vector72:
  push $0
ffffffff80105d92:	6a 00                	pushq  $0x0
  push $72
ffffffff80105d94:	6a 48                	pushq  $0x48
  jmp alltraps
ffffffff80105d96:	e9 f1 07 00 00       	jmpq   ffffffff8010658c <alltraps>

ffffffff80105d9b <vector73>:
.globl vector73
vector73:
  push $0
ffffffff80105d9b:	6a 00                	pushq  $0x0
  push $73
ffffffff80105d9d:	6a 49                	pushq  $0x49
  jmp alltraps
ffffffff80105d9f:	e9 e8 07 00 00       	jmpq   ffffffff8010658c <alltraps>

ffffffff80105da4 <vector74>:
.globl vector74
vector74:
  push $0
ffffffff80105da4:	6a 00                	pushq  $0x0
  push $74
ffffffff80105da6:	6a 4a                	pushq  $0x4a
  jmp alltraps
ffffffff80105da8:	e9 df 07 00 00       	jmpq   ffffffff8010658c <alltraps>

ffffffff80105dad <vector75>:
.globl vector75
vector75:
  push $0
ffffffff80105dad:	6a 00                	pushq  $0x0
  push $75
ffffffff80105daf:	6a 4b                	pushq  $0x4b
  jmp alltraps
ffffffff80105db1:	e9 d6 07 00 00       	jmpq   ffffffff8010658c <alltraps>

ffffffff80105db6 <vector76>:
.globl vector76
vector76:
  push $0
ffffffff80105db6:	6a 00                	pushq  $0x0
  push $76
ffffffff80105db8:	6a 4c                	pushq  $0x4c
  jmp alltraps
ffffffff80105dba:	e9 cd 07 00 00       	jmpq   ffffffff8010658c <alltraps>

ffffffff80105dbf <vector77>:
.globl vector77
vector77:
  push $0
ffffffff80105dbf:	6a 00                	pushq  $0x0
  push $77
ffffffff80105dc1:	6a 4d                	pushq  $0x4d
  jmp alltraps
ffffffff80105dc3:	e9 c4 07 00 00       	jmpq   ffffffff8010658c <alltraps>

ffffffff80105dc8 <vector78>:
.globl vector78
vector78:
  push $0
ffffffff80105dc8:	6a 00                	pushq  $0x0
  push $78
ffffffff80105dca:	6a 4e                	pushq  $0x4e
  jmp alltraps
ffffffff80105dcc:	e9 bb 07 00 00       	jmpq   ffffffff8010658c <alltraps>

ffffffff80105dd1 <vector79>:
.globl vector79
vector79:
  push $0
ffffffff80105dd1:	6a 00                	pushq  $0x0
  push $79
ffffffff80105dd3:	6a 4f                	pushq  $0x4f
  jmp alltraps
ffffffff80105dd5:	e9 b2 07 00 00       	jmpq   ffffffff8010658c <alltraps>

ffffffff80105dda <vector80>:
.globl vector80
vector80:
  push $0
ffffffff80105dda:	6a 00                	pushq  $0x0
  push $80
ffffffff80105ddc:	6a 50                	pushq  $0x50
  jmp alltraps
ffffffff80105dde:	e9 a9 07 00 00       	jmpq   ffffffff8010658c <alltraps>

ffffffff80105de3 <vector81>:
.globl vector81
vector81:
  push $0
ffffffff80105de3:	6a 00                	pushq  $0x0
  push $81
ffffffff80105de5:	6a 51                	pushq  $0x51
  jmp alltraps
ffffffff80105de7:	e9 a0 07 00 00       	jmpq   ffffffff8010658c <alltraps>

ffffffff80105dec <vector82>:
.globl vector82
vector82:
  push $0
ffffffff80105dec:	6a 00                	pushq  $0x0
  push $82
ffffffff80105dee:	6a 52                	pushq  $0x52
  jmp alltraps
ffffffff80105df0:	e9 97 07 00 00       	jmpq   ffffffff8010658c <alltraps>

ffffffff80105df5 <vector83>:
.globl vector83
vector83:
  push $0
ffffffff80105df5:	6a 00                	pushq  $0x0
  push $83
ffffffff80105df7:	6a 53                	pushq  $0x53
  jmp alltraps
ffffffff80105df9:	e9 8e 07 00 00       	jmpq   ffffffff8010658c <alltraps>

ffffffff80105dfe <vector84>:
.globl vector84
vector84:
  push $0
ffffffff80105dfe:	6a 00                	pushq  $0x0
  push $84
ffffffff80105e00:	6a 54                	pushq  $0x54
  jmp alltraps
ffffffff80105e02:	e9 85 07 00 00       	jmpq   ffffffff8010658c <alltraps>

ffffffff80105e07 <vector85>:
.globl vector85
vector85:
  push $0
ffffffff80105e07:	6a 00                	pushq  $0x0
  push $85
ffffffff80105e09:	6a 55                	pushq  $0x55
  jmp alltraps
ffffffff80105e0b:	e9 7c 07 00 00       	jmpq   ffffffff8010658c <alltraps>

ffffffff80105e10 <vector86>:
.globl vector86
vector86:
  push $0
ffffffff80105e10:	6a 00                	pushq  $0x0
  push $86
ffffffff80105e12:	6a 56                	pushq  $0x56
  jmp alltraps
ffffffff80105e14:	e9 73 07 00 00       	jmpq   ffffffff8010658c <alltraps>

ffffffff80105e19 <vector87>:
.globl vector87
vector87:
  push $0
ffffffff80105e19:	6a 00                	pushq  $0x0
  push $87
ffffffff80105e1b:	6a 57                	pushq  $0x57
  jmp alltraps
ffffffff80105e1d:	e9 6a 07 00 00       	jmpq   ffffffff8010658c <alltraps>

ffffffff80105e22 <vector88>:
.globl vector88
vector88:
  push $0
ffffffff80105e22:	6a 00                	pushq  $0x0
  push $88
ffffffff80105e24:	6a 58                	pushq  $0x58
  jmp alltraps
ffffffff80105e26:	e9 61 07 00 00       	jmpq   ffffffff8010658c <alltraps>

ffffffff80105e2b <vector89>:
.globl vector89
vector89:
  push $0
ffffffff80105e2b:	6a 00                	pushq  $0x0
  push $89
ffffffff80105e2d:	6a 59                	pushq  $0x59
  jmp alltraps
ffffffff80105e2f:	e9 58 07 00 00       	jmpq   ffffffff8010658c <alltraps>

ffffffff80105e34 <vector90>:
.globl vector90
vector90:
  push $0
ffffffff80105e34:	6a 00                	pushq  $0x0
  push $90
ffffffff80105e36:	6a 5a                	pushq  $0x5a
  jmp alltraps
ffffffff80105e38:	e9 4f 07 00 00       	jmpq   ffffffff8010658c <alltraps>

ffffffff80105e3d <vector91>:
.globl vector91
vector91:
  push $0
ffffffff80105e3d:	6a 00                	pushq  $0x0
  push $91
ffffffff80105e3f:	6a 5b                	pushq  $0x5b
  jmp alltraps
ffffffff80105e41:	e9 46 07 00 00       	jmpq   ffffffff8010658c <alltraps>

ffffffff80105e46 <vector92>:
.globl vector92
vector92:
  push $0
ffffffff80105e46:	6a 00                	pushq  $0x0
  push $92
ffffffff80105e48:	6a 5c                	pushq  $0x5c
  jmp alltraps
ffffffff80105e4a:	e9 3d 07 00 00       	jmpq   ffffffff8010658c <alltraps>

ffffffff80105e4f <vector93>:
.globl vector93
vector93:
  push $0
ffffffff80105e4f:	6a 00                	pushq  $0x0
  push $93
ffffffff80105e51:	6a 5d                	pushq  $0x5d
  jmp alltraps
ffffffff80105e53:	e9 34 07 00 00       	jmpq   ffffffff8010658c <alltraps>

ffffffff80105e58 <vector94>:
.globl vector94
vector94:
  push $0
ffffffff80105e58:	6a 00                	pushq  $0x0
  push $94
ffffffff80105e5a:	6a 5e                	pushq  $0x5e
  jmp alltraps
ffffffff80105e5c:	e9 2b 07 00 00       	jmpq   ffffffff8010658c <alltraps>

ffffffff80105e61 <vector95>:
.globl vector95
vector95:
  push $0
ffffffff80105e61:	6a 00                	pushq  $0x0
  push $95
ffffffff80105e63:	6a 5f                	pushq  $0x5f
  jmp alltraps
ffffffff80105e65:	e9 22 07 00 00       	jmpq   ffffffff8010658c <alltraps>

ffffffff80105e6a <vector96>:
.globl vector96
vector96:
  push $0
ffffffff80105e6a:	6a 00                	pushq  $0x0
  push $96
ffffffff80105e6c:	6a 60                	pushq  $0x60
  jmp alltraps
ffffffff80105e6e:	e9 19 07 00 00       	jmpq   ffffffff8010658c <alltraps>

ffffffff80105e73 <vector97>:
.globl vector97
vector97:
  push $0
ffffffff80105e73:	6a 00                	pushq  $0x0
  push $97
ffffffff80105e75:	6a 61                	pushq  $0x61
  jmp alltraps
ffffffff80105e77:	e9 10 07 00 00       	jmpq   ffffffff8010658c <alltraps>

ffffffff80105e7c <vector98>:
.globl vector98
vector98:
  push $0
ffffffff80105e7c:	6a 00                	pushq  $0x0
  push $98
ffffffff80105e7e:	6a 62                	pushq  $0x62
  jmp alltraps
ffffffff80105e80:	e9 07 07 00 00       	jmpq   ffffffff8010658c <alltraps>

ffffffff80105e85 <vector99>:
.globl vector99
vector99:
  push $0
ffffffff80105e85:	6a 00                	pushq  $0x0
  push $99
ffffffff80105e87:	6a 63                	pushq  $0x63
  jmp alltraps
ffffffff80105e89:	e9 fe 06 00 00       	jmpq   ffffffff8010658c <alltraps>

ffffffff80105e8e <vector100>:
.globl vector100
vector100:
  push $0
ffffffff80105e8e:	6a 00                	pushq  $0x0
  push $100
ffffffff80105e90:	6a 64                	pushq  $0x64
  jmp alltraps
ffffffff80105e92:	e9 f5 06 00 00       	jmpq   ffffffff8010658c <alltraps>

ffffffff80105e97 <vector101>:
.globl vector101
vector101:
  push $0
ffffffff80105e97:	6a 00                	pushq  $0x0
  push $101
ffffffff80105e99:	6a 65                	pushq  $0x65
  jmp alltraps
ffffffff80105e9b:	e9 ec 06 00 00       	jmpq   ffffffff8010658c <alltraps>

ffffffff80105ea0 <vector102>:
.globl vector102
vector102:
  push $0
ffffffff80105ea0:	6a 00                	pushq  $0x0
  push $102
ffffffff80105ea2:	6a 66                	pushq  $0x66
  jmp alltraps
ffffffff80105ea4:	e9 e3 06 00 00       	jmpq   ffffffff8010658c <alltraps>

ffffffff80105ea9 <vector103>:
.globl vector103
vector103:
  push $0
ffffffff80105ea9:	6a 00                	pushq  $0x0
  push $103
ffffffff80105eab:	6a 67                	pushq  $0x67
  jmp alltraps
ffffffff80105ead:	e9 da 06 00 00       	jmpq   ffffffff8010658c <alltraps>

ffffffff80105eb2 <vector104>:
.globl vector104
vector104:
  push $0
ffffffff80105eb2:	6a 00                	pushq  $0x0
  push $104
ffffffff80105eb4:	6a 68                	pushq  $0x68
  jmp alltraps
ffffffff80105eb6:	e9 d1 06 00 00       	jmpq   ffffffff8010658c <alltraps>

ffffffff80105ebb <vector105>:
.globl vector105
vector105:
  push $0
ffffffff80105ebb:	6a 00                	pushq  $0x0
  push $105
ffffffff80105ebd:	6a 69                	pushq  $0x69
  jmp alltraps
ffffffff80105ebf:	e9 c8 06 00 00       	jmpq   ffffffff8010658c <alltraps>

ffffffff80105ec4 <vector106>:
.globl vector106
vector106:
  push $0
ffffffff80105ec4:	6a 00                	pushq  $0x0
  push $106
ffffffff80105ec6:	6a 6a                	pushq  $0x6a
  jmp alltraps
ffffffff80105ec8:	e9 bf 06 00 00       	jmpq   ffffffff8010658c <alltraps>

ffffffff80105ecd <vector107>:
.globl vector107
vector107:
  push $0
ffffffff80105ecd:	6a 00                	pushq  $0x0
  push $107
ffffffff80105ecf:	6a 6b                	pushq  $0x6b
  jmp alltraps
ffffffff80105ed1:	e9 b6 06 00 00       	jmpq   ffffffff8010658c <alltraps>

ffffffff80105ed6 <vector108>:
.globl vector108
vector108:
  push $0
ffffffff80105ed6:	6a 00                	pushq  $0x0
  push $108
ffffffff80105ed8:	6a 6c                	pushq  $0x6c
  jmp alltraps
ffffffff80105eda:	e9 ad 06 00 00       	jmpq   ffffffff8010658c <alltraps>

ffffffff80105edf <vector109>:
.globl vector109
vector109:
  push $0
ffffffff80105edf:	6a 00                	pushq  $0x0
  push $109
ffffffff80105ee1:	6a 6d                	pushq  $0x6d
  jmp alltraps
ffffffff80105ee3:	e9 a4 06 00 00       	jmpq   ffffffff8010658c <alltraps>

ffffffff80105ee8 <vector110>:
.globl vector110
vector110:
  push $0
ffffffff80105ee8:	6a 00                	pushq  $0x0
  push $110
ffffffff80105eea:	6a 6e                	pushq  $0x6e
  jmp alltraps
ffffffff80105eec:	e9 9b 06 00 00       	jmpq   ffffffff8010658c <alltraps>

ffffffff80105ef1 <vector111>:
.globl vector111
vector111:
  push $0
ffffffff80105ef1:	6a 00                	pushq  $0x0
  push $111
ffffffff80105ef3:	6a 6f                	pushq  $0x6f
  jmp alltraps
ffffffff80105ef5:	e9 92 06 00 00       	jmpq   ffffffff8010658c <alltraps>

ffffffff80105efa <vector112>:
.globl vector112
vector112:
  push $0
ffffffff80105efa:	6a 00                	pushq  $0x0
  push $112
ffffffff80105efc:	6a 70                	pushq  $0x70
  jmp alltraps
ffffffff80105efe:	e9 89 06 00 00       	jmpq   ffffffff8010658c <alltraps>

ffffffff80105f03 <vector113>:
.globl vector113
vector113:
  push $0
ffffffff80105f03:	6a 00                	pushq  $0x0
  push $113
ffffffff80105f05:	6a 71                	pushq  $0x71
  jmp alltraps
ffffffff80105f07:	e9 80 06 00 00       	jmpq   ffffffff8010658c <alltraps>

ffffffff80105f0c <vector114>:
.globl vector114
vector114:
  push $0
ffffffff80105f0c:	6a 00                	pushq  $0x0
  push $114
ffffffff80105f0e:	6a 72                	pushq  $0x72
  jmp alltraps
ffffffff80105f10:	e9 77 06 00 00       	jmpq   ffffffff8010658c <alltraps>

ffffffff80105f15 <vector115>:
.globl vector115
vector115:
  push $0
ffffffff80105f15:	6a 00                	pushq  $0x0
  push $115
ffffffff80105f17:	6a 73                	pushq  $0x73
  jmp alltraps
ffffffff80105f19:	e9 6e 06 00 00       	jmpq   ffffffff8010658c <alltraps>

ffffffff80105f1e <vector116>:
.globl vector116
vector116:
  push $0
ffffffff80105f1e:	6a 00                	pushq  $0x0
  push $116
ffffffff80105f20:	6a 74                	pushq  $0x74
  jmp alltraps
ffffffff80105f22:	e9 65 06 00 00       	jmpq   ffffffff8010658c <alltraps>

ffffffff80105f27 <vector117>:
.globl vector117
vector117:
  push $0
ffffffff80105f27:	6a 00                	pushq  $0x0
  push $117
ffffffff80105f29:	6a 75                	pushq  $0x75
  jmp alltraps
ffffffff80105f2b:	e9 5c 06 00 00       	jmpq   ffffffff8010658c <alltraps>

ffffffff80105f30 <vector118>:
.globl vector118
vector118:
  push $0
ffffffff80105f30:	6a 00                	pushq  $0x0
  push $118
ffffffff80105f32:	6a 76                	pushq  $0x76
  jmp alltraps
ffffffff80105f34:	e9 53 06 00 00       	jmpq   ffffffff8010658c <alltraps>

ffffffff80105f39 <vector119>:
.globl vector119
vector119:
  push $0
ffffffff80105f39:	6a 00                	pushq  $0x0
  push $119
ffffffff80105f3b:	6a 77                	pushq  $0x77
  jmp alltraps
ffffffff80105f3d:	e9 4a 06 00 00       	jmpq   ffffffff8010658c <alltraps>

ffffffff80105f42 <vector120>:
.globl vector120
vector120:
  push $0
ffffffff80105f42:	6a 00                	pushq  $0x0
  push $120
ffffffff80105f44:	6a 78                	pushq  $0x78
  jmp alltraps
ffffffff80105f46:	e9 41 06 00 00       	jmpq   ffffffff8010658c <alltraps>

ffffffff80105f4b <vector121>:
.globl vector121
vector121:
  push $0
ffffffff80105f4b:	6a 00                	pushq  $0x0
  push $121
ffffffff80105f4d:	6a 79                	pushq  $0x79
  jmp alltraps
ffffffff80105f4f:	e9 38 06 00 00       	jmpq   ffffffff8010658c <alltraps>

ffffffff80105f54 <vector122>:
.globl vector122
vector122:
  push $0
ffffffff80105f54:	6a 00                	pushq  $0x0
  push $122
ffffffff80105f56:	6a 7a                	pushq  $0x7a
  jmp alltraps
ffffffff80105f58:	e9 2f 06 00 00       	jmpq   ffffffff8010658c <alltraps>

ffffffff80105f5d <vector123>:
.globl vector123
vector123:
  push $0
ffffffff80105f5d:	6a 00                	pushq  $0x0
  push $123
ffffffff80105f5f:	6a 7b                	pushq  $0x7b
  jmp alltraps
ffffffff80105f61:	e9 26 06 00 00       	jmpq   ffffffff8010658c <alltraps>

ffffffff80105f66 <vector124>:
.globl vector124
vector124:
  push $0
ffffffff80105f66:	6a 00                	pushq  $0x0
  push $124
ffffffff80105f68:	6a 7c                	pushq  $0x7c
  jmp alltraps
ffffffff80105f6a:	e9 1d 06 00 00       	jmpq   ffffffff8010658c <alltraps>

ffffffff80105f6f <vector125>:
.globl vector125
vector125:
  push $0
ffffffff80105f6f:	6a 00                	pushq  $0x0
  push $125
ffffffff80105f71:	6a 7d                	pushq  $0x7d
  jmp alltraps
ffffffff80105f73:	e9 14 06 00 00       	jmpq   ffffffff8010658c <alltraps>

ffffffff80105f78 <vector126>:
.globl vector126
vector126:
  push $0
ffffffff80105f78:	6a 00                	pushq  $0x0
  push $126
ffffffff80105f7a:	6a 7e                	pushq  $0x7e
  jmp alltraps
ffffffff80105f7c:	e9 0b 06 00 00       	jmpq   ffffffff8010658c <alltraps>

ffffffff80105f81 <vector127>:
.globl vector127
vector127:
  push $0
ffffffff80105f81:	6a 00                	pushq  $0x0
  push $127
ffffffff80105f83:	6a 7f                	pushq  $0x7f
  jmp alltraps
ffffffff80105f85:	e9 02 06 00 00       	jmpq   ffffffff8010658c <alltraps>

ffffffff80105f8a <vector128>:
.globl vector128
vector128:
  push $0
ffffffff80105f8a:	6a 00                	pushq  $0x0
  push $128
ffffffff80105f8c:	68 80 00 00 00       	pushq  $0x80
  jmp alltraps
ffffffff80105f91:	e9 f6 05 00 00       	jmpq   ffffffff8010658c <alltraps>

ffffffff80105f96 <vector129>:
.globl vector129
vector129:
  push $0
ffffffff80105f96:	6a 00                	pushq  $0x0
  push $129
ffffffff80105f98:	68 81 00 00 00       	pushq  $0x81
  jmp alltraps
ffffffff80105f9d:	e9 ea 05 00 00       	jmpq   ffffffff8010658c <alltraps>

ffffffff80105fa2 <vector130>:
.globl vector130
vector130:
  push $0
ffffffff80105fa2:	6a 00                	pushq  $0x0
  push $130
ffffffff80105fa4:	68 82 00 00 00       	pushq  $0x82
  jmp alltraps
ffffffff80105fa9:	e9 de 05 00 00       	jmpq   ffffffff8010658c <alltraps>

ffffffff80105fae <vector131>:
.globl vector131
vector131:
  push $0
ffffffff80105fae:	6a 00                	pushq  $0x0
  push $131
ffffffff80105fb0:	68 83 00 00 00       	pushq  $0x83
  jmp alltraps
ffffffff80105fb5:	e9 d2 05 00 00       	jmpq   ffffffff8010658c <alltraps>

ffffffff80105fba <vector132>:
.globl vector132
vector132:
  push $0
ffffffff80105fba:	6a 00                	pushq  $0x0
  push $132
ffffffff80105fbc:	68 84 00 00 00       	pushq  $0x84
  jmp alltraps
ffffffff80105fc1:	e9 c6 05 00 00       	jmpq   ffffffff8010658c <alltraps>

ffffffff80105fc6 <vector133>:
.globl vector133
vector133:
  push $0
ffffffff80105fc6:	6a 00                	pushq  $0x0
  push $133
ffffffff80105fc8:	68 85 00 00 00       	pushq  $0x85
  jmp alltraps
ffffffff80105fcd:	e9 ba 05 00 00       	jmpq   ffffffff8010658c <alltraps>

ffffffff80105fd2 <vector134>:
.globl vector134
vector134:
  push $0
ffffffff80105fd2:	6a 00                	pushq  $0x0
  push $134
ffffffff80105fd4:	68 86 00 00 00       	pushq  $0x86
  jmp alltraps
ffffffff80105fd9:	e9 ae 05 00 00       	jmpq   ffffffff8010658c <alltraps>

ffffffff80105fde <vector135>:
.globl vector135
vector135:
  push $0
ffffffff80105fde:	6a 00                	pushq  $0x0
  push $135
ffffffff80105fe0:	68 87 00 00 00       	pushq  $0x87
  jmp alltraps
ffffffff80105fe5:	e9 a2 05 00 00       	jmpq   ffffffff8010658c <alltraps>

ffffffff80105fea <vector136>:
.globl vector136
vector136:
  push $0
ffffffff80105fea:	6a 00                	pushq  $0x0
  push $136
ffffffff80105fec:	68 88 00 00 00       	pushq  $0x88
  jmp alltraps
ffffffff80105ff1:	e9 96 05 00 00       	jmpq   ffffffff8010658c <alltraps>

ffffffff80105ff6 <vector137>:
.globl vector137
vector137:
  push $0
ffffffff80105ff6:	6a 00                	pushq  $0x0
  push $137
ffffffff80105ff8:	68 89 00 00 00       	pushq  $0x89
  jmp alltraps
ffffffff80105ffd:	e9 8a 05 00 00       	jmpq   ffffffff8010658c <alltraps>

ffffffff80106002 <vector138>:
.globl vector138
vector138:
  push $0
ffffffff80106002:	6a 00                	pushq  $0x0
  push $138
ffffffff80106004:	68 8a 00 00 00       	pushq  $0x8a
  jmp alltraps
ffffffff80106009:	e9 7e 05 00 00       	jmpq   ffffffff8010658c <alltraps>

ffffffff8010600e <vector139>:
.globl vector139
vector139:
  push $0
ffffffff8010600e:	6a 00                	pushq  $0x0
  push $139
ffffffff80106010:	68 8b 00 00 00       	pushq  $0x8b
  jmp alltraps
ffffffff80106015:	e9 72 05 00 00       	jmpq   ffffffff8010658c <alltraps>

ffffffff8010601a <vector140>:
.globl vector140
vector140:
  push $0
ffffffff8010601a:	6a 00                	pushq  $0x0
  push $140
ffffffff8010601c:	68 8c 00 00 00       	pushq  $0x8c
  jmp alltraps
ffffffff80106021:	e9 66 05 00 00       	jmpq   ffffffff8010658c <alltraps>

ffffffff80106026 <vector141>:
.globl vector141
vector141:
  push $0
ffffffff80106026:	6a 00                	pushq  $0x0
  push $141
ffffffff80106028:	68 8d 00 00 00       	pushq  $0x8d
  jmp alltraps
ffffffff8010602d:	e9 5a 05 00 00       	jmpq   ffffffff8010658c <alltraps>

ffffffff80106032 <vector142>:
.globl vector142
vector142:
  push $0
ffffffff80106032:	6a 00                	pushq  $0x0
  push $142
ffffffff80106034:	68 8e 00 00 00       	pushq  $0x8e
  jmp alltraps
ffffffff80106039:	e9 4e 05 00 00       	jmpq   ffffffff8010658c <alltraps>

ffffffff8010603e <vector143>:
.globl vector143
vector143:
  push $0
ffffffff8010603e:	6a 00                	pushq  $0x0
  push $143
ffffffff80106040:	68 8f 00 00 00       	pushq  $0x8f
  jmp alltraps
ffffffff80106045:	e9 42 05 00 00       	jmpq   ffffffff8010658c <alltraps>

ffffffff8010604a <vector144>:
.globl vector144
vector144:
  push $0
ffffffff8010604a:	6a 00                	pushq  $0x0
  push $144
ffffffff8010604c:	68 90 00 00 00       	pushq  $0x90
  jmp alltraps
ffffffff80106051:	e9 36 05 00 00       	jmpq   ffffffff8010658c <alltraps>

ffffffff80106056 <vector145>:
.globl vector145
vector145:
  push $0
ffffffff80106056:	6a 00                	pushq  $0x0
  push $145
ffffffff80106058:	68 91 00 00 00       	pushq  $0x91
  jmp alltraps
ffffffff8010605d:	e9 2a 05 00 00       	jmpq   ffffffff8010658c <alltraps>

ffffffff80106062 <vector146>:
.globl vector146
vector146:
  push $0
ffffffff80106062:	6a 00                	pushq  $0x0
  push $146
ffffffff80106064:	68 92 00 00 00       	pushq  $0x92
  jmp alltraps
ffffffff80106069:	e9 1e 05 00 00       	jmpq   ffffffff8010658c <alltraps>

ffffffff8010606e <vector147>:
.globl vector147
vector147:
  push $0
ffffffff8010606e:	6a 00                	pushq  $0x0
  push $147
ffffffff80106070:	68 93 00 00 00       	pushq  $0x93
  jmp alltraps
ffffffff80106075:	e9 12 05 00 00       	jmpq   ffffffff8010658c <alltraps>

ffffffff8010607a <vector148>:
.globl vector148
vector148:
  push $0
ffffffff8010607a:	6a 00                	pushq  $0x0
  push $148
ffffffff8010607c:	68 94 00 00 00       	pushq  $0x94
  jmp alltraps
ffffffff80106081:	e9 06 05 00 00       	jmpq   ffffffff8010658c <alltraps>

ffffffff80106086 <vector149>:
.globl vector149
vector149:
  push $0
ffffffff80106086:	6a 00                	pushq  $0x0
  push $149
ffffffff80106088:	68 95 00 00 00       	pushq  $0x95
  jmp alltraps
ffffffff8010608d:	e9 fa 04 00 00       	jmpq   ffffffff8010658c <alltraps>

ffffffff80106092 <vector150>:
.globl vector150
vector150:
  push $0
ffffffff80106092:	6a 00                	pushq  $0x0
  push $150
ffffffff80106094:	68 96 00 00 00       	pushq  $0x96
  jmp alltraps
ffffffff80106099:	e9 ee 04 00 00       	jmpq   ffffffff8010658c <alltraps>

ffffffff8010609e <vector151>:
.globl vector151
vector151:
  push $0
ffffffff8010609e:	6a 00                	pushq  $0x0
  push $151
ffffffff801060a0:	68 97 00 00 00       	pushq  $0x97
  jmp alltraps
ffffffff801060a5:	e9 e2 04 00 00       	jmpq   ffffffff8010658c <alltraps>

ffffffff801060aa <vector152>:
.globl vector152
vector152:
  push $0
ffffffff801060aa:	6a 00                	pushq  $0x0
  push $152
ffffffff801060ac:	68 98 00 00 00       	pushq  $0x98
  jmp alltraps
ffffffff801060b1:	e9 d6 04 00 00       	jmpq   ffffffff8010658c <alltraps>

ffffffff801060b6 <vector153>:
.globl vector153
vector153:
  push $0
ffffffff801060b6:	6a 00                	pushq  $0x0
  push $153
ffffffff801060b8:	68 99 00 00 00       	pushq  $0x99
  jmp alltraps
ffffffff801060bd:	e9 ca 04 00 00       	jmpq   ffffffff8010658c <alltraps>

ffffffff801060c2 <vector154>:
.globl vector154
vector154:
  push $0
ffffffff801060c2:	6a 00                	pushq  $0x0
  push $154
ffffffff801060c4:	68 9a 00 00 00       	pushq  $0x9a
  jmp alltraps
ffffffff801060c9:	e9 be 04 00 00       	jmpq   ffffffff8010658c <alltraps>

ffffffff801060ce <vector155>:
.globl vector155
vector155:
  push $0
ffffffff801060ce:	6a 00                	pushq  $0x0
  push $155
ffffffff801060d0:	68 9b 00 00 00       	pushq  $0x9b
  jmp alltraps
ffffffff801060d5:	e9 b2 04 00 00       	jmpq   ffffffff8010658c <alltraps>

ffffffff801060da <vector156>:
.globl vector156
vector156:
  push $0
ffffffff801060da:	6a 00                	pushq  $0x0
  push $156
ffffffff801060dc:	68 9c 00 00 00       	pushq  $0x9c
  jmp alltraps
ffffffff801060e1:	e9 a6 04 00 00       	jmpq   ffffffff8010658c <alltraps>

ffffffff801060e6 <vector157>:
.globl vector157
vector157:
  push $0
ffffffff801060e6:	6a 00                	pushq  $0x0
  push $157
ffffffff801060e8:	68 9d 00 00 00       	pushq  $0x9d
  jmp alltraps
ffffffff801060ed:	e9 9a 04 00 00       	jmpq   ffffffff8010658c <alltraps>

ffffffff801060f2 <vector158>:
.globl vector158
vector158:
  push $0
ffffffff801060f2:	6a 00                	pushq  $0x0
  push $158
ffffffff801060f4:	68 9e 00 00 00       	pushq  $0x9e
  jmp alltraps
ffffffff801060f9:	e9 8e 04 00 00       	jmpq   ffffffff8010658c <alltraps>

ffffffff801060fe <vector159>:
.globl vector159
vector159:
  push $0
ffffffff801060fe:	6a 00                	pushq  $0x0
  push $159
ffffffff80106100:	68 9f 00 00 00       	pushq  $0x9f
  jmp alltraps
ffffffff80106105:	e9 82 04 00 00       	jmpq   ffffffff8010658c <alltraps>

ffffffff8010610a <vector160>:
.globl vector160
vector160:
  push $0
ffffffff8010610a:	6a 00                	pushq  $0x0
  push $160
ffffffff8010610c:	68 a0 00 00 00       	pushq  $0xa0
  jmp alltraps
ffffffff80106111:	e9 76 04 00 00       	jmpq   ffffffff8010658c <alltraps>

ffffffff80106116 <vector161>:
.globl vector161
vector161:
  push $0
ffffffff80106116:	6a 00                	pushq  $0x0
  push $161
ffffffff80106118:	68 a1 00 00 00       	pushq  $0xa1
  jmp alltraps
ffffffff8010611d:	e9 6a 04 00 00       	jmpq   ffffffff8010658c <alltraps>

ffffffff80106122 <vector162>:
.globl vector162
vector162:
  push $0
ffffffff80106122:	6a 00                	pushq  $0x0
  push $162
ffffffff80106124:	68 a2 00 00 00       	pushq  $0xa2
  jmp alltraps
ffffffff80106129:	e9 5e 04 00 00       	jmpq   ffffffff8010658c <alltraps>

ffffffff8010612e <vector163>:
.globl vector163
vector163:
  push $0
ffffffff8010612e:	6a 00                	pushq  $0x0
  push $163
ffffffff80106130:	68 a3 00 00 00       	pushq  $0xa3
  jmp alltraps
ffffffff80106135:	e9 52 04 00 00       	jmpq   ffffffff8010658c <alltraps>

ffffffff8010613a <vector164>:
.globl vector164
vector164:
  push $0
ffffffff8010613a:	6a 00                	pushq  $0x0
  push $164
ffffffff8010613c:	68 a4 00 00 00       	pushq  $0xa4
  jmp alltraps
ffffffff80106141:	e9 46 04 00 00       	jmpq   ffffffff8010658c <alltraps>

ffffffff80106146 <vector165>:
.globl vector165
vector165:
  push $0
ffffffff80106146:	6a 00                	pushq  $0x0
  push $165
ffffffff80106148:	68 a5 00 00 00       	pushq  $0xa5
  jmp alltraps
ffffffff8010614d:	e9 3a 04 00 00       	jmpq   ffffffff8010658c <alltraps>

ffffffff80106152 <vector166>:
.globl vector166
vector166:
  push $0
ffffffff80106152:	6a 00                	pushq  $0x0
  push $166
ffffffff80106154:	68 a6 00 00 00       	pushq  $0xa6
  jmp alltraps
ffffffff80106159:	e9 2e 04 00 00       	jmpq   ffffffff8010658c <alltraps>

ffffffff8010615e <vector167>:
.globl vector167
vector167:
  push $0
ffffffff8010615e:	6a 00                	pushq  $0x0
  push $167
ffffffff80106160:	68 a7 00 00 00       	pushq  $0xa7
  jmp alltraps
ffffffff80106165:	e9 22 04 00 00       	jmpq   ffffffff8010658c <alltraps>

ffffffff8010616a <vector168>:
.globl vector168
vector168:
  push $0
ffffffff8010616a:	6a 00                	pushq  $0x0
  push $168
ffffffff8010616c:	68 a8 00 00 00       	pushq  $0xa8
  jmp alltraps
ffffffff80106171:	e9 16 04 00 00       	jmpq   ffffffff8010658c <alltraps>

ffffffff80106176 <vector169>:
.globl vector169
vector169:
  push $0
ffffffff80106176:	6a 00                	pushq  $0x0
  push $169
ffffffff80106178:	68 a9 00 00 00       	pushq  $0xa9
  jmp alltraps
ffffffff8010617d:	e9 0a 04 00 00       	jmpq   ffffffff8010658c <alltraps>

ffffffff80106182 <vector170>:
.globl vector170
vector170:
  push $0
ffffffff80106182:	6a 00                	pushq  $0x0
  push $170
ffffffff80106184:	68 aa 00 00 00       	pushq  $0xaa
  jmp alltraps
ffffffff80106189:	e9 fe 03 00 00       	jmpq   ffffffff8010658c <alltraps>

ffffffff8010618e <vector171>:
.globl vector171
vector171:
  push $0
ffffffff8010618e:	6a 00                	pushq  $0x0
  push $171
ffffffff80106190:	68 ab 00 00 00       	pushq  $0xab
  jmp alltraps
ffffffff80106195:	e9 f2 03 00 00       	jmpq   ffffffff8010658c <alltraps>

ffffffff8010619a <vector172>:
.globl vector172
vector172:
  push $0
ffffffff8010619a:	6a 00                	pushq  $0x0
  push $172
ffffffff8010619c:	68 ac 00 00 00       	pushq  $0xac
  jmp alltraps
ffffffff801061a1:	e9 e6 03 00 00       	jmpq   ffffffff8010658c <alltraps>

ffffffff801061a6 <vector173>:
.globl vector173
vector173:
  push $0
ffffffff801061a6:	6a 00                	pushq  $0x0
  push $173
ffffffff801061a8:	68 ad 00 00 00       	pushq  $0xad
  jmp alltraps
ffffffff801061ad:	e9 da 03 00 00       	jmpq   ffffffff8010658c <alltraps>

ffffffff801061b2 <vector174>:
.globl vector174
vector174:
  push $0
ffffffff801061b2:	6a 00                	pushq  $0x0
  push $174
ffffffff801061b4:	68 ae 00 00 00       	pushq  $0xae
  jmp alltraps
ffffffff801061b9:	e9 ce 03 00 00       	jmpq   ffffffff8010658c <alltraps>

ffffffff801061be <vector175>:
.globl vector175
vector175:
  push $0
ffffffff801061be:	6a 00                	pushq  $0x0
  push $175
ffffffff801061c0:	68 af 00 00 00       	pushq  $0xaf
  jmp alltraps
ffffffff801061c5:	e9 c2 03 00 00       	jmpq   ffffffff8010658c <alltraps>

ffffffff801061ca <vector176>:
.globl vector176
vector176:
  push $0
ffffffff801061ca:	6a 00                	pushq  $0x0
  push $176
ffffffff801061cc:	68 b0 00 00 00       	pushq  $0xb0
  jmp alltraps
ffffffff801061d1:	e9 b6 03 00 00       	jmpq   ffffffff8010658c <alltraps>

ffffffff801061d6 <vector177>:
.globl vector177
vector177:
  push $0
ffffffff801061d6:	6a 00                	pushq  $0x0
  push $177
ffffffff801061d8:	68 b1 00 00 00       	pushq  $0xb1
  jmp alltraps
ffffffff801061dd:	e9 aa 03 00 00       	jmpq   ffffffff8010658c <alltraps>

ffffffff801061e2 <vector178>:
.globl vector178
vector178:
  push $0
ffffffff801061e2:	6a 00                	pushq  $0x0
  push $178
ffffffff801061e4:	68 b2 00 00 00       	pushq  $0xb2
  jmp alltraps
ffffffff801061e9:	e9 9e 03 00 00       	jmpq   ffffffff8010658c <alltraps>

ffffffff801061ee <vector179>:
.globl vector179
vector179:
  push $0
ffffffff801061ee:	6a 00                	pushq  $0x0
  push $179
ffffffff801061f0:	68 b3 00 00 00       	pushq  $0xb3
  jmp alltraps
ffffffff801061f5:	e9 92 03 00 00       	jmpq   ffffffff8010658c <alltraps>

ffffffff801061fa <vector180>:
.globl vector180
vector180:
  push $0
ffffffff801061fa:	6a 00                	pushq  $0x0
  push $180
ffffffff801061fc:	68 b4 00 00 00       	pushq  $0xb4
  jmp alltraps
ffffffff80106201:	e9 86 03 00 00       	jmpq   ffffffff8010658c <alltraps>

ffffffff80106206 <vector181>:
.globl vector181
vector181:
  push $0
ffffffff80106206:	6a 00                	pushq  $0x0
  push $181
ffffffff80106208:	68 b5 00 00 00       	pushq  $0xb5
  jmp alltraps
ffffffff8010620d:	e9 7a 03 00 00       	jmpq   ffffffff8010658c <alltraps>

ffffffff80106212 <vector182>:
.globl vector182
vector182:
  push $0
ffffffff80106212:	6a 00                	pushq  $0x0
  push $182
ffffffff80106214:	68 b6 00 00 00       	pushq  $0xb6
  jmp alltraps
ffffffff80106219:	e9 6e 03 00 00       	jmpq   ffffffff8010658c <alltraps>

ffffffff8010621e <vector183>:
.globl vector183
vector183:
  push $0
ffffffff8010621e:	6a 00                	pushq  $0x0
  push $183
ffffffff80106220:	68 b7 00 00 00       	pushq  $0xb7
  jmp alltraps
ffffffff80106225:	e9 62 03 00 00       	jmpq   ffffffff8010658c <alltraps>

ffffffff8010622a <vector184>:
.globl vector184
vector184:
  push $0
ffffffff8010622a:	6a 00                	pushq  $0x0
  push $184
ffffffff8010622c:	68 b8 00 00 00       	pushq  $0xb8
  jmp alltraps
ffffffff80106231:	e9 56 03 00 00       	jmpq   ffffffff8010658c <alltraps>

ffffffff80106236 <vector185>:
.globl vector185
vector185:
  push $0
ffffffff80106236:	6a 00                	pushq  $0x0
  push $185
ffffffff80106238:	68 b9 00 00 00       	pushq  $0xb9
  jmp alltraps
ffffffff8010623d:	e9 4a 03 00 00       	jmpq   ffffffff8010658c <alltraps>

ffffffff80106242 <vector186>:
.globl vector186
vector186:
  push $0
ffffffff80106242:	6a 00                	pushq  $0x0
  push $186
ffffffff80106244:	68 ba 00 00 00       	pushq  $0xba
  jmp alltraps
ffffffff80106249:	e9 3e 03 00 00       	jmpq   ffffffff8010658c <alltraps>

ffffffff8010624e <vector187>:
.globl vector187
vector187:
  push $0
ffffffff8010624e:	6a 00                	pushq  $0x0
  push $187
ffffffff80106250:	68 bb 00 00 00       	pushq  $0xbb
  jmp alltraps
ffffffff80106255:	e9 32 03 00 00       	jmpq   ffffffff8010658c <alltraps>

ffffffff8010625a <vector188>:
.globl vector188
vector188:
  push $0
ffffffff8010625a:	6a 00                	pushq  $0x0
  push $188
ffffffff8010625c:	68 bc 00 00 00       	pushq  $0xbc
  jmp alltraps
ffffffff80106261:	e9 26 03 00 00       	jmpq   ffffffff8010658c <alltraps>

ffffffff80106266 <vector189>:
.globl vector189
vector189:
  push $0
ffffffff80106266:	6a 00                	pushq  $0x0
  push $189
ffffffff80106268:	68 bd 00 00 00       	pushq  $0xbd
  jmp alltraps
ffffffff8010626d:	e9 1a 03 00 00       	jmpq   ffffffff8010658c <alltraps>

ffffffff80106272 <vector190>:
.globl vector190
vector190:
  push $0
ffffffff80106272:	6a 00                	pushq  $0x0
  push $190
ffffffff80106274:	68 be 00 00 00       	pushq  $0xbe
  jmp alltraps
ffffffff80106279:	e9 0e 03 00 00       	jmpq   ffffffff8010658c <alltraps>

ffffffff8010627e <vector191>:
.globl vector191
vector191:
  push $0
ffffffff8010627e:	6a 00                	pushq  $0x0
  push $191
ffffffff80106280:	68 bf 00 00 00       	pushq  $0xbf
  jmp alltraps
ffffffff80106285:	e9 02 03 00 00       	jmpq   ffffffff8010658c <alltraps>

ffffffff8010628a <vector192>:
.globl vector192
vector192:
  push $0
ffffffff8010628a:	6a 00                	pushq  $0x0
  push $192
ffffffff8010628c:	68 c0 00 00 00       	pushq  $0xc0
  jmp alltraps
ffffffff80106291:	e9 f6 02 00 00       	jmpq   ffffffff8010658c <alltraps>

ffffffff80106296 <vector193>:
.globl vector193
vector193:
  push $0
ffffffff80106296:	6a 00                	pushq  $0x0
  push $193
ffffffff80106298:	68 c1 00 00 00       	pushq  $0xc1
  jmp alltraps
ffffffff8010629d:	e9 ea 02 00 00       	jmpq   ffffffff8010658c <alltraps>

ffffffff801062a2 <vector194>:
.globl vector194
vector194:
  push $0
ffffffff801062a2:	6a 00                	pushq  $0x0
  push $194
ffffffff801062a4:	68 c2 00 00 00       	pushq  $0xc2
  jmp alltraps
ffffffff801062a9:	e9 de 02 00 00       	jmpq   ffffffff8010658c <alltraps>

ffffffff801062ae <vector195>:
.globl vector195
vector195:
  push $0
ffffffff801062ae:	6a 00                	pushq  $0x0
  push $195
ffffffff801062b0:	68 c3 00 00 00       	pushq  $0xc3
  jmp alltraps
ffffffff801062b5:	e9 d2 02 00 00       	jmpq   ffffffff8010658c <alltraps>

ffffffff801062ba <vector196>:
.globl vector196
vector196:
  push $0
ffffffff801062ba:	6a 00                	pushq  $0x0
  push $196
ffffffff801062bc:	68 c4 00 00 00       	pushq  $0xc4
  jmp alltraps
ffffffff801062c1:	e9 c6 02 00 00       	jmpq   ffffffff8010658c <alltraps>

ffffffff801062c6 <vector197>:
.globl vector197
vector197:
  push $0
ffffffff801062c6:	6a 00                	pushq  $0x0
  push $197
ffffffff801062c8:	68 c5 00 00 00       	pushq  $0xc5
  jmp alltraps
ffffffff801062cd:	e9 ba 02 00 00       	jmpq   ffffffff8010658c <alltraps>

ffffffff801062d2 <vector198>:
.globl vector198
vector198:
  push $0
ffffffff801062d2:	6a 00                	pushq  $0x0
  push $198
ffffffff801062d4:	68 c6 00 00 00       	pushq  $0xc6
  jmp alltraps
ffffffff801062d9:	e9 ae 02 00 00       	jmpq   ffffffff8010658c <alltraps>

ffffffff801062de <vector199>:
.globl vector199
vector199:
  push $0
ffffffff801062de:	6a 00                	pushq  $0x0
  push $199
ffffffff801062e0:	68 c7 00 00 00       	pushq  $0xc7
  jmp alltraps
ffffffff801062e5:	e9 a2 02 00 00       	jmpq   ffffffff8010658c <alltraps>

ffffffff801062ea <vector200>:
.globl vector200
vector200:
  push $0
ffffffff801062ea:	6a 00                	pushq  $0x0
  push $200
ffffffff801062ec:	68 c8 00 00 00       	pushq  $0xc8
  jmp alltraps
ffffffff801062f1:	e9 96 02 00 00       	jmpq   ffffffff8010658c <alltraps>

ffffffff801062f6 <vector201>:
.globl vector201
vector201:
  push $0
ffffffff801062f6:	6a 00                	pushq  $0x0
  push $201
ffffffff801062f8:	68 c9 00 00 00       	pushq  $0xc9
  jmp alltraps
ffffffff801062fd:	e9 8a 02 00 00       	jmpq   ffffffff8010658c <alltraps>

ffffffff80106302 <vector202>:
.globl vector202
vector202:
  push $0
ffffffff80106302:	6a 00                	pushq  $0x0
  push $202
ffffffff80106304:	68 ca 00 00 00       	pushq  $0xca
  jmp alltraps
ffffffff80106309:	e9 7e 02 00 00       	jmpq   ffffffff8010658c <alltraps>

ffffffff8010630e <vector203>:
.globl vector203
vector203:
  push $0
ffffffff8010630e:	6a 00                	pushq  $0x0
  push $203
ffffffff80106310:	68 cb 00 00 00       	pushq  $0xcb
  jmp alltraps
ffffffff80106315:	e9 72 02 00 00       	jmpq   ffffffff8010658c <alltraps>

ffffffff8010631a <vector204>:
.globl vector204
vector204:
  push $0
ffffffff8010631a:	6a 00                	pushq  $0x0
  push $204
ffffffff8010631c:	68 cc 00 00 00       	pushq  $0xcc
  jmp alltraps
ffffffff80106321:	e9 66 02 00 00       	jmpq   ffffffff8010658c <alltraps>

ffffffff80106326 <vector205>:
.globl vector205
vector205:
  push $0
ffffffff80106326:	6a 00                	pushq  $0x0
  push $205
ffffffff80106328:	68 cd 00 00 00       	pushq  $0xcd
  jmp alltraps
ffffffff8010632d:	e9 5a 02 00 00       	jmpq   ffffffff8010658c <alltraps>

ffffffff80106332 <vector206>:
.globl vector206
vector206:
  push $0
ffffffff80106332:	6a 00                	pushq  $0x0
  push $206
ffffffff80106334:	68 ce 00 00 00       	pushq  $0xce
  jmp alltraps
ffffffff80106339:	e9 4e 02 00 00       	jmpq   ffffffff8010658c <alltraps>

ffffffff8010633e <vector207>:
.globl vector207
vector207:
  push $0
ffffffff8010633e:	6a 00                	pushq  $0x0
  push $207
ffffffff80106340:	68 cf 00 00 00       	pushq  $0xcf
  jmp alltraps
ffffffff80106345:	e9 42 02 00 00       	jmpq   ffffffff8010658c <alltraps>

ffffffff8010634a <vector208>:
.globl vector208
vector208:
  push $0
ffffffff8010634a:	6a 00                	pushq  $0x0
  push $208
ffffffff8010634c:	68 d0 00 00 00       	pushq  $0xd0
  jmp alltraps
ffffffff80106351:	e9 36 02 00 00       	jmpq   ffffffff8010658c <alltraps>

ffffffff80106356 <vector209>:
.globl vector209
vector209:
  push $0
ffffffff80106356:	6a 00                	pushq  $0x0
  push $209
ffffffff80106358:	68 d1 00 00 00       	pushq  $0xd1
  jmp alltraps
ffffffff8010635d:	e9 2a 02 00 00       	jmpq   ffffffff8010658c <alltraps>

ffffffff80106362 <vector210>:
.globl vector210
vector210:
  push $0
ffffffff80106362:	6a 00                	pushq  $0x0
  push $210
ffffffff80106364:	68 d2 00 00 00       	pushq  $0xd2
  jmp alltraps
ffffffff80106369:	e9 1e 02 00 00       	jmpq   ffffffff8010658c <alltraps>

ffffffff8010636e <vector211>:
.globl vector211
vector211:
  push $0
ffffffff8010636e:	6a 00                	pushq  $0x0
  push $211
ffffffff80106370:	68 d3 00 00 00       	pushq  $0xd3
  jmp alltraps
ffffffff80106375:	e9 12 02 00 00       	jmpq   ffffffff8010658c <alltraps>

ffffffff8010637a <vector212>:
.globl vector212
vector212:
  push $0
ffffffff8010637a:	6a 00                	pushq  $0x0
  push $212
ffffffff8010637c:	68 d4 00 00 00       	pushq  $0xd4
  jmp alltraps
ffffffff80106381:	e9 06 02 00 00       	jmpq   ffffffff8010658c <alltraps>

ffffffff80106386 <vector213>:
.globl vector213
vector213:
  push $0
ffffffff80106386:	6a 00                	pushq  $0x0
  push $213
ffffffff80106388:	68 d5 00 00 00       	pushq  $0xd5
  jmp alltraps
ffffffff8010638d:	e9 fa 01 00 00       	jmpq   ffffffff8010658c <alltraps>

ffffffff80106392 <vector214>:
.globl vector214
vector214:
  push $0
ffffffff80106392:	6a 00                	pushq  $0x0
  push $214
ffffffff80106394:	68 d6 00 00 00       	pushq  $0xd6
  jmp alltraps
ffffffff80106399:	e9 ee 01 00 00       	jmpq   ffffffff8010658c <alltraps>

ffffffff8010639e <vector215>:
.globl vector215
vector215:
  push $0
ffffffff8010639e:	6a 00                	pushq  $0x0
  push $215
ffffffff801063a0:	68 d7 00 00 00       	pushq  $0xd7
  jmp alltraps
ffffffff801063a5:	e9 e2 01 00 00       	jmpq   ffffffff8010658c <alltraps>

ffffffff801063aa <vector216>:
.globl vector216
vector216:
  push $0
ffffffff801063aa:	6a 00                	pushq  $0x0
  push $216
ffffffff801063ac:	68 d8 00 00 00       	pushq  $0xd8
  jmp alltraps
ffffffff801063b1:	e9 d6 01 00 00       	jmpq   ffffffff8010658c <alltraps>

ffffffff801063b6 <vector217>:
.globl vector217
vector217:
  push $0
ffffffff801063b6:	6a 00                	pushq  $0x0
  push $217
ffffffff801063b8:	68 d9 00 00 00       	pushq  $0xd9
  jmp alltraps
ffffffff801063bd:	e9 ca 01 00 00       	jmpq   ffffffff8010658c <alltraps>

ffffffff801063c2 <vector218>:
.globl vector218
vector218:
  push $0
ffffffff801063c2:	6a 00                	pushq  $0x0
  push $218
ffffffff801063c4:	68 da 00 00 00       	pushq  $0xda
  jmp alltraps
ffffffff801063c9:	e9 be 01 00 00       	jmpq   ffffffff8010658c <alltraps>

ffffffff801063ce <vector219>:
.globl vector219
vector219:
  push $0
ffffffff801063ce:	6a 00                	pushq  $0x0
  push $219
ffffffff801063d0:	68 db 00 00 00       	pushq  $0xdb
  jmp alltraps
ffffffff801063d5:	e9 b2 01 00 00       	jmpq   ffffffff8010658c <alltraps>

ffffffff801063da <vector220>:
.globl vector220
vector220:
  push $0
ffffffff801063da:	6a 00                	pushq  $0x0
  push $220
ffffffff801063dc:	68 dc 00 00 00       	pushq  $0xdc
  jmp alltraps
ffffffff801063e1:	e9 a6 01 00 00       	jmpq   ffffffff8010658c <alltraps>

ffffffff801063e6 <vector221>:
.globl vector221
vector221:
  push $0
ffffffff801063e6:	6a 00                	pushq  $0x0
  push $221
ffffffff801063e8:	68 dd 00 00 00       	pushq  $0xdd
  jmp alltraps
ffffffff801063ed:	e9 9a 01 00 00       	jmpq   ffffffff8010658c <alltraps>

ffffffff801063f2 <vector222>:
.globl vector222
vector222:
  push $0
ffffffff801063f2:	6a 00                	pushq  $0x0
  push $222
ffffffff801063f4:	68 de 00 00 00       	pushq  $0xde
  jmp alltraps
ffffffff801063f9:	e9 8e 01 00 00       	jmpq   ffffffff8010658c <alltraps>

ffffffff801063fe <vector223>:
.globl vector223
vector223:
  push $0
ffffffff801063fe:	6a 00                	pushq  $0x0
  push $223
ffffffff80106400:	68 df 00 00 00       	pushq  $0xdf
  jmp alltraps
ffffffff80106405:	e9 82 01 00 00       	jmpq   ffffffff8010658c <alltraps>

ffffffff8010640a <vector224>:
.globl vector224
vector224:
  push $0
ffffffff8010640a:	6a 00                	pushq  $0x0
  push $224
ffffffff8010640c:	68 e0 00 00 00       	pushq  $0xe0
  jmp alltraps
ffffffff80106411:	e9 76 01 00 00       	jmpq   ffffffff8010658c <alltraps>

ffffffff80106416 <vector225>:
.globl vector225
vector225:
  push $0
ffffffff80106416:	6a 00                	pushq  $0x0
  push $225
ffffffff80106418:	68 e1 00 00 00       	pushq  $0xe1
  jmp alltraps
ffffffff8010641d:	e9 6a 01 00 00       	jmpq   ffffffff8010658c <alltraps>

ffffffff80106422 <vector226>:
.globl vector226
vector226:
  push $0
ffffffff80106422:	6a 00                	pushq  $0x0
  push $226
ffffffff80106424:	68 e2 00 00 00       	pushq  $0xe2
  jmp alltraps
ffffffff80106429:	e9 5e 01 00 00       	jmpq   ffffffff8010658c <alltraps>

ffffffff8010642e <vector227>:
.globl vector227
vector227:
  push $0
ffffffff8010642e:	6a 00                	pushq  $0x0
  push $227
ffffffff80106430:	68 e3 00 00 00       	pushq  $0xe3
  jmp alltraps
ffffffff80106435:	e9 52 01 00 00       	jmpq   ffffffff8010658c <alltraps>

ffffffff8010643a <vector228>:
.globl vector228
vector228:
  push $0
ffffffff8010643a:	6a 00                	pushq  $0x0
  push $228
ffffffff8010643c:	68 e4 00 00 00       	pushq  $0xe4
  jmp alltraps
ffffffff80106441:	e9 46 01 00 00       	jmpq   ffffffff8010658c <alltraps>

ffffffff80106446 <vector229>:
.globl vector229
vector229:
  push $0
ffffffff80106446:	6a 00                	pushq  $0x0
  push $229
ffffffff80106448:	68 e5 00 00 00       	pushq  $0xe5
  jmp alltraps
ffffffff8010644d:	e9 3a 01 00 00       	jmpq   ffffffff8010658c <alltraps>

ffffffff80106452 <vector230>:
.globl vector230
vector230:
  push $0
ffffffff80106452:	6a 00                	pushq  $0x0
  push $230
ffffffff80106454:	68 e6 00 00 00       	pushq  $0xe6
  jmp alltraps
ffffffff80106459:	e9 2e 01 00 00       	jmpq   ffffffff8010658c <alltraps>

ffffffff8010645e <vector231>:
.globl vector231
vector231:
  push $0
ffffffff8010645e:	6a 00                	pushq  $0x0
  push $231
ffffffff80106460:	68 e7 00 00 00       	pushq  $0xe7
  jmp alltraps
ffffffff80106465:	e9 22 01 00 00       	jmpq   ffffffff8010658c <alltraps>

ffffffff8010646a <vector232>:
.globl vector232
vector232:
  push $0
ffffffff8010646a:	6a 00                	pushq  $0x0
  push $232
ffffffff8010646c:	68 e8 00 00 00       	pushq  $0xe8
  jmp alltraps
ffffffff80106471:	e9 16 01 00 00       	jmpq   ffffffff8010658c <alltraps>

ffffffff80106476 <vector233>:
.globl vector233
vector233:
  push $0
ffffffff80106476:	6a 00                	pushq  $0x0
  push $233
ffffffff80106478:	68 e9 00 00 00       	pushq  $0xe9
  jmp alltraps
ffffffff8010647d:	e9 0a 01 00 00       	jmpq   ffffffff8010658c <alltraps>

ffffffff80106482 <vector234>:
.globl vector234
vector234:
  push $0
ffffffff80106482:	6a 00                	pushq  $0x0
  push $234
ffffffff80106484:	68 ea 00 00 00       	pushq  $0xea
  jmp alltraps
ffffffff80106489:	e9 fe 00 00 00       	jmpq   ffffffff8010658c <alltraps>

ffffffff8010648e <vector235>:
.globl vector235
vector235:
  push $0
ffffffff8010648e:	6a 00                	pushq  $0x0
  push $235
ffffffff80106490:	68 eb 00 00 00       	pushq  $0xeb
  jmp alltraps
ffffffff80106495:	e9 f2 00 00 00       	jmpq   ffffffff8010658c <alltraps>

ffffffff8010649a <vector236>:
.globl vector236
vector236:
  push $0
ffffffff8010649a:	6a 00                	pushq  $0x0
  push $236
ffffffff8010649c:	68 ec 00 00 00       	pushq  $0xec
  jmp alltraps
ffffffff801064a1:	e9 e6 00 00 00       	jmpq   ffffffff8010658c <alltraps>

ffffffff801064a6 <vector237>:
.globl vector237
vector237:
  push $0
ffffffff801064a6:	6a 00                	pushq  $0x0
  push $237
ffffffff801064a8:	68 ed 00 00 00       	pushq  $0xed
  jmp alltraps
ffffffff801064ad:	e9 da 00 00 00       	jmpq   ffffffff8010658c <alltraps>

ffffffff801064b2 <vector238>:
.globl vector238
vector238:
  push $0
ffffffff801064b2:	6a 00                	pushq  $0x0
  push $238
ffffffff801064b4:	68 ee 00 00 00       	pushq  $0xee
  jmp alltraps
ffffffff801064b9:	e9 ce 00 00 00       	jmpq   ffffffff8010658c <alltraps>

ffffffff801064be <vector239>:
.globl vector239
vector239:
  push $0
ffffffff801064be:	6a 00                	pushq  $0x0
  push $239
ffffffff801064c0:	68 ef 00 00 00       	pushq  $0xef
  jmp alltraps
ffffffff801064c5:	e9 c2 00 00 00       	jmpq   ffffffff8010658c <alltraps>

ffffffff801064ca <vector240>:
.globl vector240
vector240:
  push $0
ffffffff801064ca:	6a 00                	pushq  $0x0
  push $240
ffffffff801064cc:	68 f0 00 00 00       	pushq  $0xf0
  jmp alltraps
ffffffff801064d1:	e9 b6 00 00 00       	jmpq   ffffffff8010658c <alltraps>

ffffffff801064d6 <vector241>:
.globl vector241
vector241:
  push $0
ffffffff801064d6:	6a 00                	pushq  $0x0
  push $241
ffffffff801064d8:	68 f1 00 00 00       	pushq  $0xf1
  jmp alltraps
ffffffff801064dd:	e9 aa 00 00 00       	jmpq   ffffffff8010658c <alltraps>

ffffffff801064e2 <vector242>:
.globl vector242
vector242:
  push $0
ffffffff801064e2:	6a 00                	pushq  $0x0
  push $242
ffffffff801064e4:	68 f2 00 00 00       	pushq  $0xf2
  jmp alltraps
ffffffff801064e9:	e9 9e 00 00 00       	jmpq   ffffffff8010658c <alltraps>

ffffffff801064ee <vector243>:
.globl vector243
vector243:
  push $0
ffffffff801064ee:	6a 00                	pushq  $0x0
  push $243
ffffffff801064f0:	68 f3 00 00 00       	pushq  $0xf3
  jmp alltraps
ffffffff801064f5:	e9 92 00 00 00       	jmpq   ffffffff8010658c <alltraps>

ffffffff801064fa <vector244>:
.globl vector244
vector244:
  push $0
ffffffff801064fa:	6a 00                	pushq  $0x0
  push $244
ffffffff801064fc:	68 f4 00 00 00       	pushq  $0xf4
  jmp alltraps
ffffffff80106501:	e9 86 00 00 00       	jmpq   ffffffff8010658c <alltraps>

ffffffff80106506 <vector245>:
.globl vector245
vector245:
  push $0
ffffffff80106506:	6a 00                	pushq  $0x0
  push $245
ffffffff80106508:	68 f5 00 00 00       	pushq  $0xf5
  jmp alltraps
ffffffff8010650d:	e9 7a 00 00 00       	jmpq   ffffffff8010658c <alltraps>

ffffffff80106512 <vector246>:
.globl vector246
vector246:
  push $0
ffffffff80106512:	6a 00                	pushq  $0x0
  push $246
ffffffff80106514:	68 f6 00 00 00       	pushq  $0xf6
  jmp alltraps
ffffffff80106519:	e9 6e 00 00 00       	jmpq   ffffffff8010658c <alltraps>

ffffffff8010651e <vector247>:
.globl vector247
vector247:
  push $0
ffffffff8010651e:	6a 00                	pushq  $0x0
  push $247
ffffffff80106520:	68 f7 00 00 00       	pushq  $0xf7
  jmp alltraps
ffffffff80106525:	e9 62 00 00 00       	jmpq   ffffffff8010658c <alltraps>

ffffffff8010652a <vector248>:
.globl vector248
vector248:
  push $0
ffffffff8010652a:	6a 00                	pushq  $0x0
  push $248
ffffffff8010652c:	68 f8 00 00 00       	pushq  $0xf8
  jmp alltraps
ffffffff80106531:	e9 56 00 00 00       	jmpq   ffffffff8010658c <alltraps>

ffffffff80106536 <vector249>:
.globl vector249
vector249:
  push $0
ffffffff80106536:	6a 00                	pushq  $0x0
  push $249
ffffffff80106538:	68 f9 00 00 00       	pushq  $0xf9
  jmp alltraps
ffffffff8010653d:	e9 4a 00 00 00       	jmpq   ffffffff8010658c <alltraps>

ffffffff80106542 <vector250>:
.globl vector250
vector250:
  push $0
ffffffff80106542:	6a 00                	pushq  $0x0
  push $250
ffffffff80106544:	68 fa 00 00 00       	pushq  $0xfa
  jmp alltraps
ffffffff80106549:	e9 3e 00 00 00       	jmpq   ffffffff8010658c <alltraps>

ffffffff8010654e <vector251>:
.globl vector251
vector251:
  push $0
ffffffff8010654e:	6a 00                	pushq  $0x0
  push $251
ffffffff80106550:	68 fb 00 00 00       	pushq  $0xfb
  jmp alltraps
ffffffff80106555:	e9 32 00 00 00       	jmpq   ffffffff8010658c <alltraps>

ffffffff8010655a <vector252>:
.globl vector252
vector252:
  push $0
ffffffff8010655a:	6a 00                	pushq  $0x0
  push $252
ffffffff8010655c:	68 fc 00 00 00       	pushq  $0xfc
  jmp alltraps
ffffffff80106561:	e9 26 00 00 00       	jmpq   ffffffff8010658c <alltraps>

ffffffff80106566 <vector253>:
.globl vector253
vector253:
  push $0
ffffffff80106566:	6a 00                	pushq  $0x0
  push $253
ffffffff80106568:	68 fd 00 00 00       	pushq  $0xfd
  jmp alltraps
ffffffff8010656d:	e9 1a 00 00 00       	jmpq   ffffffff8010658c <alltraps>

ffffffff80106572 <vector254>:
.globl vector254
vector254:
  push $0
ffffffff80106572:	6a 00                	pushq  $0x0
  push $254
ffffffff80106574:	68 fe 00 00 00       	pushq  $0xfe
  jmp alltraps
ffffffff80106579:	e9 0e 00 00 00       	jmpq   ffffffff8010658c <alltraps>

ffffffff8010657e <vector255>:
.globl vector255
vector255:
  push $0
ffffffff8010657e:	6a 00                	pushq  $0x0
  push $255
ffffffff80106580:	68 ff 00 00 00       	pushq  $0xff
  jmp alltraps
ffffffff80106585:	e9 02 00 00 00       	jmpq   ffffffff8010658c <alltraps>
ffffffff8010658a:	66 90                	xchg   %ax,%ax

ffffffff8010658c <alltraps>:
.globl alltraps
alltraps:
  push %r15
ffffffff8010658c:	41 57                	push   %r15
  push %r14
ffffffff8010658e:	41 56                	push   %r14
  push %r13
ffffffff80106590:	41 55                	push   %r13
  push %r12
ffffffff80106592:	41 54                	push   %r12
  push %r11
ffffffff80106594:	41 53                	push   %r11
  push %r10
ffffffff80106596:	41 52                	push   %r10
  push %r9
ffffffff80106598:	41 51                	push   %r9
  push %r8
ffffffff8010659a:	41 50                	push   %r8
  push %rdi
ffffffff8010659c:	57                   	push   %rdi
  push %rsi
ffffffff8010659d:	56                   	push   %rsi
  push %rbp
ffffffff8010659e:	55                   	push   %rbp
  push %rdx
ffffffff8010659f:	52                   	push   %rdx
  push %rcx
ffffffff801065a0:	51                   	push   %rcx
  push %rbx
ffffffff801065a1:	53                   	push   %rbx
  push %rax
ffffffff801065a2:	50                   	push   %rax

  mov %rsp, %rdi
ffffffff801065a3:	48 89 e7             	mov    %rsp,%rdi
  call trap
ffffffff801065a6:	e8 05 03 00 00       	callq  ffffffff801068b0 <trap>

ffffffff801065ab <trapret>:

.globl trapret
trapret:
  pop %rax
ffffffff801065ab:	58                   	pop    %rax
  pop %rbx
ffffffff801065ac:	5b                   	pop    %rbx
  pop %rcx
ffffffff801065ad:	59                   	pop    %rcx
  pop %rdx
ffffffff801065ae:	5a                   	pop    %rdx
  pop %rbp
ffffffff801065af:	5d                   	pop    %rbp
  pop %rsi
ffffffff801065b0:	5e                   	pop    %rsi
  pop %rdi
ffffffff801065b1:	5f                   	pop    %rdi
  pop %r8
ffffffff801065b2:	41 58                	pop    %r8
  pop %r9
ffffffff801065b4:	41 59                	pop    %r9
  pop %r10
ffffffff801065b6:	41 5a                	pop    %r10
  pop %r11
ffffffff801065b8:	41 5b                	pop    %r11
  pop %r12
ffffffff801065ba:	41 5c                	pop    %r12
  pop %r13
ffffffff801065bc:	41 5d                	pop    %r13
  pop %r14
ffffffff801065be:	41 5e                	pop    %r14
  pop %r15
ffffffff801065c0:	41 5f                	pop    %r15
  add $16, %rsp
ffffffff801065c2:	48 83 c4 10          	add    $0x10,%rsp
ffffffff801065c6:	48 cf                	iretq  
ffffffff801065c8:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
ffffffff801065cf:	00 

ffffffff801065d0 <tvinit>:

static const uint8_t STACK_REDZONE = 128;

void
tvinit(void)
{
ffffffff801065d0:	55                   	push   %rbp
ffffffff801065d1:	48 89 e5             	mov    %rsp,%rbp
  int i;

  for(i = 0; i < 256; i++)
ffffffff801065d4:	48 83 ec 20          	sub    $0x20,%rsp
ffffffff801065d8:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
ffffffff801065df:	81 7d fc 00 01 00 00 	cmpl   $0x100,-0x4(%rbp)
ffffffff801065e6:	0f 8d 5a 00 00 00    	jge    ffffffff80106646 <tvinit+0x76>
ffffffff801065ec:	31 c0                	xor    %eax,%eax
ffffffff801065ee:	b9 08 00 00 00       	mov    $0x8,%ecx
    set_gate_desc(&idt[i], 0, SEG_KCODE<<3, vectors[i], KERNEL_PL);
ffffffff801065f3:	48 63 55 fc          	movslq -0x4(%rbp),%rdx
ffffffff801065f7:	48 89 d6             	mov    %rdx,%rsi
ffffffff801065fa:	48 c1 e6 04          	shl    $0x4,%rsi
ffffffff801065fe:	48 8d be c0 6b 1f 83 	lea    -0x7ce09440(%rsi),%rdi
ffffffff80106605:	48 8d 14 d5 68 10 12 	lea    -0x7fedef98(,%rdx,8),%rdx
ffffffff8010660c:	80 
ffffffff8010660d:	48 8b 12             	mov    (%rdx),%rdx
ffffffff80106610:	41 b8 08 00 00 00    	mov    $0x8,%r8d
ffffffff80106616:	45 31 c9             	xor    %r9d,%r9d
ffffffff80106619:	44 89 ce             	mov    %r9d,%esi
ffffffff8010661c:	48 89 55 f0          	mov    %rdx,-0x10(%rbp)
ffffffff80106620:	44 89 c2             	mov    %r8d,%edx
ffffffff80106623:	4c 8b 55 f0          	mov    -0x10(%rbp),%r10
ffffffff80106627:	89 4d ec             	mov    %ecx,-0x14(%rbp)
ffffffff8010662a:	4c 89 d1             	mov    %r10,%rcx
ffffffff8010662d:	45 89 c8             	mov    %r9d,%r8d
ffffffff80106630:	89 45 e8             	mov    %eax,-0x18(%rbp)
ffffffff80106633:	e8 58 00 00 00       	callq  ffffffff80106690 <set_gate_desc>
  for(i = 0; i < 256; i++)
ffffffff80106638:	8b 45 fc             	mov    -0x4(%rbp),%eax
ffffffff8010663b:	83 c0 01             	add    $0x1,%eax
ffffffff8010663e:	89 45 fc             	mov    %eax,-0x4(%rbp)
ffffffff80106641:	e9 99 ff ff ff       	jmpq   ffffffff801065df <tvinit+0xf>
  set_gate_desc(&idt[TRAP_SYSCALL], 1, SEG_KCODE<<3, vectors[TRAP_SYSCALL], USER_PL);
ffffffff80106646:	48 8b 0c 25 68 12 12 	mov    0xffffffff80121268,%rcx
ffffffff8010664d:	80 
ffffffff8010664e:	48 c7 c7 c0 6f 1f 83 	mov    $0xffffffff831f6fc0,%rdi
ffffffff80106655:	be 01 00 00 00       	mov    $0x1,%esi
ffffffff8010665a:	ba 08 00 00 00       	mov    $0x8,%edx
ffffffff8010665f:	41 b8 03 00 00 00    	mov    $0x3,%r8d
ffffffff80106665:	e8 26 00 00 00       	callq  ffffffff80106690 <set_gate_desc>

  initlock(&tickslock, "time");
ffffffff8010666a:	48 c7 c7 50 6b 1f 83 	mov    $0xffffffff831f6b50,%rdi
ffffffff80106671:	48 c7 c6 00 00 11 80 	mov    $0xffffffff80110000,%rsi
ffffffff80106678:	e8 03 f1 ff ff       	callq  ffffffff80105780 <initlock>
}
ffffffff8010667d:	48 83 c4 20          	add    $0x20,%rsp
ffffffff80106681:	5d                   	pop    %rbp
ffffffff80106682:	c3                   	retq   
ffffffff80106683:	66 66 66 66 2e 0f 1f 	data16 data16 data16 nopw %cs:0x0(%rax,%rax,1)
ffffffff8010668a:	84 00 00 00 00 00 

ffffffff80106690 <set_gate_desc>:
} __packed;

static_assert(sizeof(struct gate_desc) == 16, "gate_desc size 16");

static inline void set_gate_desc(struct gate_desc *gd, bool istrap, uint16_t sel, void *ptr, int dpl)
{
ffffffff80106690:	55                   	push   %rbp
ffffffff80106691:	48 89 e5             	mov    %rsp,%rbp
ffffffff80106694:	53                   	push   %rbx
ffffffff80106695:	48 83 ec 28          	sub    $0x28,%rsp
ffffffff80106699:	66 89 d0             	mov    %dx,%ax
ffffffff8010669c:	41 88 f1             	mov    %sil,%r9b
ffffffff8010669f:	48 89 7d f0          	mov    %rdi,-0x10(%rbp)
ffffffff801066a3:	41 80 e1 01          	and    $0x1,%r9b
ffffffff801066a7:	44 88 4d ef          	mov    %r9b,-0x11(%rbp)
ffffffff801066ab:	66 89 45 ec          	mov    %ax,-0x14(%rbp)
ffffffff801066af:	48 89 4d e0          	mov    %rcx,-0x20(%rbp)
ffffffff801066b3:	44 89 45 dc          	mov    %r8d,-0x24(%rbp)
	uintptr_t off = (uintptr_t)ptr;
ffffffff801066b7:	48 8b 4d e0          	mov    -0x20(%rbp),%rcx
ffffffff801066bb:	48 89 4d d0          	mov    %rcx,-0x30(%rbp)

	gd->off_15_0 = (off >> 0) & 0xffff;
ffffffff801066bf:	48 8b 4d f0          	mov    -0x10(%rbp),%rcx
ffffffff801066c3:	0f b7 55 d0          	movzwl -0x30(%rbp),%edx
ffffffff801066c7:	89 d7                	mov    %edx,%edi
ffffffff801066c9:	66 89 f8             	mov    %di,%ax
ffffffff801066cc:	48 8b 79 08          	mov    0x8(%rcx),%rdi
ffffffff801066d0:	48 89 79 08          	mov    %rdi,0x8(%rcx)
ffffffff801066d4:	66 89 01             	mov    %ax,(%rcx)
	gd->sel = sel;
ffffffff801066d7:	48 8b 4d f0          	mov    -0x10(%rbp),%rcx
ffffffff801066db:	0f b7 55 ec          	movzwl -0x14(%rbp),%edx
ffffffff801066df:	89 d7                	mov    %edx,%edi
ffffffff801066e1:	4c 8b 51 08          	mov    0x8(%rcx),%r10
ffffffff801066e5:	66 89 f8             	mov    %di,%ax
ffffffff801066e8:	4c 89 51 08          	mov    %r10,0x8(%rcx)
ffffffff801066ec:	66 89 41 02          	mov    %ax,0x2(%rcx)
	gd->ist = 0;
ffffffff801066f0:	48 8b 4d f0          	mov    -0x10(%rbp),%rcx
ffffffff801066f4:	48 8b 39             	mov    (%rcx),%rdi
ffffffff801066f7:	4c 8b 51 08          	mov    0x8(%rcx),%r10
ffffffff801066fb:	49 bb ff ff ff ff f8 	movabs $0xfffffff8ffffffff,%r11
ffffffff80106702:	ff ff ff 
ffffffff80106705:	4c 21 df             	and    %r11,%rdi
ffffffff80106708:	4c 89 51 08          	mov    %r10,0x8(%rcx)
ffffffff8010670c:	48 89 39             	mov    %rdi,(%rcx)
	gd->rsv1 = 0;
ffffffff8010670f:	48 8b 4d f0          	mov    -0x10(%rbp),%rcx
ffffffff80106713:	48 8b 39             	mov    (%rcx),%rdi
ffffffff80106716:	4c 8b 51 08          	mov    0x8(%rcx),%r10
ffffffff8010671a:	49 bb ff ff ff ff 07 	movabs $0xffffff07ffffffff,%r11
ffffffff80106721:	ff ff ff 
ffffffff80106724:	4c 21 df             	and    %r11,%rdi
ffffffff80106727:	4c 89 51 08          	mov    %r10,0x8(%rcx)
ffffffff8010672b:	48 89 39             	mov    %rdi,(%rcx)
	gd->type = istrap ? STS_TG64 : STS_IG64;
ffffffff8010672e:	0f b6 55 ef          	movzbl -0x11(%rbp),%edx
ffffffff80106732:	83 e2 01             	and    $0x1,%edx
ffffffff80106735:	83 ca 0e             	or     $0xe,%edx
ffffffff80106738:	48 8b 4d f0          	mov    -0x10(%rbp),%rcx
ffffffff8010673c:	89 d7                	mov    %edx,%edi
ffffffff8010673e:	4c 8b 11             	mov    (%rcx),%r10
ffffffff80106741:	4c 8b 59 08          	mov    0x8(%rcx),%r11
ffffffff80106745:	48 c1 e7 28          	shl    $0x28,%rdi
ffffffff80106749:	48 bb ff ff ff ff ff 	movabs $0xfffff0ffffffffff,%rbx
ffffffff80106750:	f0 ff ff 
ffffffff80106753:	49 21 da             	and    %rbx,%r10
ffffffff80106756:	49 09 fa             	or     %rdi,%r10
ffffffff80106759:	4c 89 59 08          	mov    %r11,0x8(%rcx)
ffffffff8010675d:	4c 89 11             	mov    %r10,(%rcx)
	gd->s = 0;
ffffffff80106760:	48 8b 4d f0          	mov    -0x10(%rbp),%rcx
ffffffff80106764:	48 8b 39             	mov    (%rcx),%rdi
ffffffff80106767:	4c 8b 51 08          	mov    0x8(%rcx),%r10
ffffffff8010676b:	49 bb ff ff ff ff ff 	movabs $0xffffefffffffffff,%r11
ffffffff80106772:	ef ff ff 
ffffffff80106775:	4c 21 df             	and    %r11,%rdi
ffffffff80106778:	4c 89 51 08          	mov    %r10,0x8(%rcx)
ffffffff8010677c:	48 89 39             	mov    %rdi,(%rcx)
	gd->dpl = dpl;
ffffffff8010677f:	48 8b 4d f0          	mov    -0x10(%rbp),%rcx
ffffffff80106783:	8b 55 dc             	mov    -0x24(%rbp),%edx
ffffffff80106786:	48 8b 39             	mov    (%rcx),%rdi
ffffffff80106789:	4c 8b 51 08          	mov    0x8(%rcx),%r10
ffffffff8010678d:	83 e2 03             	and    $0x3,%edx
ffffffff80106790:	41 89 d3             	mov    %edx,%r11d
ffffffff80106793:	49 c1 e3 2d          	shl    $0x2d,%r11
ffffffff80106797:	48 bb ff ff ff ff ff 	movabs $0xffff9fffffffffff,%rbx
ffffffff8010679e:	9f ff ff 
ffffffff801067a1:	48 21 df             	and    %rbx,%rdi
ffffffff801067a4:	4c 09 df             	or     %r11,%rdi
ffffffff801067a7:	4c 89 51 08          	mov    %r10,0x8(%rcx)
ffffffff801067ab:	48 89 39             	mov    %rdi,(%rcx)
	gd->p = 1;
ffffffff801067ae:	48 8b 4d f0          	mov    -0x10(%rbp),%rcx
ffffffff801067b2:	48 8b 39             	mov    (%rcx),%rdi
ffffffff801067b5:	4c 8b 51 08          	mov    0x8(%rcx),%r10
ffffffff801067b9:	49 bb 00 00 00 00 00 	movabs $0x800000000000,%r11
ffffffff801067c0:	80 00 00 
ffffffff801067c3:	4c 09 df             	or     %r11,%rdi
ffffffff801067c6:	4c 89 51 08          	mov    %r10,0x8(%rcx)
ffffffff801067ca:	48 89 39             	mov    %rdi,(%rcx)
	gd->off_31_16 = (off >> 16) & 0xffff;
ffffffff801067cd:	48 8b 4d f0          	mov    -0x10(%rbp),%rcx
ffffffff801067d1:	0f b7 55 d2          	movzwl -0x2e(%rbp),%edx
ffffffff801067d5:	89 d7                	mov    %edx,%edi
ffffffff801067d7:	4c 8b 51 08          	mov    0x8(%rcx),%r10
ffffffff801067db:	66 89 f8             	mov    %di,%ax
ffffffff801067de:	4c 89 51 08          	mov    %r10,0x8(%rcx)
ffffffff801067e2:	66 89 41 06          	mov    %ax,0x6(%rcx)
	gd->off_63_32 = (off >> 32) & 0xffffffff;
ffffffff801067e6:	48 8b 4d f0          	mov    -0x10(%rbp),%rcx
ffffffff801067ea:	8b 55 d4             	mov    -0x2c(%rbp),%edx
ffffffff801067ed:	48 8b 39             	mov    (%rcx),%rdi
ffffffff801067f0:	89 51 08             	mov    %edx,0x8(%rcx)
ffffffff801067f3:	48 89 39             	mov    %rdi,(%rcx)
	gd->rsv2 = 0;
ffffffff801067f6:	48 8b 4d f0          	mov    -0x10(%rbp),%rcx
ffffffff801067fa:	48 8b 39             	mov    (%rcx),%rdi
ffffffff801067fd:	8b 51 08             	mov    0x8(%rcx),%edx
ffffffff80106800:	41 89 d2             	mov    %edx,%r10d
ffffffff80106803:	4c 89 51 08          	mov    %r10,0x8(%rcx)
ffffffff80106807:	48 89 39             	mov    %rdi,(%rcx)
}
ffffffff8010680a:	48 83 c4 28          	add    $0x28,%rsp
ffffffff8010680e:	5b                   	pop    %rbx
ffffffff8010680f:	5d                   	pop    %rbp
ffffffff80106810:	c3                   	retq   
ffffffff80106811:	66 66 66 66 66 66 2e 	data16 data16 data16 data16 data16 nopw %cs:0x0(%rax,%rax,1)
ffffffff80106818:	0f 1f 84 00 00 00 00 
ffffffff8010681f:	00 

ffffffff80106820 <idtinit>:

void
idtinit(void)
{
ffffffff80106820:	55                   	push   %rbp
ffffffff80106821:	48 89 e5             	mov    %rsp,%rbp
  lidt((void *)idt, sizeof(idt));
ffffffff80106824:	48 c7 c7 c0 6b 1f 83 	mov    $0xffffffff831f6bc0,%rdi
ffffffff8010682b:	be 00 10 00 00       	mov    $0x1000,%esi
ffffffff80106830:	e8 0b 00 00 00       	callq  ffffffff80106840 <lidt>
}
ffffffff80106835:	5d                   	pop    %rbp
ffffffff80106836:	c3                   	retq   
ffffffff80106837:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
ffffffff8010683e:	00 00 

ffffffff80106840 <lidt>:
{
ffffffff80106840:	55                   	push   %rbp
ffffffff80106841:	48 89 e5             	mov    %rsp,%rbp
ffffffff80106844:	48 83 ec 18          	sub    $0x18,%rsp
ffffffff80106848:	48 8d 45 ea          	lea    -0x16(%rbp),%rax
ffffffff8010684c:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
ffffffff80106850:	89 75 f4             	mov    %esi,-0xc(%rbp)
  pd[0] = size-1;
ffffffff80106853:	8b 75 f4             	mov    -0xc(%rbp),%esi
ffffffff80106856:	83 ee 01             	sub    $0x1,%esi
ffffffff80106859:	66 89 f1             	mov    %si,%cx
ffffffff8010685c:	66 89 4d ea          	mov    %cx,-0x16(%rbp)
  pd[1] = (uint64_t)p;
ffffffff80106860:	48 8b 7d f8          	mov    -0x8(%rbp),%rdi
ffffffff80106864:	66 89 f9             	mov    %di,%cx
ffffffff80106867:	66 89 4d ec          	mov    %cx,-0x14(%rbp)
  pd[2] = (uint64_t)p >> 16;
ffffffff8010686b:	48 8b 7d f8          	mov    -0x8(%rbp),%rdi
ffffffff8010686f:	48 c1 ef 10          	shr    $0x10,%rdi
ffffffff80106873:	66 89 f9             	mov    %di,%cx
ffffffff80106876:	66 89 4d ee          	mov    %cx,-0x12(%rbp)
  pd[3] = (uint64_t)p >> 32;
ffffffff8010687a:	48 8b 7d f8          	mov    -0x8(%rbp),%rdi
ffffffff8010687e:	48 c1 ef 20          	shr    $0x20,%rdi
ffffffff80106882:	66 89 f9             	mov    %di,%cx
ffffffff80106885:	66 89 4d f0          	mov    %cx,-0x10(%rbp)
  pd[4] = (uint64_t)p >> 48;
ffffffff80106889:	48 8b 7d f8          	mov    -0x8(%rbp),%rdi
ffffffff8010688d:	48 c1 ef 30          	shr    $0x30,%rdi
ffffffff80106891:	66 89 f9             	mov    %di,%cx
ffffffff80106894:	66 89 4d f2          	mov    %cx,-0xe(%rbp)
  asm volatile("lidt (%0)" : : "r" (pd));
ffffffff80106898:	0f 01 18             	lidt   (%rax)
}
ffffffff8010689b:	48 83 c4 18          	add    $0x18,%rsp
ffffffff8010689f:	5d                   	pop    %rbp
ffffffff801068a0:	c3                   	retq   
ffffffff801068a1:	66 66 66 66 66 66 2e 	data16 data16 data16 data16 data16 nopw %cs:0x0(%rax,%rax,1)
ffffffff801068a8:	0f 1f 84 00 00 00 00 
ffffffff801068af:	00 

ffffffff801068b0 <trap>:

//PAGEBREAK: 41
void
trap(struct trap_frame *tf)
{
ffffffff801068b0:	55                   	push   %rbp
ffffffff801068b1:	48 89 e5             	mov    %rsp,%rbp
ffffffff801068b4:	48 81 ec 80 00 00 00 	sub    $0x80,%rsp
ffffffff801068bb:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  if(tf->trapno == TRAP_SYSCALL){
ffffffff801068bf:	48 8b 7d f8          	mov    -0x8(%rbp),%rdi
ffffffff801068c3:	48 83 7f 78 40       	cmpq   $0x40,0x78(%rdi)
ffffffff801068c8:	0f 85 50 00 00 00    	jne    ffffffff8010691e <trap+0x6e>
    if(myproc()->killed)
ffffffff801068ce:	e8 fd 03 00 00       	callq  ffffffff80106cd0 <myproc>
ffffffff801068d3:	83 b8 28 01 00 00 00 	cmpl   $0x0,0x128(%rax)
ffffffff801068da:	0f 84 05 00 00 00    	je     ffffffff801068e5 <trap+0x35>
      exit();
ffffffff801068e0:	e8 6b 16 00 00       	callq  ffffffff80107f50 <exit>
    myproc()->tf = tf;
ffffffff801068e5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
ffffffff801068e9:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
ffffffff801068ed:	e8 de 03 00 00       	callq  ffffffff80106cd0 <myproc>
ffffffff801068f2:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
ffffffff801068f6:	48 89 88 10 01 00 00 	mov    %rcx,0x110(%rax)
    syscall();
ffffffff801068fd:	e8 de 2a 00 00       	callq  ffffffff801093e0 <syscall>
    if(myproc()->killed)
ffffffff80106902:	e8 c9 03 00 00       	callq  ffffffff80106cd0 <myproc>
ffffffff80106907:	83 b8 28 01 00 00 00 	cmpl   $0x0,0x128(%rax)
ffffffff8010690e:	0f 84 05 00 00 00    	je     ffffffff80106919 <trap+0x69>
      exit();
ffffffff80106914:	e8 37 16 00 00       	callq  ffffffff80107f50 <exit>
    return;
ffffffff80106919:	e9 9b 03 00 00       	jmpq   ffffffff80106cb9 <trap+0x409>
  }

  uint64_t addr;

  switch(tf->trapno){
ffffffff8010691e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
ffffffff80106922:	48 8b 40 78          	mov    0x78(%rax),%rax
ffffffff80106926:	48 83 c0 e0          	add    $0xffffffffffffffe0,%rax
ffffffff8010692a:	48 89 c1             	mov    %rax,%rcx
ffffffff8010692d:	48 83 e9 1f          	sub    $0x1f,%rcx
ffffffff80106931:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
ffffffff80106935:	48 89 4d c8          	mov    %rcx,-0x38(%rbp)
ffffffff80106939:	0f 87 d2 00 00 00    	ja     ffffffff80106a11 <trap+0x161>
ffffffff8010693f:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
ffffffff80106943:	48 8b 0c c5 00 ff 10 	mov    -0x7fef0100(,%rax,8),%rcx
ffffffff8010694a:	80 
ffffffff8010694b:	ff e1                	jmpq   *%rcx
  case TRAP_IRQ0 + IRQ_TIMER:
    if(cpunum() == 0){
ffffffff8010694d:	e8 4e b1 ff ff       	callq  ffffffff80101aa0 <cpunum>
ffffffff80106952:	83 f8 00             	cmp    $0x0,%eax
ffffffff80106955:	0f 85 3f 00 00 00    	jne    ffffffff8010699a <trap+0xea>
      acquire(&tickslock);
ffffffff8010695b:	48 c7 c7 50 6b 1f 83 	mov    $0xffffffff831f6b50,%rdi
ffffffff80106962:	e8 59 ee ff ff       	callq  ffffffff801057c0 <acquire>
      ticks++;
ffffffff80106967:	8b 04 25 c0 7b 1f 83 	mov    0xffffffff831f7bc0,%eax
ffffffff8010696e:	ff c0                	inc    %eax
ffffffff80106970:	89 04 25 c0 7b 1f 83 	mov    %eax,0xffffffff831f7bc0
      wakeup(&ticks);
ffffffff80106977:	48 c7 c7 c0 7b 1f 83 	mov    $0xffffffff831f7bc0,%rdi
ffffffff8010697e:	e8 4d 1d 00 00       	callq  ffffffff801086d0 <wakeup>
      release(&tickslock);
ffffffff80106983:	48 c7 c7 50 6b 1f 83 	mov    $0xffffffff831f6b50,%rdi
ffffffff8010698a:	e8 71 f0 ff ff       	callq  ffffffff80105a00 <release>

      swap_timer();
ffffffff8010698f:	31 c0                	xor    %eax,%eax
ffffffff80106991:	88 c1                	mov    %al,%cl
ffffffff80106993:	88 c8                	mov    %cl,%al
ffffffff80106995:	e8 56 88 00 00       	callq  ffffffff8010f1f0 <swap_timer>
    }
    lapiceoi();
ffffffff8010699a:	e8 11 b2 ff ff       	callq  ffffffff80101bb0 <lapiceoi>
    break;
ffffffff8010699f:	e9 62 02 00 00       	jmpq   ffffffff80106c06 <trap+0x356>
  case TRAP_IRQ0 + IRQ_IDE:
    ideintr();
ffffffff801069a4:	e8 87 8f 00 00       	callq  ffffffff8010f930 <ideintr>
    lapiceoi();
ffffffff801069a9:	e8 02 b2 ff ff       	callq  ffffffff80101bb0 <lapiceoi>
    break;
ffffffff801069ae:	e9 53 02 00 00       	jmpq   ffffffff80106c06 <trap+0x356>
  case TRAP_IRQ0 + IRQ_IDE+1:
    // Bochs generates spurious IDE1 interrupts.
    break;
ffffffff801069b3:	e9 4e 02 00 00       	jmpq   ffffffff80106c06 <trap+0x356>
  case TRAP_IRQ0 + IRQ_KBD:
    kbdintr();
ffffffff801069b8:	e8 23 45 00 00       	callq  ffffffff8010aee0 <kbdintr>
    lapiceoi();
ffffffff801069bd:	e8 ee b1 ff ff       	callq  ffffffff80101bb0 <lapiceoi>
    break;
ffffffff801069c2:	e9 3f 02 00 00       	jmpq   ffffffff80106c06 <trap+0x356>
  case TRAP_IRQ0 + IRQ_COM1:
    uartintr();
ffffffff801069c7:	e8 54 42 00 00       	callq  ffffffff8010ac20 <uartintr>
    lapiceoi();
ffffffff801069cc:	e8 df b1 ff ff       	callq  ffffffff80101bb0 <lapiceoi>
    break;
ffffffff801069d1:	e9 30 02 00 00       	jmpq   ffffffff80106c06 <trap+0x356>
  case TRAP_IRQ0 + 7:
  case TRAP_IRQ0 + IRQ_SPURIOUS:
    cprintf("cpu%d: spurious interrupt at %x:%x\n",
            cpunum(), tf->cs, tf->rip);
ffffffff801069d6:	e8 c5 b0 ff ff       	callq  ffffffff80101aa0 <cpunum>
ffffffff801069db:	48 8b 4d f8          	mov    -0x8(%rbp),%rcx
ffffffff801069df:	48 8b 91 90 00 00 00 	mov    0x90(%rcx),%rdx
ffffffff801069e6:	48 8b 4d f8          	mov    -0x8(%rbp),%rcx
ffffffff801069ea:	48 8b 89 88 00 00 00 	mov    0x88(%rcx),%rcx
    cprintf("cpu%d: spurious interrupt at %x:%x\n",
ffffffff801069f1:	48 c7 c7 05 00 11 80 	mov    $0xffffffff80110005,%rdi
ffffffff801069f8:	31 f6                	xor    %esi,%esi
ffffffff801069fa:	41 88 f0             	mov    %sil,%r8b
ffffffff801069fd:	89 c6                	mov    %eax,%esi
ffffffff801069ff:	44 88 c0             	mov    %r8b,%al
ffffffff80106a02:	e8 59 9f ff ff       	callq  ffffffff80100960 <cprintf>
    lapiceoi();
ffffffff80106a07:	e8 a4 b1 ff ff       	callq  ffffffff80101bb0 <lapiceoi>
    break;
ffffffff80106a0c:	e9 f5 01 00 00       	jmpq   ffffffff80106c06 <trap+0x356>

  //PAGEBREAK: 13
  default:
    addr = rcr2();
ffffffff80106a11:	e8 da 02 00 00       	callq  ffffffff80106cf0 <rcr2>
ffffffff80106a16:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

    if (tf->trapno == TRAP_PF) {
ffffffff80106a1a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
ffffffff80106a1e:	48 83 78 78 0e       	cmpq   $0xe,0x78(%rax)
ffffffff80106a23:	0f 85 4e 01 00 00    	jne    ffffffff80106b77 <trap+0x2c7>
      // Page Fault Cases
      num_page_faults += 1;
ffffffff80106a29:	8b 04 25 78 64 1f 83 	mov    0xffffffff831f6478,%eax
ffffffff80106a30:	ff c0                	inc    %eax
ffffffff80106a32:	89 04 25 78 64 1f 83 	mov    %eax,0xffffffff831f6478

      struct proc* proc = myproc();
ffffffff80106a39:	e8 92 02 00 00       	callq  ffffffff80106cd0 <myproc>
ffffffff80106a3e:	48 89 45 e8          	mov    %rax,-0x18(%rbp)

      if (proc == 0 || (tf->cs&3) == 0) {
ffffffff80106a42:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
ffffffff80106a47:	0f 84 19 00 00 00    	je     ffffffff80106a66 <trap+0x1b6>
ffffffff80106a4d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
ffffffff80106a51:	48 8b 80 90 00 00 00 	mov    0x90(%rax),%rax
ffffffff80106a58:	48 83 e0 03          	and    $0x3,%rax
ffffffff80106a5c:	48 83 f8 00          	cmp    $0x0,%rax
ffffffff80106a60:	0f 85 59 00 00 00    	jne    ffffffff80106abf <trap+0x20f>
        // In kernel, it must be our mistake.
        cprintf("unexpected trap %d err %d from cpu %d rip %lx (cr2=0x%x)\n",
                tf->trapno, tf->err, cpunum(), tf->rip, addr);
ffffffff80106a66:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
ffffffff80106a6a:	48 8b 70 78          	mov    0x78(%rax),%rsi
ffffffff80106a6e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
ffffffff80106a72:	48 8b 90 80 00 00 00 	mov    0x80(%rax),%rdx
ffffffff80106a79:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
ffffffff80106a7d:	48 89 55 b8          	mov    %rdx,-0x48(%rbp)
ffffffff80106a81:	e8 1a b0 ff ff       	callq  ffffffff80101aa0 <cpunum>
ffffffff80106a86:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
ffffffff80106a8a:	4c 8b 82 88 00 00 00 	mov    0x88(%rdx),%r8
ffffffff80106a91:	4c 8b 4d f0          	mov    -0x10(%rbp),%r9
        cprintf("unexpected trap %d err %d from cpu %d rip %lx (cr2=0x%x)\n",
ffffffff80106a95:	48 c7 c7 29 00 11 80 	mov    $0xffffffff80110029,%rdi
ffffffff80106a9c:	31 c9                	xor    %ecx,%ecx
ffffffff80106a9e:	41 88 ca             	mov    %cl,%r10b
ffffffff80106aa1:	48 8b 75 c0          	mov    -0x40(%rbp),%rsi
ffffffff80106aa5:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
ffffffff80106aa9:	89 c1                	mov    %eax,%ecx
ffffffff80106aab:	44 88 d0             	mov    %r10b,%al
ffffffff80106aae:	e8 ad 9e ff ff       	callq  ffffffff80100960 <cprintf>
        panic("trap");
ffffffff80106ab3:	48 c7 c7 63 00 11 80 	mov    $0xffffffff80110063,%rdi
ffffffff80106aba:	e8 b1 a3 ff ff       	callq  ffffffff80100e70 <panic>
      }

      if (tf->err == 4) {
ffffffff80106abf:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
ffffffff80106ac3:	48 83 b8 80 00 00 00 	cmpq   $0x4,0x80(%rax)
ffffffff80106aca:	04 
ffffffff80106acb:	0f 85 12 00 00 00    	jne    ffffffff80106ae3 <trap+0x233>
        // Not present because it's swapped. Swap it in, possibly evicting
        // another page first.
        swap_restore_page(proc, addr);
ffffffff80106ad1:	48 8b 7d e8          	mov    -0x18(%rbp),%rdi
ffffffff80106ad5:	48 8b 75 f0          	mov    -0x10(%rbp),%rsi
ffffffff80106ad9:	e8 d2 86 00 00       	callq  ffffffff8010f1b0 <swap_restore_page>
        return;
ffffffff80106ade:	e9 d6 01 00 00       	jmpq   ffffffff80106cb9 <trap+0x409>
ffffffff80106ae3:	31 c0                	xor    %eax,%eax
      }

      pte_t* pte = walkpml4(proc->pml4, (void*) addr, 0);
ffffffff80106ae5:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
ffffffff80106ae9:	48 8b 39             	mov    (%rcx),%rdi
ffffffff80106aec:	48 8b 75 f0          	mov    -0x10(%rbp),%rsi
ffffffff80106af0:	31 d2                	xor    %edx,%edx
ffffffff80106af2:	89 45 b4             	mov    %eax,-0x4c(%rbp)
ffffffff80106af5:	e8 76 c1 ff ff       	callq  ffffffff80102c70 <walkpml4>
ffffffff80106afa:	48 89 45 e0          	mov    %rax,-0x20(%rbp)

      if (pte != 0 && *pte & PTE_RO) {
ffffffff80106afe:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
ffffffff80106b03:	0f 84 2d 00 00 00    	je     ffffffff80106b36 <trap+0x286>
ffffffff80106b09:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
ffffffff80106b0d:	48 8b 00             	mov    (%rax),%rax
ffffffff80106b10:	48 25 00 08 00 00    	and    $0x800,%rax
ffffffff80106b16:	48 83 f8 00          	cmp    $0x0,%rax
ffffffff80106b1a:	0f 84 16 00 00 00    	je     ffffffff80106b36 <trap+0x286>
        // CASE: Marked read-only during a CoW fork.
        copy_writable_page(proc, addr, pte);
ffffffff80106b20:	48 8b 7d e8          	mov    -0x18(%rbp),%rdi
ffffffff80106b24:	48 8b 75 f0          	mov    -0x10(%rbp),%rsi
ffffffff80106b28:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
ffffffff80106b2c:	e8 3f e9 ff ff       	callq  ffffffff80105470 <copy_writable_page>
        return;
ffffffff80106b31:	e9 83 01 00 00       	jmpq   ffffffff80106cb9 <trap+0x409>
      }

      if (tf->rsp - STACK_REDZONE <= addr && addr < SZ_2G) {
ffffffff80106b36:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
ffffffff80106b3a:	48 8b 80 a0 00 00 00 	mov    0xa0(%rax),%rax
ffffffff80106b41:	48 2d 80 00 00 00    	sub    $0x80,%rax
ffffffff80106b47:	48 3b 45 f0          	cmp    -0x10(%rbp),%rax
ffffffff80106b4b:	0f 87 21 00 00 00    	ja     ffffffff80106b72 <trap+0x2c2>
ffffffff80106b51:	b8 00 00 00 80       	mov    $0x80000000,%eax
ffffffff80106b56:	89 c1                	mov    %eax,%ecx
ffffffff80106b58:	48 39 4d f0          	cmp    %rcx,-0x10(%rbp)
ffffffff80106b5c:	0f 83 10 00 00 00    	jae    ffffffff80106b72 <trap+0x2c2>
        // CASE: Need to expand stack
        // A valid stack reference is between 2G and rsp less the x86 "red zone."
        growstack();
ffffffff80106b62:	31 c0                	xor    %eax,%eax
ffffffff80106b64:	88 c1                	mov    %al,%cl
ffffffff80106b66:	88 c8                	mov    %cl,%al
ffffffff80106b68:	e8 03 eb ff ff       	callq  ffffffff80105670 <growstack>
        return;
ffffffff80106b6d:	e9 47 01 00 00       	jmpq   ffffffff80106cb9 <trap+0x409>
      }
    }
ffffffff80106b72:	e9 00 00 00 00       	jmpq   ffffffff80106b77 <trap+0x2c7>

    // Assume process misbehaved.
    cprintf("pid %d %s: trap %d err %d on cpu %d "
            "rip 0x%lx addr 0x%x--kill proc\n",
            myproc()->pid, myproc()->name, tf->trapno, tf->err, cpunum(), tf->rip,
ffffffff80106b77:	e8 54 01 00 00       	callq  ffffffff80106cd0 <myproc>
ffffffff80106b7c:	8b b0 04 01 00 00    	mov    0x104(%rax),%esi
ffffffff80106b82:	89 75 b0             	mov    %esi,-0x50(%rbp)
ffffffff80106b85:	e8 46 01 00 00       	callq  ffffffff80106cd0 <myproc>
ffffffff80106b8a:	48 05 2c 01 00 00    	add    $0x12c,%rax
ffffffff80106b90:	48 8b 4d f8          	mov    -0x8(%rbp),%rcx
ffffffff80106b94:	48 8b 49 78          	mov    0x78(%rcx),%rcx
ffffffff80106b98:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
ffffffff80106b9c:	4c 8b 82 80 00 00 00 	mov    0x80(%rdx),%r8
ffffffff80106ba3:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
ffffffff80106ba7:	48 89 4d a0          	mov    %rcx,-0x60(%rbp)
ffffffff80106bab:	4c 89 45 98          	mov    %r8,-0x68(%rbp)
ffffffff80106baf:	e8 ec ae ff ff       	callq  ffffffff80101aa0 <cpunum>
ffffffff80106bb4:	48 8b 4d f8          	mov    -0x8(%rbp),%rcx
ffffffff80106bb8:	48 8b 89 88 00 00 00 	mov    0x88(%rcx),%rcx
            addr);
ffffffff80106bbf:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
    cprintf("pid %d %s: trap %d err %d on cpu %d "
ffffffff80106bc3:	49 89 e0             	mov    %rsp,%r8
ffffffff80106bc6:	49 89 50 08          	mov    %rdx,0x8(%r8)
ffffffff80106bca:	49 89 08             	mov    %rcx,(%r8)
ffffffff80106bcd:	48 c7 c7 68 00 11 80 	mov    $0xffffffff80110068,%rdi
ffffffff80106bd4:	31 f6                	xor    %esi,%esi
ffffffff80106bd6:	41 88 f1             	mov    %sil,%r9b
ffffffff80106bd9:	8b 75 b0             	mov    -0x50(%rbp),%esi
ffffffff80106bdc:	48 8b 55 a8          	mov    -0x58(%rbp),%rdx
ffffffff80106be0:	48 8b 4d a0          	mov    -0x60(%rbp),%rcx
ffffffff80106be4:	4c 8b 45 98          	mov    -0x68(%rbp),%r8
ffffffff80106be8:	44 88 4d 97          	mov    %r9b,-0x69(%rbp)
ffffffff80106bec:	41 89 c1             	mov    %eax,%r9d
ffffffff80106bef:	8a 45 97             	mov    -0x69(%rbp),%al
ffffffff80106bf2:	e8 69 9d ff ff       	callq  ffffffff80100960 <cprintf>
    myproc()->killed = 1;
ffffffff80106bf7:	e8 d4 00 00 00       	callq  ffffffff80106cd0 <myproc>
ffffffff80106bfc:	c7 80 28 01 00 00 01 	movl   $0x1,0x128(%rax)
ffffffff80106c03:	00 00 00 
  }

  // Force process exit if it has been killed and is in user space.
  // (If it is still executing in the kernel, let it keep running
  // until it gets to the regular system call return.)
  if(myproc() && myproc()->killed && (tf->cs&3) == DPL_USER)
ffffffff80106c06:	e8 c5 00 00 00       	callq  ffffffff80106cd0 <myproc>
ffffffff80106c0b:	48 83 f8 00          	cmp    $0x0,%rax
ffffffff80106c0f:	0f 84 30 00 00 00    	je     ffffffff80106c45 <trap+0x395>
ffffffff80106c15:	e8 b6 00 00 00       	callq  ffffffff80106cd0 <myproc>
ffffffff80106c1a:	83 b8 28 01 00 00 00 	cmpl   $0x0,0x128(%rax)
ffffffff80106c21:	0f 84 1e 00 00 00    	je     ffffffff80106c45 <trap+0x395>
ffffffff80106c27:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
ffffffff80106c2b:	48 8b 80 90 00 00 00 	mov    0x90(%rax),%rax
ffffffff80106c32:	48 83 e0 03          	and    $0x3,%rax
ffffffff80106c36:	48 83 f8 03          	cmp    $0x3,%rax
ffffffff80106c3a:	0f 85 05 00 00 00    	jne    ffffffff80106c45 <trap+0x395>
    exit();
ffffffff80106c40:	e8 0b 13 00 00       	callq  ffffffff80107f50 <exit>

  // Force process to give up CPU on clock tick.
  // If interrupts were on while locks held, would need to check nlock.
  if(myproc() && myproc()->state == RUNNING && tf->trapno == TRAP_IRQ0+IRQ_TIMER)
ffffffff80106c45:	e8 86 00 00 00       	callq  ffffffff80106cd0 <myproc>
ffffffff80106c4a:	48 83 f8 00          	cmp    $0x0,%rax
ffffffff80106c4e:	0f 84 26 00 00 00    	je     ffffffff80106c7a <trap+0x3ca>
ffffffff80106c54:	e8 77 00 00 00       	callq  ffffffff80106cd0 <myproc>
ffffffff80106c59:	83 b8 00 01 00 00 04 	cmpl   $0x4,0x100(%rax)
ffffffff80106c60:	0f 85 14 00 00 00    	jne    ffffffff80106c7a <trap+0x3ca>
ffffffff80106c66:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
ffffffff80106c6a:	48 83 78 78 20       	cmpq   $0x20,0x78(%rax)
ffffffff80106c6f:	0f 85 05 00 00 00    	jne    ffffffff80106c7a <trap+0x3ca>
    yield();
ffffffff80106c75:	e8 b6 19 00 00       	callq  ffffffff80108630 <yield>

  // Check if the process has been killed since we yielded
  if(myproc() && myproc()->killed && (tf->cs&3) == DPL_USER)
ffffffff80106c7a:	e8 51 00 00 00       	callq  ffffffff80106cd0 <myproc>
ffffffff80106c7f:	48 83 f8 00          	cmp    $0x0,%rax
ffffffff80106c83:	0f 84 30 00 00 00    	je     ffffffff80106cb9 <trap+0x409>
ffffffff80106c89:	e8 42 00 00 00       	callq  ffffffff80106cd0 <myproc>
ffffffff80106c8e:	83 b8 28 01 00 00 00 	cmpl   $0x0,0x128(%rax)
ffffffff80106c95:	0f 84 1e 00 00 00    	je     ffffffff80106cb9 <trap+0x409>
ffffffff80106c9b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
ffffffff80106c9f:	48 8b 80 90 00 00 00 	mov    0x90(%rax),%rax
ffffffff80106ca6:	48 83 e0 03          	and    $0x3,%rax
ffffffff80106caa:	48 83 f8 03          	cmp    $0x3,%rax
ffffffff80106cae:	0f 85 05 00 00 00    	jne    ffffffff80106cb9 <trap+0x409>
    exit();
ffffffff80106cb4:	e8 97 12 00 00       	callq  ffffffff80107f50 <exit>
}
ffffffff80106cb9:	48 81 c4 80 00 00 00 	add    $0x80,%rsp
ffffffff80106cc0:	5d                   	pop    %rbp
ffffffff80106cc1:	c3                   	retq   
ffffffff80106cc2:	66 66 66 66 66 2e 0f 	data16 data16 data16 data16 nopw %cs:0x0(%rax,%rax,1)
ffffffff80106cc9:	1f 84 00 00 00 00 00 

ffffffff80106cd0 <myproc>:
{
ffffffff80106cd0:	55                   	push   %rbp
ffffffff80106cd1:	48 89 e5             	mov    %rsp,%rbp
  return mycpu()->proc;
ffffffff80106cd4:	e8 37 00 00 00       	callq  ffffffff80106d10 <mycpu>
ffffffff80106cd9:	48 8b 80 d0 00 00 00 	mov    0xd0(%rax),%rax
ffffffff80106ce0:	5d                   	pop    %rbp
ffffffff80106ce1:	c3                   	retq   
ffffffff80106ce2:	66 66 66 66 66 2e 0f 	data16 data16 data16 data16 nopw %cs:0x0(%rax,%rax,1)
ffffffff80106ce9:	1f 84 00 00 00 00 00 

ffffffff80106cf0 <rcr2>:
{
ffffffff80106cf0:	55                   	push   %rbp
ffffffff80106cf1:	48 89 e5             	mov    %rsp,%rbp
  asm volatile("mov %%cr2,%0" : "=r" (val));
ffffffff80106cf4:	50                   	push   %rax
ffffffff80106cf5:	0f 20 d0             	mov    %cr2,%rax
ffffffff80106cf8:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  return val;
ffffffff80106cfc:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
ffffffff80106d00:	48 83 c4 08          	add    $0x8,%rsp
ffffffff80106d04:	5d                   	pop    %rbp
ffffffff80106d05:	c3                   	retq   
ffffffff80106d06:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
ffffffff80106d0d:	00 00 00 

ffffffff80106d10 <mycpu>:
{
ffffffff80106d10:	55                   	push   %rbp
ffffffff80106d11:	48 89 e5             	mov    %rsp,%rbp
  return &cpus[0];
ffffffff80106d14:	48 c7 c0 e0 7b 1f 83 	mov    $0xffffffff831f7be0,%rax
ffffffff80106d1b:	5d                   	pop    %rbp
ffffffff80106d1c:	c3                   	retq   
ffffffff80106d1d:	0f 1f 00             	nopl   (%rax)

ffffffff80106d20 <mpinit>:
  return conf;
}

void
mpinit(void)
{
ffffffff80106d20:	55                   	push   %rbp
ffffffff80106d21:	48 89 e5             	mov    %rsp,%rbp
ffffffff80106d24:	48 83 ec 60          	sub    $0x60,%rsp
ffffffff80106d28:	48 8d 45 e8          	lea    -0x18(%rbp),%rax
ffffffff80106d2c:	48 8d 7d e8          	lea    -0x18(%rbp),%rdi
  struct mp *mp;
  struct mpconf *conf;
  struct mpproc *proc;
  struct mpioapic *ioapic;

  if((conf = mpconfig(&mp)) == 0)
ffffffff80106d30:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
ffffffff80106d34:	e8 d7 01 00 00       	callq  ffffffff80106f10 <mpconfig>
ffffffff80106d39:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
ffffffff80106d3d:	48 83 f8 00          	cmp    $0x0,%rax
ffffffff80106d41:	0f 85 05 00 00 00    	jne    ffffffff80106d4c <mpinit+0x2c>
    return;
ffffffff80106d47:	e9 b3 01 00 00       	jmpq   ffffffff80106eff <mpinit+0x1df>
  ismp = 1;
ffffffff80106d4c:	c7 04 25 d4 7b 1f 83 	movl   $0x1,0xffffffff831f7bd4
ffffffff80106d53:	01 00 00 00 
  lapic = IO2V((uint64_t)conf->lapicaddr);
ffffffff80106d57:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
ffffffff80106d5b:	8b 48 24             	mov    0x24(%rax),%ecx
ffffffff80106d5e:	89 c8                	mov    %ecx,%eax
ffffffff80106d60:	48 ba 00 00 00 00 ff 	movabs $0xffffffff00000000,%rdx
ffffffff80106d67:	ff ff ff 
ffffffff80106d6a:	48 09 d0             	or     %rdx,%rax
ffffffff80106d6d:	48 89 04 25 38 66 1f 	mov    %rax,0xffffffff831f6638
ffffffff80106d74:	83 
  for(p=(uchar*)(conf+1), e=(uchar*)conf+conf->length; p<e; ){
ffffffff80106d75:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
ffffffff80106d79:	48 83 c0 2c          	add    $0x2c,%rax
ffffffff80106d7d:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
ffffffff80106d81:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
ffffffff80106d85:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
ffffffff80106d89:	0f b7 4a 04          	movzwl 0x4(%rdx),%ecx
ffffffff80106d8d:	48 63 d1             	movslq %ecx,%rdx
ffffffff80106d90:	48 01 d0             	add    %rdx,%rax
ffffffff80106d93:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
ffffffff80106d97:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
ffffffff80106d9b:	48 3b 45 f0          	cmp    -0x10(%rbp),%rax
ffffffff80106d9f:	0f 83 c9 00 00 00    	jae    ffffffff80106e6e <mpinit+0x14e>
    switch(*p){
ffffffff80106da5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
ffffffff80106da9:	0f b6 08             	movzbl (%rax),%ecx
ffffffff80106dac:	89 c8                	mov    %ecx,%eax
ffffffff80106dae:	48 89 c2             	mov    %rax,%rdx
ffffffff80106db1:	48 83 ea 04          	sub    $0x4,%rdx
ffffffff80106db5:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
ffffffff80106db9:	48 89 55 b8          	mov    %rdx,-0x48(%rbp)
ffffffff80106dbd:	0f 87 9b 00 00 00    	ja     ffffffff80106e5e <mpinit+0x13e>
ffffffff80106dc3:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
ffffffff80106dc7:	48 8b 0c c5 b0 00 11 	mov    -0x7feeff50(,%rax,8),%rcx
ffffffff80106dce:	80 
ffffffff80106dcf:	ff e1                	jmpq   *%rcx
    case MPPROC:
      proc = (struct mpproc*)p;
ffffffff80106dd1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
ffffffff80106dd5:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
      if(ncpu < NCPU) {
ffffffff80106dd9:	8b 0c 25 a0 82 1f 83 	mov    0xffffffff831f82a0,%ecx
ffffffff80106de0:	83 f9 08             	cmp    $0x8,%ecx
ffffffff80106de3:	0f 8d 2c 00 00 00    	jge    ffffffff80106e15 <mpinit+0xf5>
        cpus[ncpu].apicid = proc->apicid;  // apicid may differ from ncpu
ffffffff80106de9:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
ffffffff80106ded:	8a 48 01             	mov    0x1(%rax),%cl
ffffffff80106df0:	48 63 04 25 a0 82 1f 	movslq 0xffffffff831f82a0,%rax
ffffffff80106df7:	83 
ffffffff80106df8:	48 69 c0 d8 00 00 00 	imul   $0xd8,%rax,%rax
ffffffff80106dff:	88 88 e0 7b 1f 83    	mov    %cl,-0x7ce08420(%rax)
        ncpu++;
ffffffff80106e05:	8b 14 25 a0 82 1f 83 	mov    0xffffffff831f82a0,%edx
ffffffff80106e0c:	ff c2                	inc    %edx
ffffffff80106e0e:	89 14 25 a0 82 1f 83 	mov    %edx,0xffffffff831f82a0
      }
      p += sizeof(struct mpproc);
ffffffff80106e15:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
ffffffff80106e19:	48 83 c0 14          	add    $0x14,%rax
ffffffff80106e1d:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
      continue;
ffffffff80106e21:	e9 71 ff ff ff       	jmpq   ffffffff80106d97 <mpinit+0x77>
    case MPIOAPIC:
      ioapic = (struct mpioapic*)p;
ffffffff80106e26:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
ffffffff80106e2a:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
      ioapicid = ioapic->apicno;
ffffffff80106e2e:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
ffffffff80106e32:	8a 48 01             	mov    0x1(%rax),%cl
ffffffff80106e35:	88 0c 25 d0 7b 1f 83 	mov    %cl,0xffffffff831f7bd0
      p += sizeof(struct mpioapic);
ffffffff80106e3c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
ffffffff80106e40:	48 83 c0 08          	add    $0x8,%rax
ffffffff80106e44:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
      continue;
ffffffff80106e48:	e9 4a ff ff ff       	jmpq   ffffffff80106d97 <mpinit+0x77>
    case MPBUS:
    case MPIOINTR:
    case MPLINTR:
      p += 8;
ffffffff80106e4d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
ffffffff80106e51:	48 83 c0 08          	add    $0x8,%rax
ffffffff80106e55:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
      continue;
ffffffff80106e59:	e9 39 ff ff ff       	jmpq   ffffffff80106d97 <mpinit+0x77>
    default:
      ismp = 0;
ffffffff80106e5e:	c7 04 25 d4 7b 1f 83 	movl   $0x0,0xffffffff831f7bd4
ffffffff80106e65:	00 00 00 00 
  for(p=(uchar*)(conf+1), e=(uchar*)conf+conf->length; p<e; ){
ffffffff80106e69:	e9 29 ff ff ff       	jmpq   ffffffff80106d97 <mpinit+0x77>
      break;
    }
  }
  if(!ismp){
ffffffff80106e6e:	8b 04 25 d4 7b 1f 83 	mov    0xffffffff831f7bd4,%eax
ffffffff80106e75:	83 f8 00             	cmp    $0x0,%eax
ffffffff80106e78:	0f 85 24 00 00 00    	jne    ffffffff80106ea2 <mpinit+0x182>
    // Didn't like what we found; fall back to no MP.
    ncpu = 1;
ffffffff80106e7e:	c7 04 25 a0 82 1f 83 	movl   $0x1,0xffffffff831f82a0
ffffffff80106e85:	01 00 00 00 
    lapic = 0;
ffffffff80106e89:	48 c7 04 25 38 66 1f 	movq   $0x0,0xffffffff831f6638
ffffffff80106e90:	83 00 00 00 00 
    ioapicid = 0;
ffffffff80106e95:	c6 04 25 d0 7b 1f 83 	movb   $0x0,0xffffffff831f7bd0
ffffffff80106e9c:	00 
    return;
ffffffff80106e9d:	e9 5d 00 00 00       	jmpq   ffffffff80106eff <mpinit+0x1df>
  }

  if(mp->imcrp){
ffffffff80106ea2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
ffffffff80106ea6:	80 78 0c 00          	cmpb   $0x0,0xc(%rax)
ffffffff80106eaa:	0f 84 4f 00 00 00    	je     ffffffff80106eff <mpinit+0x1df>
ffffffff80106eb0:	b8 22 00 00 00       	mov    $0x22,%eax
ffffffff80106eb5:	b9 70 00 00 00       	mov    $0x70,%ecx
    // Bochs doesn't support IMCR, so this doesn't run on Bochs.
    // But it would on real hardware.
    outb(0x22, 0x70);   // Select IMCR
ffffffff80106eba:	bf 22 00 00 00       	mov    $0x22,%edi
ffffffff80106ebf:	be 70 00 00 00       	mov    $0x70,%esi
ffffffff80106ec4:	89 45 b4             	mov    %eax,-0x4c(%rbp)
ffffffff80106ec7:	89 4d b0             	mov    %ecx,-0x50(%rbp)
ffffffff80106eca:	e8 41 01 00 00       	callq  ffffffff80107010 <outb>
ffffffff80106ecf:	b8 23 00 00 00       	mov    $0x23,%eax
    outb(0x23, inb(0x23) | 1);  // Mask external interrupts.
ffffffff80106ed4:	bf 23 00 00 00       	mov    $0x23,%edi
ffffffff80106ed9:	89 45 ac             	mov    %eax,-0x54(%rbp)
ffffffff80106edc:	e8 5f 01 00 00       	callq  ffffffff80107040 <inb>
ffffffff80106ee1:	b9 23 00 00 00       	mov    $0x23,%ecx
ffffffff80106ee6:	0f b6 f0             	movzbl %al,%esi
ffffffff80106ee9:	83 ce 01             	or     $0x1,%esi
ffffffff80106eec:	40 88 f0             	mov    %sil,%al
ffffffff80106eef:	0f b6 f0             	movzbl %al,%esi
ffffffff80106ef2:	bf 23 00 00 00       	mov    $0x23,%edi
ffffffff80106ef7:	89 4d a8             	mov    %ecx,-0x58(%rbp)
ffffffff80106efa:	e8 11 01 00 00       	callq  ffffffff80107010 <outb>
  }
}
ffffffff80106eff:	48 83 c4 60          	add    $0x60,%rsp
ffffffff80106f03:	5d                   	pop    %rbp
ffffffff80106f04:	c3                   	retq   
ffffffff80106f05:	66 66 2e 0f 1f 84 00 	data16 nopw %cs:0x0(%rax,%rax,1)
ffffffff80106f0c:	00 00 00 00 

ffffffff80106f10 <mpconfig>:
{
ffffffff80106f10:	55                   	push   %rbp
ffffffff80106f11:	48 89 e5             	mov    %rsp,%rbp
ffffffff80106f14:	48 83 ec 20          	sub    $0x20,%rsp
ffffffff80106f18:	48 89 7d f0          	mov    %rdi,-0x10(%rbp)
  if((mp = mpsearch()) == 0 || mp->physaddr == 0)
ffffffff80106f1c:	e8 4f 01 00 00       	callq  ffffffff80107070 <mpsearch>
ffffffff80106f21:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
ffffffff80106f25:	48 83 f8 00          	cmp    $0x0,%rax
ffffffff80106f29:	0f 84 0e 00 00 00    	je     ffffffff80106f3d <mpconfig+0x2d>
ffffffff80106f2f:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
ffffffff80106f33:	83 78 04 00          	cmpl   $0x0,0x4(%rax)
ffffffff80106f37:	0f 85 0d 00 00 00    	jne    ffffffff80106f4a <mpconfig+0x3a>
    return 0;
ffffffff80106f3d:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
ffffffff80106f44:	00 
ffffffff80106f45:	e9 b0 00 00 00       	jmpq   ffffffff80106ffa <mpconfig+0xea>
  conf = (struct mpconf*) P2V((uint64_t) mp->physaddr);
ffffffff80106f4a:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
ffffffff80106f4e:	8b 48 04             	mov    0x4(%rax),%ecx
ffffffff80106f51:	89 c8                	mov    %ecx,%eax
ffffffff80106f53:	48 05 00 00 00 80    	add    $0xffffffff80000000,%rax
ffffffff80106f59:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  if(memcmp(conf, "PCMP", 4) != 0)
ffffffff80106f5d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
ffffffff80106f61:	48 c7 c6 d8 00 11 80 	mov    $0xffffffff801100d8,%rsi
ffffffff80106f68:	ba 04 00 00 00       	mov    $0x4,%edx
ffffffff80106f6d:	48 89 c7             	mov    %rax,%rdi
ffffffff80106f70:	e8 7b 40 00 00       	callq  ffffffff8010aff0 <memcmp>
ffffffff80106f75:	83 f8 00             	cmp    $0x0,%eax
ffffffff80106f78:	0f 84 0d 00 00 00    	je     ffffffff80106f8b <mpconfig+0x7b>
    return 0;
ffffffff80106f7e:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
ffffffff80106f85:	00 
ffffffff80106f86:	e9 6f 00 00 00       	jmpq   ffffffff80106ffa <mpconfig+0xea>
  if(conf->version != 1 && conf->version != 4)
ffffffff80106f8b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
ffffffff80106f8f:	0f b6 48 06          	movzbl 0x6(%rax),%ecx
ffffffff80106f93:	83 f9 01             	cmp    $0x1,%ecx
ffffffff80106f96:	0f 84 1e 00 00 00    	je     ffffffff80106fba <mpconfig+0xaa>
ffffffff80106f9c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
ffffffff80106fa0:	0f b6 48 06          	movzbl 0x6(%rax),%ecx
ffffffff80106fa4:	83 f9 04             	cmp    $0x4,%ecx
ffffffff80106fa7:	0f 84 0d 00 00 00    	je     ffffffff80106fba <mpconfig+0xaa>
    return 0;
ffffffff80106fad:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
ffffffff80106fb4:	00 
ffffffff80106fb5:	e9 40 00 00 00       	jmpq   ffffffff80106ffa <mpconfig+0xea>
  if(sum((uchar*)conf, conf->length) != 0)
ffffffff80106fba:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
ffffffff80106fbe:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
ffffffff80106fc2:	0f b7 71 04          	movzwl 0x4(%rcx),%esi
ffffffff80106fc6:	48 89 c7             	mov    %rax,%rdi
ffffffff80106fc9:	e8 b2 01 00 00       	callq  ffffffff80107180 <sum>
ffffffff80106fce:	0f b6 f0             	movzbl %al,%esi
ffffffff80106fd1:	83 fe 00             	cmp    $0x0,%esi
ffffffff80106fd4:	0f 84 0d 00 00 00    	je     ffffffff80106fe7 <mpconfig+0xd7>
    return 0;
ffffffff80106fda:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
ffffffff80106fe1:	00 
ffffffff80106fe2:	e9 13 00 00 00       	jmpq   ffffffff80106ffa <mpconfig+0xea>
  *pmp = mp;
ffffffff80106fe7:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
ffffffff80106feb:	48 8b 4d f0          	mov    -0x10(%rbp),%rcx
ffffffff80106fef:	48 89 01             	mov    %rax,(%rcx)
  return conf;
ffffffff80106ff2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
ffffffff80106ff6:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
}
ffffffff80106ffa:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
ffffffff80106ffe:	48 83 c4 20          	add    $0x20,%rsp
ffffffff80107002:	5d                   	pop    %rbp
ffffffff80107003:	c3                   	retq   
ffffffff80107004:	66 66 66 2e 0f 1f 84 	data16 data16 nopw %cs:0x0(%rax,%rax,1)
ffffffff8010700b:	00 00 00 00 00 

ffffffff80107010 <outb>:
{
ffffffff80107010:	55                   	push   %rbp
ffffffff80107011:	48 89 e5             	mov    %rsp,%rbp
ffffffff80107014:	48 83 ec 04          	sub    $0x4,%rsp
ffffffff80107018:	40 88 f0             	mov    %sil,%al
ffffffff8010701b:	66 89 f9             	mov    %di,%cx
ffffffff8010701e:	66 89 4d fe          	mov    %cx,-0x2(%rbp)
ffffffff80107022:	88 45 fd             	mov    %al,-0x3(%rbp)
  asm volatile("out %0,%1" : : "a" (data), "d" (port));
ffffffff80107025:	8a 45 fd             	mov    -0x3(%rbp),%al
ffffffff80107028:	66 8b 55 fe          	mov    -0x2(%rbp),%dx
ffffffff8010702c:	ee                   	out    %al,(%dx)
}
ffffffff8010702d:	48 83 c4 04          	add    $0x4,%rsp
ffffffff80107031:	5d                   	pop    %rbp
ffffffff80107032:	c3                   	retq   
ffffffff80107033:	66 66 66 66 2e 0f 1f 	data16 data16 data16 nopw %cs:0x0(%rax,%rax,1)
ffffffff8010703a:	84 00 00 00 00 00 

ffffffff80107040 <inb>:
{
ffffffff80107040:	55                   	push   %rbp
ffffffff80107041:	48 89 e5             	mov    %rsp,%rbp
ffffffff80107044:	48 83 ec 04          	sub    $0x4,%rsp
ffffffff80107048:	66 89 f8             	mov    %di,%ax
ffffffff8010704b:	66 89 45 fe          	mov    %ax,-0x2(%rbp)
  asm volatile("in %1,%0" : "=a" (data) : "d" (port));
ffffffff8010704f:	66 8b 55 fe          	mov    -0x2(%rbp),%dx
ffffffff80107053:	ec                   	in     (%dx),%al
ffffffff80107054:	88 45 fd             	mov    %al,-0x3(%rbp)
  return data;
ffffffff80107057:	0f b6 45 fd          	movzbl -0x3(%rbp),%eax
ffffffff8010705b:	48 83 c4 04          	add    $0x4,%rsp
ffffffff8010705f:	5d                   	pop    %rbp
ffffffff80107060:	c3                   	retq   
ffffffff80107061:	66 66 66 66 66 66 2e 	data16 data16 data16 data16 data16 nopw %cs:0x0(%rax,%rax,1)
ffffffff80107068:	0f 1f 84 00 00 00 00 
ffffffff8010706f:	00 

ffffffff80107070 <mpsearch>:
{
ffffffff80107070:	55                   	push   %rbp
ffffffff80107071:	48 89 e5             	mov    %rsp,%rbp
ffffffff80107074:	48 83 ec 40          	sub    $0x40,%rsp
ffffffff80107078:	b8 00 04 00 00       	mov    $0x400,%eax
ffffffff8010707d:	89 c1                	mov    %eax,%ecx
ffffffff8010707f:	48 81 c1 00 00 00 80 	add    $0xffffffff80000000,%rcx
  bda = (uchar *) P2V(0x400);
ffffffff80107086:	48 89 4d f0          	mov    %rcx,-0x10(%rbp)
  if((p = ((bda[0x0F]<<8)| bda[0x0E]) << 4)){
ffffffff8010708a:	48 8b 4d f0          	mov    -0x10(%rbp),%rcx
ffffffff8010708e:	0f b6 41 0f          	movzbl 0xf(%rcx),%eax
ffffffff80107092:	c1 e0 08             	shl    $0x8,%eax
ffffffff80107095:	48 8b 4d f0          	mov    -0x10(%rbp),%rcx
ffffffff80107099:	0f b6 51 0e          	movzbl 0xe(%rcx),%edx
ffffffff8010709d:	09 d0                	or     %edx,%eax
ffffffff8010709f:	c1 e0 04             	shl    $0x4,%eax
ffffffff801070a2:	89 45 ec             	mov    %eax,-0x14(%rbp)
ffffffff801070a5:	83 f8 00             	cmp    $0x0,%eax
ffffffff801070a8:	0f 84 37 00 00 00    	je     ffffffff801070e5 <mpsearch+0x75>
ffffffff801070ae:	b8 00 04 00 00       	mov    $0x400,%eax
    if((mp = mpsearch1(p, 1024)))
ffffffff801070b3:	8b 4d ec             	mov    -0x14(%rbp),%ecx
ffffffff801070b6:	89 cf                	mov    %ecx,%edi
ffffffff801070b8:	be 00 04 00 00       	mov    $0x400,%esi
ffffffff801070bd:	89 45 dc             	mov    %eax,-0x24(%rbp)
ffffffff801070c0:	e8 1b 01 00 00       	callq  ffffffff801071e0 <mpsearch1>
ffffffff801070c5:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
ffffffff801070c9:	48 83 f8 00          	cmp    $0x0,%rax
ffffffff801070cd:	0f 84 0d 00 00 00    	je     ffffffff801070e0 <mpsearch+0x70>
      return mp;
ffffffff801070d3:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
ffffffff801070d7:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
ffffffff801070db:	e9 87 00 00 00       	jmpq   ffffffff80107167 <mpsearch+0xf7>
  } else {
ffffffff801070e0:	e9 5a 00 00 00       	jmpq   ffffffff8010713f <mpsearch+0xcf>
ffffffff801070e5:	b8 00 04 00 00       	mov    $0x400,%eax
    p = ((bda[0x14]<<8)|bda[0x13])*1024;
ffffffff801070ea:	48 8b 4d f0          	mov    -0x10(%rbp),%rcx
ffffffff801070ee:	0f b6 51 14          	movzbl 0x14(%rcx),%edx
ffffffff801070f2:	c1 e2 08             	shl    $0x8,%edx
ffffffff801070f5:	48 8b 4d f0          	mov    -0x10(%rbp),%rcx
ffffffff801070f9:	0f b6 71 13          	movzbl 0x13(%rcx),%esi
ffffffff801070fd:	09 f2                	or     %esi,%edx
ffffffff801070ff:	c1 e2 0a             	shl    $0xa,%edx
ffffffff80107102:	89 55 ec             	mov    %edx,-0x14(%rbp)
    if((mp = mpsearch1(p-1024, 1024)))
ffffffff80107105:	8b 55 ec             	mov    -0x14(%rbp),%edx
ffffffff80107108:	81 ea 00 04 00 00    	sub    $0x400,%edx
ffffffff8010710e:	89 d2                	mov    %edx,%edx
ffffffff80107110:	89 d7                	mov    %edx,%edi
ffffffff80107112:	be 00 04 00 00       	mov    $0x400,%esi
ffffffff80107117:	89 45 d8             	mov    %eax,-0x28(%rbp)
ffffffff8010711a:	e8 c1 00 00 00       	callq  ffffffff801071e0 <mpsearch1>
ffffffff8010711f:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
ffffffff80107123:	48 83 f8 00          	cmp    $0x0,%rax
ffffffff80107127:	0f 84 0d 00 00 00    	je     ffffffff8010713a <mpsearch+0xca>
      return mp;
ffffffff8010712d:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
ffffffff80107131:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
ffffffff80107135:	e9 2d 00 00 00       	jmpq   ffffffff80107167 <mpsearch+0xf7>
ffffffff8010713a:	e9 00 00 00 00       	jmpq   ffffffff8010713f <mpsearch+0xcf>
ffffffff8010713f:	b8 00 00 0f 00       	mov    $0xf0000,%eax
ffffffff80107144:	89 c1                	mov    %eax,%ecx
ffffffff80107146:	b8 00 00 01 00       	mov    $0x10000,%eax
  return mpsearch1(0xF0000, 0x10000);
ffffffff8010714b:	ba 00 00 0f 00       	mov    $0xf0000,%edx
ffffffff80107150:	89 d7                	mov    %edx,%edi
ffffffff80107152:	be 00 00 01 00       	mov    $0x10000,%esi
ffffffff80107157:	48 89 4d d0          	mov    %rcx,-0x30(%rbp)
ffffffff8010715b:	89 45 cc             	mov    %eax,-0x34(%rbp)
ffffffff8010715e:	e8 7d 00 00 00       	callq  ffffffff801071e0 <mpsearch1>
ffffffff80107163:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
}
ffffffff80107167:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
ffffffff8010716b:	48 83 c4 40          	add    $0x40,%rsp
ffffffff8010716f:	5d                   	pop    %rbp
ffffffff80107170:	c3                   	retq   
ffffffff80107171:	66 66 66 66 66 66 2e 	data16 data16 data16 data16 data16 nopw %cs:0x0(%rax,%rax,1)
ffffffff80107178:	0f 1f 84 00 00 00 00 
ffffffff8010717f:	00 

ffffffff80107180 <sum>:
{
ffffffff80107180:	55                   	push   %rbp
ffffffff80107181:	48 89 e5             	mov    %rsp,%rbp
ffffffff80107184:	48 83 ec 18          	sub    $0x18,%rsp
ffffffff80107188:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
ffffffff8010718c:	89 75 f4             	mov    %esi,-0xc(%rbp)
  sum = 0;
ffffffff8010718f:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%rbp)
  for(i=0; i<len; i++)
ffffffff80107196:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%rbp)
ffffffff8010719d:	8b 45 f0             	mov    -0x10(%rbp),%eax
ffffffff801071a0:	3b 45 f4             	cmp    -0xc(%rbp),%eax
ffffffff801071a3:	0f 8d 20 00 00 00    	jge    ffffffff801071c9 <sum+0x49>
    sum += addr[i];
ffffffff801071a9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
ffffffff801071ad:	48 63 4d f0          	movslq -0x10(%rbp),%rcx
ffffffff801071b1:	0f b6 14 08          	movzbl (%rax,%rcx,1),%edx
ffffffff801071b5:	03 55 ec             	add    -0x14(%rbp),%edx
ffffffff801071b8:	89 55 ec             	mov    %edx,-0x14(%rbp)
  for(i=0; i<len; i++)
ffffffff801071bb:	8b 45 f0             	mov    -0x10(%rbp),%eax
ffffffff801071be:	83 c0 01             	add    $0x1,%eax
ffffffff801071c1:	89 45 f0             	mov    %eax,-0x10(%rbp)
ffffffff801071c4:	e9 d4 ff ff ff       	jmpq   ffffffff8010719d <sum+0x1d>
  return sum;
ffffffff801071c9:	8b 45 ec             	mov    -0x14(%rbp),%eax
ffffffff801071cc:	88 c1                	mov    %al,%cl
ffffffff801071ce:	0f b6 c1             	movzbl %cl,%eax
ffffffff801071d1:	48 83 c4 18          	add    $0x18,%rsp
ffffffff801071d5:	5d                   	pop    %rbp
ffffffff801071d6:	c3                   	retq   
ffffffff801071d7:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
ffffffff801071de:	00 00 

ffffffff801071e0 <mpsearch1>:
{
ffffffff801071e0:	55                   	push   %rbp
ffffffff801071e1:	48 89 e5             	mov    %rsp,%rbp
ffffffff801071e4:	48 83 ec 40          	sub    $0x40,%rsp
ffffffff801071e8:	48 89 7d f0          	mov    %rdi,-0x10(%rbp)
ffffffff801071ec:	89 75 ec             	mov    %esi,-0x14(%rbp)
  addr = P2V(a);
ffffffff801071ef:	48 8b 7d f0          	mov    -0x10(%rbp),%rdi
ffffffff801071f3:	48 81 c7 00 00 00 80 	add    $0xffffffff80000000,%rdi
ffffffff801071fa:	48 89 7d d0          	mov    %rdi,-0x30(%rbp)
  e = addr+len;
ffffffff801071fe:	48 8b 7d d0          	mov    -0x30(%rbp),%rdi
ffffffff80107202:	48 63 45 ec          	movslq -0x14(%rbp),%rax
ffffffff80107206:	48 01 c7             	add    %rax,%rdi
ffffffff80107209:	48 89 7d e0          	mov    %rdi,-0x20(%rbp)
  for(p = addr; p < e; p += sizeof(struct mp))
ffffffff8010720d:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
ffffffff80107211:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
ffffffff80107215:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
ffffffff80107219:	48 3b 45 e0          	cmp    -0x20(%rbp),%rax
ffffffff8010721d:	0f 83 63 00 00 00    	jae    ffffffff80107286 <mpsearch1+0xa6>
    if(memcmp(p, "_MP_", 4) == 0 && sum(p, sizeof(struct mp)) == 0)
ffffffff80107223:	48 8b 7d d8          	mov    -0x28(%rbp),%rdi
ffffffff80107227:	48 c7 c6 dd 00 11 80 	mov    $0xffffffff801100dd,%rsi
ffffffff8010722e:	ba 04 00 00 00       	mov    $0x4,%edx
ffffffff80107233:	e8 b8 3d 00 00       	callq  ffffffff8010aff0 <memcmp>
ffffffff80107238:	83 f8 00             	cmp    $0x0,%eax
ffffffff8010723b:	0f 85 2f 00 00 00    	jne    ffffffff80107270 <mpsearch1+0x90>
ffffffff80107241:	b8 10 00 00 00       	mov    $0x10,%eax
ffffffff80107246:	48 8b 7d d8          	mov    -0x28(%rbp),%rdi
ffffffff8010724a:	be 10 00 00 00       	mov    $0x10,%esi
ffffffff8010724f:	89 45 cc             	mov    %eax,-0x34(%rbp)
ffffffff80107252:	e8 29 ff ff ff       	callq  ffffffff80107180 <sum>
ffffffff80107257:	0f b6 f0             	movzbl %al,%esi
ffffffff8010725a:	83 fe 00             	cmp    $0x0,%esi
ffffffff8010725d:	0f 85 0d 00 00 00    	jne    ffffffff80107270 <mpsearch1+0x90>
      return (struct mp*)p;
ffffffff80107263:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
ffffffff80107267:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
ffffffff8010726b:	e9 1e 00 00 00       	jmpq   ffffffff8010728e <mpsearch1+0xae>
    if(memcmp(p, "_MP_", 4) == 0 && sum(p, sizeof(struct mp)) == 0)
ffffffff80107270:	e9 00 00 00 00       	jmpq   ffffffff80107275 <mpsearch1+0x95>
  for(p = addr; p < e; p += sizeof(struct mp))
ffffffff80107275:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
ffffffff80107279:	48 83 c0 10          	add    $0x10,%rax
ffffffff8010727d:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
ffffffff80107281:	e9 8f ff ff ff       	jmpq   ffffffff80107215 <mpsearch1+0x35>
  return 0;
ffffffff80107286:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
ffffffff8010728d:	00 
}
ffffffff8010728e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
ffffffff80107292:	48 83 c4 40          	add    $0x40,%rsp
ffffffff80107296:	5d                   	pop    %rbp
ffffffff80107297:	c3                   	retq   
ffffffff80107298:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
ffffffff8010729f:	00 

ffffffff801072a0 <picenable>:
  outb(IO_PIC2+1, mask >> 8);
}

void
picenable(int irq)
{
ffffffff801072a0:	55                   	push   %rbp
ffffffff801072a1:	48 89 e5             	mov    %rsp,%rbp
ffffffff801072a4:	48 83 ec 10          	sub    $0x10,%rsp
ffffffff801072a8:	b8 01 00 00 00       	mov    $0x1,%eax
ffffffff801072ad:	89 7d fc             	mov    %edi,-0x4(%rbp)
  picsetmask(irqmask & ~(1<<irq));
ffffffff801072b0:	66 8b 0c 25 68 18 12 	mov    0xffffffff80121868,%cx
ffffffff801072b7:	80 
ffffffff801072b8:	0f b7 f9             	movzwl %cx,%edi
ffffffff801072bb:	8b 4d fc             	mov    -0x4(%rbp),%ecx
ffffffff801072be:	d3 e0                	shl    %cl,%eax
ffffffff801072c0:	83 f0 ff             	xor    $0xffffffff,%eax
ffffffff801072c3:	21 c7                	and    %eax,%edi
ffffffff801072c5:	66 89 fa             	mov    %di,%dx
ffffffff801072c8:	0f b7 fa             	movzwl %dx,%edi
ffffffff801072cb:	e8 10 00 00 00       	callq  ffffffff801072e0 <picsetmask>
}
ffffffff801072d0:	48 83 c4 10          	add    $0x10,%rsp
ffffffff801072d4:	5d                   	pop    %rbp
ffffffff801072d5:	c3                   	retq   
ffffffff801072d6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
ffffffff801072dd:	00 00 00 

ffffffff801072e0 <picsetmask>:
{
ffffffff801072e0:	55                   	push   %rbp
ffffffff801072e1:	48 89 e5             	mov    %rsp,%rbp
ffffffff801072e4:	48 83 ec 10          	sub    $0x10,%rsp
ffffffff801072e8:	66 89 f8             	mov    %di,%ax
ffffffff801072eb:	bf 21 00 00 00       	mov    $0x21,%edi
ffffffff801072f0:	66 89 45 fe          	mov    %ax,-0x2(%rbp)
  irqmask = mask;
ffffffff801072f4:	66 8b 45 fe          	mov    -0x2(%rbp),%ax
ffffffff801072f8:	66 89 04 25 68 18 12 	mov    %ax,0xffffffff80121868
ffffffff801072ff:	80 
  outb(IO_PIC1+1, mask);
ffffffff80107300:	66 8b 45 fe          	mov    -0x2(%rbp),%ax
ffffffff80107304:	88 c1                	mov    %al,%cl
ffffffff80107306:	0f b6 f1             	movzbl %cl,%esi
ffffffff80107309:	ba 21 00 00 00       	mov    $0x21,%edx
ffffffff8010730e:	89 7d f8             	mov    %edi,-0x8(%rbp)
ffffffff80107311:	89 d7                	mov    %edx,%edi
ffffffff80107313:	e8 48 01 00 00       	callq  ffffffff80107460 <outb>
ffffffff80107318:	ba a1 00 00 00       	mov    $0xa1,%edx
  outb(IO_PIC2+1, mask >> 8);
ffffffff8010731d:	0f b7 75 fe          	movzwl -0x2(%rbp),%esi
ffffffff80107321:	c1 fe 08             	sar    $0x8,%esi
ffffffff80107324:	40 88 f1             	mov    %sil,%cl
ffffffff80107327:	0f b6 f1             	movzbl %cl,%esi
ffffffff8010732a:	bf a1 00 00 00       	mov    $0xa1,%edi
ffffffff8010732f:	89 55 f4             	mov    %edx,-0xc(%rbp)
ffffffff80107332:	e8 29 01 00 00       	callq  ffffffff80107460 <outb>
}
ffffffff80107337:	48 83 c4 10          	add    $0x10,%rsp
ffffffff8010733b:	5d                   	pop    %rbp
ffffffff8010733c:	c3                   	retq   
ffffffff8010733d:	0f 1f 00             	nopl   (%rax)

ffffffff80107340 <picinit>:

// Initialize the 8259A interrupt controllers.
void
picinit(void)
{
ffffffff80107340:	55                   	push   %rbp
ffffffff80107341:	48 89 e5             	mov    %rsp,%rbp
ffffffff80107344:	48 83 ec 30          	sub    $0x30,%rsp
ffffffff80107348:	b8 21 00 00 00       	mov    $0x21,%eax
ffffffff8010734d:	b9 ff 00 00 00       	mov    $0xff,%ecx
  // mask all interrupts
  outb(IO_PIC1+1, 0xFF);
ffffffff80107352:	89 c7                	mov    %eax,%edi
ffffffff80107354:	89 ce                	mov    %ecx,%esi
ffffffff80107356:	89 45 fc             	mov    %eax,-0x4(%rbp)
ffffffff80107359:	89 4d f8             	mov    %ecx,-0x8(%rbp)
ffffffff8010735c:	e8 ff 00 00 00       	callq  ffffffff80107460 <outb>
ffffffff80107361:	b8 a1 00 00 00       	mov    $0xa1,%eax
  outb(IO_PIC2+1, 0xFF);
ffffffff80107366:	89 c7                	mov    %eax,%edi
ffffffff80107368:	8b 75 f8             	mov    -0x8(%rbp),%esi
ffffffff8010736b:	89 45 f4             	mov    %eax,-0xc(%rbp)
ffffffff8010736e:	e8 ed 00 00 00       	callq  ffffffff80107460 <outb>
ffffffff80107373:	b8 20 00 00 00       	mov    $0x20,%eax
ffffffff80107378:	b9 11 00 00 00       	mov    $0x11,%ecx

  // ICW1:  0001g0hi
  //    g:  0 = edge triggering, 1 = level triggering
  //    h:  0 = cascaded PICs, 1 = master only
  //    i:  0 = no ICW4, 1 = ICW4 required
  outb(IO_PIC1, 0x11);
ffffffff8010737d:	89 c7                	mov    %eax,%edi
ffffffff8010737f:	89 ce                	mov    %ecx,%esi
ffffffff80107381:	89 45 f0             	mov    %eax,-0x10(%rbp)
ffffffff80107384:	89 4d ec             	mov    %ecx,-0x14(%rbp)
ffffffff80107387:	e8 d4 00 00 00       	callq  ffffffff80107460 <outb>

  // ICW2:  Vector offset
  outb(IO_PIC1+1, TRAP_IRQ0);
ffffffff8010738c:	8b 7d fc             	mov    -0x4(%rbp),%edi
ffffffff8010738f:	8b 75 f0             	mov    -0x10(%rbp),%esi
ffffffff80107392:	e8 c9 00 00 00       	callq  ffffffff80107460 <outb>

  // ICW3:  (master PIC) bit mask of IR lines connected to slaves
  //        (slave PIC) 3-bit # of slave's connection to master
  outb(IO_PIC1+1, 1<<IRQ_SLAVE);
ffffffff80107397:	be 04 00 00 00       	mov    $0x4,%esi
ffffffff8010739c:	8b 7d fc             	mov    -0x4(%rbp),%edi
ffffffff8010739f:	e8 bc 00 00 00       	callq  ffffffff80107460 <outb>
ffffffff801073a4:	b8 03 00 00 00       	mov    $0x3,%eax
  //    m:  0 = slave PIC, 1 = master PIC
  //      (ignored when b is 0, as the master/slave role
  //      can be hardwired).
  //    a:  1 = Automatic EOI mode
  //    p:  0 = MCS-80/85 mode, 1 = intel x86 mode
  outb(IO_PIC1+1, 0x3);
ffffffff801073a9:	8b 7d fc             	mov    -0x4(%rbp),%edi
ffffffff801073ac:	89 c6                	mov    %eax,%esi
ffffffff801073ae:	89 45 e8             	mov    %eax,-0x18(%rbp)
ffffffff801073b1:	e8 aa 00 00 00       	callq  ffffffff80107460 <outb>
ffffffff801073b6:	b8 a0 00 00 00       	mov    $0xa0,%eax

  // Set up slave (8259A-2)
  outb(IO_PIC2, 0x11);                  // ICW1
ffffffff801073bb:	89 c7                	mov    %eax,%edi
ffffffff801073bd:	8b 75 ec             	mov    -0x14(%rbp),%esi
ffffffff801073c0:	89 45 e4             	mov    %eax,-0x1c(%rbp)
ffffffff801073c3:	e8 98 00 00 00       	callq  ffffffff80107460 <outb>
  outb(IO_PIC2+1, TRAP_IRQ0 + 8);      // ICW2
ffffffff801073c8:	be 28 00 00 00       	mov    $0x28,%esi
ffffffff801073cd:	8b 7d f4             	mov    -0xc(%rbp),%edi
ffffffff801073d0:	e8 8b 00 00 00       	callq  ffffffff80107460 <outb>
  outb(IO_PIC2+1, IRQ_SLAVE);           // ICW3
ffffffff801073d5:	be 02 00 00 00       	mov    $0x2,%esi
ffffffff801073da:	8b 7d f4             	mov    -0xc(%rbp),%edi
ffffffff801073dd:	e8 7e 00 00 00       	callq  ffffffff80107460 <outb>
  // NB Automatic EOI mode doesn't tend to work on the slave.
  // Linux source code says it's "to be investigated".
  outb(IO_PIC2+1, 0x3);                 // ICW4
ffffffff801073e2:	8b 7d f4             	mov    -0xc(%rbp),%edi
ffffffff801073e5:	8b 75 e8             	mov    -0x18(%rbp),%esi
ffffffff801073e8:	e8 73 00 00 00       	callq  ffffffff80107460 <outb>
ffffffff801073ed:	b8 68 00 00 00       	mov    $0x68,%eax

  // OCW3:  0ef01prs
  //   ef:  0x = NOP, 10 = clear specific mask, 11 = set specific mask
  //    p:  0 = no polling, 1 = polling mode
  //   rs:  0x = NOP, 10 = read IRR, 11 = read ISR
  outb(IO_PIC1, 0x68);             // clear specific mask
ffffffff801073f2:	8b 7d f0             	mov    -0x10(%rbp),%edi
ffffffff801073f5:	89 c6                	mov    %eax,%esi
ffffffff801073f7:	89 45 e0             	mov    %eax,-0x20(%rbp)
ffffffff801073fa:	e8 61 00 00 00       	callq  ffffffff80107460 <outb>
ffffffff801073ff:	b8 0a 00 00 00       	mov    $0xa,%eax
  outb(IO_PIC1, 0x0a);             // read IRR by default
ffffffff80107404:	8b 7d f0             	mov    -0x10(%rbp),%edi
ffffffff80107407:	89 c6                	mov    %eax,%esi
ffffffff80107409:	89 45 dc             	mov    %eax,-0x24(%rbp)
ffffffff8010740c:	e8 4f 00 00 00       	callq  ffffffff80107460 <outb>

  outb(IO_PIC2, 0x68);             // OCW3
ffffffff80107411:	8b 7d e4             	mov    -0x1c(%rbp),%edi
ffffffff80107414:	8b 75 e0             	mov    -0x20(%rbp),%esi
ffffffff80107417:	e8 44 00 00 00       	callq  ffffffff80107460 <outb>
  outb(IO_PIC2, 0x0a);             // OCW3
ffffffff8010741c:	8b 7d e4             	mov    -0x1c(%rbp),%edi
ffffffff8010741f:	8b 75 dc             	mov    -0x24(%rbp),%esi
ffffffff80107422:	e8 39 00 00 00       	callq  ffffffff80107460 <outb>

  if(irqmask != 0xFFFF)
ffffffff80107427:	66 8b 14 25 68 18 12 	mov    0xffffffff80121868,%dx
ffffffff8010742e:	80 
ffffffff8010742f:	0f b7 c2             	movzwl %dx,%eax
ffffffff80107432:	3d ff ff 00 00       	cmp    $0xffff,%eax
ffffffff80107437:	0f 84 10 00 00 00    	je     ffffffff8010744d <picinit+0x10d>
    picsetmask(irqmask);
ffffffff8010743d:	66 8b 04 25 68 18 12 	mov    0xffffffff80121868,%ax
ffffffff80107444:	80 
ffffffff80107445:	0f b7 f8             	movzwl %ax,%edi
ffffffff80107448:	e8 93 fe ff ff       	callq  ffffffff801072e0 <picsetmask>
}
ffffffff8010744d:	48 83 c4 30          	add    $0x30,%rsp
ffffffff80107451:	5d                   	pop    %rbp
ffffffff80107452:	c3                   	retq   
ffffffff80107453:	66 66 66 66 2e 0f 1f 	data16 data16 data16 nopw %cs:0x0(%rax,%rax,1)
ffffffff8010745a:	84 00 00 00 00 00 

ffffffff80107460 <outb>:
{
ffffffff80107460:	55                   	push   %rbp
ffffffff80107461:	48 89 e5             	mov    %rsp,%rbp
ffffffff80107464:	48 83 ec 04          	sub    $0x4,%rsp
ffffffff80107468:	40 88 f0             	mov    %sil,%al
ffffffff8010746b:	66 89 f9             	mov    %di,%cx
ffffffff8010746e:	66 89 4d fe          	mov    %cx,-0x2(%rbp)
ffffffff80107472:	88 45 fd             	mov    %al,-0x3(%rbp)
  asm volatile("out %0,%1" : : "a" (data), "d" (port));
ffffffff80107475:	8a 45 fd             	mov    -0x3(%rbp),%al
ffffffff80107478:	66 8b 55 fe          	mov    -0x2(%rbp),%dx
ffffffff8010747c:	ee                   	out    %al,(%dx)
}
ffffffff8010747d:	48 83 c4 04          	add    $0x4,%rsp
ffffffff80107481:	5d                   	pop    %rbp
ffffffff80107482:	c3                   	retq   
ffffffff80107483:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
ffffffff8010748a:	00 00 00 
ffffffff8010748d:	0f 1f 00             	nopl   (%rax)

ffffffff80107490 <calc_extent_size>:

size_t extent_size = 0;
extern struct superblock sb;

void calc_extent_size()
{
ffffffff80107490:	55                   	push   %rbp
ffffffff80107491:	48 89 e5             	mov    %rsp,%rbp
  size_t bitmap_blocks = sb.inodestart - sb.bmapstart;
ffffffff80107494:	48 83 ec 30          	sub    $0x30,%rsp
ffffffff80107498:	8b 04 25 54 27 20 83 	mov    0xffffffff83202754,%eax
ffffffff8010749f:	8b 0c 25 50 27 20 83 	mov    0xffffffff83202750,%ecx
ffffffff801074a6:	29 c8                	sub    %ecx,%eax
ffffffff801074a8:	89 c2                	mov    %eax,%edx
ffffffff801074aa:	48 89 55 f8          	mov    %rdx,-0x8(%rbp)
  extent_size = 0;
ffffffff801074ae:	48 c7 04 25 80 64 1f 	movq   $0x0,0xffffffff831f6480
ffffffff801074b5:	83 00 00 00 00 

  for (int i = 0; i < bitmap_blocks; i++) {
ffffffff801074ba:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)
ffffffff801074c1:	48 63 45 f4          	movslq -0xc(%rbp),%rax
ffffffff801074c5:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
ffffffff801074c9:	0f 83 d4 00 00 00    	jae    ffffffff801075a3 <calc_extent_size+0x113>
ffffffff801074cf:	b8 01 00 00 00       	mov    $0x1,%eax
    struct buf* buf = bread(ROOTDEV, sb.bmapstart + i);
ffffffff801074d4:	8b 0c 25 50 27 20 83 	mov    0xffffffff83202750,%ecx
ffffffff801074db:	03 4d f4             	add    -0xc(%rbp),%ecx
ffffffff801074de:	bf 01 00 00 00       	mov    $0x1,%edi
ffffffff801074e3:	89 ce                	mov    %ecx,%esi
ffffffff801074e5:	89 45 dc             	mov    %eax,-0x24(%rbp)
ffffffff801074e8:	e8 63 2a 00 00       	callq  ffffffff80109f50 <bread>
ffffffff801074ed:	48 89 45 e8          	mov    %rax,-0x18(%rbp)

    for (int j = 0; j < BSIZE; j++) { // for each byte
ffffffff801074f1:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%rbp)
ffffffff801074f8:	81 7d e4 00 02 00 00 	cmpl   $0x200,-0x1c(%rbp)
ffffffff801074ff:	0f 8d 87 00 00 00    	jge    ffffffff8010758c <calc_extent_size+0xfc>
      for (int k = 0; k < 8; k++) { // for each bit
ffffffff80107505:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%rbp)
ffffffff8010750c:	83 7d e0 08          	cmpl   $0x8,-0x20(%rbp)
ffffffff80107510:	0f 8d 63 00 00 00    	jge    ffffffff80107579 <calc_extent_size+0xe9>
ffffffff80107516:	b8 01 00 00 00       	mov    $0x1,%eax
ffffffff8010751b:	b9 07 00 00 00       	mov    $0x7,%ecx
        if ((0x1 << (7 - k)) & buf->data[j]) {
ffffffff80107520:	2b 4d e0             	sub    -0x20(%rbp),%ecx
ffffffff80107523:	d3 e0                	shl    %cl,%eax
ffffffff80107525:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
ffffffff80107529:	48 63 75 e4          	movslq -0x1c(%rbp),%rsi
ffffffff8010752d:	0f b6 bc 32 b0 00 00 	movzbl 0xb0(%rdx,%rsi,1),%edi
ffffffff80107534:	00 
ffffffff80107535:	21 f8                	and    %edi,%eax
ffffffff80107537:	83 f8 00             	cmp    $0x0,%eax
ffffffff8010753a:	0f 84 18 00 00 00    	je     ffffffff80107558 <calc_extent_size+0xc8>
          extent_size++;
ffffffff80107540:	48 8b 04 25 80 64 1f 	mov    0xffffffff831f6480,%rax
ffffffff80107547:	83 
ffffffff80107548:	48 ff c0             	inc    %rax
ffffffff8010754b:	48 89 04 25 80 64 1f 	mov    %rax,0xffffffff831f6480
ffffffff80107552:	83 
        } else {
ffffffff80107553:	e9 0e 00 00 00       	jmpq   ffffffff80107566 <calc_extent_size+0xd6>
          brelse(buf);
ffffffff80107558:	48 8b 7d e8          	mov    -0x18(%rbp),%rdi
ffffffff8010755c:	e8 df 2a 00 00       	callq  ffffffff8010a040 <brelse>
          return;
ffffffff80107561:	e9 3d 00 00 00       	jmpq   ffffffff801075a3 <calc_extent_size+0x113>
        }
      }
ffffffff80107566:	e9 00 00 00 00       	jmpq   ffffffff8010756b <calc_extent_size+0xdb>
      for (int k = 0; k < 8; k++) { // for each bit
ffffffff8010756b:	8b 45 e0             	mov    -0x20(%rbp),%eax
ffffffff8010756e:	83 c0 01             	add    $0x1,%eax
ffffffff80107571:	89 45 e0             	mov    %eax,-0x20(%rbp)
ffffffff80107574:	e9 93 ff ff ff       	jmpq   ffffffff8010750c <calc_extent_size+0x7c>
    }
ffffffff80107579:	e9 00 00 00 00       	jmpq   ffffffff8010757e <calc_extent_size+0xee>
    for (int j = 0; j < BSIZE; j++) { // for each byte
ffffffff8010757e:	8b 45 e4             	mov    -0x1c(%rbp),%eax
ffffffff80107581:	83 c0 01             	add    $0x1,%eax
ffffffff80107584:	89 45 e4             	mov    %eax,-0x1c(%rbp)
ffffffff80107587:	e9 6c ff ff ff       	jmpq   ffffffff801074f8 <calc_extent_size+0x68>
    brelse(buf);
ffffffff8010758c:	48 8b 7d e8          	mov    -0x18(%rbp),%rdi
ffffffff80107590:	e8 ab 2a 00 00       	callq  ffffffff8010a040 <brelse>
  for (int i = 0; i < bitmap_blocks; i++) {
ffffffff80107595:	8b 45 f4             	mov    -0xc(%rbp),%eax
ffffffff80107598:	83 c0 01             	add    $0x1,%eax
ffffffff8010759b:	89 45 f4             	mov    %eax,-0xc(%rbp)
ffffffff8010759e:	e9 1e ff ff ff       	jmpq   ffffffff801074c1 <calc_extent_size+0x31>
  }
}
ffffffff801075a3:	48 83 c4 30          	add    $0x30,%rsp
ffffffff801075a7:	5d                   	pop    %rbp
ffffffff801075a8:	c3                   	retq   
ffffffff801075a9:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)

ffffffff801075b0 <reboot>:


void reboot(void)
{
ffffffff801075b0:	55                   	push   %rbp
ffffffff801075b1:	48 89 e5             	mov    %rsp,%rbp
    uint8_t good = 0x02;
ffffffff801075b4:	48 83 ec 10          	sub    $0x10,%rsp
ffffffff801075b8:	c6 45 ff 02          	movb   $0x2,-0x1(%rbp)
    while (good & 0x02)
ffffffff801075bc:	0f b6 45 ff          	movzbl -0x1(%rbp),%eax
ffffffff801075c0:	83 e0 02             	and    $0x2,%eax
ffffffff801075c3:	83 f8 00             	cmp    $0x0,%eax
ffffffff801075c6:	0f 84 1a 00 00 00    	je     ffffffff801075e6 <reboot+0x36>
ffffffff801075cc:	b8 64 00 00 00       	mov    $0x64,%eax
        good = inb(0x64);
ffffffff801075d1:	bf 64 00 00 00       	mov    $0x64,%edi
ffffffff801075d6:	89 45 f8             	mov    %eax,-0x8(%rbp)
ffffffff801075d9:	e8 32 00 00 00       	callq  ffffffff80107610 <inb>
ffffffff801075de:	88 45 ff             	mov    %al,-0x1(%rbp)
    while (good & 0x02)
ffffffff801075e1:	e9 d6 ff ff ff       	jmpq   ffffffff801075bc <reboot+0xc>
ffffffff801075e6:	b8 64 00 00 00       	mov    $0x64,%eax
ffffffff801075eb:	b9 fe 00 00 00       	mov    $0xfe,%ecx
    outb(0x64, 0xFE);
ffffffff801075f0:	bf 64 00 00 00       	mov    $0x64,%edi
ffffffff801075f5:	be fe 00 00 00       	mov    $0xfe,%esi
ffffffff801075fa:	89 45 f4             	mov    %eax,-0xc(%rbp)
ffffffff801075fd:	89 4d f0             	mov    %ecx,-0x10(%rbp)
ffffffff80107600:	e8 3b 00 00 00       	callq  ffffffff80107640 <outb>
loop:
    asm volatile ("hlt");
ffffffff80107605:	f4                   	hlt    
    goto loop;
ffffffff80107606:	e9 fa ff ff ff       	jmpq   ffffffff80107605 <reboot+0x55>
ffffffff8010760b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

ffffffff80107610 <inb>:
{
ffffffff80107610:	55                   	push   %rbp
ffffffff80107611:	48 89 e5             	mov    %rsp,%rbp
ffffffff80107614:	48 83 ec 04          	sub    $0x4,%rsp
ffffffff80107618:	66 89 f8             	mov    %di,%ax
ffffffff8010761b:	66 89 45 fe          	mov    %ax,-0x2(%rbp)
  asm volatile("in %1,%0" : "=a" (data) : "d" (port));
ffffffff8010761f:	66 8b 55 fe          	mov    -0x2(%rbp),%dx
ffffffff80107623:	ec                   	in     (%dx),%al
ffffffff80107624:	88 45 fd             	mov    %al,-0x3(%rbp)
  return data;
ffffffff80107627:	0f b6 45 fd          	movzbl -0x3(%rbp),%eax
ffffffff8010762b:	48 83 c4 04          	add    $0x4,%rsp
ffffffff8010762f:	5d                   	pop    %rbp
ffffffff80107630:	c3                   	retq   
ffffffff80107631:	66 66 66 66 66 66 2e 	data16 data16 data16 data16 data16 nopw %cs:0x0(%rax,%rax,1)
ffffffff80107638:	0f 1f 84 00 00 00 00 
ffffffff8010763f:	00 

ffffffff80107640 <outb>:
{
ffffffff80107640:	55                   	push   %rbp
ffffffff80107641:	48 89 e5             	mov    %rsp,%rbp
ffffffff80107644:	48 83 ec 04          	sub    $0x4,%rsp
ffffffff80107648:	40 88 f0             	mov    %sil,%al
ffffffff8010764b:	66 89 f9             	mov    %di,%cx
ffffffff8010764e:	66 89 4d fe          	mov    %cx,-0x2(%rbp)
ffffffff80107652:	88 45 fd             	mov    %al,-0x3(%rbp)
  asm volatile("out %0,%1" : : "a" (data), "d" (port));
ffffffff80107655:	8a 45 fd             	mov    -0x3(%rbp),%al
ffffffff80107658:	66 8b 55 fe          	mov    -0x2(%rbp),%dx
ffffffff8010765c:	ee                   	out    %al,(%dx)
}
ffffffff8010765d:	48 83 c4 04          	add    $0x4,%rsp
ffffffff80107661:	5d                   	pop    %rbp
ffffffff80107662:	c3                   	retq   
ffffffff80107663:	66 66 66 66 2e 0f 1f 	data16 data16 data16 nopw %cs:0x0(%rax,%rax,1)
ffffffff8010766a:	84 00 00 00 00 00 

ffffffff80107670 <pinit>:
}

void
pinit(void)
{
ffffffff80107670:	55                   	push   %rbp
ffffffff80107671:	48 89 e5             	mov    %rsp,%rbp
  initlock(&ptable.lock, "ptable");
ffffffff80107674:	48 c7 c7 a8 82 1f 83 	mov    $0xffffffff831f82a8,%rdi
ffffffff8010767b:	48 c7 c6 e2 00 11 80 	mov    $0xffffffff801100e2,%rsi
ffffffff80107682:	e8 f9 e0 ff ff       	callq  ffffffff80105780 <initlock>
}
ffffffff80107687:	5d                   	pop    %rbp
ffffffff80107688:	c3                   	retq   
ffffffff80107689:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)

ffffffff80107690 <find_mapped_file>:
 * Also optionally returns process holding it via output param.
 *
 * Acquires ptable lock.
 */
struct mapped_file* find_mapped_file(uint inum, struct proc** pproc)
{
ffffffff80107690:	55                   	push   %rbp
ffffffff80107691:	48 89 e5             	mov    %rsp,%rbp
ffffffff80107694:	48 83 ec 30          	sub    $0x30,%rsp
ffffffff80107698:	89 7d fc             	mov    %edi,-0x4(%rbp)
ffffffff8010769b:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  struct mapped_file* mapped_file = NULL;
ffffffff8010769f:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
ffffffff801076a6:	00 
  acquire(&ptable.lock);
ffffffff801076a7:	48 c7 c7 a8 82 1f 83 	mov    $0xffffffff831f82a8,%rdi
ffffffff801076ae:	e8 0d e1 ff ff       	callq  ffffffff801057c0 <acquire>

  for (int i = 0; i < NPROC; i++) {
ffffffff801076b3:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%rbp)
ffffffff801076ba:	83 7d e4 40          	cmpl   $0x40,-0x1c(%rbp)
ffffffff801076be:	0f 8d 91 00 00 00    	jge    ffffffff80107755 <find_mapped_file+0xc5>
    struct proc* proc = &ptable.proc[i];
ffffffff801076c4:	48 63 45 e4          	movslq -0x1c(%rbp),%rax
ffffffff801076c8:	48 8d 04 80          	lea    (%rax,%rax,4),%rax
ffffffff801076cc:	48 c1 e0 06          	shl    $0x6,%rax
ffffffff801076d0:	48 8d 80 10 83 1f 83 	lea    -0x7ce07cf0(%rax),%rax
ffffffff801076d7:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
    if (proc->state != UNUSED
ffffffff801076db:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
ffffffff801076df:	83 b8 00 01 00 00 00 	cmpl   $0x0,0x100(%rax)
     && proc->mapinfo.mapped_file != NULL
ffffffff801076e6:	0f 84 56 00 00 00    	je     ffffffff80107742 <find_mapped_file+0xb2>
ffffffff801076ec:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
ffffffff801076f0:	48 83 b8 e8 00 00 00 	cmpq   $0x0,0xe8(%rax)
ffffffff801076f7:	00 
     && proc->mapinfo.mapped_file->inode->inum == inum) {
ffffffff801076f8:	0f 84 44 00 00 00    	je     ffffffff80107742 <find_mapped_file+0xb2>
ffffffff801076fe:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
ffffffff80107702:	48 8b 80 e8 00 00 00 	mov    0xe8(%rax),%rax
ffffffff80107709:	48 8b 00             	mov    (%rax),%rax
ffffffff8010770c:	8b 48 04             	mov    0x4(%rax),%ecx
ffffffff8010770f:	3b 4d fc             	cmp    -0x4(%rbp),%ecx
    if (proc->state != UNUSED
ffffffff80107712:	0f 85 2a 00 00 00    	jne    ffffffff80107742 <find_mapped_file+0xb2>
      mapped_file = proc->mapinfo.mapped_file;
ffffffff80107718:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
ffffffff8010771c:	48 8b 80 e8 00 00 00 	mov    0xe8(%rax),%rax
ffffffff80107723:	48 89 45 e8          	mov    %rax,-0x18(%rbp)

      if (pproc != NULL) {
ffffffff80107727:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
ffffffff8010772c:	0f 84 0b 00 00 00    	je     ffffffff8010773d <find_mapped_file+0xad>
        *pproc = proc;
ffffffff80107732:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
ffffffff80107736:	48 8b 4d f0          	mov    -0x10(%rbp),%rcx
ffffffff8010773a:	48 89 01             	mov    %rax,(%rcx)
      }

      break;
ffffffff8010773d:	e9 13 00 00 00       	jmpq   ffffffff80107755 <find_mapped_file+0xc5>
    }
  }
ffffffff80107742:	e9 00 00 00 00       	jmpq   ffffffff80107747 <find_mapped_file+0xb7>
  for (int i = 0; i < NPROC; i++) {
ffffffff80107747:	8b 45 e4             	mov    -0x1c(%rbp),%eax
ffffffff8010774a:	83 c0 01             	add    $0x1,%eax
ffffffff8010774d:	89 45 e4             	mov    %eax,-0x1c(%rbp)
ffffffff80107750:	e9 65 ff ff ff       	jmpq   ffffffff801076ba <find_mapped_file+0x2a>

  release(&ptable.lock);
ffffffff80107755:	48 c7 c7 a8 82 1f 83 	mov    $0xffffffff831f82a8,%rdi
ffffffff8010775c:	e8 9f e2 ff ff       	callq  ffffffff80105a00 <release>
  return mapped_file;
ffffffff80107761:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
ffffffff80107765:	48 83 c4 30          	add    $0x30,%rsp
ffffffff80107769:	5d                   	pop    %rbp
ffffffff8010776a:	c3                   	retq   
ffffffff8010776b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

ffffffff80107770 <kernel_duplicate_mapped_file>:
/**
 * Duplicates the current mapped file from the given source proc to the given
 * dest proc.
 */
void kernel_duplicate_mapped_file(struct proc* source, struct proc* dest)
{
ffffffff80107770:	55                   	push   %rbp
ffffffff80107771:	48 89 e5             	mov    %rsp,%rbp
ffffffff80107774:	48 83 ec 40          	sub    $0x40,%rsp
ffffffff80107778:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
ffffffff8010777c:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  if (source->mapinfo.mapped_file == NULL) {
ffffffff80107780:	48 8b 75 f8          	mov    -0x8(%rbp),%rsi
ffffffff80107784:	48 83 be e8 00 00 00 	cmpq   $0x0,0xe8(%rsi)
ffffffff8010778b:	00 
ffffffff8010778c:	0f 85 05 00 00 00    	jne    ffffffff80107797 <kernel_duplicate_mapped_file+0x27>
    // This won't work.
    return;
ffffffff80107792:	e9 fc 00 00 00       	jmpq   ffffffff80107893 <kernel_duplicate_mapped_file+0x123>
  }

  struct mapped_file* mapped_file = source->mapinfo.mapped_file;
ffffffff80107797:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
ffffffff8010779b:	48 8b 80 e8 00 00 00 	mov    0xe8(%rax),%rax
ffffffff801077a2:	48 89 45 e8          	mov    %rax,-0x18(%rbp)

  acquire(&mapped_file->lock);
ffffffff801077a6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
ffffffff801077aa:	48 83 c0 08          	add    $0x8,%rax
ffffffff801077ae:	48 89 c7             	mov    %rax,%rdi
ffffffff801077b1:	e8 0a e0 ff ff       	callq  ffffffff801057c0 <acquire>
  ++mapped_file->refcount;
ffffffff801077b6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
ffffffff801077ba:	8a 48 74             	mov    0x74(%rax),%cl
ffffffff801077bd:	80 c1 01             	add    $0x1,%cl
ffffffff801077c0:	88 48 74             	mov    %cl,0x74(%rax)
  release(&mapped_file->lock);
ffffffff801077c3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
ffffffff801077c7:	48 83 c0 08          	add    $0x8,%rax
ffffffff801077cb:	48 89 c7             	mov    %rax,%rdi
ffffffff801077ce:	e8 2d e2 ff ff       	callq  ffffffff80105a00 <release>

  // Use source proc to calculate physical address, then map each physical
  // page into the dest proc.
  for (int i = 0; i < mapped_file->pages; ++i) {
ffffffff801077d3:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%rbp)
ffffffff801077da:	8b 45 e4             	mov    -0x1c(%rbp),%eax
ffffffff801077dd:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
ffffffff801077e1:	3b 41 70             	cmp    0x70(%rcx),%eax
ffffffff801077e4:	0f 83 a9 00 00 00    	jae    ffffffff80107893 <kernel_duplicate_mapped_file+0x123>
ffffffff801077ea:	b8 00 00 00 80       	mov    $0x80000000,%eax
ffffffff801077ef:	89 c1                	mov    %eax,%ecx
    char* v_offset = (char*) MAPPED_FILE_VADDR + (i * PGSIZE);
ffffffff801077f1:	8b 45 e4             	mov    -0x1c(%rbp),%eax
ffffffff801077f4:	c1 e0 0c             	shl    $0xc,%eax
ffffffff801077f7:	48 63 d0             	movslq %eax,%rdx
ffffffff801077fa:	48 01 d1             	add    %rdx,%rcx
ffffffff801077fd:	48 89 4d d8          	mov    %rcx,-0x28(%rbp)
    char* phys = uva2ka(source->pml4, v_offset);
ffffffff80107801:	48 8b 4d f8          	mov    -0x8(%rbp),%rcx
ffffffff80107805:	48 8b 39             	mov    (%rcx),%rdi
ffffffff80107808:	48 8b 75 d8          	mov    -0x28(%rbp),%rsi
ffffffff8010780c:	e8 ff d9 ff ff       	callq  ffffffff80105210 <uva2ka>
ffffffff80107811:	41 b8 01 00 00 00    	mov    $0x1,%r8d
ffffffff80107817:	41 b9 06 00 00 00    	mov    $0x6,%r9d
ffffffff8010781d:	48 89 45 d0          	mov    %rax,-0x30(%rbp)

    if (mappages(dest->pml4, PGNUM(v_offset), 1,
ffffffff80107821:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
ffffffff80107825:	48 8b 38             	mov    (%rax),%rdi
ffffffff80107828:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
ffffffff8010782c:	48 c1 e8 0c          	shr    $0xc,%rax
          PGNUM(V2P(phys)), PTE_W | PTE_U, dest->pid) == -1) {
ffffffff80107830:	48 8b 4d d0          	mov    -0x30(%rbp),%rcx
ffffffff80107834:	48 81 e9 00 00 00 80 	sub    $0xffffffff80000000,%rcx
ffffffff8010783b:	48 c1 e9 0c          	shr    $0xc,%rcx
ffffffff8010783f:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
ffffffff80107843:	44 8b 92 04 01 00 00 	mov    0x104(%rdx),%r10d
    if (mappages(dest->pml4, PGNUM(v_offset), 1,
ffffffff8010784a:	ba 01 00 00 00       	mov    $0x1,%edx
ffffffff8010784f:	41 bb 06 00 00 00    	mov    $0x6,%r11d
ffffffff80107855:	48 89 c6             	mov    %rax,%rsi
ffffffff80107858:	44 89 45 cc          	mov    %r8d,-0x34(%rbp)
ffffffff8010785c:	45 89 d8             	mov    %r11d,%r8d
ffffffff8010785f:	44 89 4d c8          	mov    %r9d,-0x38(%rbp)
ffffffff80107863:	45 89 d1             	mov    %r10d,%r9d
ffffffff80107866:	e8 25 ba ff ff       	callq  ffffffff80103290 <mappages>
          PGNUM(V2P(phys)), PTE_W | PTE_U, dest->pid) == -1) {
ffffffff8010786b:	83 f8 ff             	cmp    $0xffffffff,%eax
    if (mappages(dest->pml4, PGNUM(v_offset), 1,
ffffffff8010786e:	0f 85 0c 00 00 00    	jne    ffffffff80107880 <kernel_duplicate_mapped_file+0x110>
      panic("mappages failure");
ffffffff80107874:	48 c7 c7 e9 00 11 80 	mov    $0xffffffff801100e9,%rdi
ffffffff8010787b:	e8 f0 95 ff ff       	callq  ffffffff80100e70 <panic>
    }
  }
ffffffff80107880:	e9 00 00 00 00       	jmpq   ffffffff80107885 <kernel_duplicate_mapped_file+0x115>
  for (int i = 0; i < mapped_file->pages; ++i) {
ffffffff80107885:	8b 45 e4             	mov    -0x1c(%rbp),%eax
ffffffff80107888:	83 c0 01             	add    $0x1,%eax
ffffffff8010788b:	89 45 e4             	mov    %eax,-0x1c(%rbp)
ffffffff8010788e:	e9 47 ff ff ff       	jmpq   ffffffff801077da <kernel_duplicate_mapped_file+0x6a>
}
ffffffff80107893:	48 83 c4 40          	add    $0x40,%rsp
ffffffff80107897:	5d                   	pop    %rbp
ffffffff80107898:	c3                   	retq   
ffffffff80107899:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)

ffffffff801078a0 <get_proc>:

struct proc* get_proc(int pid)
{
ffffffff801078a0:	55                   	push   %rbp
ffffffff801078a1:	48 89 e5             	mov    %rsp,%rbp
ffffffff801078a4:	48 83 ec 20          	sub    $0x20,%rsp
ffffffff801078a8:	89 7d f4             	mov    %edi,-0xc(%rbp)
  for (struct proc* p = ptable.proc; p < &ptable.proc[NPROC]; p++) {
ffffffff801078ab:	48 c7 45 e8 10 83 1f 	movq   $0xffffffff831f8310,-0x18(%rbp)
ffffffff801078b2:	83 
ffffffff801078b3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
ffffffff801078b7:	48 c7 c1 10 d3 1f 83 	mov    $0xffffffff831fd310,%rcx
ffffffff801078be:	48 29 c8             	sub    %rcx,%rax
ffffffff801078c1:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
ffffffff801078c5:	0f 83 3d 00 00 00    	jae    ffffffff80107908 <get_proc+0x68>
ffffffff801078cb:	e9 00 00 00 00       	jmpq   ffffffff801078d0 <get_proc+0x30>
    if (p->pid == pid) {
ffffffff801078d0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
ffffffff801078d4:	8b 88 04 01 00 00    	mov    0x104(%rax),%ecx
ffffffff801078da:	3b 4d f4             	cmp    -0xc(%rbp),%ecx
ffffffff801078dd:	0f 85 0d 00 00 00    	jne    ffffffff801078f0 <get_proc+0x50>
      return p;
ffffffff801078e3:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
ffffffff801078e7:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
ffffffff801078eb:	e9 20 00 00 00       	jmpq   ffffffff80107910 <get_proc+0x70>
    }
  }
ffffffff801078f0:	e9 00 00 00 00       	jmpq   ffffffff801078f5 <get_proc+0x55>
  for (struct proc* p = ptable.proc; p < &ptable.proc[NPROC]; p++) {
ffffffff801078f5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
ffffffff801078f9:	48 05 40 01 00 00    	add    $0x140,%rax
ffffffff801078ff:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
ffffffff80107903:	e9 ab ff ff ff       	jmpq   ffffffff801078b3 <get_proc+0x13>

  return NULL;
ffffffff80107908:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
ffffffff8010790f:	00 
}
ffffffff80107910:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
ffffffff80107914:	48 83 c4 20          	add    $0x20,%rsp
ffffffff80107918:	5d                   	pop    %rbp
ffffffff80107919:	c3                   	retq   
ffffffff8010791a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)

ffffffff80107920 <get_proc_by_ordinal>:

struct proc* get_proc_by_ordinal(size_t i)
{
ffffffff80107920:	55                   	push   %rbp
ffffffff80107921:	48 89 e5             	mov    %rsp,%rbp
ffffffff80107924:	50                   	push   %rax
ffffffff80107925:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  return &ptable.proc[i];
ffffffff80107929:	48 8b 7d f8          	mov    -0x8(%rbp),%rdi
ffffffff8010792d:	48 8d 3c bf          	lea    (%rdi,%rdi,4),%rdi
ffffffff80107931:	48 c1 e7 06          	shl    $0x6,%rdi
ffffffff80107935:	48 8d 87 10 83 1f 83 	lea    -0x7ce07cf0(%rdi),%rax
ffffffff8010793c:	48 83 c4 08          	add    $0x8,%rsp
ffffffff80107940:	5d                   	pop    %rbp
ffffffff80107941:	c3                   	retq   
ffffffff80107942:	66 66 66 66 66 2e 0f 	data16 data16 data16 data16 nopw %cs:0x0(%rax,%rax,1)
ffffffff80107949:	1f 84 00 00 00 00 00 

ffffffff80107950 <userinit>:

//PAGEBREAK: 32
// Set up first user process.
void
userinit(void)
{
ffffffff80107950:	55                   	push   %rbp
ffffffff80107951:	48 89 e5             	mov    %rsp,%rbp
  struct proc *p;
  extern char _binary_out_initcode_start[], _binary_out_initcode_size[];

  p = allocproc();
ffffffff80107954:	48 83 ec 20          	sub    $0x20,%rsp
ffffffff80107958:	e8 83 01 00 00       	callq  ffffffff80107ae0 <allocproc>
ffffffff8010795d:	48 89 45 f8          	mov    %rax,-0x8(%rbp)

  initproc = p;
ffffffff80107961:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
ffffffff80107965:	48 89 04 25 88 64 1f 	mov    %rax,0xffffffff831f6488
ffffffff8010796c:	83 
  if((p->pml4 = setupkvm()) == 0)
ffffffff8010796d:	e8 1e ba ff ff       	callq  ffffffff80103390 <setupkvm>
ffffffff80107972:	48 8b 4d f8          	mov    -0x8(%rbp),%rcx
ffffffff80107976:	48 89 01             	mov    %rax,(%rcx)
ffffffff80107979:	48 83 f8 00          	cmp    $0x0,%rax
ffffffff8010797d:	0f 85 0c 00 00 00    	jne    ffffffff8010798f <userinit+0x3f>
    panic("userinit: out of memory?");
ffffffff80107983:	48 c7 c7 fa 00 11 80 	mov    $0xffffffff801100fa,%rdi
ffffffff8010798a:	e8 e1 94 ff ff       	callq  ffffffff80100e70 <panic>
  inituvm(p->pml4, _binary_out_initcode_start, (int64_t)_binary_out_initcode_size, p->pid);
ffffffff8010798f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
ffffffff80107993:	48 8b 38             	mov    (%rax),%rdi
ffffffff80107996:	8b 88 04 01 00 00    	mov    0x104(%rax),%ecx
ffffffff8010799c:	48 c7 c0 3c 00 00 00 	mov    $0x3c,%rax
ffffffff801079a3:	89 c2                	mov    %eax,%edx
ffffffff801079a5:	48 c7 c6 a2 23 12 80 	mov    $0xffffffff801223a2,%rsi
ffffffff801079ac:	e8 ff bc ff ff       	callq  ffffffff801036b0 <inituvm>
  p->mem_regions[CODE].start = 0;
ffffffff801079b1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
ffffffff801079b5:	48 c7 40 08 00 00 00 	movq   $0x0,0x8(%rax)
ffffffff801079bc:	00 
  p->mem_regions[CODE].size = PGROUNDUP((int64_t)_binary_out_initcode_size);
ffffffff801079bd:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
ffffffff801079c1:	48 c7 c6 3b 10 00 00 	mov    $0x103b,%rsi
ffffffff801079c8:	48 81 e6 00 f0 ff ff 	and    $0xfffffffffffff000,%rsi
ffffffff801079cf:	48 89 70 10          	mov    %rsi,0x10(%rax)
  memset(p->tf, 0, sizeof(*p->tf));
ffffffff801079d3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
ffffffff801079d7:	48 8b b8 10 01 00 00 	mov    0x110(%rax),%rdi
ffffffff801079de:	31 c9                	xor    %ecx,%ecx
ffffffff801079e0:	ba b0 00 00 00       	mov    $0xb0,%edx
ffffffff801079e5:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
ffffffff801079e9:	89 ce                	mov    %ecx,%esi
ffffffff801079eb:	e8 10 35 00 00       	callq  ffffffff8010af00 <memset>
  p->tf->cs = (SEG_UCODE << 3) | DPL_USER;
ffffffff801079f0:	48 8b 7d f8          	mov    -0x8(%rbp),%rdi
ffffffff801079f4:	48 8b bf 10 01 00 00 	mov    0x110(%rdi),%rdi
ffffffff801079fb:	48 c7 87 90 00 00 00 	movq   $0x23,0x90(%rdi)
ffffffff80107a02:	23 00 00 00 
  p->tf->ss = (SEG_UDATA << 3) | DPL_USER;
ffffffff80107a06:	48 8b 7d f8          	mov    -0x8(%rbp),%rdi
ffffffff80107a0a:	48 8b bf 10 01 00 00 	mov    0x110(%rdi),%rdi
ffffffff80107a11:	48 c7 87 a8 00 00 00 	movq   $0x2b,0xa8(%rdi)
ffffffff80107a18:	2b 00 00 00 
  p->tf->rflags = FLAGS_IF;
ffffffff80107a1c:	48 8b 7d f8          	mov    -0x8(%rbp),%rdi
ffffffff80107a20:	48 8b bf 10 01 00 00 	mov    0x110(%rdi),%rdi
ffffffff80107a27:	48 c7 87 98 00 00 00 	movq   $0x200,0x98(%rdi)
ffffffff80107a2e:	00 02 00 00 
  p->tf->rip = 0;  // beginning of initcode.S
ffffffff80107a32:	48 8b 7d f8          	mov    -0x8(%rbp),%rdi
ffffffff80107a36:	48 8b bf 10 01 00 00 	mov    0x110(%rdi),%rdi
ffffffff80107a3d:	48 c7 87 88 00 00 00 	movq   $0x0,0x88(%rdi)
ffffffff80107a44:	00 00 00 00 
  p->tf->rsp = PGROUNDUP((uint64_t)_binary_out_initcode_size) + 2 * PGSIZE;
ffffffff80107a48:	48 8b 7d f8          	mov    -0x8(%rbp),%rdi
ffffffff80107a4c:	48 8b bf 10 01 00 00 	mov    0x110(%rdi),%rdi
ffffffff80107a53:	4c 8b 45 f0          	mov    -0x10(%rbp),%r8
ffffffff80107a57:	49 81 c0 00 20 00 00 	add    $0x2000,%r8
ffffffff80107a5e:	4c 89 87 a0 00 00 00 	mov    %r8,0xa0(%rdi)
  p->mem_regions[USTACK].start = (char*)PGROUNDUP((uint64_t)_binary_out_initcode_size) + PGSIZE;
ffffffff80107a65:	48 8b 7d f8          	mov    -0x8(%rbp),%rdi
ffffffff80107a69:	4c 8b 45 f0          	mov    -0x10(%rbp),%r8
ffffffff80107a6d:	49 81 c0 00 10 00 00 	add    $0x1000,%r8
ffffffff80107a74:	4c 89 47 28          	mov    %r8,0x28(%rdi)
  p->mem_regions[USTACK].size = PGSIZE;
ffffffff80107a78:	48 8b 7d f8          	mov    -0x8(%rbp),%rdi
ffffffff80107a7c:	48 c7 47 30 00 10 00 	movq   $0x1000,0x30(%rdi)
ffffffff80107a83:	00 

  safestrcpy(p->name, "initcode", sizeof(p->name));
ffffffff80107a84:	48 8b 7d f8          	mov    -0x8(%rbp),%rdi
ffffffff80107a88:	48 81 c7 2c 01 00 00 	add    $0x12c,%rdi
ffffffff80107a8f:	48 c7 c6 13 01 11 80 	mov    $0xffffffff80110113,%rsi
ffffffff80107a96:	ba 10 00 00 00       	mov    $0x10,%edx
ffffffff80107a9b:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
ffffffff80107a9f:	e8 9c 38 00 00       	callq  ffffffff8010b340 <safestrcpy>

  // // this assignment to p->state lets other cores
  // // run this process. the acquire forces the above
  // // writes to be visible, and the lock is also needed
  // // because the assignment might not be atomic.
  acquire(&ptable.lock);
ffffffff80107aa4:	48 c7 c7 a8 82 1f 83 	mov    $0xffffffff831f82a8,%rdi
ffffffff80107aab:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
ffffffff80107aaf:	e8 0c dd ff ff       	callq  ffffffff801057c0 <acquire>

  p->state = RUNNABLE;
ffffffff80107ab4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
ffffffff80107ab8:	c7 80 00 01 00 00 03 	movl   $0x3,0x100(%rax)
ffffffff80107abf:	00 00 00 

  release(&ptable.lock);
ffffffff80107ac2:	48 c7 c7 a8 82 1f 83 	mov    $0xffffffff831f82a8,%rdi
ffffffff80107ac9:	e8 32 df ff ff       	callq  ffffffff80105a00 <release>
}
ffffffff80107ace:	48 83 c4 20          	add    $0x20,%rsp
ffffffff80107ad2:	5d                   	pop    %rbp
ffffffff80107ad3:	c3                   	retq   
ffffffff80107ad4:	66 66 66 2e 0f 1f 84 	data16 data16 nopw %cs:0x0(%rax,%rax,1)
ffffffff80107adb:	00 00 00 00 00 

ffffffff80107ae0 <allocproc>:
{
ffffffff80107ae0:	55                   	push   %rbp
ffffffff80107ae1:	48 89 e5             	mov    %rsp,%rbp
  acquire(&ptable.lock);
ffffffff80107ae4:	48 83 ec 40          	sub    $0x40,%rsp
ffffffff80107ae8:	48 c7 c7 a8 82 1f 83 	mov    $0xffffffff831f82a8,%rdi
ffffffff80107aef:	e8 cc dc ff ff       	callq  ffffffff801057c0 <acquire>
  for(p = ptable.proc; p < &ptable.proc[NPROC]; p++)
ffffffff80107af4:	48 c7 45 f0 10 83 1f 	movq   $0xffffffff831f8310,-0x10(%rbp)
ffffffff80107afb:	83 
ffffffff80107afc:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
ffffffff80107b00:	48 c7 c1 10 d3 1f 83 	mov    $0xffffffff831fd310,%rcx
ffffffff80107b07:	48 29 c8             	sub    %rcx,%rax
ffffffff80107b0a:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
ffffffff80107b0e:	0f 83 33 00 00 00    	jae    ffffffff80107b47 <allocproc+0x67>
ffffffff80107b14:	e9 00 00 00 00       	jmpq   ffffffff80107b19 <allocproc+0x39>
    if(p->state == UNUSED)
ffffffff80107b19:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
ffffffff80107b1d:	83 b8 00 01 00 00 00 	cmpl   $0x0,0x100(%rax)
ffffffff80107b24:	0f 85 05 00 00 00    	jne    ffffffff80107b2f <allocproc+0x4f>
      goto found;
ffffffff80107b2a:	e9 31 00 00 00       	jmpq   ffffffff80107b60 <allocproc+0x80>
    if(p->state == UNUSED)
ffffffff80107b2f:	e9 00 00 00 00       	jmpq   ffffffff80107b34 <allocproc+0x54>
  for(p = ptable.proc; p < &ptable.proc[NPROC]; p++)
ffffffff80107b34:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
ffffffff80107b38:	48 05 40 01 00 00    	add    $0x140,%rax
ffffffff80107b3e:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
ffffffff80107b42:	e9 b5 ff ff ff       	jmpq   ffffffff80107afc <allocproc+0x1c>
  release(&ptable.lock);
ffffffff80107b47:	48 c7 c7 a8 82 1f 83 	mov    $0xffffffff831f82a8,%rdi
ffffffff80107b4e:	e8 ad de ff ff       	callq  ffffffff80105a00 <release>
  return 0;
ffffffff80107b53:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
ffffffff80107b5a:	00 
ffffffff80107b5b:	e9 3b 01 00 00       	jmpq   ffffffff80107c9b <allocproc+0x1bb>
  p->state = EMBRYO;
ffffffff80107b60:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
ffffffff80107b64:	c7 80 00 01 00 00 01 	movl   $0x1,0x100(%rax)
ffffffff80107b6b:	00 00 00 
  p->pid = nextpid++;
ffffffff80107b6e:	8b 0c 25 70 18 12 80 	mov    0xffffffff80121870,%ecx
ffffffff80107b75:	89 ca                	mov    %ecx,%edx
ffffffff80107b77:	ff c2                	inc    %edx
ffffffff80107b79:	89 14 25 70 18 12 80 	mov    %edx,0xffffffff80121870
ffffffff80107b80:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
ffffffff80107b84:	89 88 04 01 00 00    	mov    %ecx,0x104(%rax)
  release(&ptable.lock);
ffffffff80107b8a:	48 c7 c7 a8 82 1f 83 	mov    $0xffffffff831f82a8,%rdi
ffffffff80107b91:	e8 6a de ff ff       	callq  ffffffff80105a00 <release>
  if((p->kstack = kalloc()) == 0){
ffffffff80107b96:	e8 e5 8b ff ff       	callq  ffffffff80100780 <kalloc>
ffffffff80107b9b:	48 8b 7d f0          	mov    -0x10(%rbp),%rdi
ffffffff80107b9f:	48 89 87 f8 00 00 00 	mov    %rax,0xf8(%rdi)
ffffffff80107ba6:	48 83 f8 00          	cmp    $0x0,%rax
ffffffff80107baa:	0f 85 1b 00 00 00    	jne    ffffffff80107bcb <allocproc+0xeb>
    p->state = UNUSED;
ffffffff80107bb0:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
ffffffff80107bb4:	c7 80 00 01 00 00 00 	movl   $0x0,0x100(%rax)
ffffffff80107bbb:	00 00 00 
    return 0;
ffffffff80107bbe:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
ffffffff80107bc5:	00 
ffffffff80107bc6:	e9 d0 00 00 00       	jmpq   ffffffff80107c9b <allocproc+0x1bb>
ffffffff80107bcb:	31 c0                	xor    %eax,%eax
ffffffff80107bcd:	b9 0b 00 00 00       	mov    $0xb,%ecx
  sp = p->kstack + KSTACKSIZE;
ffffffff80107bd2:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
ffffffff80107bd6:	48 8b 92 f8 00 00 00 	mov    0xf8(%rdx),%rdx
ffffffff80107bdd:	48 81 c2 00 10 00 00 	add    $0x1000,%rdx
ffffffff80107be4:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  sp -= sizeof *p->tf;
ffffffff80107be8:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
ffffffff80107bec:	48 81 c2 50 ff ff ff 	add    $0xffffffffffffff50,%rdx
ffffffff80107bf3:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  p->tf = (struct trap_frame*)sp;
ffffffff80107bf7:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
ffffffff80107bfb:	48 8b 75 f0          	mov    -0x10(%rbp),%rsi
ffffffff80107bff:	48 89 96 10 01 00 00 	mov    %rdx,0x110(%rsi)
  sp -= 8;
ffffffff80107c06:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
ffffffff80107c0a:	48 83 c2 f8          	add    $0xfffffffffffffff8,%rdx
ffffffff80107c0e:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  *(uint64_t*)sp = (uint64_t)trapret;
ffffffff80107c12:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
ffffffff80107c16:	48 c7 02 ab 65 10 80 	movq   $0xffffffff801065ab,(%rdx)
  sp -= sizeof *p->context;
ffffffff80107c1d:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
ffffffff80107c21:	48 83 c2 c0          	add    $0xffffffffffffffc0,%rdx
ffffffff80107c25:	48 89 55 e8          	mov    %rdx,-0x18(%rbp)
  p->context = (struct context*)sp;
ffffffff80107c29:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
ffffffff80107c2d:	48 8b 75 f0          	mov    -0x10(%rbp),%rsi
ffffffff80107c31:	48 89 96 18 01 00 00 	mov    %rdx,0x118(%rsi)
  memset(p->context, 0, sizeof *p->context);
ffffffff80107c38:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
ffffffff80107c3c:	48 8b ba 18 01 00 00 	mov    0x118(%rdx),%rdi
ffffffff80107c43:	31 f6                	xor    %esi,%esi
ffffffff80107c45:	ba 40 00 00 00       	mov    $0x40,%edx
ffffffff80107c4a:	89 45 dc             	mov    %eax,-0x24(%rbp)
ffffffff80107c4d:	89 4d d8             	mov    %ecx,-0x28(%rbp)
ffffffff80107c50:	e8 ab 32 00 00       	callq  ffffffff8010af00 <memset>
  p->context->rip = (uint64_t)forkret;
ffffffff80107c55:	48 8b 7d f0          	mov    -0x10(%rbp),%rdi
ffffffff80107c59:	48 8b bf 18 01 00 00 	mov    0x118(%rdi),%rdi
ffffffff80107c60:	48 c7 47 38 70 86 10 	movq   $0xffffffff80108670,0x38(%rdi)
ffffffff80107c67:	80 
  memset(p->open_files, 0, sizeof *p->open_files);
ffffffff80107c68:	48 8b 7d f0          	mov    -0x10(%rbp),%rdi
ffffffff80107c6c:	48 83 c7 38          	add    $0x38,%rdi
ffffffff80107c70:	31 f6                	xor    %esi,%esi
ffffffff80107c72:	ba 0b 00 00 00       	mov    $0xb,%edx
ffffffff80107c77:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
ffffffff80107c7b:	e8 80 32 00 00       	callq  ffffffff8010af00 <memset>
  p->mapinfo.mapped_file = NULL;
ffffffff80107c80:	48 8b 7d f0          	mov    -0x10(%rbp),%rdi
ffffffff80107c84:	48 c7 87 e8 00 00 00 	movq   $0x0,0xe8(%rdi)
ffffffff80107c8b:	00 00 00 00 
  return p;
ffffffff80107c8f:	48 8b 7d f0          	mov    -0x10(%rbp),%rdi
ffffffff80107c93:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
ffffffff80107c97:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
}
ffffffff80107c9b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
ffffffff80107c9f:	48 83 c4 40          	add    $0x40,%rsp
ffffffff80107ca3:	5d                   	pop    %rbp
ffffffff80107ca4:	c3                   	retq   
ffffffff80107ca5:	66 66 2e 0f 1f 84 00 	data16 nopw %cs:0x0(%rax,%rax,1)
ffffffff80107cac:	00 00 00 00 

ffffffff80107cb0 <fork>:
// Create a new process copying p as the parent.
// Sets up stack to return as if from system call.
// Caller must set state of returned proc to RUNNABLE.
int
fork(void)
{
ffffffff80107cb0:	55                   	push   %rbp
ffffffff80107cb1:	48 89 e5             	mov    %rsp,%rbp
  struct proc* child = allocproc();
ffffffff80107cb4:	48 83 ec 50          	sub    $0x50,%rsp
ffffffff80107cb8:	e8 23 fe ff ff       	callq  ffffffff80107ae0 <allocproc>
ffffffff80107cbd:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

  if (child == 0) {
ffffffff80107cc1:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
ffffffff80107cc6:	0f 85 0c 00 00 00    	jne    ffffffff80107cd8 <fork+0x28>
    return -1;
ffffffff80107ccc:	c7 45 fc ff ff ff ff 	movl   $0xffffffff,-0x4(%rbp)
ffffffff80107cd3:	e9 ee 01 00 00       	jmpq   ffffffff80107ec6 <fork+0x216>
  }

  acquire_entry_lock();
ffffffff80107cd8:	31 c0                	xor    %eax,%eax
ffffffff80107cda:	88 c1                	mov    %al,%cl
ffffffff80107cdc:	88 c8                	mov    %cl,%al
ffffffff80107cde:	e8 dd 86 ff ff       	callq  ffffffff801003c0 <acquire_entry_lock>

  struct proc* parent = myproc();
ffffffff80107ce3:	e8 e8 01 00 00       	callq  ffffffff80107ed0 <myproc>
ffffffff80107ce8:	ba 30 00 00 00       	mov    $0x30,%edx
ffffffff80107ced:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  child->parent = parent;
ffffffff80107cf1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
ffffffff80107cf5:	48 8b 75 f0          	mov    -0x10(%rbp),%rsi
ffffffff80107cf9:	48 89 86 08 01 00 00 	mov    %rax,0x108(%rsi)

  // Dupe memory regions & VM.
  memmove(child->mem_regions, parent->mem_regions, sizeof(child->mem_regions));
ffffffff80107d00:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
ffffffff80107d04:	48 83 c0 08          	add    $0x8,%rax
ffffffff80107d08:	48 8b 75 e8          	mov    -0x18(%rbp),%rsi
ffffffff80107d0c:	48 83 c6 08          	add    $0x8,%rsi
ffffffff80107d10:	bf 30 00 00 00       	mov    $0x30,%edi
ffffffff80107d15:	89 7d e4             	mov    %edi,-0x1c(%rbp)
ffffffff80107d18:	48 89 c7             	mov    %rax,%rdi
ffffffff80107d1b:	44 8b 45 e4          	mov    -0x1c(%rbp),%r8d
ffffffff80107d1f:	89 55 e0             	mov    %edx,-0x20(%rbp)
ffffffff80107d22:	44 89 c2             	mov    %r8d,%edx
ffffffff80107d25:	e8 66 33 00 00       	callq  ffffffff8010b090 <memmove>

  child->pml4 = copyuvm(parent->pml4, parent->mem_regions, child->pid);
ffffffff80107d2a:	48 8b 75 e8          	mov    -0x18(%rbp),%rsi
ffffffff80107d2e:	48 8b 3e             	mov    (%rsi),%rdi
ffffffff80107d31:	48 8b 75 e8          	mov    -0x18(%rbp),%rsi
ffffffff80107d35:	48 83 c6 08          	add    $0x8,%rsi
ffffffff80107d39:	4c 8b 4d f0          	mov    -0x10(%rbp),%r9
ffffffff80107d3d:	41 8b 91 04 01 00 00 	mov    0x104(%r9),%edx
ffffffff80107d44:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
ffffffff80107d48:	e8 b3 d2 ff ff       	callq  ffffffff80105000 <copyuvm>
ffffffff80107d4d:	48 8b 75 f0          	mov    -0x10(%rbp),%rsi
ffffffff80107d51:	48 89 06             	mov    %rax,(%rsi)

  release_entry_lock();
ffffffff80107d54:	31 d2                	xor    %edx,%edx
ffffffff80107d56:	88 d1                	mov    %dl,%cl
ffffffff80107d58:	88 c8                	mov    %cl,%al
ffffffff80107d5a:	e8 81 86 ff ff       	callq  ffffffff801003e0 <release_entry_lock>

  if (child->pml4 == 0) {
ffffffff80107d5f:	48 8b 75 f0          	mov    -0x10(%rbp),%rsi
ffffffff80107d63:	48 83 3e 00          	cmpq   $0x0,(%rsi)
ffffffff80107d67:	0f 85 42 00 00 00    	jne    ffffffff80107daf <fork+0xff>
    // Error copying VM. Place child back into unallocated state.
    kfree(child->kstack);
ffffffff80107d6d:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
ffffffff80107d71:	48 8b b8 f8 00 00 00 	mov    0xf8(%rax),%rdi
ffffffff80107d78:	e8 f3 87 ff ff       	callq  ffffffff80100570 <kfree>
    acquire(&ptable.lock);
ffffffff80107d7d:	48 c7 c7 a8 82 1f 83 	mov    $0xffffffff831f82a8,%rdi
ffffffff80107d84:	e8 37 da ff ff       	callq  ffffffff801057c0 <acquire>
    child->state = UNUSED;
ffffffff80107d89:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
ffffffff80107d8d:	c7 80 00 01 00 00 00 	movl   $0x0,0x100(%rax)
ffffffff80107d94:	00 00 00 
    release(&ptable.lock);
ffffffff80107d97:	48 c7 c7 a8 82 1f 83 	mov    $0xffffffff831f82a8,%rdi
ffffffff80107d9e:	e8 5d dc ff ff       	callq  ffffffff80105a00 <release>
    return -1;
ffffffff80107da3:	c7 45 fc ff ff ff ff 	movl   $0xffffffff,-0x4(%rbp)
ffffffff80107daa:	e9 17 01 00 00       	jmpq   ffffffff80107ec6 <fork+0x216>
ffffffff80107daf:	b8 b0 00 00 00       	mov    $0xb0,%eax
ffffffff80107db4:	89 c1                	mov    %eax,%ecx
  }

  // Copy trap frame from parent, but overwrite the child's return value to be
  // zero.
  *child->tf = *parent->tf;
ffffffff80107db6:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
ffffffff80107dba:	48 8b 92 10 01 00 00 	mov    0x110(%rdx),%rdx
ffffffff80107dc1:	48 8b 75 e8          	mov    -0x18(%rbp),%rsi
ffffffff80107dc5:	48 8b b6 10 01 00 00 	mov    0x110(%rsi),%rsi
ffffffff80107dcc:	b8 b0 00 00 00       	mov    $0xb0,%eax
ffffffff80107dd1:	89 c7                	mov    %eax,%edi
ffffffff80107dd3:	48 89 7d d0          	mov    %rdi,-0x30(%rbp)
ffffffff80107dd7:	48 89 d7             	mov    %rdx,%rdi
ffffffff80107dda:	48 8b 55 d0          	mov    -0x30(%rbp),%rdx
ffffffff80107dde:	48 89 4d c8          	mov    %rcx,-0x38(%rbp)
ffffffff80107de2:	e8 a9 33 00 00       	callq  ffffffff8010b190 <memcpy>
  child->tf->rax = 0;
ffffffff80107de7:	48 8b 4d f0          	mov    -0x10(%rbp),%rcx
ffffffff80107deb:	48 8b 89 10 01 00 00 	mov    0x110(%rcx),%rcx
ffffffff80107df2:	48 c7 01 00 00 00 00 	movq   $0x0,(%rcx)
  kernel_duplicate_open_files(parent->open_files, child->open_files);
ffffffff80107df9:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
ffffffff80107dfd:	48 83 c1 38          	add    $0x38,%rcx
ffffffff80107e01:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
ffffffff80107e05:	48 83 c2 38          	add    $0x38,%rdx
ffffffff80107e09:	48 89 cf             	mov    %rcx,%rdi
ffffffff80107e0c:	48 89 d6             	mov    %rdx,%rsi
ffffffff80107e0f:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
ffffffff80107e13:	e8 88 5e 00 00       	callq  ffffffff8010dca0 <kernel_duplicate_open_files>

  if (parent->mapinfo.mapped_file != NULL) {
ffffffff80107e18:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
ffffffff80107e1c:	48 83 b8 e8 00 00 00 	cmpq   $0x0,0xe8(%rax)
ffffffff80107e23:	00 
ffffffff80107e24:	0f 84 31 00 00 00    	je     ffffffff80107e5b <fork+0x1ab>
    // Have the child share the parent's mapped file.
    kernel_duplicate_mapped_file(parent, child);
ffffffff80107e2a:	48 8b 7d e8          	mov    -0x18(%rbp),%rdi
ffffffff80107e2e:	48 8b 75 f0          	mov    -0x10(%rbp),%rsi
ffffffff80107e32:	e8 39 f9 ff ff       	callq  ffffffff80107770 <kernel_duplicate_mapped_file>
    child->mapinfo = parent->mapinfo;
ffffffff80107e37:	48 8b 75 f0          	mov    -0x10(%rbp),%rsi
ffffffff80107e3b:	48 8b 7d e8          	mov    -0x18(%rbp),%rdi
ffffffff80107e3f:	48 8b 87 e8 00 00 00 	mov    0xe8(%rdi),%rax
ffffffff80107e46:	48 89 86 e8 00 00 00 	mov    %rax,0xe8(%rsi)
ffffffff80107e4d:	48 8b 87 f0 00 00 00 	mov    0xf0(%rdi),%rax
ffffffff80107e54:	48 89 86 f0 00 00 00 	mov    %rax,0xf0(%rsi)
ffffffff80107e5b:	b8 10 00 00 00       	mov    $0x10,%eax
  }

  safestrcpy(child->name, parent->name, sizeof(child->name));
ffffffff80107e60:	48 8b 4d f0          	mov    -0x10(%rbp),%rcx
ffffffff80107e64:	48 81 c1 2c 01 00 00 	add    $0x12c,%rcx
ffffffff80107e6b:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
ffffffff80107e6f:	48 81 c2 2c 01 00 00 	add    $0x12c,%rdx
ffffffff80107e76:	be 10 00 00 00       	mov    $0x10,%esi
ffffffff80107e7b:	48 89 cf             	mov    %rcx,%rdi
ffffffff80107e7e:	89 75 bc             	mov    %esi,-0x44(%rbp)
ffffffff80107e81:	48 89 d6             	mov    %rdx,%rsi
ffffffff80107e84:	8b 55 bc             	mov    -0x44(%rbp),%edx
ffffffff80107e87:	89 45 b8             	mov    %eax,-0x48(%rbp)
ffffffff80107e8a:	e8 b1 34 00 00       	callq  ffffffff8010b340 <safestrcpy>

  acquire(&ptable.lock);
ffffffff80107e8f:	48 c7 c7 a8 82 1f 83 	mov    $0xffffffff831f82a8,%rdi
ffffffff80107e96:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
ffffffff80107e9a:	e8 21 d9 ff ff       	callq  ffffffff801057c0 <acquire>
  child->state = RUNNABLE;
ffffffff80107e9f:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
ffffffff80107ea3:	c7 80 00 01 00 00 03 	movl   $0x3,0x100(%rax)
ffffffff80107eaa:	00 00 00 
  release(&ptable.lock);
ffffffff80107ead:	48 c7 c7 a8 82 1f 83 	mov    $0xffffffff831f82a8,%rdi
ffffffff80107eb4:	e8 47 db ff ff       	callq  ffffffff80105a00 <release>

  return child->pid;
ffffffff80107eb9:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
ffffffff80107ebd:	8b 90 04 01 00 00    	mov    0x104(%rax),%edx
ffffffff80107ec3:	89 55 fc             	mov    %edx,-0x4(%rbp)
}
ffffffff80107ec6:	8b 45 fc             	mov    -0x4(%rbp),%eax
ffffffff80107ec9:	48 83 c4 50          	add    $0x50,%rsp
ffffffff80107ecd:	5d                   	pop    %rbp
ffffffff80107ece:	c3                   	retq   
ffffffff80107ecf:	90                   	nop

ffffffff80107ed0 <myproc>:
{
ffffffff80107ed0:	55                   	push   %rbp
ffffffff80107ed1:	48 89 e5             	mov    %rsp,%rbp
  return mycpu()->proc;
ffffffff80107ed4:	e8 27 07 00 00       	callq  ffffffff80108600 <mycpu>
ffffffff80107ed9:	48 8b 80 d0 00 00 00 	mov    0xd0(%rax),%rax
ffffffff80107ee0:	5d                   	pop    %rbp
ffffffff80107ee1:	c3                   	retq   
ffffffff80107ee2:	66 66 66 66 66 2e 0f 	data16 data16 data16 data16 nopw %cs:0x0(%rax,%rax,1)
ffffffff80107ee9:	1f 84 00 00 00 00 00 

ffffffff80107ef0 <clean_open_files>:

// Assumes ptable lock is held
void
clean_open_files(struct open_file files[])
{
ffffffff80107ef0:	55                   	push   %rbp
ffffffff80107ef1:	48 89 e5             	mov    %rsp,%rbp
ffffffff80107ef4:	48 83 ec 10          	sub    $0x10,%rsp
ffffffff80107ef8:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  for (int i = 0; i < NOFILE; i++) {
ffffffff80107efc:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)
ffffffff80107f03:	83 7d f4 10          	cmpl   $0x10,-0xc(%rbp)
ffffffff80107f07:	0f 8d 3a 00 00 00    	jge    ffffffff80107f47 <clean_open_files+0x57>
    if (files[i].type != FILE_UNUSED) {
ffffffff80107f0d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
ffffffff80107f11:	48 63 4d f4          	movslq -0xc(%rbp),%rcx
ffffffff80107f15:	48 6b c9 0b          	imul   $0xb,%rcx,%rcx
ffffffff80107f19:	48 01 c8             	add    %rcx,%rax
ffffffff80107f1c:	0f be 50 0a          	movsbl 0xa(%rax),%edx
ffffffff80107f20:	83 fa 00             	cmp    $0x0,%edx
ffffffff80107f23:	0f 84 0b 00 00 00    	je     ffffffff80107f34 <clean_open_files+0x44>
      kernel_sys_close(i);
ffffffff80107f29:	8b 7d f4             	mov    -0xc(%rbp),%edi
ffffffff80107f2c:	e8 4f 55 00 00       	callq  ffffffff8010d480 <kernel_sys_close>
ffffffff80107f31:	89 45 f0             	mov    %eax,-0x10(%rbp)
    }
  }
ffffffff80107f34:	e9 00 00 00 00       	jmpq   ffffffff80107f39 <clean_open_files+0x49>
  for (int i = 0; i < NOFILE; i++) {
ffffffff80107f39:	8b 45 f4             	mov    -0xc(%rbp),%eax
ffffffff80107f3c:	83 c0 01             	add    $0x1,%eax
ffffffff80107f3f:	89 45 f4             	mov    %eax,-0xc(%rbp)
ffffffff80107f42:	e9 bc ff ff ff       	jmpq   ffffffff80107f03 <clean_open_files+0x13>
}
ffffffff80107f47:	48 83 c4 10          	add    $0x10,%rsp
ffffffff80107f4b:	5d                   	pop    %rbp
ffffffff80107f4c:	c3                   	retq   
ffffffff80107f4d:	0f 1f 00             	nopl   (%rax)

ffffffff80107f50 <exit>:
// Exit the current process.  Does not return.
// An exited process remains in the zombie state
// until its parent calls wait() to find out it exited.
void
exit(void)
{
ffffffff80107f50:	55                   	push   %rbp
ffffffff80107f51:	48 89 e5             	mov    %rsp,%rbp
  struct proc* this_proc = myproc();
ffffffff80107f54:	48 83 ec 20          	sub    $0x20,%rsp
ffffffff80107f58:	e8 73 ff ff ff       	callq  ffffffff80107ed0 <myproc>
ffffffff80107f5d:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  clean_open_files(this_proc->open_files);
ffffffff80107f61:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
ffffffff80107f65:	48 83 c0 38          	add    $0x38,%rax
ffffffff80107f69:	48 89 c7             	mov    %rax,%rdi
ffffffff80107f6c:	e8 7f ff ff ff       	callq  ffffffff80107ef0 <clean_open_files>

  if (this_proc->mapinfo.mapped_file != NULL) {
ffffffff80107f71:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
ffffffff80107f75:	48 83 b8 e8 00 00 00 	cmpq   $0x0,0xe8(%rax)
ffffffff80107f7c:	00 
ffffffff80107f7d:	0f 84 21 00 00 00    	je     ffffffff80107fa4 <exit+0x54>
    kernel_munmap(this_proc->mapinfo.fd);
ffffffff80107f83:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
ffffffff80107f87:	8b b8 f0 00 00 00    	mov    0xf0(%rax),%edi
ffffffff80107f8d:	e8 ce 56 00 00       	callq  ffffffff8010d660 <kernel_munmap>
    this_proc->mapinfo.mapped_file = NULL;
ffffffff80107f92:	48 8b 4d f8          	mov    -0x8(%rbp),%rcx
ffffffff80107f96:	48 c7 81 e8 00 00 00 	movq   $0x0,0xe8(%rcx)
ffffffff80107f9d:	00 00 00 00 
ffffffff80107fa1:	89 45 ec             	mov    %eax,-0x14(%rbp)
  }

  acquire(&ptable.lock);
ffffffff80107fa4:	48 c7 c7 a8 82 1f 83 	mov    $0xffffffff831f82a8,%rdi
ffffffff80107fab:	e8 10 d8 ff ff       	callq  ffffffff801057c0 <acquire>

  this_proc->state = ZOMBIE;
ffffffff80107fb0:	48 8b 7d f8          	mov    -0x8(%rbp),%rdi
ffffffff80107fb4:	c7 87 00 01 00 00 05 	movl   $0x5,0x100(%rdi)
ffffffff80107fbb:	00 00 00 
  // Might be exiting due to being killed. Flip that back off.
  this_proc->killed = 0;
ffffffff80107fbe:	48 8b 7d f8          	mov    -0x8(%rbp),%rdi
ffffffff80107fc2:	c7 87 28 01 00 00 00 	movl   $0x0,0x128(%rdi)
ffffffff80107fc9:	00 00 00 

  struct proc* this_parent = this_proc->parent;
ffffffff80107fcc:	48 8b 7d f8          	mov    -0x8(%rbp),%rdi
ffffffff80107fd0:	48 8b bf 08 01 00 00 	mov    0x108(%rdi),%rdi
ffffffff80107fd7:	48 89 7d f0          	mov    %rdi,-0x10(%rbp)
  if (this_parent->state == UNUSED || this_parent->state == ZOMBIE) {
ffffffff80107fdb:	48 8b 7d f0          	mov    -0x10(%rbp),%rdi
ffffffff80107fdf:	83 bf 00 01 00 00 00 	cmpl   $0x0,0x100(%rdi)
ffffffff80107fe6:	0f 84 11 00 00 00    	je     ffffffff80107ffd <exit+0xad>
ffffffff80107fec:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
ffffffff80107ff0:	83 b8 00 01 00 00 05 	cmpl   $0x5,0x100(%rax)
ffffffff80107ff7:	0f 85 13 00 00 00    	jne    ffffffff80108010 <exit+0xc0>
    this_proc->parent = initproc;
ffffffff80107ffd:	48 8b 04 25 88 64 1f 	mov    0xffffffff831f6488,%rax
ffffffff80108004:	83 
ffffffff80108005:	48 8b 4d f8          	mov    -0x8(%rbp),%rcx
ffffffff80108009:	48 89 81 08 01 00 00 	mov    %rax,0x108(%rcx)
  }

  wakeup1(this_proc->parent);
ffffffff80108010:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
ffffffff80108014:	48 8b 80 08 01 00 00 	mov    0x108(%rax),%rax
ffffffff8010801b:	48 89 c7             	mov    %rax,%rdi
ffffffff8010801e:	e8 1d 00 00 00       	callq  ffffffff80108040 <wakeup1>
  sched();
ffffffff80108023:	e8 a8 00 00 00       	callq  ffffffff801080d0 <sched>

  release(&ptable.lock);
ffffffff80108028:	48 c7 c7 a8 82 1f 83 	mov    $0xffffffff831f82a8,%rdi
ffffffff8010802f:	e8 cc d9 ff ff       	callq  ffffffff80105a00 <release>
}
ffffffff80108034:	48 83 c4 20          	add    $0x20,%rsp
ffffffff80108038:	5d                   	pop    %rbp
ffffffff80108039:	c3                   	retq   
ffffffff8010803a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)

ffffffff80108040 <wakeup1>:
//PAGEBREAK!
// Wake up all processes sleeping on chan.
// The ptable lock must be held.
static void
wakeup1(void *chan)
{
ffffffff80108040:	55                   	push   %rbp
ffffffff80108041:	48 89 e5             	mov    %rsp,%rbp
ffffffff80108044:	48 83 ec 18          	sub    $0x18,%rsp
ffffffff80108048:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  struct proc *p;

  for(p = ptable.proc; p < &ptable.proc[NPROC]; p++)
ffffffff8010804c:	48 c7 45 f0 10 83 1f 	movq   $0xffffffff831f8310,-0x10(%rbp)
ffffffff80108053:	83 
ffffffff80108054:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
ffffffff80108058:	48 c7 c1 10 d3 1f 83 	mov    $0xffffffff831fd310,%rcx
ffffffff8010805f:	48 29 c8             	sub    %rcx,%rax
ffffffff80108062:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
ffffffff80108066:	0f 83 51 00 00 00    	jae    ffffffff801080bd <wakeup1+0x7d>
ffffffff8010806c:	e9 00 00 00 00       	jmpq   ffffffff80108071 <wakeup1+0x31>
    if(p->state == SLEEPING && p->chan == chan)
ffffffff80108071:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
ffffffff80108075:	83 b8 00 01 00 00 02 	cmpl   $0x2,0x100(%rax)
ffffffff8010807c:	0f 85 23 00 00 00    	jne    ffffffff801080a5 <wakeup1+0x65>
ffffffff80108082:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
ffffffff80108086:	48 8b 80 20 01 00 00 	mov    0x120(%rax),%rax
ffffffff8010808d:	48 3b 45 f8          	cmp    -0x8(%rbp),%rax
ffffffff80108091:	0f 85 0e 00 00 00    	jne    ffffffff801080a5 <wakeup1+0x65>
      p->state = RUNNABLE;
ffffffff80108097:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
ffffffff8010809b:	c7 80 00 01 00 00 03 	movl   $0x3,0x100(%rax)
ffffffff801080a2:	00 00 00 
    if(p->state == SLEEPING && p->chan == chan)
ffffffff801080a5:	e9 00 00 00 00       	jmpq   ffffffff801080aa <wakeup1+0x6a>
  for(p = ptable.proc; p < &ptable.proc[NPROC]; p++)
ffffffff801080aa:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
ffffffff801080ae:	48 05 40 01 00 00    	add    $0x140,%rax
ffffffff801080b4:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
ffffffff801080b8:	e9 97 ff ff ff       	jmpq   ffffffff80108054 <wakeup1+0x14>
}
ffffffff801080bd:	48 83 c4 18          	add    $0x18,%rsp
ffffffff801080c1:	5d                   	pop    %rbp
ffffffff801080c2:	c3                   	retq   
ffffffff801080c3:	66 66 66 66 2e 0f 1f 	data16 data16 data16 nopw %cs:0x0(%rax,%rax,1)
ffffffff801080ca:	84 00 00 00 00 00 

ffffffff801080d0 <sched>:
{
ffffffff801080d0:	55                   	push   %rbp
ffffffff801080d1:	48 89 e5             	mov    %rsp,%rbp
  if(!holding(&ptable.lock))
ffffffff801080d4:	48 83 ec 20          	sub    $0x20,%rsp
ffffffff801080d8:	48 c7 c7 a8 82 1f 83 	mov    $0xffffffff831f82a8,%rdi
ffffffff801080df:	e8 cc d7 ff ff       	callq  ffffffff801058b0 <holding>
ffffffff801080e4:	83 f8 00             	cmp    $0x0,%eax
ffffffff801080e7:	0f 85 0c 00 00 00    	jne    ffffffff801080f9 <sched+0x29>
    panic("sched ptable.lock");
ffffffff801080ed:	48 c7 c7 1c 01 11 80 	mov    $0xffffffff8011011c,%rdi
ffffffff801080f4:	e8 77 8d ff ff       	callq  ffffffff80100e70 <panic>
  if(mycpu()->ncli != 1) {
ffffffff801080f9:	e8 02 05 00 00       	callq  ffffffff80108600 <mycpu>
ffffffff801080fe:	83 b8 bc 00 00 00 01 	cmpl   $0x1,0xbc(%rax)
ffffffff80108105:	0f 84 63 00 00 00    	je     ffffffff8010816e <sched+0x9e>
    cprintf("pid : %d\n", myproc()->pid);
ffffffff8010810b:	e8 c0 fd ff ff       	callq  ffffffff80107ed0 <myproc>
ffffffff80108110:	8b b0 04 01 00 00    	mov    0x104(%rax),%esi
ffffffff80108116:	48 c7 c7 2e 01 11 80 	mov    $0xffffffff8011012e,%rdi
ffffffff8010811d:	31 c9                	xor    %ecx,%ecx
ffffffff8010811f:	88 ca                	mov    %cl,%dl
ffffffff80108121:	88 d0                	mov    %dl,%al
ffffffff80108123:	e8 38 88 ff ff       	callq  ffffffff80100960 <cprintf>
    cprintf("ncli : %d\n", mycpu()->ncli);
ffffffff80108128:	e8 d3 04 00 00       	callq  ffffffff80108600 <mycpu>
ffffffff8010812d:	8b b0 bc 00 00 00    	mov    0xbc(%rax),%esi
ffffffff80108133:	48 c7 c7 38 01 11 80 	mov    $0xffffffff80110138,%rdi
ffffffff8010813a:	31 c9                	xor    %ecx,%ecx
ffffffff8010813c:	88 ca                	mov    %cl,%dl
ffffffff8010813e:	88 d0                	mov    %dl,%al
ffffffff80108140:	e8 1b 88 ff ff       	callq  ffffffff80100960 <cprintf>
    cprintf("intena : %d\n", mycpu()->intena);
ffffffff80108145:	e8 b6 04 00 00       	callq  ffffffff80108600 <mycpu>
ffffffff8010814a:	8b b0 c0 00 00 00    	mov    0xc0(%rax),%esi
ffffffff80108150:	48 c7 c7 43 01 11 80 	mov    $0xffffffff80110143,%rdi
ffffffff80108157:	31 c9                	xor    %ecx,%ecx
ffffffff80108159:	88 ca                	mov    %cl,%dl
ffffffff8010815b:	88 d0                	mov    %dl,%al
ffffffff8010815d:	e8 fe 87 ff ff       	callq  ffffffff80100960 <cprintf>
    panic("sched locks");
ffffffff80108162:	48 c7 c7 50 01 11 80 	mov    $0xffffffff80110150,%rdi
ffffffff80108169:	e8 02 8d ff ff       	callq  ffffffff80100e70 <panic>
  if(myproc()->state == RUNNING)
ffffffff8010816e:	e8 5d fd ff ff       	callq  ffffffff80107ed0 <myproc>
ffffffff80108173:	83 b8 00 01 00 00 04 	cmpl   $0x4,0x100(%rax)
ffffffff8010817a:	0f 85 0c 00 00 00    	jne    ffffffff8010818c <sched+0xbc>
    panic("sched running");
ffffffff80108180:	48 c7 c7 5c 01 11 80 	mov    $0xffffffff8011015c,%rdi
ffffffff80108187:	e8 e4 8c ff ff       	callq  ffffffff80100e70 <panic>
  if(readeflags()&FLAGS_IF)
ffffffff8010818c:	e8 7f 04 00 00       	callq  ffffffff80108610 <readeflags>
ffffffff80108191:	48 25 00 02 00 00    	and    $0x200,%rax
ffffffff80108197:	48 83 f8 00          	cmp    $0x0,%rax
ffffffff8010819b:	0f 84 0c 00 00 00    	je     ffffffff801081ad <sched+0xdd>
    panic("sched interruptible");
ffffffff801081a1:	48 c7 c7 6a 01 11 80 	mov    $0xffffffff8011016a,%rdi
ffffffff801081a8:	e8 c3 8c ff ff       	callq  ffffffff80100e70 <panic>
  intena = mycpu()->intena;
ffffffff801081ad:	e8 4e 04 00 00       	callq  ffffffff80108600 <mycpu>
ffffffff801081b2:	8b 88 c0 00 00 00    	mov    0xc0(%rax),%ecx
ffffffff801081b8:	89 4d fc             	mov    %ecx,-0x4(%rbp)
  swtch(&myproc()->context, mycpu()->scheduler);
ffffffff801081bb:	e8 10 fd ff ff       	callq  ffffffff80107ed0 <myproc>
ffffffff801081c0:	48 05 18 01 00 00    	add    $0x118,%rax
ffffffff801081c6:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
ffffffff801081ca:	e8 31 04 00 00       	callq  ffffffff80108600 <mycpu>
ffffffff801081cf:	48 8b 70 08          	mov    0x8(%rax),%rsi
ffffffff801081d3:	48 8b 7d f0          	mov    -0x10(%rbp),%rdi
ffffffff801081d7:	e8 d0 09 00 00       	callq  ffffffff80108bac <swtch>
  mycpu()->intena = intena;
ffffffff801081dc:	8b 4d fc             	mov    -0x4(%rbp),%ecx
ffffffff801081df:	89 4d ec             	mov    %ecx,-0x14(%rbp)
ffffffff801081e2:	e8 19 04 00 00       	callq  ffffffff80108600 <mycpu>
ffffffff801081e7:	8b 4d ec             	mov    -0x14(%rbp),%ecx
ffffffff801081ea:	89 88 c0 00 00 00    	mov    %ecx,0xc0(%rax)
}
ffffffff801081f0:	48 83 c4 20          	add    $0x20,%rsp
ffffffff801081f4:	5d                   	pop    %rbp
ffffffff801081f5:	c3                   	retq   
ffffffff801081f6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
ffffffff801081fd:	00 00 00 

ffffffff80108200 <wait>:
{
ffffffff80108200:	55                   	push   %rbp
ffffffff80108201:	48 89 e5             	mov    %rsp,%rbp
  struct proc* this_proc = myproc();
ffffffff80108204:	48 83 ec 20          	sub    $0x20,%rsp
ffffffff80108208:	e8 c3 fc ff ff       	callq  ffffffff80107ed0 <myproc>
ffffffff8010820d:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  acquire(&ptable.lock);
ffffffff80108211:	48 c7 c7 a8 82 1f 83 	mov    $0xffffffff831f82a8,%rdi
ffffffff80108218:	e8 a3 d5 ff ff       	callq  ffffffff801057c0 <acquire>
  if (!has_active_children(this_proc)) {
ffffffff8010821d:	48 8b 7d f0          	mov    -0x10(%rbp),%rdi
ffffffff80108221:	e8 ba 00 00 00       	callq  ffffffff801082e0 <has_active_children>
ffffffff80108226:	a8 01                	test   $0x1,%al
ffffffff80108228:	0f 85 18 00 00 00    	jne    ffffffff80108246 <wait+0x46>
    release(&ptable.lock);
ffffffff8010822e:	48 c7 c7 a8 82 1f 83 	mov    $0xffffffff831f82a8,%rdi
ffffffff80108235:	e8 c6 d7 ff ff       	callq  ffffffff80105a00 <release>
    return -1;
ffffffff8010823a:	c7 45 fc ff ff ff ff 	movl   $0xffffffff,-0x4(%rbp)
ffffffff80108241:	e9 8a 00 00 00       	jmpq   ffffffff801082d0 <wait+0xd0>
  while ((zombie_child = first_zombie_child(this_proc)) == NULL) {
ffffffff80108246:	48 8b 7d f0          	mov    -0x10(%rbp),%rdi
ffffffff8010824a:	e8 21 01 00 00       	callq  ffffffff80108370 <first_zombie_child>
ffffffff8010824f:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
ffffffff80108253:	48 83 f8 00          	cmp    $0x0,%rax
ffffffff80108257:	0f 85 18 00 00 00    	jne    ffffffff80108275 <wait+0x75>
    sleep(this_proc, &ptable.lock);
ffffffff8010825d:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
ffffffff80108261:	48 c7 c6 a8 82 1f 83 	mov    $0xffffffff831f82a8,%rsi
ffffffff80108268:	48 89 c7             	mov    %rax,%rdi
ffffffff8010826b:	e8 b0 01 00 00       	callq  ffffffff80108420 <sleep>
  while ((zombie_child = first_zombie_child(this_proc)) == NULL) {
ffffffff80108270:	e9 d1 ff ff ff       	jmpq   ffffffff80108246 <wait+0x46>
  kfree(zombie_child->kstack);
ffffffff80108275:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
ffffffff80108279:	48 8b b8 f8 00 00 00 	mov    0xf8(%rax),%rdi
ffffffff80108280:	e8 eb 82 ff ff       	callq  ffffffff80100570 <kfree>
  zombie_child->kstack = NULL;
ffffffff80108285:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
ffffffff80108289:	48 c7 80 f8 00 00 00 	movq   $0x0,0xf8(%rax)
ffffffff80108290:	00 00 00 00 
  int zombie_pid = zombie_child->pid;
ffffffff80108294:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
ffffffff80108298:	8b 88 04 01 00 00    	mov    0x104(%rax),%ecx
ffffffff8010829e:	89 4d e4             	mov    %ecx,-0x1c(%rbp)
  freevm(zombie_child->pml4, zombie_pid);
ffffffff801082a1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
ffffffff801082a5:	48 8b 38             	mov    (%rax),%rdi
ffffffff801082a8:	8b 75 e4             	mov    -0x1c(%rbp),%esi
ffffffff801082ab:	e8 a0 c6 ff ff       	callq  ffffffff80104950 <freevm>
  zombie_child->state = UNUSED;
ffffffff801082b0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
ffffffff801082b4:	c7 80 00 01 00 00 00 	movl   $0x0,0x100(%rax)
ffffffff801082bb:	00 00 00 
  release(&ptable.lock);
ffffffff801082be:	48 c7 c7 a8 82 1f 83 	mov    $0xffffffff831f82a8,%rdi
ffffffff801082c5:	e8 36 d7 ff ff       	callq  ffffffff80105a00 <release>
  return zombie_pid;
ffffffff801082ca:	8b 4d e4             	mov    -0x1c(%rbp),%ecx
ffffffff801082cd:	89 4d fc             	mov    %ecx,-0x4(%rbp)
}
ffffffff801082d0:	8b 45 fc             	mov    -0x4(%rbp),%eax
ffffffff801082d3:	48 83 c4 20          	add    $0x20,%rsp
ffffffff801082d7:	5d                   	pop    %rbp
ffffffff801082d8:	c3                   	retq   
ffffffff801082d9:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)

ffffffff801082e0 <has_active_children>:
{
ffffffff801082e0:	55                   	push   %rbp
ffffffff801082e1:	48 89 e5             	mov    %rsp,%rbp
ffffffff801082e4:	48 83 ec 18          	sub    $0x18,%rsp
ffffffff801082e8:	48 89 7d f0          	mov    %rdi,-0x10(%rbp)
  for (int i = 1; i < NPROC; i++) {
ffffffff801082ec:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%rbp)
ffffffff801082f3:	83 7d ec 40          	cmpl   $0x40,-0x14(%rbp)
ffffffff801082f7:	0f 8d 60 00 00 00    	jge    ffffffff8010835d <has_active_children+0x7d>
    if (ptable.proc[i].parent == this_proc
ffffffff801082fd:	48 63 45 ec          	movslq -0x14(%rbp),%rax
ffffffff80108301:	48 8d 04 80          	lea    (%rax,%rax,4),%rax
ffffffff80108305:	48 c1 e0 06          	shl    $0x6,%rax
ffffffff80108309:	48 8d 80 10 83 1f 83 	lea    -0x7ce07cf0(%rax),%rax
ffffffff80108310:	48 8b 80 08 01 00 00 	mov    0x108(%rax),%rax
ffffffff80108317:	48 3b 45 f0          	cmp    -0x10(%rbp),%rax
     && ptable.proc[i].state != UNUSED) {
ffffffff8010831b:	0f 85 29 00 00 00    	jne    ffffffff8010834a <has_active_children+0x6a>
ffffffff80108321:	48 63 45 ec          	movslq -0x14(%rbp),%rax
ffffffff80108325:	48 8d 04 80          	lea    (%rax,%rax,4),%rax
ffffffff80108329:	48 c1 e0 06          	shl    $0x6,%rax
ffffffff8010832d:	48 8d 80 10 83 1f 83 	lea    -0x7ce07cf0(%rax),%rax
ffffffff80108334:	83 b8 00 01 00 00 00 	cmpl   $0x0,0x100(%rax)
    if (ptable.proc[i].parent == this_proc
ffffffff8010833b:	0f 84 09 00 00 00    	je     ffffffff8010834a <has_active_children+0x6a>
      return true;
ffffffff80108341:	c6 45 ff 01          	movb   $0x1,-0x1(%rbp)
ffffffff80108345:	e9 17 00 00 00       	jmpq   ffffffff80108361 <has_active_children+0x81>
  }
ffffffff8010834a:	e9 00 00 00 00       	jmpq   ffffffff8010834f <has_active_children+0x6f>
  for (int i = 1; i < NPROC; i++) {
ffffffff8010834f:	8b 45 ec             	mov    -0x14(%rbp),%eax
ffffffff80108352:	83 c0 01             	add    $0x1,%eax
ffffffff80108355:	89 45 ec             	mov    %eax,-0x14(%rbp)
ffffffff80108358:	e9 96 ff ff ff       	jmpq   ffffffff801082f3 <has_active_children+0x13>
  return false;
ffffffff8010835d:	c6 45 ff 00          	movb   $0x0,-0x1(%rbp)
}
ffffffff80108361:	8a 45 ff             	mov    -0x1(%rbp),%al
ffffffff80108364:	24 01                	and    $0x1,%al
ffffffff80108366:	0f b6 c0             	movzbl %al,%eax
ffffffff80108369:	48 83 c4 18          	add    $0x18,%rsp
ffffffff8010836d:	5d                   	pop    %rbp
ffffffff8010836e:	c3                   	retq   
ffffffff8010836f:	90                   	nop

ffffffff80108370 <first_zombie_child>:
{
ffffffff80108370:	55                   	push   %rbp
ffffffff80108371:	48 89 e5             	mov    %rsp,%rbp
ffffffff80108374:	48 83 ec 18          	sub    $0x18,%rsp
ffffffff80108378:	48 89 7d f0          	mov    %rdi,-0x10(%rbp)
  for (int i = 1; i < NPROC; i++) {
ffffffff8010837c:	c7 45 ec 01 00 00 00 	movl   $0x1,-0x14(%rbp)
ffffffff80108383:	83 7d ec 40          	cmpl   $0x40,-0x14(%rbp)
ffffffff80108387:	0f 8d 73 00 00 00    	jge    ffffffff80108400 <first_zombie_child+0x90>
    if (ptable.proc[i].parent == this_proc
ffffffff8010838d:	48 63 45 ec          	movslq -0x14(%rbp),%rax
ffffffff80108391:	48 8d 04 80          	lea    (%rax,%rax,4),%rax
ffffffff80108395:	48 c1 e0 06          	shl    $0x6,%rax
ffffffff80108399:	48 8d 80 10 83 1f 83 	lea    -0x7ce07cf0(%rax),%rax
ffffffff801083a0:	48 8b 80 08 01 00 00 	mov    0x108(%rax),%rax
ffffffff801083a7:	48 3b 45 f0          	cmp    -0x10(%rbp),%rax
        && ptable.proc[i].state == ZOMBIE) {
ffffffff801083ab:	0f 85 3c 00 00 00    	jne    ffffffff801083ed <first_zombie_child+0x7d>
ffffffff801083b1:	48 63 45 ec          	movslq -0x14(%rbp),%rax
ffffffff801083b5:	48 8d 04 80          	lea    (%rax,%rax,4),%rax
ffffffff801083b9:	48 c1 e0 06          	shl    $0x6,%rax
ffffffff801083bd:	48 8d 80 10 83 1f 83 	lea    -0x7ce07cf0(%rax),%rax
ffffffff801083c4:	83 b8 00 01 00 00 05 	cmpl   $0x5,0x100(%rax)
    if (ptable.proc[i].parent == this_proc
ffffffff801083cb:	0f 85 1c 00 00 00    	jne    ffffffff801083ed <first_zombie_child+0x7d>
      return &ptable.proc[i];
ffffffff801083d1:	48 63 45 ec          	movslq -0x14(%rbp),%rax
ffffffff801083d5:	48 8d 04 80          	lea    (%rax,%rax,4),%rax
ffffffff801083d9:	48 c1 e0 06          	shl    $0x6,%rax
ffffffff801083dd:	48 8d 80 10 83 1f 83 	lea    -0x7ce07cf0(%rax),%rax
ffffffff801083e4:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
ffffffff801083e8:	e9 1b 00 00 00       	jmpq   ffffffff80108408 <first_zombie_child+0x98>
  }
ffffffff801083ed:	e9 00 00 00 00       	jmpq   ffffffff801083f2 <first_zombie_child+0x82>
  for (int i = 1; i < NPROC; i++) {
ffffffff801083f2:	8b 45 ec             	mov    -0x14(%rbp),%eax
ffffffff801083f5:	83 c0 01             	add    $0x1,%eax
ffffffff801083f8:	89 45 ec             	mov    %eax,-0x14(%rbp)
ffffffff801083fb:	e9 83 ff ff ff       	jmpq   ffffffff80108383 <first_zombie_child+0x13>
  return NULL;
ffffffff80108400:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
ffffffff80108407:	00 
}
ffffffff80108408:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
ffffffff8010840c:	48 83 c4 18          	add    $0x18,%rsp
ffffffff80108410:	5d                   	pop    %rbp
ffffffff80108411:	c3                   	retq   
ffffffff80108412:	66 66 66 66 66 2e 0f 	data16 data16 data16 data16 nopw %cs:0x0(%rax,%rax,1)
ffffffff80108419:	1f 84 00 00 00 00 00 

ffffffff80108420 <sleep>:
{
ffffffff80108420:	55                   	push   %rbp
ffffffff80108421:	48 89 e5             	mov    %rsp,%rbp
ffffffff80108424:	48 83 ec 30          	sub    $0x30,%rsp
ffffffff80108428:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
ffffffff8010842c:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  if(myproc() == 0)
ffffffff80108430:	e8 9b fa ff ff       	callq  ffffffff80107ed0 <myproc>
ffffffff80108435:	48 83 f8 00          	cmp    $0x0,%rax
ffffffff80108439:	0f 85 0c 00 00 00    	jne    ffffffff8010844b <sleep+0x2b>
    panic("sleep");
ffffffff8010843f:	48 c7 c7 7e 01 11 80 	mov    $0xffffffff8011017e,%rdi
ffffffff80108446:	e8 25 8a ff ff       	callq  ffffffff80100e70 <panic>
  if(lk == 0)
ffffffff8010844b:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
ffffffff80108450:	0f 85 0c 00 00 00    	jne    ffffffff80108462 <sleep+0x42>
    panic("sleep without lk");
ffffffff80108456:	48 c7 c7 84 01 11 80 	mov    $0xffffffff80110184,%rdi
ffffffff8010845d:	e8 0e 8a ff ff       	callq  ffffffff80100e70 <panic>
  if(lk != &ptable.lock){  //DOC: sleeplock0
ffffffff80108462:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
ffffffff80108466:	48 c7 c1 a8 82 1f 83 	mov    $0xffffffff831f82a8,%rcx
ffffffff8010846d:	48 29 c8             	sub    %rcx,%rax
ffffffff80108470:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
ffffffff80108474:	0f 84 1a 00 00 00    	je     ffffffff80108494 <sleep+0x74>
ffffffff8010847a:	e9 00 00 00 00       	jmpq   ffffffff8010847f <sleep+0x5f>
    acquire(&ptable.lock);  //DOC: sleeplock1
ffffffff8010847f:	48 c7 c7 a8 82 1f 83 	mov    $0xffffffff831f82a8,%rdi
ffffffff80108486:	e8 35 d3 ff ff       	callq  ffffffff801057c0 <acquire>
    release(lk);
ffffffff8010848b:	48 8b 7d f0          	mov    -0x10(%rbp),%rdi
ffffffff8010848f:	e8 6c d5 ff ff       	callq  ffffffff80105a00 <release>
  myproc()->chan = chan;
ffffffff80108494:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
ffffffff80108498:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
ffffffff8010849c:	e8 2f fa ff ff       	callq  ffffffff80107ed0 <myproc>
ffffffff801084a1:	48 8b 4d e0          	mov    -0x20(%rbp),%rcx
ffffffff801084a5:	48 89 88 20 01 00 00 	mov    %rcx,0x120(%rax)
  myproc()->state = SLEEPING;
ffffffff801084ac:	e8 1f fa ff ff       	callq  ffffffff80107ed0 <myproc>
ffffffff801084b1:	c7 80 00 01 00 00 02 	movl   $0x2,0x100(%rax)
ffffffff801084b8:	00 00 00 
  sched();
ffffffff801084bb:	e8 10 fc ff ff       	callq  ffffffff801080d0 <sched>
  myproc()->chan = 0;
ffffffff801084c0:	e8 0b fa ff ff       	callq  ffffffff80107ed0 <myproc>
ffffffff801084c5:	48 c7 80 20 01 00 00 	movq   $0x0,0x120(%rax)
ffffffff801084cc:	00 00 00 00 
  if(lk != &ptable.lock){  //DOC: sleeplock2
ffffffff801084d0:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
ffffffff801084d4:	48 c7 c1 a8 82 1f 83 	mov    $0xffffffff831f82a8,%rcx
ffffffff801084db:	48 29 c8             	sub    %rcx,%rax
ffffffff801084de:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
ffffffff801084e2:	0f 84 1a 00 00 00    	je     ffffffff80108502 <sleep+0xe2>
ffffffff801084e8:	e9 00 00 00 00       	jmpq   ffffffff801084ed <sleep+0xcd>
    release(&ptable.lock);
ffffffff801084ed:	48 c7 c7 a8 82 1f 83 	mov    $0xffffffff831f82a8,%rdi
ffffffff801084f4:	e8 07 d5 ff ff       	callq  ffffffff80105a00 <release>
    acquire(lk);
ffffffff801084f9:	48 8b 7d f0          	mov    -0x10(%rbp),%rdi
ffffffff801084fd:	e8 be d2 ff ff       	callq  ffffffff801057c0 <acquire>
}
ffffffff80108502:	48 83 c4 30          	add    $0x30,%rsp
ffffffff80108506:	5d                   	pop    %rbp
ffffffff80108507:	c3                   	retq   
ffffffff80108508:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
ffffffff8010850f:	00 

ffffffff80108510 <scheduler>:
{
ffffffff80108510:	55                   	push   %rbp
ffffffff80108511:	48 89 e5             	mov    %rsp,%rbp
ffffffff80108514:	48 83 ec 20          	sub    $0x20,%rsp
    sti();
ffffffff80108518:	e8 d3 00 00 00       	callq  ffffffff801085f0 <sti>
    acquire(&ptable.lock);
ffffffff8010851d:	48 c7 c7 a8 82 1f 83 	mov    $0xffffffff831f82a8,%rdi
ffffffff80108524:	e8 97 d2 ff ff       	callq  ffffffff801057c0 <acquire>
    for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
ffffffff80108529:	48 c7 45 f8 10 83 1f 	movq   $0xffffffff831f8310,-0x8(%rbp)
ffffffff80108530:	83 
ffffffff80108531:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
ffffffff80108535:	48 c7 c1 10 d3 1f 83 	mov    $0xffffffff831fd310,%rcx
ffffffff8010853c:	48 29 c8             	sub    %rcx,%rax
ffffffff8010853f:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
ffffffff80108543:	0f 83 8e 00 00 00    	jae    ffffffff801085d7 <scheduler+0xc7>
ffffffff80108549:	e9 00 00 00 00       	jmpq   ffffffff8010854e <scheduler+0x3e>
      if(p->state != RUNNABLE)
ffffffff8010854e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
ffffffff80108552:	83 b8 00 01 00 00 03 	cmpl   $0x3,0x100(%rax)
ffffffff80108559:	0f 84 05 00 00 00    	je     ffffffff80108564 <scheduler+0x54>
        continue;
ffffffff8010855f:	e9 60 00 00 00       	jmpq   ffffffff801085c4 <scheduler+0xb4>
      mycpu()->proc = p;
ffffffff80108564:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
ffffffff80108568:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
ffffffff8010856c:	e8 8f 00 00 00       	callq  ffffffff80108600 <mycpu>
ffffffff80108571:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
ffffffff80108575:	48 89 88 d0 00 00 00 	mov    %rcx,0xd0(%rax)
      switchuvm(p);
ffffffff8010857c:	48 8b 7d f8          	mov    -0x8(%rbp),%rdi
ffffffff80108580:	e8 6b b0 ff ff       	callq  ffffffff801035f0 <switchuvm>
      p->state = RUNNING;
ffffffff80108585:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
ffffffff80108589:	c7 80 00 01 00 00 04 	movl   $0x4,0x100(%rax)
ffffffff80108590:	00 00 00 
      swtch(&mycpu()->scheduler, p->context);
ffffffff80108593:	e8 68 00 00 00       	callq  ffffffff80108600 <mycpu>
ffffffff80108598:	48 83 c0 08          	add    $0x8,%rax
ffffffff8010859c:	48 8b 4d f8          	mov    -0x8(%rbp),%rcx
ffffffff801085a0:	48 8b b1 18 01 00 00 	mov    0x118(%rcx),%rsi
ffffffff801085a7:	48 89 c7             	mov    %rax,%rdi
ffffffff801085aa:	e8 fd 05 00 00       	callq  ffffffff80108bac <swtch>
      switchkvm();
ffffffff801085af:	e8 fc af ff ff       	callq  ffffffff801035b0 <switchkvm>
      mycpu()->proc = 0;
ffffffff801085b4:	e8 47 00 00 00       	callq  ffffffff80108600 <mycpu>
ffffffff801085b9:	48 c7 80 d0 00 00 00 	movq   $0x0,0xd0(%rax)
ffffffff801085c0:	00 00 00 00 
    for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
ffffffff801085c4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
ffffffff801085c8:	48 05 40 01 00 00    	add    $0x140,%rax
ffffffff801085ce:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
ffffffff801085d2:	e9 5a ff ff ff       	jmpq   ffffffff80108531 <scheduler+0x21>
    release(&ptable.lock);
ffffffff801085d7:	48 c7 c7 a8 82 1f 83 	mov    $0xffffffff831f82a8,%rdi
ffffffff801085de:	e8 1d d4 ff ff       	callq  ffffffff80105a00 <release>
  for(;;){
ffffffff801085e3:	e9 30 ff ff ff       	jmpq   ffffffff80108518 <scheduler+0x8>
ffffffff801085e8:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
ffffffff801085ef:	00 

ffffffff801085f0 <sti>:
{
ffffffff801085f0:	55                   	push   %rbp
ffffffff801085f1:	48 89 e5             	mov    %rsp,%rbp
  asm volatile("sti");
ffffffff801085f4:	fb                   	sti    
}
ffffffff801085f5:	5d                   	pop    %rbp
ffffffff801085f6:	c3                   	retq   
ffffffff801085f7:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
ffffffff801085fe:	00 00 

ffffffff80108600 <mycpu>:
{
ffffffff80108600:	55                   	push   %rbp
ffffffff80108601:	48 89 e5             	mov    %rsp,%rbp
  return &cpus[0];
ffffffff80108604:	48 c7 c0 e0 7b 1f 83 	mov    $0xffffffff831f7be0,%rax
ffffffff8010860b:	5d                   	pop    %rbp
ffffffff8010860c:	c3                   	retq   
ffffffff8010860d:	0f 1f 00             	nopl   (%rax)

ffffffff80108610 <readeflags>:
{
ffffffff80108610:	55                   	push   %rbp
ffffffff80108611:	48 89 e5             	mov    %rsp,%rbp
  asm volatile("pushf; pop %0" : "=r" (eflags));
ffffffff80108614:	50                   	push   %rax
ffffffff80108615:	9c                   	pushfq 
ffffffff80108616:	58                   	pop    %rax
ffffffff80108617:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  return eflags;
ffffffff8010861b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
ffffffff8010861f:	48 83 c4 08          	add    $0x8,%rsp
ffffffff80108623:	5d                   	pop    %rbp
ffffffff80108624:	c3                   	retq   
ffffffff80108625:	66 66 2e 0f 1f 84 00 	data16 nopw %cs:0x0(%rax,%rax,1)
ffffffff8010862c:	00 00 00 00 

ffffffff80108630 <yield>:
{
ffffffff80108630:	55                   	push   %rbp
ffffffff80108631:	48 89 e5             	mov    %rsp,%rbp
  acquire(&ptable.lock);  //DOC: yieldlock
ffffffff80108634:	48 c7 c7 a8 82 1f 83 	mov    $0xffffffff831f82a8,%rdi
ffffffff8010863b:	e8 80 d1 ff ff       	callq  ffffffff801057c0 <acquire>
  myproc()->state = RUNNABLE;
ffffffff80108640:	e8 8b f8 ff ff       	callq  ffffffff80107ed0 <myproc>
ffffffff80108645:	c7 80 00 01 00 00 03 	movl   $0x3,0x100(%rax)
ffffffff8010864c:	00 00 00 
  sched();
ffffffff8010864f:	e8 7c fa ff ff       	callq  ffffffff801080d0 <sched>
  release(&ptable.lock);
ffffffff80108654:	48 c7 c7 a8 82 1f 83 	mov    $0xffffffff831f82a8,%rdi
ffffffff8010865b:	e8 a0 d3 ff ff       	callq  ffffffff80105a00 <release>
}
ffffffff80108660:	5d                   	pop    %rbp
ffffffff80108661:	c3                   	retq   
ffffffff80108662:	66 66 66 66 66 2e 0f 	data16 data16 data16 data16 nopw %cs:0x0(%rax,%rax,1)
ffffffff80108669:	1f 84 00 00 00 00 00 

ffffffff80108670 <forkret>:
{
ffffffff80108670:	55                   	push   %rbp
ffffffff80108671:	48 89 e5             	mov    %rsp,%rbp
  release(&ptable.lock);
ffffffff80108674:	48 c7 c7 a8 82 1f 83 	mov    $0xffffffff831f82a8,%rdi
ffffffff8010867b:	e8 80 d3 ff ff       	callq  ffffffff80105a00 <release>
  if (first) {
ffffffff80108680:	8b 04 25 74 18 12 80 	mov    0xffffffff80121874,%eax
ffffffff80108687:	83 f8 00             	cmp    $0x0,%eax
ffffffff8010868a:	0f 84 3c 00 00 00    	je     ffffffff801086cc <forkret+0x5c>
    first = 0;
ffffffff80108690:	c7 04 25 74 18 12 80 	movl   $0x0,0xffffffff80121874
ffffffff80108697:	00 00 00 00 
    iinit(ROOTDEV);
ffffffff8010869b:	bf 01 00 00 00       	mov    $0x1,%edi
ffffffff801086a0:	e8 db 32 00 00       	callq  ffffffff8010b980 <iinit>
    if (extent_size == 0) {
ffffffff801086a5:	48 8b 04 25 80 64 1f 	mov    0xffffffff831f6480,%rax
ffffffff801086ac:	83 
ffffffff801086ad:	48 83 f8 00          	cmp    $0x0,%rax
ffffffff801086b1:	0f 85 10 00 00 00    	jne    ffffffff801086c7 <forkret+0x57>
      calc_extent_size();
ffffffff801086b7:	e8 d4 ed ff ff       	callq  ffffffff80107490 <calc_extent_size>
      recover_trans(); // Recover any failed journaled FS transaction.
ffffffff801086bc:	31 c0                	xor    %eax,%eax
ffffffff801086be:	88 c1                	mov    %al,%cl
ffffffff801086c0:	88 c8                	mov    %cl,%al
ffffffff801086c2:	e8 09 72 00 00       	callq  ffffffff8010f8d0 <recover_trans>
  }
ffffffff801086c7:	e9 00 00 00 00       	jmpq   ffffffff801086cc <forkret+0x5c>
}
ffffffff801086cc:	5d                   	pop    %rbp
ffffffff801086cd:	c3                   	retq   
ffffffff801086ce:	66 90                	xchg   %ax,%ax

ffffffff801086d0 <wakeup>:

// Wake up all processes sleeping on chan.
void
wakeup(void *chan)
{
ffffffff801086d0:	55                   	push   %rbp
ffffffff801086d1:	48 89 e5             	mov    %rsp,%rbp
ffffffff801086d4:	48 83 ec 10          	sub    $0x10,%rsp
ffffffff801086d8:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  acquire(&ptable.lock);
ffffffff801086dc:	48 c7 c7 a8 82 1f 83 	mov    $0xffffffff831f82a8,%rdi
ffffffff801086e3:	e8 d8 d0 ff ff       	callq  ffffffff801057c0 <acquire>
  wakeup1(chan);
ffffffff801086e8:	48 8b 7d f8          	mov    -0x8(%rbp),%rdi
ffffffff801086ec:	e8 4f f9 ff ff       	callq  ffffffff80108040 <wakeup1>
  release(&ptable.lock);
ffffffff801086f1:	48 c7 c7 a8 82 1f 83 	mov    $0xffffffff831f82a8,%rdi
ffffffff801086f8:	e8 03 d3 ff ff       	callq  ffffffff80105a00 <release>
}
ffffffff801086fd:	48 83 c4 10          	add    $0x10,%rsp
ffffffff80108701:	5d                   	pop    %rbp
ffffffff80108702:	c3                   	retq   
ffffffff80108703:	66 66 66 66 2e 0f 1f 	data16 data16 data16 nopw %cs:0x0(%rax,%rax,1)
ffffffff8010870a:	84 00 00 00 00 00 

ffffffff80108710 <kill>:
// Kill the process with the given pid.
// Process won't exit until it returns
// to user space (see trap in trap.c).
int
kill(int pid)
{
ffffffff80108710:	55                   	push   %rbp
ffffffff80108711:	48 89 e5             	mov    %rsp,%rbp
ffffffff80108714:	48 83 ec 20          	sub    $0x20,%rsp
ffffffff80108718:	89 7d f8             	mov    %edi,-0x8(%rbp)
  struct proc *p;

  acquire(&ptable.lock);
ffffffff8010871b:	48 c7 c7 a8 82 1f 83 	mov    $0xffffffff831f82a8,%rdi
ffffffff80108722:	e8 99 d0 ff ff       	callq  ffffffff801057c0 <acquire>
  for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
ffffffff80108727:	48 c7 45 f0 10 83 1f 	movq   $0xffffffff831f8310,-0x10(%rbp)
ffffffff8010872e:	83 
ffffffff8010872f:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
ffffffff80108733:	48 c7 c1 10 d3 1f 83 	mov    $0xffffffff831fd310,%rcx
ffffffff8010873a:	48 29 c8             	sub    %rcx,%rax
ffffffff8010873d:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
ffffffff80108741:	0f 83 75 00 00 00    	jae    ffffffff801087bc <kill+0xac>
ffffffff80108747:	e9 00 00 00 00       	jmpq   ffffffff8010874c <kill+0x3c>
    if(p->pid == pid){
ffffffff8010874c:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
ffffffff80108750:	8b 88 04 01 00 00    	mov    0x104(%rax),%ecx
ffffffff80108756:	3b 4d f8             	cmp    -0x8(%rbp),%ecx
ffffffff80108759:	0f 85 45 00 00 00    	jne    ffffffff801087a4 <kill+0x94>
      p->killed = 1;
ffffffff8010875f:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
ffffffff80108763:	c7 80 28 01 00 00 01 	movl   $0x1,0x128(%rax)
ffffffff8010876a:	00 00 00 
      // Wake process from sleep if necessary.
      if(p->state == SLEEPING)
ffffffff8010876d:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
ffffffff80108771:	83 b8 00 01 00 00 02 	cmpl   $0x2,0x100(%rax)
ffffffff80108778:	0f 85 0e 00 00 00    	jne    ffffffff8010878c <kill+0x7c>
        p->state = RUNNABLE;
ffffffff8010877e:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
ffffffff80108782:	c7 80 00 01 00 00 03 	movl   $0x3,0x100(%rax)
ffffffff80108789:	00 00 00 
      release(&ptable.lock);
ffffffff8010878c:	48 c7 c7 a8 82 1f 83 	mov    $0xffffffff831f82a8,%rdi
ffffffff80108793:	e8 68 d2 ff ff       	callq  ffffffff80105a00 <release>
      return 0;
ffffffff80108798:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
ffffffff8010879f:	e9 2b 00 00 00       	jmpq   ffffffff801087cf <kill+0xbf>
    }
  }
ffffffff801087a4:	e9 00 00 00 00       	jmpq   ffffffff801087a9 <kill+0x99>
  for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
ffffffff801087a9:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
ffffffff801087ad:	48 05 40 01 00 00    	add    $0x140,%rax
ffffffff801087b3:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
ffffffff801087b7:	e9 73 ff ff ff       	jmpq   ffffffff8010872f <kill+0x1f>
  release(&ptable.lock);
ffffffff801087bc:	48 c7 c7 a8 82 1f 83 	mov    $0xffffffff831f82a8,%rdi
ffffffff801087c3:	e8 38 d2 ff ff       	callq  ffffffff80105a00 <release>
  return -1;
ffffffff801087c8:	c7 45 fc ff ff ff ff 	movl   $0xffffffff,-0x4(%rbp)
}
ffffffff801087cf:	8b 45 fc             	mov    -0x4(%rbp),%eax
ffffffff801087d2:	48 83 c4 20          	add    $0x20,%rsp
ffffffff801087d6:	5d                   	pop    %rbp
ffffffff801087d7:	c3                   	retq   
ffffffff801087d8:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
ffffffff801087df:	00 

ffffffff801087e0 <procdump>:
// Print a process listing to console.  For debugging.
// Runs when user types ^P on console.
// No lock to avoid wedging a stuck machine further.
void
procdump(void)
{
ffffffff801087e0:	55                   	push   %rbp
ffffffff801087e1:	48 89 e5             	mov    %rsp,%rbp
  int i;
  struct proc *p;
  char *state;
  uint64_t pc[10];

  for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
ffffffff801087e4:	53                   	push   %rbx
ffffffff801087e5:	48 81 ec b8 00 00 00 	sub    $0xb8,%rsp
ffffffff801087ec:	48 c7 45 e8 10 83 1f 	movq   $0xffffffff831f8310,-0x18(%rbp)
ffffffff801087f3:	83 
ffffffff801087f4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
ffffffff801087f8:	48 c7 c1 10 d3 1f 83 	mov    $0xffffffff831fd310,%rcx
ffffffff801087ff:	48 29 c8             	sub    %rcx,%rax
ffffffff80108802:	48 89 85 68 ff ff ff 	mov    %rax,-0x98(%rbp)
ffffffff80108809:	0f 83 10 03 00 00    	jae    ffffffff80108b1f <procdump+0x33f>
ffffffff8010880f:	e9 00 00 00 00       	jmpq   ffffffff80108814 <procdump+0x34>
    if(p->state == UNUSED)
ffffffff80108814:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
ffffffff80108818:	83 b8 00 01 00 00 00 	cmpl   $0x0,0x100(%rax)
ffffffff8010881f:	0f 85 05 00 00 00    	jne    ffffffff8010882a <procdump+0x4a>
      continue;
ffffffff80108825:	e9 e2 02 00 00       	jmpq   ffffffff80108b0c <procdump+0x32c>
    if(p->state != 0 && p->state < NELEM(states) && states[p->state])
ffffffff8010882a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
ffffffff8010882e:	83 b8 00 01 00 00 00 	cmpl   $0x0,0x100(%rax)
ffffffff80108835:	0f 84 54 00 00 00    	je     ffffffff8010888f <procdump+0xaf>
ffffffff8010883b:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
ffffffff8010883f:	8b 88 00 01 00 00    	mov    0x100(%rax),%ecx
ffffffff80108845:	89 c8                	mov    %ecx,%eax
ffffffff80108847:	48 83 f8 06          	cmp    $0x6,%rax
ffffffff8010884b:	0f 83 3e 00 00 00    	jae    ffffffff8010888f <procdump+0xaf>
ffffffff80108851:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
ffffffff80108855:	8b 88 00 01 00 00    	mov    0x100(%rax),%ecx
ffffffff8010885b:	89 c8                	mov    %ecx,%eax
ffffffff8010885d:	48 8d 04 c5 80 18 12 	lea    -0x7fede780(,%rax,8),%rax
ffffffff80108864:	80 
ffffffff80108865:	48 83 38 00          	cmpq   $0x0,(%rax)
ffffffff80108869:	0f 84 20 00 00 00    	je     ffffffff8010888f <procdump+0xaf>
      state = states[p->state];
ffffffff8010886f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
ffffffff80108873:	8b 88 00 01 00 00    	mov    0x100(%rax),%ecx
ffffffff80108879:	89 c8                	mov    %ecx,%eax
ffffffff8010887b:	48 8d 04 c5 80 18 12 	lea    -0x7fede780(,%rax,8),%rax
ffffffff80108882:	80 
ffffffff80108883:	48 8b 00             	mov    (%rax),%rax
ffffffff80108886:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
ffffffff8010888a:	e9 08 00 00 00       	jmpq   ffffffff80108897 <procdump+0xb7>
    else
      state = "???";
ffffffff8010888f:	48 c7 45 e0 bf 01 11 	movq   $0xffffffff801101bf,-0x20(%rbp)
ffffffff80108896:	80 
    cprintf("%d %s %s", p->pid, state, p->name);
ffffffff80108897:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
ffffffff8010889b:	8b b0 04 01 00 00    	mov    0x104(%rax),%esi
ffffffff801088a1:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
ffffffff801088a5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
ffffffff801088a9:	48 05 2c 01 00 00    	add    $0x12c,%rax
ffffffff801088af:	48 c7 c7 c3 01 11 80 	mov    $0xffffffff801101c3,%rdi
ffffffff801088b6:	31 c9                	xor    %ecx,%ecx
ffffffff801088b8:	41 88 c8             	mov    %cl,%r8b
ffffffff801088bb:	48 89 c1             	mov    %rax,%rcx
ffffffff801088be:	44 88 c0             	mov    %r8b,%al
ffffffff801088c1:	e8 9a 80 ff ff       	callq  ffffffff80100960 <cprintf>
    if(p->state == SLEEPING){
ffffffff801088c6:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
ffffffff801088ca:	83 b9 00 01 00 00 02 	cmpl   $0x2,0x100(%rcx)
ffffffff801088d1:	0f 85 8a 00 00 00    	jne    ffffffff80108961 <procdump+0x181>
ffffffff801088d7:	48 8d 75 90          	lea    -0x70(%rbp),%rsi
      getcallerpcs((uint64_t*)p->context->rbp, pc);
ffffffff801088db:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
ffffffff801088df:	48 8b 80 18 01 00 00 	mov    0x118(%rax),%rax
ffffffff801088e6:	48 8b 40 30          	mov    0x30(%rax),%rax
ffffffff801088ea:	48 89 c7             	mov    %rax,%rdi
ffffffff801088ed:	e8 4e d0 ff ff       	callq  ffffffff80105940 <getcallerpcs>
      for(i=0; i<10 && pc[i] != 0; i++)
ffffffff801088f2:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)
ffffffff801088f9:	31 c0                	xor    %eax,%eax
ffffffff801088fb:	88 c1                	mov    %al,%cl
ffffffff801088fd:	83 7d f4 0a          	cmpl   $0xa,-0xc(%rbp)
ffffffff80108901:	88 8d 67 ff ff ff    	mov    %cl,-0x99(%rbp)
ffffffff80108907:	0f 8d 13 00 00 00    	jge    ffffffff80108920 <procdump+0x140>
ffffffff8010890d:	48 63 45 f4          	movslq -0xc(%rbp),%rax
ffffffff80108911:	48 83 7c c5 90 00    	cmpq   $0x0,-0x70(%rbp,%rax,8)
ffffffff80108917:	0f 95 c1             	setne  %cl
ffffffff8010891a:	88 8d 67 ff ff ff    	mov    %cl,-0x99(%rbp)
ffffffff80108920:	8a 85 67 ff ff ff    	mov    -0x99(%rbp),%al
ffffffff80108926:	a8 01                	test   $0x1,%al
ffffffff80108928:	0f 85 05 00 00 00    	jne    ffffffff80108933 <procdump+0x153>
ffffffff8010892e:	e9 29 00 00 00       	jmpq   ffffffff8010895c <procdump+0x17c>
        cprintf(" %p", pc[i]);
ffffffff80108933:	48 63 45 f4          	movslq -0xc(%rbp),%rax
ffffffff80108937:	48 8b 74 c5 90       	mov    -0x70(%rbp,%rax,8),%rsi
ffffffff8010893c:	48 c7 c7 7c fb 10 80 	mov    $0xffffffff8010fb7c,%rdi
ffffffff80108943:	31 c9                	xor    %ecx,%ecx
ffffffff80108945:	88 ca                	mov    %cl,%dl
ffffffff80108947:	88 d0                	mov    %dl,%al
ffffffff80108949:	e8 12 80 ff ff       	callq  ffffffff80100960 <cprintf>
      for(i=0; i<10 && pc[i] != 0; i++)
ffffffff8010894e:	8b 45 f4             	mov    -0xc(%rbp),%eax
ffffffff80108951:	83 c0 01             	add    $0x1,%eax
ffffffff80108954:	89 45 f4             	mov    %eax,-0xc(%rbp)
ffffffff80108957:	e9 9d ff ff ff       	jmpq   ffffffff801088f9 <procdump+0x119>
    }
ffffffff8010895c:	e9 00 00 00 00       	jmpq   ffffffff80108961 <procdump+0x181>

    // Print file table:
    cprintf("\n\nOpen file table:\n");
ffffffff80108961:	48 c7 c7 cc 01 11 80 	mov    $0xffffffff801101cc,%rdi
ffffffff80108968:	31 c0                	xor    %eax,%eax
ffffffff8010896a:	88 c1                	mov    %al,%cl
ffffffff8010896c:	88 c8                	mov    %cl,%al
ffffffff8010896e:	e8 ed 7f ff ff       	callq  ffffffff80100960 <cprintf>

    for (int descriptor = 0; descriptor < NOFILE; descriptor++) {
ffffffff80108973:	c7 45 8c 00 00 00 00 	movl   $0x0,-0x74(%rbp)
ffffffff8010897a:	83 7d 8c 10          	cmpl   $0x10,-0x74(%rbp)
ffffffff8010897e:	0f 8d 76 01 00 00    	jge    ffffffff80108afa <procdump+0x31a>
      struct open_file* file = &p->open_files[descriptor];
ffffffff80108984:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
ffffffff80108988:	48 83 c0 38          	add    $0x38,%rax
ffffffff8010898c:	48 63 4d 8c          	movslq -0x74(%rbp),%rcx
ffffffff80108990:	48 6b c9 0b          	imul   $0xb,%rcx,%rcx
ffffffff80108994:	48 01 c8             	add    %rcx,%rax
ffffffff80108997:	48 89 45 80          	mov    %rax,-0x80(%rbp)

      if (file->type == FILE_UNUSED) {
ffffffff8010899b:	48 8b 45 80          	mov    -0x80(%rbp),%rax
ffffffff8010899f:	0f be 50 0a          	movsbl 0xa(%rax),%edx
ffffffff801089a3:	83 fa 00             	cmp    $0x0,%edx
ffffffff801089a6:	0f 85 1a 00 00 00    	jne    ffffffff801089c6 <procdump+0x1e6>
        cprintf("   %d: (unused)\n", descriptor);
ffffffff801089ac:	8b 75 8c             	mov    -0x74(%rbp),%esi
ffffffff801089af:	48 c7 c7 e0 01 11 80 	mov    $0xffffffff801101e0,%rdi
ffffffff801089b6:	31 c0                	xor    %eax,%eax
ffffffff801089b8:	88 c1                	mov    %al,%cl
ffffffff801089ba:	88 c8                	mov    %cl,%al
ffffffff801089bc:	e8 9f 7f ff ff       	callq  ffffffff80100960 <cprintf>
      } else if (file->type == FILE_INODE) {
ffffffff801089c1:	e9 21 01 00 00       	jmpq   ffffffff80108ae7 <procdump+0x307>
ffffffff801089c6:	48 8b 45 80          	mov    -0x80(%rbp),%rax
ffffffff801089ca:	0f be 48 0a          	movsbl 0xa(%rax),%ecx
ffffffff801089ce:	83 f9 01             	cmp    $0x1,%ecx
ffffffff801089d1:	0f 85 88 00 00 00    	jne    ffffffff80108a5f <procdump+0x27f>
        struct inode* inode = file->file_desc->inode;
ffffffff801089d7:	48 8b 45 80          	mov    -0x80(%rbp),%rax
ffffffff801089db:	48 8b 00             	mov    (%rax),%rax
ffffffff801089de:	48 8b 00             	mov    (%rax),%rax
ffffffff801089e1:	48 89 85 78 ff ff ff 	mov    %rax,-0x88(%rbp)
        cprintf("   %d: {dev=%d inum=%d ref=%d flags=%d type=%d} offset=%d mode=0x%x\n",
         descriptor, inode->dev, inode->inum, inode->ref, inode->flags, inode->type,
ffffffff801089e8:	8b 75 8c             	mov    -0x74(%rbp),%esi
ffffffff801089eb:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
ffffffff801089f2:	8b 10                	mov    (%rax),%edx
ffffffff801089f4:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
ffffffff801089fb:	8b 48 04             	mov    0x4(%rax),%ecx
ffffffff801089fe:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
ffffffff80108a05:	44 8b 40 08          	mov    0x8(%rax),%r8d
ffffffff80108a09:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
ffffffff80108a10:	44 8b 88 90 00 00 00 	mov    0x90(%rax),%r9d
ffffffff80108a17:	48 8b 85 78 ff ff ff 	mov    -0x88(%rbp),%rax
ffffffff80108a1e:	0f bf b8 94 00 00 00 	movswl 0x94(%rax),%edi
         file->file_desc->curr_offset, file->mode);
ffffffff80108a25:	48 8b 45 80          	mov    -0x80(%rbp),%rax
ffffffff80108a29:	48 8b 00             	mov    (%rax),%rax
ffffffff80108a2c:	44 8b 50 08          	mov    0x8(%rax),%r10d
ffffffff80108a30:	48 8b 45 80          	mov    -0x80(%rbp),%rax
ffffffff80108a34:	44 0f bf 58 08       	movswl 0x8(%rax),%r11d
        cprintf("   %d: {dev=%d inum=%d ref=%d flags=%d type=%d} offset=%d mode=0x%x\n",
ffffffff80108a39:	48 89 e0             	mov    %rsp,%rax
ffffffff80108a3c:	44 89 58 10          	mov    %r11d,0x10(%rax)
ffffffff80108a40:	44 89 50 08          	mov    %r10d,0x8(%rax)
ffffffff80108a44:	89 38                	mov    %edi,(%rax)
ffffffff80108a46:	48 c7 c7 f1 01 11 80 	mov    $0xffffffff801101f1,%rdi
ffffffff80108a4d:	45 31 d2             	xor    %r10d,%r10d
ffffffff80108a50:	44 88 d3             	mov    %r10b,%bl
ffffffff80108a53:	88 d8                	mov    %bl,%al
ffffffff80108a55:	e8 06 7f ff ff       	callq  ffffffff80100960 <cprintf>
      } else if (file->type == FILE_PIPE) {
ffffffff80108a5a:	e9 83 00 00 00       	jmpq   ffffffff80108ae2 <procdump+0x302>
ffffffff80108a5f:	48 8b 45 80          	mov    -0x80(%rbp),%rax
ffffffff80108a63:	0f be 48 0a          	movsbl 0xa(%rax),%ecx
ffffffff80108a67:	83 f9 02             	cmp    $0x2,%ecx
ffffffff80108a6a:	0f 85 6d 00 00 00    	jne    ffffffff80108add <procdump+0x2fd>
        struct pipe* pipe = file->pipe;
ffffffff80108a70:	48 8b 45 80          	mov    -0x80(%rbp),%rax
ffffffff80108a74:	48 8b 00             	mov    (%rax),%rax
ffffffff80108a77:	48 89 85 70 ff ff ff 	mov    %rax,-0x90(%rbp)
        cprintf("   %d: PIPE={w_off=%d r_off=%d w_refcount=%d r_refcount=%d} mode=0x%x\n",
         descriptor, pipe->w_offset, pipe->r_offset, pipe->w_refcount, pipe->r_refcount,
ffffffff80108a7e:	8b 75 8c             	mov    -0x74(%rbp),%esi
ffffffff80108a81:	48 8b 85 70 ff ff ff 	mov    -0x90(%rbp),%rax
ffffffff80108a88:	0f bf 90 68 08 00 00 	movswl 0x868(%rax),%edx
ffffffff80108a8f:	48 8b 85 70 ff ff ff 	mov    -0x90(%rbp),%rax
ffffffff80108a96:	0f bf 88 6a 08 00 00 	movswl 0x86a(%rax),%ecx
ffffffff80108a9d:	48 8b 85 70 ff ff ff 	mov    -0x90(%rbp),%rax
ffffffff80108aa4:	44 0f b6 80 6c 08 00 	movzbl 0x86c(%rax),%r8d
ffffffff80108aab:	00 
ffffffff80108aac:	48 8b 85 70 ff ff ff 	mov    -0x90(%rbp),%rax
ffffffff80108ab3:	44 0f b6 88 6d 08 00 	movzbl 0x86d(%rax),%r9d
ffffffff80108aba:	00 
         file->mode);
ffffffff80108abb:	48 8b 45 80          	mov    -0x80(%rbp),%rax
ffffffff80108abf:	0f bf 78 08          	movswl 0x8(%rax),%edi
        cprintf("   %d: PIPE={w_off=%d r_off=%d w_refcount=%d r_refcount=%d} mode=0x%x\n",
ffffffff80108ac3:	48 89 e0             	mov    %rsp,%rax
ffffffff80108ac6:	89 38                	mov    %edi,(%rax)
ffffffff80108ac8:	48 c7 c7 36 02 11 80 	mov    $0xffffffff80110236,%rdi
ffffffff80108acf:	45 31 d2             	xor    %r10d,%r10d
ffffffff80108ad2:	45 88 d3             	mov    %r10b,%r11b
ffffffff80108ad5:	44 88 d8             	mov    %r11b,%al
ffffffff80108ad8:	e8 83 7e ff ff       	callq  ffffffff80100960 <cprintf>
ffffffff80108add:	e9 00 00 00 00       	jmpq   ffffffff80108ae2 <procdump+0x302>
ffffffff80108ae2:	e9 00 00 00 00       	jmpq   ffffffff80108ae7 <procdump+0x307>
      }
    }
ffffffff80108ae7:	e9 00 00 00 00       	jmpq   ffffffff80108aec <procdump+0x30c>
    for (int descriptor = 0; descriptor < NOFILE; descriptor++) {
ffffffff80108aec:	8b 45 8c             	mov    -0x74(%rbp),%eax
ffffffff80108aef:	83 c0 01             	add    $0x1,%eax
ffffffff80108af2:	89 45 8c             	mov    %eax,-0x74(%rbp)
ffffffff80108af5:	e9 80 fe ff ff       	jmpq   ffffffff8010897a <procdump+0x19a>

    cprintf("\n");
ffffffff80108afa:	48 c7 c7 2d fb 10 80 	mov    $0xffffffff8010fb2d,%rdi
ffffffff80108b01:	31 c0                	xor    %eax,%eax
ffffffff80108b03:	88 c1                	mov    %al,%cl
ffffffff80108b05:	88 c8                	mov    %cl,%al
ffffffff80108b07:	e8 54 7e ff ff       	callq  ffffffff80100960 <cprintf>
  for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
ffffffff80108b0c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
ffffffff80108b10:	48 05 40 01 00 00    	add    $0x140,%rax
ffffffff80108b16:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
ffffffff80108b1a:	e9 d5 fc ff ff       	jmpq   ffffffff801087f4 <procdump+0x14>
  }
}
ffffffff80108b1f:	48 81 c4 b8 00 00 00 	add    $0xb8,%rsp
ffffffff80108b26:	5b                   	pop    %rbx
ffffffff80108b27:	5d                   	pop    %rbp
ffffffff80108b28:	c3                   	retq   
ffffffff80108b29:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)

ffffffff80108b30 <findproc>:

struct proc *
findproc(int pid) {
ffffffff80108b30:	55                   	push   %rbp
ffffffff80108b31:	48 89 e5             	mov    %rsp,%rbp
ffffffff80108b34:	48 83 ec 20          	sub    $0x20,%rsp
ffffffff80108b38:	89 7d f4             	mov    %edi,-0xc(%rbp)
  struct proc *p;
  for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
ffffffff80108b3b:	48 c7 45 e8 10 83 1f 	movq   $0xffffffff831f8310,-0x18(%rbp)
ffffffff80108b42:	83 
ffffffff80108b43:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
ffffffff80108b47:	48 c7 c1 10 d3 1f 83 	mov    $0xffffffff831fd310,%rcx
ffffffff80108b4e:	48 29 c8             	sub    %rcx,%rax
ffffffff80108b51:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
ffffffff80108b55:	0f 83 3d 00 00 00    	jae    ffffffff80108b98 <findproc+0x68>
ffffffff80108b5b:	e9 00 00 00 00       	jmpq   ffffffff80108b60 <findproc+0x30>
    if (p->pid == pid)
ffffffff80108b60:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
ffffffff80108b64:	8b 88 04 01 00 00    	mov    0x104(%rax),%ecx
ffffffff80108b6a:	3b 4d f4             	cmp    -0xc(%rbp),%ecx
ffffffff80108b6d:	0f 85 0d 00 00 00    	jne    ffffffff80108b80 <findproc+0x50>
      return p;
ffffffff80108b73:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
ffffffff80108b77:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
ffffffff80108b7b:	e9 20 00 00 00       	jmpq   ffffffff80108ba0 <findproc+0x70>
  }
ffffffff80108b80:	e9 00 00 00 00       	jmpq   ffffffff80108b85 <findproc+0x55>
  for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
ffffffff80108b85:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
ffffffff80108b89:	48 05 40 01 00 00    	add    $0x140,%rax
ffffffff80108b8f:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
ffffffff80108b93:	e9 ab ff ff ff       	jmpq   ffffffff80108b43 <findproc+0x13>
  return 0;
ffffffff80108b98:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
ffffffff80108b9f:	00 
}
ffffffff80108ba0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
ffffffff80108ba4:	48 83 c4 20          	add    $0x20,%rsp
ffffffff80108ba8:	5d                   	pop    %rbp
ffffffff80108ba9:	c3                   	retq   
ffffffff80108baa:	66 90                	xchg   %ax,%ax

ffffffff80108bac <swtch>:
.globl swtch
swtch:
  push %rbp
ffffffff80108bac:	55                   	push   %rbp
  push %rbx
ffffffff80108bad:	53                   	push   %rbx
  push %r11
ffffffff80108bae:	41 53                	push   %r11
  push %r12
ffffffff80108bb0:	41 54                	push   %r12
  push %r13
ffffffff80108bb2:	41 55                	push   %r13
  push %r14
ffffffff80108bb4:	41 56                	push   %r14
  push %r15
ffffffff80108bb6:	41 57                	push   %r15

  mov %rsp, (%rdi)
ffffffff80108bb8:	48 89 27             	mov    %rsp,(%rdi)
  mov %rsi, %rsp
ffffffff80108bbb:	48 89 f4             	mov    %rsi,%rsp

  pop %r15
ffffffff80108bbe:	41 5f                	pop    %r15
  pop %r14
ffffffff80108bc0:	41 5e                	pop    %r14
  pop %r13
ffffffff80108bc2:	41 5d                	pop    %r13
  pop %r12
ffffffff80108bc4:	41 5c                	pop    %r12
  pop %r11
ffffffff80108bc6:	41 5b                	pop    %r11
  pop %rbx
ffffffff80108bc8:	5b                   	pop    %rbx
  pop %rbp
ffffffff80108bc9:	5d                   	pop    %rbp

ffffffff80108bca:	c3                   	retq   
ffffffff80108bcb:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

ffffffff80108bd0 <fetchint_helper>:
// library system call function. The saved user %esp points
// to a saved program counter, and then the first argument.

// Fetch the int at addr from the current process.
int
fetchint_helper(uint64_t addr, int *ip, struct mem_region* region) {
ffffffff80108bd0:	55                   	push   %rbp
ffffffff80108bd1:	48 89 e5             	mov    %rsp,%rbp
ffffffff80108bd4:	48 83 ec 20          	sub    $0x20,%rsp
ffffffff80108bd8:	48 89 7d f0          	mov    %rdi,-0x10(%rbp)
ffffffff80108bdc:	48 89 75 e8          	mov    %rsi,-0x18(%rbp)
ffffffff80108be0:	48 89 55 e0          	mov    %rdx,-0x20(%rbp)
  if ((addr >= (uint64_t)region->start) && (addr + 4 < (uint64_t)region->start + region->size)) {
ffffffff80108be4:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
ffffffff80108be8:	48 8b 75 e0          	mov    -0x20(%rbp),%rsi
ffffffff80108bec:	48 8b 36             	mov    (%rsi),%rsi
ffffffff80108bef:	48 39 f2             	cmp    %rsi,%rdx
ffffffff80108bf2:	0f 82 38 00 00 00    	jb     ffffffff80108c30 <fetchint_helper+0x60>
ffffffff80108bf8:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
ffffffff80108bfc:	48 83 c0 04          	add    $0x4,%rax
ffffffff80108c00:	48 8b 4d e0          	mov    -0x20(%rbp),%rcx
ffffffff80108c04:	48 8b 09             	mov    (%rcx),%rcx
ffffffff80108c07:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
ffffffff80108c0b:	48 03 4a 08          	add    0x8(%rdx),%rcx
ffffffff80108c0f:	48 39 c8             	cmp    %rcx,%rax
ffffffff80108c12:	0f 83 18 00 00 00    	jae    ffffffff80108c30 <fetchint_helper+0x60>
    *ip = *(int*)(addr);
ffffffff80108c18:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
ffffffff80108c1c:	8b 08                	mov    (%rax),%ecx
ffffffff80108c1e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
ffffffff80108c22:	89 08                	mov    %ecx,(%rax)
    return 0;
ffffffff80108c24:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
ffffffff80108c2b:	e9 07 00 00 00       	jmpq   ffffffff80108c37 <fetchint_helper+0x67>
  }
  return -1;
ffffffff80108c30:	c7 45 fc ff ff ff ff 	movl   $0xffffffff,-0x4(%rbp)
}
ffffffff80108c37:	8b 45 fc             	mov    -0x4(%rbp),%eax
ffffffff80108c3a:	48 83 c4 20          	add    $0x20,%rsp
ffffffff80108c3e:	5d                   	pop    %rbp
ffffffff80108c3f:	c3                   	retq   

ffffffff80108c40 <fetchint>:

int
fetchint(uint64_t addr, int *ip)
{
ffffffff80108c40:	55                   	push   %rbp
ffffffff80108c41:	48 89 e5             	mov    %rsp,%rbp
ffffffff80108c44:	48 83 ec 50          	sub    $0x50,%rsp
ffffffff80108c48:	48 89 7d f0          	mov    %rdi,-0x10(%rbp)
ffffffff80108c4c:	48 89 75 e8          	mov    %rsi,-0x18(%rbp)
  int i;
  i = fetchint_helper(addr, ip, &myproc()->mem_regions[CODE]);
ffffffff80108c50:	48 8b 7d f0          	mov    -0x10(%rbp),%rdi
ffffffff80108c54:	48 8b 75 e8          	mov    -0x18(%rbp),%rsi
ffffffff80108c58:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
ffffffff80108c5c:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
ffffffff80108c60:	e8 cb 00 00 00       	callq  ffffffff80108d30 <myproc>
ffffffff80108c65:	48 83 c0 08          	add    $0x8,%rax
ffffffff80108c69:	48 8b 7d d8          	mov    -0x28(%rbp),%rdi
ffffffff80108c6d:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
ffffffff80108c71:	48 89 c2             	mov    %rax,%rdx
ffffffff80108c74:	e8 57 ff ff ff       	callq  ffffffff80108bd0 <fetchint_helper>
ffffffff80108c79:	89 45 e4             	mov    %eax,-0x1c(%rbp)
  if (i == 0) {
ffffffff80108c7c:	83 7d e4 00          	cmpl   $0x0,-0x1c(%rbp)
ffffffff80108c80:	0f 85 0c 00 00 00    	jne    ffffffff80108c92 <fetchint+0x52>
    return 0;
ffffffff80108c86:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
ffffffff80108c8d:	e9 93 00 00 00       	jmpq   ffffffff80108d25 <fetchint+0xe5>
  }
  i = fetchint_helper(addr, ip, &myproc()->mem_regions[HEAP]);
ffffffff80108c92:	48 8b 7d f0          	mov    -0x10(%rbp),%rdi
ffffffff80108c96:	48 8b 75 e8          	mov    -0x18(%rbp),%rsi
ffffffff80108c9a:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
ffffffff80108c9e:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
ffffffff80108ca2:	e8 89 00 00 00       	callq  ffffffff80108d30 <myproc>
ffffffff80108ca7:	48 83 c0 08          	add    $0x8,%rax
ffffffff80108cab:	48 83 c0 10          	add    $0x10,%rax
ffffffff80108caf:	48 8b 7d c8          	mov    -0x38(%rbp),%rdi
ffffffff80108cb3:	48 8b 75 c0          	mov    -0x40(%rbp),%rsi
ffffffff80108cb7:	48 89 c2             	mov    %rax,%rdx
ffffffff80108cba:	e8 11 ff ff ff       	callq  ffffffff80108bd0 <fetchint_helper>
ffffffff80108cbf:	89 45 e4             	mov    %eax,-0x1c(%rbp)
  if (i == 0) {
ffffffff80108cc2:	83 7d e4 00          	cmpl   $0x0,-0x1c(%rbp)
ffffffff80108cc6:	0f 85 0c 00 00 00    	jne    ffffffff80108cd8 <fetchint+0x98>
    return 0;
ffffffff80108ccc:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
ffffffff80108cd3:	e9 4d 00 00 00       	jmpq   ffffffff80108d25 <fetchint+0xe5>
  }
  i = fetchint_helper(addr, ip, &myproc()->mem_regions[USTACK]);
ffffffff80108cd8:	48 8b 7d f0          	mov    -0x10(%rbp),%rdi
ffffffff80108cdc:	48 8b 75 e8          	mov    -0x18(%rbp),%rsi
ffffffff80108ce0:	48 89 7d b8          	mov    %rdi,-0x48(%rbp)
ffffffff80108ce4:	48 89 75 b0          	mov    %rsi,-0x50(%rbp)
ffffffff80108ce8:	e8 43 00 00 00       	callq  ffffffff80108d30 <myproc>
ffffffff80108ced:	48 83 c0 08          	add    $0x8,%rax
ffffffff80108cf1:	48 83 c0 20          	add    $0x20,%rax
ffffffff80108cf5:	48 8b 7d b8          	mov    -0x48(%rbp),%rdi
ffffffff80108cf9:	48 8b 75 b0          	mov    -0x50(%rbp),%rsi
ffffffff80108cfd:	48 89 c2             	mov    %rax,%rdx
ffffffff80108d00:	e8 cb fe ff ff       	callq  ffffffff80108bd0 <fetchint_helper>
ffffffff80108d05:	89 45 e4             	mov    %eax,-0x1c(%rbp)
  if (i == 0) {
ffffffff80108d08:	83 7d e4 00          	cmpl   $0x0,-0x1c(%rbp)
ffffffff80108d0c:	0f 85 0c 00 00 00    	jne    ffffffff80108d1e <fetchint+0xde>
    return 0;
ffffffff80108d12:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
ffffffff80108d19:	e9 07 00 00 00       	jmpq   ffffffff80108d25 <fetchint+0xe5>
  }
  return -1;
ffffffff80108d1e:	c7 45 fc ff ff ff ff 	movl   $0xffffffff,-0x4(%rbp)
}
ffffffff80108d25:	8b 45 fc             	mov    -0x4(%rbp),%eax
ffffffff80108d28:	48 83 c4 50          	add    $0x50,%rsp
ffffffff80108d2c:	5d                   	pop    %rbp
ffffffff80108d2d:	c3                   	retq   
ffffffff80108d2e:	66 90                	xchg   %ax,%ax

ffffffff80108d30 <myproc>:
{
ffffffff80108d30:	55                   	push   %rbp
ffffffff80108d31:	48 89 e5             	mov    %rsp,%rbp
  return mycpu()->proc;
ffffffff80108d34:	e8 17 08 00 00       	callq  ffffffff80109550 <mycpu>
ffffffff80108d39:	48 8b 80 d0 00 00 00 	mov    0xd0(%rax),%rax
ffffffff80108d40:	5d                   	pop    %rbp
ffffffff80108d41:	c3                   	retq   
ffffffff80108d42:	66 66 66 66 66 2e 0f 	data16 data16 data16 data16 nopw %cs:0x0(%rax,%rax,1)
ffffffff80108d49:	1f 84 00 00 00 00 00 

ffffffff80108d50 <fetchint64_helper>:

int
fetchint64_helper(uint64_t addr, int64_t *ip, struct mem_region* region) {
ffffffff80108d50:	55                   	push   %rbp
ffffffff80108d51:	48 89 e5             	mov    %rsp,%rbp
ffffffff80108d54:	48 83 ec 20          	sub    $0x20,%rsp
ffffffff80108d58:	48 89 7d f0          	mov    %rdi,-0x10(%rbp)
ffffffff80108d5c:	48 89 75 e8          	mov    %rsi,-0x18(%rbp)
ffffffff80108d60:	48 89 55 e0          	mov    %rdx,-0x20(%rbp)
  if ((addr >= (uint64_t)region->start) && (addr + 8 < (uint64_t)region->start + region->size)) {
ffffffff80108d64:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
ffffffff80108d68:	48 8b 75 e0          	mov    -0x20(%rbp),%rsi
ffffffff80108d6c:	48 8b 36             	mov    (%rsi),%rsi
ffffffff80108d6f:	48 39 f2             	cmp    %rsi,%rdx
ffffffff80108d72:	0f 82 3a 00 00 00    	jb     ffffffff80108db2 <fetchint64_helper+0x62>
ffffffff80108d78:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
ffffffff80108d7c:	48 83 c0 08          	add    $0x8,%rax
ffffffff80108d80:	48 8b 4d e0          	mov    -0x20(%rbp),%rcx
ffffffff80108d84:	48 8b 09             	mov    (%rcx),%rcx
ffffffff80108d87:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
ffffffff80108d8b:	48 03 4a 08          	add    0x8(%rdx),%rcx
ffffffff80108d8f:	48 39 c8             	cmp    %rcx,%rax
ffffffff80108d92:	0f 83 1a 00 00 00    	jae    ffffffff80108db2 <fetchint64_helper+0x62>
    *ip = *(int64_t*)(addr);
ffffffff80108d98:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
ffffffff80108d9c:	48 8b 00             	mov    (%rax),%rax
ffffffff80108d9f:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
ffffffff80108da3:	48 89 01             	mov    %rax,(%rcx)
    return 0;
ffffffff80108da6:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
ffffffff80108dad:	e9 07 00 00 00       	jmpq   ffffffff80108db9 <fetchint64_helper+0x69>
  }
  return -1;
ffffffff80108db2:	c7 45 fc ff ff ff ff 	movl   $0xffffffff,-0x4(%rbp)
}
ffffffff80108db9:	8b 45 fc             	mov    -0x4(%rbp),%eax
ffffffff80108dbc:	48 83 c4 20          	add    $0x20,%rsp
ffffffff80108dc0:	5d                   	pop    %rbp
ffffffff80108dc1:	c3                   	retq   
ffffffff80108dc2:	66 66 66 66 66 2e 0f 	data16 data16 data16 data16 nopw %cs:0x0(%rax,%rax,1)
ffffffff80108dc9:	1f 84 00 00 00 00 00 

ffffffff80108dd0 <fetchint64>:

int
fetchint64(uint64_t addr, int64_t *ip)
{
ffffffff80108dd0:	55                   	push   %rbp
ffffffff80108dd1:	48 89 e5             	mov    %rsp,%rbp
ffffffff80108dd4:	48 83 ec 50          	sub    $0x50,%rsp
ffffffff80108dd8:	48 89 7d f0          	mov    %rdi,-0x10(%rbp)
ffffffff80108ddc:	48 89 75 e8          	mov    %rsi,-0x18(%rbp)
  int i;
  i = fetchint64_helper(addr, ip, &myproc()->mem_regions[CODE]);
ffffffff80108de0:	48 8b 7d f0          	mov    -0x10(%rbp),%rdi
ffffffff80108de4:	48 8b 75 e8          	mov    -0x18(%rbp),%rsi
ffffffff80108de8:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
ffffffff80108dec:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
ffffffff80108df0:	e8 3b ff ff ff       	callq  ffffffff80108d30 <myproc>
ffffffff80108df5:	48 83 c0 08          	add    $0x8,%rax
ffffffff80108df9:	48 8b 7d d8          	mov    -0x28(%rbp),%rdi
ffffffff80108dfd:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
ffffffff80108e01:	48 89 c2             	mov    %rax,%rdx
ffffffff80108e04:	e8 47 ff ff ff       	callq  ffffffff80108d50 <fetchint64_helper>
ffffffff80108e09:	89 45 e4             	mov    %eax,-0x1c(%rbp)
  if (i == 0) {
ffffffff80108e0c:	83 7d e4 00          	cmpl   $0x0,-0x1c(%rbp)
ffffffff80108e10:	0f 85 0c 00 00 00    	jne    ffffffff80108e22 <fetchint64+0x52>
    return 0;
ffffffff80108e16:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
ffffffff80108e1d:	e9 93 00 00 00       	jmpq   ffffffff80108eb5 <fetchint64+0xe5>
  }
  i = fetchint64_helper(addr, ip, &myproc()->mem_regions[HEAP]);
ffffffff80108e22:	48 8b 7d f0          	mov    -0x10(%rbp),%rdi
ffffffff80108e26:	48 8b 75 e8          	mov    -0x18(%rbp),%rsi
ffffffff80108e2a:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
ffffffff80108e2e:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
ffffffff80108e32:	e8 f9 fe ff ff       	callq  ffffffff80108d30 <myproc>
ffffffff80108e37:	48 83 c0 08          	add    $0x8,%rax
ffffffff80108e3b:	48 83 c0 10          	add    $0x10,%rax
ffffffff80108e3f:	48 8b 7d c8          	mov    -0x38(%rbp),%rdi
ffffffff80108e43:	48 8b 75 c0          	mov    -0x40(%rbp),%rsi
ffffffff80108e47:	48 89 c2             	mov    %rax,%rdx
ffffffff80108e4a:	e8 01 ff ff ff       	callq  ffffffff80108d50 <fetchint64_helper>
ffffffff80108e4f:	89 45 e4             	mov    %eax,-0x1c(%rbp)
  if (i == 0) {
ffffffff80108e52:	83 7d e4 00          	cmpl   $0x0,-0x1c(%rbp)
ffffffff80108e56:	0f 85 0c 00 00 00    	jne    ffffffff80108e68 <fetchint64+0x98>
    return 0;
ffffffff80108e5c:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
ffffffff80108e63:	e9 4d 00 00 00       	jmpq   ffffffff80108eb5 <fetchint64+0xe5>
  }
  i = fetchint64_helper(addr, ip, &myproc()->mem_regions[USTACK]);
ffffffff80108e68:	48 8b 7d f0          	mov    -0x10(%rbp),%rdi
ffffffff80108e6c:	48 8b 75 e8          	mov    -0x18(%rbp),%rsi
ffffffff80108e70:	48 89 7d b8          	mov    %rdi,-0x48(%rbp)
ffffffff80108e74:	48 89 75 b0          	mov    %rsi,-0x50(%rbp)
ffffffff80108e78:	e8 b3 fe ff ff       	callq  ffffffff80108d30 <myproc>
ffffffff80108e7d:	48 83 c0 08          	add    $0x8,%rax
ffffffff80108e81:	48 83 c0 20          	add    $0x20,%rax
ffffffff80108e85:	48 8b 7d b8          	mov    -0x48(%rbp),%rdi
ffffffff80108e89:	48 8b 75 b0          	mov    -0x50(%rbp),%rsi
ffffffff80108e8d:	48 89 c2             	mov    %rax,%rdx
ffffffff80108e90:	e8 bb fe ff ff       	callq  ffffffff80108d50 <fetchint64_helper>
ffffffff80108e95:	89 45 e4             	mov    %eax,-0x1c(%rbp)
  if (i == 0) {
ffffffff80108e98:	83 7d e4 00          	cmpl   $0x0,-0x1c(%rbp)
ffffffff80108e9c:	0f 85 0c 00 00 00    	jne    ffffffff80108eae <fetchint64+0xde>
    return 0;
ffffffff80108ea2:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
ffffffff80108ea9:	e9 07 00 00 00       	jmpq   ffffffff80108eb5 <fetchint64+0xe5>
  }
  return -1;
ffffffff80108eae:	c7 45 fc ff ff ff ff 	movl   $0xffffffff,-0x4(%rbp)
}
ffffffff80108eb5:	8b 45 fc             	mov    -0x4(%rbp),%eax
ffffffff80108eb8:	48 83 c4 50          	add    $0x50,%rsp
ffffffff80108ebc:	5d                   	pop    %rbp
ffffffff80108ebd:	c3                   	retq   
ffffffff80108ebe:	66 90                	xchg   %ax,%ax

ffffffff80108ec0 <fetchstr_helper>:

int
fetchstr_helper(uint64_t addr, char **pp, struct mem_region *region)
{
ffffffff80108ec0:	55                   	push   %rbp
ffffffff80108ec1:	48 89 e5             	mov    %rsp,%rbp
ffffffff80108ec4:	48 83 ec 30          	sub    $0x30,%rsp
ffffffff80108ec8:	48 89 7d f0          	mov    %rdi,-0x10(%rbp)
ffffffff80108ecc:	48 89 75 e8          	mov    %rsi,-0x18(%rbp)
ffffffff80108ed0:	48 89 55 e0          	mov    %rdx,-0x20(%rbp)
  char *s, *ep;

  if ((addr >= (uint64_t)region->start) && (addr < (uint64_t)region->start + region->size)) {
ffffffff80108ed4:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
ffffffff80108ed8:	48 8b 75 e0          	mov    -0x20(%rbp),%rsi
ffffffff80108edc:	48 8b 36             	mov    (%rsi),%rsi
ffffffff80108edf:	48 39 f2             	cmp    %rsi,%rdx
ffffffff80108ee2:	0f 82 9d 00 00 00    	jb     ffffffff80108f85 <fetchstr_helper+0xc5>
ffffffff80108ee8:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
ffffffff80108eec:	48 8b 4d e0          	mov    -0x20(%rbp),%rcx
ffffffff80108ef0:	48 8b 09             	mov    (%rcx),%rcx
ffffffff80108ef3:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
ffffffff80108ef7:	48 03 4a 08          	add    0x8(%rdx),%rcx
ffffffff80108efb:	48 39 c8             	cmp    %rcx,%rax
ffffffff80108efe:	0f 83 81 00 00 00    	jae    ffffffff80108f85 <fetchstr_helper+0xc5>
    *pp = (char*)addr;
ffffffff80108f04:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
ffffffff80108f08:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
ffffffff80108f0c:	48 89 01             	mov    %rax,(%rcx)
    ep = region->start + region->size;
ffffffff80108f0f:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
ffffffff80108f13:	48 8b 00             	mov    (%rax),%rax
ffffffff80108f16:	48 8b 4d e0          	mov    -0x20(%rbp),%rcx
ffffffff80108f1a:	48 03 41 08          	add    0x8(%rcx),%rax
ffffffff80108f1e:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
    for(s = *pp; s < ep; s++)
ffffffff80108f22:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
ffffffff80108f26:	48 8b 00             	mov    (%rax),%rax
ffffffff80108f29:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
ffffffff80108f2d:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
ffffffff80108f31:	48 3b 45 d0          	cmp    -0x30(%rbp),%rax
ffffffff80108f35:	0f 83 3e 00 00 00    	jae    ffffffff80108f79 <fetchstr_helper+0xb9>
      if(*s == 0)
ffffffff80108f3b:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
ffffffff80108f3f:	0f be 08             	movsbl (%rax),%ecx
ffffffff80108f42:	83 f9 00             	cmp    $0x0,%ecx
ffffffff80108f45:	0f 85 18 00 00 00    	jne    ffffffff80108f63 <fetchstr_helper+0xa3>
        return s - *pp;
ffffffff80108f4b:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
ffffffff80108f4f:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
ffffffff80108f53:	48 8b 09             	mov    (%rcx),%rcx
ffffffff80108f56:	48 29 c8             	sub    %rcx,%rax
ffffffff80108f59:	89 c2                	mov    %eax,%edx
ffffffff80108f5b:	89 55 fc             	mov    %edx,-0x4(%rbp)
ffffffff80108f5e:	e9 29 00 00 00       	jmpq   ffffffff80108f8c <fetchstr_helper+0xcc>
      if(*s == 0)
ffffffff80108f63:	e9 00 00 00 00       	jmpq   ffffffff80108f68 <fetchstr_helper+0xa8>
    for(s = *pp; s < ep; s++)
ffffffff80108f68:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
ffffffff80108f6c:	48 83 c0 01          	add    $0x1,%rax
ffffffff80108f70:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
ffffffff80108f74:	e9 b4 ff ff ff       	jmpq   ffffffff80108f2d <fetchstr_helper+0x6d>
    return -1;
ffffffff80108f79:	c7 45 fc ff ff ff ff 	movl   $0xffffffff,-0x4(%rbp)
ffffffff80108f80:	e9 07 00 00 00       	jmpq   ffffffff80108f8c <fetchstr_helper+0xcc>
  }
  return -1;
ffffffff80108f85:	c7 45 fc ff ff ff ff 	movl   $0xffffffff,-0x4(%rbp)
}
ffffffff80108f8c:	8b 45 fc             	mov    -0x4(%rbp),%eax
ffffffff80108f8f:	48 83 c4 30          	add    $0x30,%rsp
ffffffff80108f93:	5d                   	pop    %rbp
ffffffff80108f94:	c3                   	retq   
ffffffff80108f95:	66 66 2e 0f 1f 84 00 	data16 nopw %cs:0x0(%rax,%rax,1)
ffffffff80108f9c:	00 00 00 00 

ffffffff80108fa0 <fetchstr>:
// Fetch the nul-terminated string at addr from the current process.
// Doesn't actually copy the string - just sets *pp to point at it.
// Returns length of string, not including nul.
int
fetchstr(uint64_t addr, char **pp)
{
ffffffff80108fa0:	55                   	push   %rbp
ffffffff80108fa1:	48 89 e5             	mov    %rsp,%rbp
ffffffff80108fa4:	48 83 ec 50          	sub    $0x50,%rsp
ffffffff80108fa8:	48 89 7d f0          	mov    %rdi,-0x10(%rbp)
ffffffff80108fac:	48 89 75 e8          	mov    %rsi,-0x18(%rbp)
  int i;

  i = fetchstr_helper(addr, pp, &myproc()->mem_regions[CODE]);
ffffffff80108fb0:	48 8b 7d f0          	mov    -0x10(%rbp),%rdi
ffffffff80108fb4:	48 8b 75 e8          	mov    -0x18(%rbp),%rsi
ffffffff80108fb8:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
ffffffff80108fbc:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
ffffffff80108fc0:	e8 6b fd ff ff       	callq  ffffffff80108d30 <myproc>
ffffffff80108fc5:	48 83 c0 08          	add    $0x8,%rax
ffffffff80108fc9:	48 8b 7d d8          	mov    -0x28(%rbp),%rdi
ffffffff80108fcd:	48 8b 75 d0          	mov    -0x30(%rbp),%rsi
ffffffff80108fd1:	48 89 c2             	mov    %rax,%rdx
ffffffff80108fd4:	e8 e7 fe ff ff       	callq  ffffffff80108ec0 <fetchstr_helper>
ffffffff80108fd9:	89 45 e4             	mov    %eax,-0x1c(%rbp)
  if (i >=0) {
ffffffff80108fdc:	83 7d e4 00          	cmpl   $0x0,-0x1c(%rbp)
ffffffff80108fe0:	0f 8c 0b 00 00 00    	jl     ffffffff80108ff1 <fetchstr+0x51>
    return i;
ffffffff80108fe6:	8b 45 e4             	mov    -0x1c(%rbp),%eax
ffffffff80108fe9:	89 45 fc             	mov    %eax,-0x4(%rbp)
ffffffff80108fec:	e9 91 00 00 00       	jmpq   ffffffff80109082 <fetchstr+0xe2>
  }

  i = fetchstr_helper(addr, pp, &myproc()->mem_regions[HEAP]);
ffffffff80108ff1:	48 8b 7d f0          	mov    -0x10(%rbp),%rdi
ffffffff80108ff5:	48 8b 75 e8          	mov    -0x18(%rbp),%rsi
ffffffff80108ff9:	48 89 7d c8          	mov    %rdi,-0x38(%rbp)
ffffffff80108ffd:	48 89 75 c0          	mov    %rsi,-0x40(%rbp)
ffffffff80109001:	e8 2a fd ff ff       	callq  ffffffff80108d30 <myproc>
ffffffff80109006:	48 83 c0 08          	add    $0x8,%rax
ffffffff8010900a:	48 83 c0 10          	add    $0x10,%rax
ffffffff8010900e:	48 8b 7d c8          	mov    -0x38(%rbp),%rdi
ffffffff80109012:	48 8b 75 c0          	mov    -0x40(%rbp),%rsi
ffffffff80109016:	48 89 c2             	mov    %rax,%rdx
ffffffff80109019:	e8 a2 fe ff ff       	callq  ffffffff80108ec0 <fetchstr_helper>
ffffffff8010901e:	89 45 e4             	mov    %eax,-0x1c(%rbp)
  if (i >=0) {
ffffffff80109021:	83 7d e4 00          	cmpl   $0x0,-0x1c(%rbp)
ffffffff80109025:	0f 8c 0b 00 00 00    	jl     ffffffff80109036 <fetchstr+0x96>
    return i;
ffffffff8010902b:	8b 45 e4             	mov    -0x1c(%rbp),%eax
ffffffff8010902e:	89 45 fc             	mov    %eax,-0x4(%rbp)
ffffffff80109031:	e9 4c 00 00 00       	jmpq   ffffffff80109082 <fetchstr+0xe2>
  }

  i = fetchstr_helper(addr, pp, &myproc()->mem_regions[USTACK]);
ffffffff80109036:	48 8b 7d f0          	mov    -0x10(%rbp),%rdi
ffffffff8010903a:	48 8b 75 e8          	mov    -0x18(%rbp),%rsi
ffffffff8010903e:	48 89 7d b8          	mov    %rdi,-0x48(%rbp)
ffffffff80109042:	48 89 75 b0          	mov    %rsi,-0x50(%rbp)
ffffffff80109046:	e8 e5 fc ff ff       	callq  ffffffff80108d30 <myproc>
ffffffff8010904b:	48 83 c0 08          	add    $0x8,%rax
ffffffff8010904f:	48 83 c0 20          	add    $0x20,%rax
ffffffff80109053:	48 8b 7d b8          	mov    -0x48(%rbp),%rdi
ffffffff80109057:	48 8b 75 b0          	mov    -0x50(%rbp),%rsi
ffffffff8010905b:	48 89 c2             	mov    %rax,%rdx
ffffffff8010905e:	e8 5d fe ff ff       	callq  ffffffff80108ec0 <fetchstr_helper>
ffffffff80109063:	89 45 e4             	mov    %eax,-0x1c(%rbp)
  if (i >=0) {
ffffffff80109066:	83 7d e4 00          	cmpl   $0x0,-0x1c(%rbp)
ffffffff8010906a:	0f 8c 0b 00 00 00    	jl     ffffffff8010907b <fetchstr+0xdb>
    return i;
ffffffff80109070:	8b 45 e4             	mov    -0x1c(%rbp),%eax
ffffffff80109073:	89 45 fc             	mov    %eax,-0x4(%rbp)
ffffffff80109076:	e9 07 00 00 00       	jmpq   ffffffff80109082 <fetchstr+0xe2>
  }

  return -1;
ffffffff8010907b:	c7 45 fc ff ff ff ff 	movl   $0xffffffff,-0x4(%rbp)
}
ffffffff80109082:	8b 45 fc             	mov    -0x4(%rbp),%eax
ffffffff80109085:	48 83 c4 50          	add    $0x50,%rsp
ffffffff80109089:	5d                   	pop    %rbp
ffffffff8010908a:	c3                   	retq   
ffffffff8010908b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

ffffffff80109090 <argint>:
}

// Fetch the nth 32-bit system call argument.
int
argint(int n, int *ip)
{
ffffffff80109090:	55                   	push   %rbp
ffffffff80109091:	48 89 e5             	mov    %rsp,%rbp
ffffffff80109094:	48 83 ec 10          	sub    $0x10,%rsp
ffffffff80109098:	89 7d fc             	mov    %edi,-0x4(%rbp)
ffffffff8010909b:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  *ip = fetcharg(n);
ffffffff8010909f:	8b 7d fc             	mov    -0x4(%rbp),%edi
ffffffff801090a2:	e8 19 00 00 00       	callq  ffffffff801090c0 <fetcharg>
ffffffff801090a7:	31 ff                	xor    %edi,%edi
ffffffff801090a9:	89 c1                	mov    %eax,%ecx
ffffffff801090ab:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
ffffffff801090af:	89 08                	mov    %ecx,(%rax)
  return 0;
ffffffff801090b1:	89 f8                	mov    %edi,%eax
ffffffff801090b3:	48 83 c4 10          	add    $0x10,%rsp
ffffffff801090b7:	5d                   	pop    %rbp
ffffffff801090b8:	c3                   	retq   
ffffffff801090b9:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)

ffffffff801090c0 <fetcharg>:
{
ffffffff801090c0:	55                   	push   %rbp
ffffffff801090c1:	48 89 e5             	mov    %rsp,%rbp
ffffffff801090c4:	48 83 ec 20          	sub    $0x20,%rsp
ffffffff801090c8:	89 7d f4             	mov    %edi,-0xc(%rbp)
  switch (n) {
ffffffff801090cb:	8b 7d f4             	mov    -0xc(%rbp),%edi
ffffffff801090ce:	89 f8                	mov    %edi,%eax
ffffffff801090d0:	48 89 c1             	mov    %rax,%rcx
ffffffff801090d3:	48 83 e9 05          	sub    $0x5,%rcx
ffffffff801090d7:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
ffffffff801090db:	48 89 4d e0          	mov    %rcx,-0x20(%rbp)
ffffffff801090df:	0f 87 a4 00 00 00    	ja     ffffffff80109189 <fetcharg+0xc9>
ffffffff801090e5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
ffffffff801090e9:	48 8b 0c c5 80 02 11 	mov    -0x7feefd80(,%rax,8),%rcx
ffffffff801090f0:	80 
ffffffff801090f1:	ff e1                	jmpq   *%rcx
  case 0: return myproc()->tf->rdi;
ffffffff801090f3:	e8 38 fc ff ff       	callq  ffffffff80108d30 <myproc>
ffffffff801090f8:	48 8b 80 10 01 00 00 	mov    0x110(%rax),%rax
ffffffff801090ff:	48 8b 40 30          	mov    0x30(%rax),%rax
ffffffff80109103:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
ffffffff80109107:	e9 89 00 00 00       	jmpq   ffffffff80109195 <fetcharg+0xd5>
  case 1: return myproc()->tf->rsi;
ffffffff8010910c:	e8 1f fc ff ff       	callq  ffffffff80108d30 <myproc>
ffffffff80109111:	48 8b 80 10 01 00 00 	mov    0x110(%rax),%rax
ffffffff80109118:	48 8b 40 28          	mov    0x28(%rax),%rax
ffffffff8010911c:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
ffffffff80109120:	e9 70 00 00 00       	jmpq   ffffffff80109195 <fetcharg+0xd5>
  case 2: return myproc()->tf->rdx;
ffffffff80109125:	e8 06 fc ff ff       	callq  ffffffff80108d30 <myproc>
ffffffff8010912a:	48 8b 80 10 01 00 00 	mov    0x110(%rax),%rax
ffffffff80109131:	48 8b 40 18          	mov    0x18(%rax),%rax
ffffffff80109135:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
ffffffff80109139:	e9 57 00 00 00       	jmpq   ffffffff80109195 <fetcharg+0xd5>
  case 3: return myproc()->tf->rcx;
ffffffff8010913e:	e8 ed fb ff ff       	callq  ffffffff80108d30 <myproc>
ffffffff80109143:	48 8b 80 10 01 00 00 	mov    0x110(%rax),%rax
ffffffff8010914a:	48 8b 40 10          	mov    0x10(%rax),%rax
ffffffff8010914e:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
ffffffff80109152:	e9 3e 00 00 00       	jmpq   ffffffff80109195 <fetcharg+0xd5>
  case 4: return myproc()->tf->r8;
ffffffff80109157:	e8 d4 fb ff ff       	callq  ffffffff80108d30 <myproc>
ffffffff8010915c:	48 8b 80 10 01 00 00 	mov    0x110(%rax),%rax
ffffffff80109163:	48 8b 40 38          	mov    0x38(%rax),%rax
ffffffff80109167:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
ffffffff8010916b:	e9 25 00 00 00       	jmpq   ffffffff80109195 <fetcharg+0xd5>
  case 5: return myproc()->tf->r9;
ffffffff80109170:	e8 bb fb ff ff       	callq  ffffffff80108d30 <myproc>
ffffffff80109175:	48 8b 80 10 01 00 00 	mov    0x110(%rax),%rax
ffffffff8010917c:	48 8b 40 40          	mov    0x40(%rax),%rax
ffffffff80109180:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
ffffffff80109184:	e9 0c 00 00 00       	jmpq   ffffffff80109195 <fetcharg+0xd5>
  panic("more than 6 arguments for a syscall");
ffffffff80109189:	48 c7 c7 cc 02 11 80 	mov    $0xffffffff801102cc,%rdi
ffffffff80109190:	e8 db 7c ff ff       	callq  ffffffff80100e70 <panic>
}
ffffffff80109195:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
ffffffff80109199:	48 83 c4 20          	add    $0x20,%rsp
ffffffff8010919d:	5d                   	pop    %rbp
ffffffff8010919e:	c3                   	retq   
ffffffff8010919f:	90                   	nop

ffffffff801091a0 <argint64>:


// Fetch the nth 64-bit system call argument.
int
argint64(int n, int64_t *ip)
{
ffffffff801091a0:	55                   	push   %rbp
ffffffff801091a1:	48 89 e5             	mov    %rsp,%rbp
ffffffff801091a4:	48 83 ec 10          	sub    $0x10,%rsp
ffffffff801091a8:	89 7d fc             	mov    %edi,-0x4(%rbp)
ffffffff801091ab:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  *ip = fetcharg(n);
ffffffff801091af:	8b 7d fc             	mov    -0x4(%rbp),%edi
ffffffff801091b2:	e8 09 ff ff ff       	callq  ffffffff801090c0 <fetcharg>
ffffffff801091b7:	31 ff                	xor    %edi,%edi
ffffffff801091b9:	48 8b 75 f0          	mov    -0x10(%rbp),%rsi
ffffffff801091bd:	48 89 06             	mov    %rax,(%rsi)
  return 0;
ffffffff801091c0:	89 f8                	mov    %edi,%eax
ffffffff801091c2:	48 83 c4 10          	add    $0x10,%rsp
ffffffff801091c6:	5d                   	pop    %rbp
ffffffff801091c7:	c3                   	retq   
ffffffff801091c8:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
ffffffff801091cf:	00 

ffffffff801091d0 <argptr>:
// Fetch the nth word-sized system call argument as a pointer
// to a block of memory of size bytes.  Check that the pointer
// lies within the process address space.
int
argptr(int n, char **pp, int size)
{
ffffffff801091d0:	55                   	push   %rbp
ffffffff801091d1:	48 89 e5             	mov    %rsp,%rbp
ffffffff801091d4:	48 83 ec 70          	sub    $0x70,%rsp
ffffffff801091d8:	48 8d 45 e0          	lea    -0x20(%rbp),%rax
ffffffff801091dc:	89 7d f8             	mov    %edi,-0x8(%rbp)
ffffffff801091df:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
ffffffff801091e3:	89 55 ec             	mov    %edx,-0x14(%rbp)
  int64_t i;

  if(argint64(n, &i) < 0)
ffffffff801091e6:	8b 7d f8             	mov    -0x8(%rbp),%edi
ffffffff801091e9:	48 8d 75 e0          	lea    -0x20(%rbp),%rsi
ffffffff801091ed:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
ffffffff801091f1:	e8 aa ff ff ff       	callq  ffffffff801091a0 <argint64>
ffffffff801091f6:	83 f8 00             	cmp    $0x0,%eax
ffffffff801091f9:	0f 8d 0c 00 00 00    	jge    ffffffff8010920b <argptr+0x3b>
    return -1;
ffffffff801091ff:	c7 45 fc ff ff ff ff 	movl   $0xffffffff,-0x4(%rbp)
ffffffff80109206:	e9 5e 01 00 00       	jmpq   ffffffff80109369 <argptr+0x199>
  if(size < 0)
ffffffff8010920b:	83 7d ec 00          	cmpl   $0x0,-0x14(%rbp)
ffffffff8010920f:	0f 8d 0c 00 00 00    	jge    ffffffff80109221 <argptr+0x51>
    return -1;
ffffffff80109215:	c7 45 fc ff ff ff ff 	movl   $0xffffffff,-0x4(%rbp)
ffffffff8010921c:	e9 48 01 00 00       	jmpq   ffffffff80109369 <argptr+0x199>
  if (((uint64_t)i >= (uint64_t)myproc()->mem_regions[CODE].start) && ((uint64_t)i + size <= (uint64_t)myproc()->mem_regions[CODE].start + myproc()->mem_regions[CODE].size)) {
ffffffff80109221:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
ffffffff80109225:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
ffffffff80109229:	e8 02 fb ff ff       	callq  ffffffff80108d30 <myproc>
ffffffff8010922e:	48 8b 40 08          	mov    0x8(%rax),%rax
ffffffff80109232:	48 8b 4d d0          	mov    -0x30(%rbp),%rcx
ffffffff80109236:	48 39 c1             	cmp    %rax,%rcx
ffffffff80109239:	0f 82 4d 00 00 00    	jb     ffffffff8010928c <argptr+0xbc>
ffffffff8010923f:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
ffffffff80109243:	48 63 4d ec          	movslq -0x14(%rbp),%rcx
ffffffff80109247:	48 01 c8             	add    %rcx,%rax
ffffffff8010924a:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
ffffffff8010924e:	e8 dd fa ff ff       	callq  ffffffff80108d30 <myproc>
ffffffff80109253:	48 8b 40 08          	mov    0x8(%rax),%rax
ffffffff80109257:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
ffffffff8010925b:	e8 d0 fa ff ff       	callq  ffffffff80108d30 <myproc>
ffffffff80109260:	48 8b 4d c0          	mov    -0x40(%rbp),%rcx
ffffffff80109264:	48 03 48 10          	add    0x10(%rax),%rcx
ffffffff80109268:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
ffffffff8010926c:	48 39 c8             	cmp    %rcx,%rax
ffffffff8010926f:	0f 87 17 00 00 00    	ja     ffffffff8010928c <argptr+0xbc>
      *pp = (char*)i;
ffffffff80109275:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
ffffffff80109279:	48 8b 4d f0          	mov    -0x10(%rbp),%rcx
ffffffff8010927d:	48 89 01             	mov    %rax,(%rcx)
      return 0;
ffffffff80109280:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
ffffffff80109287:	e9 dd 00 00 00       	jmpq   ffffffff80109369 <argptr+0x199>
    }
  if (((uint64_t)i >= (uint64_t)myproc()->mem_regions[HEAP].start) && ((uint64_t)i + size <= (uint64_t)myproc()->mem_regions[HEAP].start + myproc()->mem_regions[HEAP].size)) {
ffffffff8010928c:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
ffffffff80109290:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
ffffffff80109294:	e8 97 fa ff ff       	callq  ffffffff80108d30 <myproc>
ffffffff80109299:	48 8b 40 18          	mov    0x18(%rax),%rax
ffffffff8010929d:	48 8b 4d b8          	mov    -0x48(%rbp),%rcx
ffffffff801092a1:	48 39 c1             	cmp    %rax,%rcx
ffffffff801092a4:	0f 82 4d 00 00 00    	jb     ffffffff801092f7 <argptr+0x127>
ffffffff801092aa:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
ffffffff801092ae:	48 63 4d ec          	movslq -0x14(%rbp),%rcx
ffffffff801092b2:	48 01 c8             	add    %rcx,%rax
ffffffff801092b5:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
ffffffff801092b9:	e8 72 fa ff ff       	callq  ffffffff80108d30 <myproc>
ffffffff801092be:	48 8b 40 18          	mov    0x18(%rax),%rax
ffffffff801092c2:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
ffffffff801092c6:	e8 65 fa ff ff       	callq  ffffffff80108d30 <myproc>
ffffffff801092cb:	48 8b 4d a8          	mov    -0x58(%rbp),%rcx
ffffffff801092cf:	48 03 48 20          	add    0x20(%rax),%rcx
ffffffff801092d3:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
ffffffff801092d7:	48 39 c8             	cmp    %rcx,%rax
ffffffff801092da:	0f 87 17 00 00 00    	ja     ffffffff801092f7 <argptr+0x127>
    *pp = (char*)i;
ffffffff801092e0:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
ffffffff801092e4:	48 8b 4d f0          	mov    -0x10(%rbp),%rcx
ffffffff801092e8:	48 89 01             	mov    %rax,(%rcx)
    return 0;
ffffffff801092eb:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
ffffffff801092f2:	e9 72 00 00 00       	jmpq   ffffffff80109369 <argptr+0x199>
  }
  if (((uint64_t)i >= (uint64_t)myproc()->mem_regions[USTACK].start) && ((uint64_t)i + size <= (uint64_t)myproc()->mem_regions[USTACK].start + myproc()->mem_regions[USTACK].size)) {
ffffffff801092f7:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
ffffffff801092fb:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
ffffffff801092ff:	e8 2c fa ff ff       	callq  ffffffff80108d30 <myproc>
ffffffff80109304:	48 8b 40 28          	mov    0x28(%rax),%rax
ffffffff80109308:	48 8b 4d a0          	mov    -0x60(%rbp),%rcx
ffffffff8010930c:	48 39 c1             	cmp    %rax,%rcx
ffffffff8010930f:	0f 82 4d 00 00 00    	jb     ffffffff80109362 <argptr+0x192>
ffffffff80109315:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
ffffffff80109319:	48 63 4d ec          	movslq -0x14(%rbp),%rcx
ffffffff8010931d:	48 01 c8             	add    %rcx,%rax
ffffffff80109320:	48 89 45 98          	mov    %rax,-0x68(%rbp)
ffffffff80109324:	e8 07 fa ff ff       	callq  ffffffff80108d30 <myproc>
ffffffff80109329:	48 8b 40 28          	mov    0x28(%rax),%rax
ffffffff8010932d:	48 89 45 90          	mov    %rax,-0x70(%rbp)
ffffffff80109331:	e8 fa f9 ff ff       	callq  ffffffff80108d30 <myproc>
ffffffff80109336:	48 8b 4d 90          	mov    -0x70(%rbp),%rcx
ffffffff8010933a:	48 03 48 30          	add    0x30(%rax),%rcx
ffffffff8010933e:	48 8b 45 98          	mov    -0x68(%rbp),%rax
ffffffff80109342:	48 39 c8             	cmp    %rcx,%rax
ffffffff80109345:	0f 87 17 00 00 00    	ja     ffffffff80109362 <argptr+0x192>
    *pp = (char*)i;
ffffffff8010934b:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
ffffffff8010934f:	48 8b 4d f0          	mov    -0x10(%rbp),%rcx
ffffffff80109353:	48 89 01             	mov    %rax,(%rcx)
    return 0;
ffffffff80109356:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
ffffffff8010935d:	e9 07 00 00 00       	jmpq   ffffffff80109369 <argptr+0x199>
  }
  return -1;
ffffffff80109362:	c7 45 fc ff ff ff ff 	movl   $0xffffffff,-0x4(%rbp)
}
ffffffff80109369:	8b 45 fc             	mov    -0x4(%rbp),%eax
ffffffff8010936c:	48 83 c4 70          	add    $0x70,%rsp
ffffffff80109370:	5d                   	pop    %rbp
ffffffff80109371:	c3                   	retq   
ffffffff80109372:	66 66 66 66 66 2e 0f 	data16 data16 data16 data16 nopw %cs:0x0(%rax,%rax,1)
ffffffff80109379:	1f 84 00 00 00 00 00 

ffffffff80109380 <argstr>:
// Check that the pointer is valid and the string is nul-terminated.
// (There is no shared writable memory, so the string can't change
// between this check and being used by the kernel.)
int
argstr(int n, char **pp)
{
ffffffff80109380:	55                   	push   %rbp
ffffffff80109381:	48 89 e5             	mov    %rsp,%rbp
ffffffff80109384:	48 83 ec 20          	sub    $0x20,%rsp
ffffffff80109388:	48 8d 45 ec          	lea    -0x14(%rbp),%rax
ffffffff8010938c:	89 7d f8             	mov    %edi,-0x8(%rbp)
ffffffff8010938f:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  int addr;
  if(argint(n, &addr) < 0)
ffffffff80109393:	8b 7d f8             	mov    -0x8(%rbp),%edi
ffffffff80109396:	48 8d 75 ec          	lea    -0x14(%rbp),%rsi
ffffffff8010939a:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
ffffffff8010939e:	e8 ed fc ff ff       	callq  ffffffff80109090 <argint>
ffffffff801093a3:	83 f8 00             	cmp    $0x0,%eax
ffffffff801093a6:	0f 8d 0c 00 00 00    	jge    ffffffff801093b8 <argstr+0x38>
    return -1;
ffffffff801093ac:	c7 45 fc ff ff ff ff 	movl   $0xffffffff,-0x4(%rbp)
ffffffff801093b3:	e9 10 00 00 00       	jmpq   ffffffff801093c8 <argstr+0x48>
  return fetchstr(addr, pp);
ffffffff801093b8:	48 63 7d ec          	movslq -0x14(%rbp),%rdi
ffffffff801093bc:	48 8b 75 f0          	mov    -0x10(%rbp),%rsi
ffffffff801093c0:	e8 db fb ff ff       	callq  ffffffff80108fa0 <fetchstr>
ffffffff801093c5:	89 45 fc             	mov    %eax,-0x4(%rbp)
}
ffffffff801093c8:	8b 45 fc             	mov    -0x4(%rbp),%eax
ffffffff801093cb:	48 83 c4 20          	add    $0x20,%rsp
ffffffff801093cf:	5d                   	pop    %rbp
ffffffff801093d0:	c3                   	retq   
ffffffff801093d1:	66 66 66 66 66 66 2e 	data16 data16 data16 data16 data16 nopw %cs:0x0(%rax,%rax,1)
ffffffff801093d8:	0f 1f 84 00 00 00 00 
ffffffff801093df:	00 

ffffffff801093e0 <syscall>:
[SYS_crashn]  = sys_crashn,
};

void
syscall(void)
{
ffffffff801093e0:	55                   	push   %rbp
ffffffff801093e1:	48 89 e5             	mov    %rsp,%rbp
  int num;

  num = myproc()->tf->rax;
ffffffff801093e4:	48 83 ec 20          	sub    $0x20,%rsp
ffffffff801093e8:	e8 43 f9 ff ff       	callq  ffffffff80108d30 <myproc>
ffffffff801093ed:	48 8b 80 10 01 00 00 	mov    0x110(%rax),%rax
ffffffff801093f4:	48 8b 00             	mov    (%rax),%rax
ffffffff801093f7:	89 c1                	mov    %eax,%ecx
ffffffff801093f9:	89 4d fc             	mov    %ecx,-0x4(%rbp)
  if(num > 0 && num < NELEM(syscalls) && syscalls[num]) {
ffffffff801093fc:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
ffffffff80109400:	0f 8e 51 00 00 00    	jle    ffffffff80109457 <syscall+0x77>
ffffffff80109406:	48 63 45 fc          	movslq -0x4(%rbp),%rax
ffffffff8010940a:	48 83 f8 1a          	cmp    $0x1a,%rax
ffffffff8010940e:	0f 83 43 00 00 00    	jae    ffffffff80109457 <syscall+0x77>
ffffffff80109414:	48 63 45 fc          	movslq -0x4(%rbp),%rax
ffffffff80109418:	48 8d 04 c5 b0 18 12 	lea    -0x7fede750(,%rax,8),%rax
ffffffff8010941f:	80 
ffffffff80109420:	48 83 38 00          	cmpq   $0x0,(%rax)
ffffffff80109424:	0f 84 2d 00 00 00    	je     ffffffff80109457 <syscall+0x77>
    myproc()->tf->rax = syscalls[num]();
ffffffff8010942a:	48 63 45 fc          	movslq -0x4(%rbp),%rax
ffffffff8010942e:	48 8d 04 c5 b0 18 12 	lea    -0x7fede750(,%rax,8),%rax
ffffffff80109435:	80 
ffffffff80109436:	ff 10                	callq  *(%rax)
ffffffff80109438:	48 63 c8             	movslq %eax,%rcx
ffffffff8010943b:	48 89 4d f0          	mov    %rcx,-0x10(%rbp)
ffffffff8010943f:	e8 ec f8 ff ff       	callq  ffffffff80108d30 <myproc>
ffffffff80109444:	48 8b 80 10 01 00 00 	mov    0x110(%rax),%rax
ffffffff8010944b:	48 8b 4d f0          	mov    -0x10(%rbp),%rcx
ffffffff8010944f:	48 89 08             	mov    %rcx,(%rax)
  } else {
ffffffff80109452:	e9 4c 00 00 00       	jmpq   ffffffff801094a3 <syscall+0xc3>
    cprintf("%d %s: unknown sys call %d\n",
            myproc()->pid, myproc()->name, num);
ffffffff80109457:	e8 d4 f8 ff ff       	callq  ffffffff80108d30 <myproc>
ffffffff8010945c:	8b b0 04 01 00 00    	mov    0x104(%rax),%esi
ffffffff80109462:	89 75 ec             	mov    %esi,-0x14(%rbp)
ffffffff80109465:	e8 c6 f8 ff ff       	callq  ffffffff80108d30 <myproc>
ffffffff8010946a:	48 05 2c 01 00 00    	add    $0x12c,%rax
ffffffff80109470:	8b 4d fc             	mov    -0x4(%rbp),%ecx
    cprintf("%d %s: unknown sys call %d\n",
ffffffff80109473:	48 c7 c7 b0 02 11 80 	mov    $0xffffffff801102b0,%rdi
ffffffff8010947a:	31 f6                	xor    %esi,%esi
ffffffff8010947c:	40 88 f2             	mov    %sil,%dl
ffffffff8010947f:	8b 75 ec             	mov    -0x14(%rbp),%esi
ffffffff80109482:	88 55 eb             	mov    %dl,-0x15(%rbp)
ffffffff80109485:	48 89 c2             	mov    %rax,%rdx
ffffffff80109488:	8a 45 eb             	mov    -0x15(%rbp),%al
ffffffff8010948b:	e8 d0 74 ff ff       	callq  ffffffff80100960 <cprintf>
    myproc()->tf->rax = -1;
ffffffff80109490:	e8 9b f8 ff ff       	callq  ffffffff80108d30 <myproc>
ffffffff80109495:	48 8b 80 10 01 00 00 	mov    0x110(%rax),%rax
ffffffff8010949c:	48 c7 00 ff ff ff ff 	movq   $0xffffffffffffffff,(%rax)
  }
}
ffffffff801094a3:	48 83 c4 20          	add    $0x20,%rsp
ffffffff801094a7:	5d                   	pop    %rbp
ffffffff801094a8:	c3                   	retq   
ffffffff801094a9:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)

ffffffff801094b0 <sys_sysinfo>:

int
sys_sysinfo(void)
{
ffffffff801094b0:	55                   	push   %rbp
ffffffff801094b1:	48 89 e5             	mov    %rsp,%rbp
ffffffff801094b4:	48 83 ec 20          	sub    $0x20,%rsp
ffffffff801094b8:	31 c0                	xor    %eax,%eax
ffffffff801094ba:	b9 08 00 00 00       	mov    $0x8,%ecx
ffffffff801094bf:	48 8d 55 f0          	lea    -0x10(%rbp),%rdx
  struct sys_info *info;

  if(argptr(0, (void*)&info, sizeof(info)) < 0)
ffffffff801094c3:	31 ff                	xor    %edi,%edi
ffffffff801094c5:	be 08 00 00 00       	mov    $0x8,%esi
ffffffff801094ca:	89 75 ec             	mov    %esi,-0x14(%rbp)
ffffffff801094cd:	48 89 d6             	mov    %rdx,%rsi
ffffffff801094d0:	8b 55 ec             	mov    -0x14(%rbp),%edx
ffffffff801094d3:	89 45 e8             	mov    %eax,-0x18(%rbp)
ffffffff801094d6:	89 4d e4             	mov    %ecx,-0x1c(%rbp)
ffffffff801094d9:	e8 f2 fc ff ff       	callq  ffffffff801091d0 <argptr>
ffffffff801094de:	83 f8 00             	cmp    $0x0,%eax
ffffffff801094e1:	0f 8d 0c 00 00 00    	jge    ffffffff801094f3 <sys_sysinfo+0x43>
    return -1;
ffffffff801094e7:	c7 45 fc ff ff ff ff 	movl   $0xffffffff,-0x4(%rbp)
ffffffff801094ee:	e9 4c 00 00 00       	jmpq   ffffffff8010953f <sys_sysinfo+0x8f>

  info->pages_in_use = pages_in_use;
ffffffff801094f3:	8b 04 25 a0 65 1f 83 	mov    0xffffffff831f65a0,%eax
ffffffff801094fa:	48 8b 4d f0          	mov    -0x10(%rbp),%rcx
ffffffff801094fe:	89 01                	mov    %eax,(%rcx)
  info->pages_in_swap = pages_in_swap;
ffffffff80109500:	8b 04 25 a8 65 1f 83 	mov    0xffffffff831f65a8,%eax
ffffffff80109507:	48 8b 4d f0          	mov    -0x10(%rbp),%rcx
ffffffff8010950b:	89 41 04             	mov    %eax,0x4(%rcx)
  info->free_pages = free_pages;
ffffffff8010950e:	8b 04 25 98 65 1f 83 	mov    0xffffffff831f6598,%eax
ffffffff80109515:	48 8b 4d f0          	mov    -0x10(%rbp),%rcx
ffffffff80109519:	89 41 08             	mov    %eax,0x8(%rcx)
  info->num_page_faults = num_page_faults;
ffffffff8010951c:	8b 04 25 78 64 1f 83 	mov    0xffffffff831f6478,%eax
ffffffff80109523:	48 8b 4d f0          	mov    -0x10(%rbp),%rcx
ffffffff80109527:	89 41 0c             	mov    %eax,0xc(%rcx)
  info->num_disk_reads = num_disk_reads;
ffffffff8010952a:	8b 04 25 98 64 1f 83 	mov    0xffffffff831f6498,%eax
ffffffff80109531:	48 8b 4d f0          	mov    -0x10(%rbp),%rcx
ffffffff80109535:	89 41 10             	mov    %eax,0x10(%rcx)

  return 0;
ffffffff80109538:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
}
ffffffff8010953f:	8b 45 fc             	mov    -0x4(%rbp),%eax
ffffffff80109542:	48 83 c4 20          	add    $0x20,%rsp
ffffffff80109546:	5d                   	pop    %rbp
ffffffff80109547:	c3                   	retq   
ffffffff80109548:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
ffffffff8010954f:	00 

ffffffff80109550 <mycpu>:
{
ffffffff80109550:	55                   	push   %rbp
ffffffff80109551:	48 89 e5             	mov    %rsp,%rbp
  return &cpus[0];
ffffffff80109554:	48 c7 c0 e0 7b 1f 83 	mov    $0xffffffff831f7be0,%rax
ffffffff8010955b:	5d                   	pop    %rbp
ffffffff8010955c:	c3                   	retq   
ffffffff8010955d:	0f 1f 00             	nopl   (%rax)

ffffffff80109560 <sys_dup>:
  return this_file->type != FILE_UNUSED;
}

int
sys_dup(void)
{
ffffffff80109560:	55                   	push   %rbp
ffffffff80109561:	48 89 e5             	mov    %rsp,%rbp
ffffffff80109564:	48 83 ec 30          	sub    $0x30,%rsp
ffffffff80109568:	31 c0                	xor    %eax,%eax
ffffffff8010956a:	48 8d 4d f8          	lea    -0x8(%rbp),%rcx
  int original_fd;

  if (argint(0, &original_fd) < 0) {
ffffffff8010956e:	31 ff                	xor    %edi,%edi
ffffffff80109570:	48 8d 75 f8          	lea    -0x8(%rbp),%rsi
ffffffff80109574:	89 45 e4             	mov    %eax,-0x1c(%rbp)
ffffffff80109577:	48 89 4d d8          	mov    %rcx,-0x28(%rbp)
ffffffff8010957b:	e8 10 fb ff ff       	callq  ffffffff80109090 <argint>
ffffffff80109580:	83 f8 00             	cmp    $0x0,%eax
ffffffff80109583:	0f 8d 0c 00 00 00    	jge    ffffffff80109595 <sys_dup+0x35>
    return -1;
ffffffff80109589:	c7 45 fc ff ff ff ff 	movl   $0xffffffff,-0x4(%rbp)
ffffffff80109590:	e9 6e 00 00 00       	jmpq   ffffffff80109603 <sys_dup+0xa3>
  }

  if (bounds_check(original_fd)) {
ffffffff80109595:	8b 7d f8             	mov    -0x8(%rbp),%edi
ffffffff80109598:	e8 73 00 00 00       	callq  ffffffff80109610 <bounds_check>
ffffffff8010959d:	a8 01                	test   $0x1,%al
ffffffff8010959f:	0f 85 05 00 00 00    	jne    ffffffff801095aa <sys_dup+0x4a>
ffffffff801095a5:	e9 0c 00 00 00       	jmpq   ffffffff801095b6 <sys_dup+0x56>
    return -1;
ffffffff801095aa:	c7 45 fc ff ff ff ff 	movl   $0xffffffff,-0x4(%rbp)
ffffffff801095b1:	e9 4d 00 00 00       	jmpq   ffffffff80109603 <sys_dup+0xa3>
  }

  struct proc* this_proc = myproc();
ffffffff801095b6:	e8 85 00 00 00       	callq  ffffffff80109640 <myproc>
ffffffff801095bb:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  struct open_file* this_file = &(this_proc->open_files[original_fd]);
ffffffff801095bf:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
ffffffff801095c3:	48 83 c0 38          	add    $0x38,%rax
ffffffff801095c7:	48 63 4d f8          	movslq -0x8(%rbp),%rcx
ffffffff801095cb:	48 6b c9 0b          	imul   $0xb,%rcx,%rcx
ffffffff801095cf:	48 01 c8             	add    %rcx,%rax
ffffffff801095d2:	48 89 45 e8          	mov    %rax,-0x18(%rbp)

  if (in_use(this_file)) {
ffffffff801095d6:	48 8b 7d e8          	mov    -0x18(%rbp),%rdi
ffffffff801095da:	e8 81 00 00 00       	callq  ffffffff80109660 <in_use>
ffffffff801095df:	a8 01                	test   $0x1,%al
ffffffff801095e1:	0f 85 05 00 00 00    	jne    ffffffff801095ec <sys_dup+0x8c>
ffffffff801095e7:	e9 10 00 00 00       	jmpq   ffffffff801095fc <sys_dup+0x9c>
    return kernel_sys_dup(original_fd);
ffffffff801095ec:	8b 7d f8             	mov    -0x8(%rbp),%edi
ffffffff801095ef:	e8 0c 36 00 00       	callq  ffffffff8010cc00 <kernel_sys_dup>
ffffffff801095f4:	89 45 fc             	mov    %eax,-0x4(%rbp)
ffffffff801095f7:	e9 07 00 00 00       	jmpq   ffffffff80109603 <sys_dup+0xa3>
  } else {
    // error, fd is not valid for dup
    return -1;
ffffffff801095fc:	c7 45 fc ff ff ff ff 	movl   $0xffffffff,-0x4(%rbp)
  }
}
ffffffff80109603:	8b 45 fc             	mov    -0x4(%rbp),%eax
ffffffff80109606:	48 83 c4 30          	add    $0x30,%rsp
ffffffff8010960a:	5d                   	pop    %rbp
ffffffff8010960b:	c3                   	retq   
ffffffff8010960c:	0f 1f 40 00          	nopl   0x0(%rax)

ffffffff80109610 <bounds_check>:
{
ffffffff80109610:	55                   	push   %rbp
ffffffff80109611:	48 89 e5             	mov    %rsp,%rbp
ffffffff80109614:	50                   	push   %rax
ffffffff80109615:	b0 01                	mov    $0x1,%al
ffffffff80109617:	89 7d fc             	mov    %edi,-0x4(%rbp)
  return fd < 0 || fd >= NOFILE;
ffffffff8010961a:	83 7d fc 00          	cmpl   $0x0,-0x4(%rbp)
ffffffff8010961e:	88 45 fb             	mov    %al,-0x5(%rbp)
ffffffff80109621:	0f 8c 0a 00 00 00    	jl     ffffffff80109631 <bounds_check+0x21>
ffffffff80109627:	83 7d fc 10          	cmpl   $0x10,-0x4(%rbp)
ffffffff8010962b:	0f 9d c0             	setge  %al
ffffffff8010962e:	88 45 fb             	mov    %al,-0x5(%rbp)
ffffffff80109631:	8a 45 fb             	mov    -0x5(%rbp),%al
ffffffff80109634:	24 01                	and    $0x1,%al
ffffffff80109636:	0f b6 c0             	movzbl %al,%eax
ffffffff80109639:	48 83 c4 08          	add    $0x8,%rsp
ffffffff8010963d:	5d                   	pop    %rbp
ffffffff8010963e:	c3                   	retq   
ffffffff8010963f:	90                   	nop

ffffffff80109640 <myproc>:
{
ffffffff80109640:	55                   	push   %rbp
ffffffff80109641:	48 89 e5             	mov    %rsp,%rbp
  return mycpu()->proc;
ffffffff80109644:	e8 d7 06 00 00       	callq  ffffffff80109d20 <mycpu>
ffffffff80109649:	48 8b 80 d0 00 00 00 	mov    0xd0(%rax),%rax
ffffffff80109650:	5d                   	pop    %rbp
ffffffff80109651:	c3                   	retq   
ffffffff80109652:	66 66 66 66 66 2e 0f 	data16 data16 data16 data16 nopw %cs:0x0(%rax,%rax,1)
ffffffff80109659:	1f 84 00 00 00 00 00 

ffffffff80109660 <in_use>:
{
ffffffff80109660:	55                   	push   %rbp
ffffffff80109661:	48 89 e5             	mov    %rsp,%rbp
ffffffff80109664:	50                   	push   %rax
ffffffff80109665:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  return this_file->type != FILE_UNUSED;
ffffffff80109669:	48 8b 7d f8          	mov    -0x8(%rbp),%rdi
ffffffff8010966d:	0f be 47 0a          	movsbl 0xa(%rdi),%eax
ffffffff80109671:	83 f8 00             	cmp    $0x0,%eax
ffffffff80109674:	0f 95 c1             	setne  %cl
ffffffff80109677:	80 e1 01             	and    $0x1,%cl
ffffffff8010967a:	0f b6 c1             	movzbl %cl,%eax
ffffffff8010967d:	48 83 c4 08          	add    $0x8,%rsp
ffffffff80109681:	5d                   	pop    %rbp
ffffffff80109682:	c3                   	retq   
ffffffff80109683:	66 66 66 66 2e 0f 1f 	data16 data16 data16 nopw %cs:0x0(%rax,%rax,1)
ffffffff8010968a:	84 00 00 00 00 00 

ffffffff80109690 <sys_read>:

int
sys_read(void)
{
ffffffff80109690:	55                   	push   %rbp
ffffffff80109691:	48 89 e5             	mov    %rsp,%rbp
ffffffff80109694:	48 83 ec 60          	sub    $0x60,%rsp
ffffffff80109698:	31 c0                	xor    %eax,%eax
ffffffff8010969a:	48 8d 4d f8          	lea    -0x8(%rbp),%rcx
  int fd;
  int num_bytes;
  char* read_buf;

  if (argint(0, &fd) < 0
ffffffff8010969e:	31 ff                	xor    %edi,%edi
ffffffff801096a0:	48 8d 75 f8          	lea    -0x8(%rbp),%rsi
ffffffff801096a4:	89 45 d4             	mov    %eax,-0x2c(%rbp)
ffffffff801096a7:	48 89 4d c8          	mov    %rcx,-0x38(%rbp)
ffffffff801096ab:	e8 e0 f9 ff ff       	callq  ffffffff80109090 <argint>
ffffffff801096b0:	83 f8 00             	cmp    $0x0,%eax
        || argint(2, &num_bytes) < 0
ffffffff801096b3:	0f 8c 51 00 00 00    	jl     ffffffff8010970a <sys_read+0x7a>
ffffffff801096b9:	b8 02 00 00 00       	mov    $0x2,%eax
ffffffff801096be:	48 8d 4d f4          	lea    -0xc(%rbp),%rcx
ffffffff801096c2:	bf 02 00 00 00       	mov    $0x2,%edi
ffffffff801096c7:	48 8d 75 f4          	lea    -0xc(%rbp),%rsi
ffffffff801096cb:	89 45 c4             	mov    %eax,-0x3c(%rbp)
ffffffff801096ce:	48 89 4d b8          	mov    %rcx,-0x48(%rbp)
ffffffff801096d2:	e8 b9 f9 ff ff       	callq  ffffffff80109090 <argint>
ffffffff801096d7:	83 f8 00             	cmp    $0x0,%eax
        || argptr(1, &read_buf, num_bytes) < 0) {
ffffffff801096da:	0f 8c 2a 00 00 00    	jl     ffffffff8010970a <sys_read+0x7a>
ffffffff801096e0:	b8 01 00 00 00       	mov    $0x1,%eax
ffffffff801096e5:	48 8d 4d e8          	lea    -0x18(%rbp),%rcx
ffffffff801096e9:	8b 55 f4             	mov    -0xc(%rbp),%edx
ffffffff801096ec:	bf 01 00 00 00       	mov    $0x1,%edi
ffffffff801096f1:	48 8d 75 e8          	lea    -0x18(%rbp),%rsi
ffffffff801096f5:	89 45 b4             	mov    %eax,-0x4c(%rbp)
ffffffff801096f8:	48 89 4d a8          	mov    %rcx,-0x58(%rbp)
ffffffff801096fc:	e8 cf fa ff ff       	callq  ffffffff801091d0 <argptr>
ffffffff80109701:	83 f8 00             	cmp    $0x0,%eax
  if (argint(0, &fd) < 0
ffffffff80109704:	0f 8d 0c 00 00 00    	jge    ffffffff80109716 <sys_read+0x86>
    return -1;
ffffffff8010970a:	c7 45 fc ff ff ff ff 	movl   $0xffffffff,-0x4(%rbp)
ffffffff80109711:	e9 75 00 00 00       	jmpq   ffffffff8010978b <sys_read+0xfb>
  }

  if (bounds_check(fd)) {
ffffffff80109716:	8b 7d f8             	mov    -0x8(%rbp),%edi
ffffffff80109719:	e8 f2 fe ff ff       	callq  ffffffff80109610 <bounds_check>
ffffffff8010971e:	a8 01                	test   $0x1,%al
ffffffff80109720:	0f 85 05 00 00 00    	jne    ffffffff8010972b <sys_read+0x9b>
ffffffff80109726:	e9 0c 00 00 00       	jmpq   ffffffff80109737 <sys_read+0xa7>
    return -1;
ffffffff8010972b:	c7 45 fc ff ff ff ff 	movl   $0xffffffff,-0x4(%rbp)
ffffffff80109732:	e9 54 00 00 00       	jmpq   ffffffff8010978b <sys_read+0xfb>
  }

  struct proc* this_proc = myproc();
ffffffff80109737:	e8 04 ff ff ff       	callq  ffffffff80109640 <myproc>
ffffffff8010973c:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  struct open_file* this_file = &(this_proc->open_files[fd]);
ffffffff80109740:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
ffffffff80109744:	48 83 c0 38          	add    $0x38,%rax
ffffffff80109748:	48 63 4d f8          	movslq -0x8(%rbp),%rcx
ffffffff8010974c:	48 6b c9 0b          	imul   $0xb,%rcx,%rcx
ffffffff80109750:	48 01 c8             	add    %rcx,%rax
ffffffff80109753:	48 89 45 d8          	mov    %rax,-0x28(%rbp)

  if (in_use(this_file)) {
ffffffff80109757:	48 8b 7d d8          	mov    -0x28(%rbp),%rdi
ffffffff8010975b:	e8 00 ff ff ff       	callq  ffffffff80109660 <in_use>
ffffffff80109760:	a8 01                	test   $0x1,%al
ffffffff80109762:	0f 85 05 00 00 00    	jne    ffffffff8010976d <sys_read+0xdd>
ffffffff80109768:	e9 17 00 00 00       	jmpq   ffffffff80109784 <sys_read+0xf4>
    return kernel_sys_read(fd, read_buf, num_bytes);
ffffffff8010976d:	8b 7d f8             	mov    -0x8(%rbp),%edi
ffffffff80109770:	48 8b 75 e8          	mov    -0x18(%rbp),%rsi
ffffffff80109774:	8b 55 f4             	mov    -0xc(%rbp),%edx
ffffffff80109777:	e8 f4 36 00 00       	callq  ffffffff8010ce70 <kernel_sys_read>
ffffffff8010977c:	89 45 fc             	mov    %eax,-0x4(%rbp)
ffffffff8010977f:	e9 07 00 00 00       	jmpq   ffffffff8010978b <sys_read+0xfb>
  } else {
    return -1;
ffffffff80109784:	c7 45 fc ff ff ff ff 	movl   $0xffffffff,-0x4(%rbp)
  }
}
ffffffff8010978b:	8b 45 fc             	mov    -0x4(%rbp),%eax
ffffffff8010978e:	48 83 c4 60          	add    $0x60,%rsp
ffffffff80109792:	5d                   	pop    %rbp
ffffffff80109793:	c3                   	retq   
ffffffff80109794:	66 66 66 2e 0f 1f 84 	data16 data16 nopw %cs:0x0(%rax,%rax,1)
ffffffff8010979b:	00 00 00 00 00 

ffffffff801097a0 <sys_write>:

int
sys_write(void)
{
ffffffff801097a0:	55                   	push   %rbp
ffffffff801097a1:	48 89 e5             	mov    %rsp,%rbp
ffffffff801097a4:	48 83 ec 60          	sub    $0x60,%rsp
ffffffff801097a8:	31 c0                	xor    %eax,%eax
ffffffff801097aa:	48 8d 4d f8          	lea    -0x8(%rbp),%rcx
  // Currently it supports printing one character to screen
  int fd;
  int num_bytes;
  char * write_buf;

  if (argint(0, &fd) < 0
ffffffff801097ae:	31 ff                	xor    %edi,%edi
ffffffff801097b0:	48 8d 75 f8          	lea    -0x8(%rbp),%rsi
ffffffff801097b4:	89 45 d4             	mov    %eax,-0x2c(%rbp)
ffffffff801097b7:	48 89 4d c8          	mov    %rcx,-0x38(%rbp)
ffffffff801097bb:	e8 d0 f8 ff ff       	callq  ffffffff80109090 <argint>
ffffffff801097c0:	83 f8 00             	cmp    $0x0,%eax
      || argint(2, &num_bytes) < 0
ffffffff801097c3:	0f 8c 51 00 00 00    	jl     ffffffff8010981a <sys_write+0x7a>
ffffffff801097c9:	b8 02 00 00 00       	mov    $0x2,%eax
ffffffff801097ce:	48 8d 4d f4          	lea    -0xc(%rbp),%rcx
ffffffff801097d2:	bf 02 00 00 00       	mov    $0x2,%edi
ffffffff801097d7:	48 8d 75 f4          	lea    -0xc(%rbp),%rsi
ffffffff801097db:	89 45 c4             	mov    %eax,-0x3c(%rbp)
ffffffff801097de:	48 89 4d b8          	mov    %rcx,-0x48(%rbp)
ffffffff801097e2:	e8 a9 f8 ff ff       	callq  ffffffff80109090 <argint>
ffffffff801097e7:	83 f8 00             	cmp    $0x0,%eax
      || argptr(1, &write_buf, num_bytes) < 0) {
ffffffff801097ea:	0f 8c 2a 00 00 00    	jl     ffffffff8010981a <sys_write+0x7a>
ffffffff801097f0:	b8 01 00 00 00       	mov    $0x1,%eax
ffffffff801097f5:	48 8d 4d e8          	lea    -0x18(%rbp),%rcx
ffffffff801097f9:	8b 55 f4             	mov    -0xc(%rbp),%edx
ffffffff801097fc:	bf 01 00 00 00       	mov    $0x1,%edi
ffffffff80109801:	48 8d 75 e8          	lea    -0x18(%rbp),%rsi
ffffffff80109805:	89 45 b4             	mov    %eax,-0x4c(%rbp)
ffffffff80109808:	48 89 4d a8          	mov    %rcx,-0x58(%rbp)
ffffffff8010980c:	e8 bf f9 ff ff       	callq  ffffffff801091d0 <argptr>
ffffffff80109811:	83 f8 00             	cmp    $0x0,%eax
  if (argint(0, &fd) < 0
ffffffff80109814:	0f 8d 0c 00 00 00    	jge    ffffffff80109826 <sys_write+0x86>
    return -1;
ffffffff8010981a:	c7 45 fc ff ff ff ff 	movl   $0xffffffff,-0x4(%rbp)
ffffffff80109821:	e9 75 00 00 00       	jmpq   ffffffff8010989b <sys_write+0xfb>
  }

  if (bounds_check(fd)) {
ffffffff80109826:	8b 7d f8             	mov    -0x8(%rbp),%edi
ffffffff80109829:	e8 e2 fd ff ff       	callq  ffffffff80109610 <bounds_check>
ffffffff8010982e:	a8 01                	test   $0x1,%al
ffffffff80109830:	0f 85 05 00 00 00    	jne    ffffffff8010983b <sys_write+0x9b>
ffffffff80109836:	e9 0c 00 00 00       	jmpq   ffffffff80109847 <sys_write+0xa7>
      return -1;
ffffffff8010983b:	c7 45 fc ff ff ff ff 	movl   $0xffffffff,-0x4(%rbp)
ffffffff80109842:	e9 54 00 00 00       	jmpq   ffffffff8010989b <sys_write+0xfb>
  }

  struct proc* this_proc = myproc();
ffffffff80109847:	e8 f4 fd ff ff       	callq  ffffffff80109640 <myproc>
ffffffff8010984c:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  struct open_file* this_file = &(this_proc->open_files[fd]);
ffffffff80109850:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
ffffffff80109854:	48 83 c0 38          	add    $0x38,%rax
ffffffff80109858:	48 63 4d f8          	movslq -0x8(%rbp),%rcx
ffffffff8010985c:	48 6b c9 0b          	imul   $0xb,%rcx,%rcx
ffffffff80109860:	48 01 c8             	add    %rcx,%rax
ffffffff80109863:	48 89 45 d8          	mov    %rax,-0x28(%rbp)

  if(in_use(this_file)) {
ffffffff80109867:	48 8b 7d d8          	mov    -0x28(%rbp),%rdi
ffffffff8010986b:	e8 f0 fd ff ff       	callq  ffffffff80109660 <in_use>
ffffffff80109870:	a8 01                	test   $0x1,%al
ffffffff80109872:	0f 85 05 00 00 00    	jne    ffffffff8010987d <sys_write+0xdd>
ffffffff80109878:	e9 17 00 00 00       	jmpq   ffffffff80109894 <sys_write+0xf4>
    return kernel_sys_write(fd, write_buf, num_bytes);
ffffffff8010987d:	8b 7d f8             	mov    -0x8(%rbp),%edi
ffffffff80109880:	48 8b 75 e8          	mov    -0x18(%rbp),%rsi
ffffffff80109884:	8b 55 f4             	mov    -0xc(%rbp),%edx
ffffffff80109887:	e8 24 39 00 00       	callq  ffffffff8010d1b0 <kernel_sys_write>
ffffffff8010988c:	89 45 fc             	mov    %eax,-0x4(%rbp)
ffffffff8010988f:	e9 07 00 00 00       	jmpq   ffffffff8010989b <sys_write+0xfb>
  } else {
    return -1;
ffffffff80109894:	c7 45 fc ff ff ff ff 	movl   $0xffffffff,-0x4(%rbp)
  }
}
ffffffff8010989b:	8b 45 fc             	mov    -0x4(%rbp),%eax
ffffffff8010989e:	48 83 c4 60          	add    $0x60,%rsp
ffffffff801098a2:	5d                   	pop    %rbp
ffffffff801098a3:	c3                   	retq   
ffffffff801098a4:	66 66 66 2e 0f 1f 84 	data16 data16 nopw %cs:0x0(%rax,%rax,1)
ffffffff801098ab:	00 00 00 00 00 

ffffffff801098b0 <sys_close>:

int
sys_close(void)
{
ffffffff801098b0:	55                   	push   %rbp
ffffffff801098b1:	48 89 e5             	mov    %rsp,%rbp
ffffffff801098b4:	48 83 ec 30          	sub    $0x30,%rsp
ffffffff801098b8:	31 c0                	xor    %eax,%eax
ffffffff801098ba:	48 8d 4d f8          	lea    -0x8(%rbp),%rcx
  int fd;

  if (argint(0, &fd) < 0) {
ffffffff801098be:	31 ff                	xor    %edi,%edi
ffffffff801098c0:	48 8d 75 f8          	lea    -0x8(%rbp),%rsi
ffffffff801098c4:	89 45 e4             	mov    %eax,-0x1c(%rbp)
ffffffff801098c7:	48 89 4d d8          	mov    %rcx,-0x28(%rbp)
ffffffff801098cb:	e8 c0 f7 ff ff       	callq  ffffffff80109090 <argint>
ffffffff801098d0:	83 f8 00             	cmp    $0x0,%eax
ffffffff801098d3:	0f 8d 0c 00 00 00    	jge    ffffffff801098e5 <sys_close+0x35>
    return -1;
ffffffff801098d9:	c7 45 fc ff ff ff ff 	movl   $0xffffffff,-0x4(%rbp)
ffffffff801098e0:	e9 6e 00 00 00       	jmpq   ffffffff80109953 <sys_close+0xa3>
  }

  if (bounds_check(fd)) {
ffffffff801098e5:	8b 7d f8             	mov    -0x8(%rbp),%edi
ffffffff801098e8:	e8 23 fd ff ff       	callq  ffffffff80109610 <bounds_check>
ffffffff801098ed:	a8 01                	test   $0x1,%al
ffffffff801098ef:	0f 85 05 00 00 00    	jne    ffffffff801098fa <sys_close+0x4a>
ffffffff801098f5:	e9 0c 00 00 00       	jmpq   ffffffff80109906 <sys_close+0x56>
      return -1;
ffffffff801098fa:	c7 45 fc ff ff ff ff 	movl   $0xffffffff,-0x4(%rbp)
ffffffff80109901:	e9 4d 00 00 00       	jmpq   ffffffff80109953 <sys_close+0xa3>
  }

  struct proc* this_proc = myproc();
ffffffff80109906:	e8 35 fd ff ff       	callq  ffffffff80109640 <myproc>
ffffffff8010990b:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  struct open_file* this_file = &(this_proc->open_files[fd]);
ffffffff8010990f:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
ffffffff80109913:	48 83 c0 38          	add    $0x38,%rax
ffffffff80109917:	48 63 4d f8          	movslq -0x8(%rbp),%rcx
ffffffff8010991b:	48 6b c9 0b          	imul   $0xb,%rcx,%rcx
ffffffff8010991f:	48 01 c8             	add    %rcx,%rax
ffffffff80109922:	48 89 45 e8          	mov    %rax,-0x18(%rbp)

  if (in_use(this_file)) {
ffffffff80109926:	48 8b 7d e8          	mov    -0x18(%rbp),%rdi
ffffffff8010992a:	e8 31 fd ff ff       	callq  ffffffff80109660 <in_use>
ffffffff8010992f:	a8 01                	test   $0x1,%al
ffffffff80109931:	0f 85 05 00 00 00    	jne    ffffffff8010993c <sys_close+0x8c>
ffffffff80109937:	e9 10 00 00 00       	jmpq   ffffffff8010994c <sys_close+0x9c>
    return kernel_sys_close(fd);
ffffffff8010993c:	8b 7d f8             	mov    -0x8(%rbp),%edi
ffffffff8010993f:	e8 3c 3b 00 00       	callq  ffffffff8010d480 <kernel_sys_close>
ffffffff80109944:	89 45 fc             	mov    %eax,-0x4(%rbp)
ffffffff80109947:	e9 07 00 00 00       	jmpq   ffffffff80109953 <sys_close+0xa3>
  } else {
    return -1;
ffffffff8010994c:	c7 45 fc ff ff ff ff 	movl   $0xffffffff,-0x4(%rbp)
  }
}
ffffffff80109953:	8b 45 fc             	mov    -0x4(%rbp),%eax
ffffffff80109956:	48 83 c4 30          	add    $0x30,%rsp
ffffffff8010995a:	5d                   	pop    %rbp
ffffffff8010995b:	c3                   	retq   
ffffffff8010995c:	0f 1f 40 00          	nopl   0x0(%rax)

ffffffff80109960 <sys_fstat>:

int
sys_fstat(void)
{
ffffffff80109960:	55                   	push   %rbp
ffffffff80109961:	48 89 e5             	mov    %rsp,%rbp
ffffffff80109964:	48 83 ec 50          	sub    $0x50,%rsp
ffffffff80109968:	31 c0                	xor    %eax,%eax
ffffffff8010996a:	48 8d 4d f8          	lea    -0x8(%rbp),%rcx
  int fd;
  struct stat *st;

  if (argint(0, &fd) < 0 || argptr(1, (void*)&st, sizeof(*st)) < 0) {
ffffffff8010996e:	31 ff                	xor    %edi,%edi
ffffffff80109970:	48 8d 75 f8          	lea    -0x8(%rbp),%rsi
ffffffff80109974:	89 45 d4             	mov    %eax,-0x2c(%rbp)
ffffffff80109977:	48 89 4d c8          	mov    %rcx,-0x38(%rbp)
ffffffff8010997b:	e8 10 f7 ff ff       	callq  ffffffff80109090 <argint>
ffffffff80109980:	83 f8 00             	cmp    $0x0,%eax
ffffffff80109983:	0f 8c 35 00 00 00    	jl     ffffffff801099be <sys_fstat+0x5e>
ffffffff80109989:	b8 01 00 00 00       	mov    $0x1,%eax
ffffffff8010998e:	b9 14 00 00 00       	mov    $0x14,%ecx
ffffffff80109993:	48 8d 55 f0          	lea    -0x10(%rbp),%rdx
ffffffff80109997:	bf 01 00 00 00       	mov    $0x1,%edi
ffffffff8010999c:	be 14 00 00 00       	mov    $0x14,%esi
ffffffff801099a1:	89 75 c4             	mov    %esi,-0x3c(%rbp)
ffffffff801099a4:	48 89 d6             	mov    %rdx,%rsi
ffffffff801099a7:	8b 55 c4             	mov    -0x3c(%rbp),%edx
ffffffff801099aa:	89 45 c0             	mov    %eax,-0x40(%rbp)
ffffffff801099ad:	89 4d bc             	mov    %ecx,-0x44(%rbp)
ffffffff801099b0:	e8 1b f8 ff ff       	callq  ffffffff801091d0 <argptr>
ffffffff801099b5:	83 f8 00             	cmp    $0x0,%eax
ffffffff801099b8:	0f 8d 0c 00 00 00    	jge    ffffffff801099ca <sys_fstat+0x6a>
    return -1;
ffffffff801099be:	c7 45 fc ff ff ff ff 	movl   $0xffffffff,-0x4(%rbp)
ffffffff801099c5:	e9 a0 00 00 00       	jmpq   ffffffff80109a6a <sys_fstat+0x10a>
  }

  if (fd >= NOFILE) {
ffffffff801099ca:	83 7d f8 10          	cmpl   $0x10,-0x8(%rbp)
ffffffff801099ce:	0f 8c 0c 00 00 00    	jl     ffffffff801099e0 <sys_fstat+0x80>
    return -1;
ffffffff801099d4:	c7 45 fc ff ff ff ff 	movl   $0xffffffff,-0x4(%rbp)
ffffffff801099db:	e9 8a 00 00 00       	jmpq   ffffffff80109a6a <sys_fstat+0x10a>
  }

  // TODO: Move innards to file.c

  struct proc* proc = myproc();
ffffffff801099e0:	e8 5b fc ff ff       	callq  ffffffff80109640 <myproc>
ffffffff801099e5:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  struct open_file *f = &proc->open_files[fd];
ffffffff801099e9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
ffffffff801099ed:	48 83 c0 38          	add    $0x38,%rax
ffffffff801099f1:	48 63 4d f8          	movslq -0x8(%rbp),%rcx
ffffffff801099f5:	48 6b c9 0b          	imul   $0xb,%rcx,%rcx
ffffffff801099f9:	48 01 c8             	add    %rcx,%rax
ffffffff801099fc:	48 89 45 e0          	mov    %rax,-0x20(%rbp)

  if (f->type == FILE_UNUSED) {
ffffffff80109a00:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
ffffffff80109a04:	0f be 50 0a          	movsbl 0xa(%rax),%edx
ffffffff80109a08:	83 fa 00             	cmp    $0x0,%edx
ffffffff80109a0b:	0f 85 0c 00 00 00    	jne    ffffffff80109a1d <sys_fstat+0xbd>
    return -1;
ffffffff80109a11:	c7 45 fc ff ff ff ff 	movl   $0xffffffff,-0x4(%rbp)
ffffffff80109a18:	e9 4d 00 00 00       	jmpq   ffffffff80109a6a <sys_fstat+0x10a>
  } else if (f->type == FILE_INODE) {
ffffffff80109a1d:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
ffffffff80109a21:	0f be 48 0a          	movsbl 0xa(%rax),%ecx
ffffffff80109a25:	83 f9 01             	cmp    $0x1,%ecx
ffffffff80109a28:	0f 85 30 00 00 00    	jne    ffffffff80109a5e <sys_fstat+0xfe>
    struct inode* inode = f->file_desc->inode;
ffffffff80109a2e:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
ffffffff80109a32:	48 8b 00             	mov    (%rax),%rax
ffffffff80109a35:	48 8b 00             	mov    (%rax),%rax
ffffffff80109a38:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
    iload(inode);
ffffffff80109a3c:	48 8b 7d d8          	mov    -0x28(%rbp),%rdi
ffffffff80109a40:	e8 cb 24 00 00       	callq  ffffffff8010bf10 <iload>
    stati(inode, st);
ffffffff80109a45:	48 8b 7d d8          	mov    -0x28(%rbp),%rdi
ffffffff80109a49:	48 8b 75 f0          	mov    -0x10(%rbp),%rsi
ffffffff80109a4d:	e8 ee 26 00 00       	callq  ffffffff8010c140 <stati>
    return 0;
ffffffff80109a52:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
ffffffff80109a59:	e9 0c 00 00 00       	jmpq   ffffffff80109a6a <sys_fstat+0x10a>
ffffffff80109a5e:	e9 00 00 00 00       	jmpq   ffffffff80109a63 <sys_fstat+0x103>
  }

  return -1;
ffffffff80109a63:	c7 45 fc ff ff ff ff 	movl   $0xffffffff,-0x4(%rbp)
}
ffffffff80109a6a:	8b 45 fc             	mov    -0x4(%rbp),%eax
ffffffff80109a6d:	48 83 c4 50          	add    $0x50,%rsp
ffffffff80109a71:	5d                   	pop    %rbp
ffffffff80109a72:	c3                   	retq   
ffffffff80109a73:	66 66 66 66 2e 0f 1f 	data16 data16 data16 nopw %cs:0x0(%rax,%rax,1)
ffffffff80109a7a:	84 00 00 00 00 00 

ffffffff80109a80 <sys_link>:

// Create the path new as a link to the same inode as old.
int
sys_link(void)
{
ffffffff80109a80:	55                   	push   %rbp
ffffffff80109a81:	48 89 e5             	mov    %rsp,%rbp
ffffffff80109a84:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  return -1;
ffffffff80109a89:	5d                   	pop    %rbp
ffffffff80109a8a:	c3                   	retq   
ffffffff80109a8b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

ffffffff80109a90 <sys_unlink>:


//PAGEBREAK!
int
sys_unlink(void)
{
ffffffff80109a90:	55                   	push   %rbp
ffffffff80109a91:	48 89 e5             	mov    %rsp,%rbp
ffffffff80109a94:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  return -1;
ffffffff80109a99:	5d                   	pop    %rbp
ffffffff80109a9a:	c3                   	retq   
ffffffff80109a9b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

ffffffff80109aa0 <sys_open>:
}


int
sys_open(void)
{
ffffffff80109aa0:	55                   	push   %rbp
ffffffff80109aa1:	48 89 e5             	mov    %rsp,%rbp
ffffffff80109aa4:	48 83 ec 30          	sub    $0x30,%rsp
ffffffff80109aa8:	31 c0                	xor    %eax,%eax
ffffffff80109aaa:	48 8d 4d f0          	lea    -0x10(%rbp),%rcx
  char* path;
  int mode;

  if (argstr(0, &path) < 0 || argint(1, &mode) < 0)
ffffffff80109aae:	31 ff                	xor    %edi,%edi
ffffffff80109ab0:	48 8d 75 f0          	lea    -0x10(%rbp),%rsi
ffffffff80109ab4:	89 45 e8             	mov    %eax,-0x18(%rbp)
ffffffff80109ab7:	48 89 4d e0          	mov    %rcx,-0x20(%rbp)
ffffffff80109abb:	e8 c0 f8 ff ff       	callq  ffffffff80109380 <argstr>
ffffffff80109ac0:	83 f8 00             	cmp    $0x0,%eax
ffffffff80109ac3:	0f 8c 27 00 00 00    	jl     ffffffff80109af0 <sys_open+0x50>
ffffffff80109ac9:	b8 01 00 00 00       	mov    $0x1,%eax
ffffffff80109ace:	48 8d 4d ec          	lea    -0x14(%rbp),%rcx
ffffffff80109ad2:	bf 01 00 00 00       	mov    $0x1,%edi
ffffffff80109ad7:	48 8d 75 ec          	lea    -0x14(%rbp),%rsi
ffffffff80109adb:	89 45 dc             	mov    %eax,-0x24(%rbp)
ffffffff80109ade:	48 89 4d d0          	mov    %rcx,-0x30(%rbp)
ffffffff80109ae2:	e8 a9 f5 ff ff       	callq  ffffffff80109090 <argint>
ffffffff80109ae7:	83 f8 00             	cmp    $0x0,%eax
ffffffff80109aea:	0f 8d 0c 00 00 00    	jge    ffffffff80109afc <sys_open+0x5c>
  {
    return -1;
ffffffff80109af0:	c7 45 fc ff ff ff ff 	movl   $0xffffffff,-0x4(%rbp)
ffffffff80109af7:	e9 0f 00 00 00       	jmpq   ffffffff80109b0b <sys_open+0x6b>
  }

  return kernel_sys_open(path, mode);
ffffffff80109afc:	48 8b 7d f0          	mov    -0x10(%rbp),%rdi
ffffffff80109b00:	8b 75 ec             	mov    -0x14(%rbp),%esi
ffffffff80109b03:	e8 d8 3c 00 00       	callq  ffffffff8010d7e0 <kernel_sys_open>
ffffffff80109b08:	89 45 fc             	mov    %eax,-0x4(%rbp)
}
ffffffff80109b0b:	8b 45 fc             	mov    -0x4(%rbp),%eax
ffffffff80109b0e:	48 83 c4 30          	add    $0x30,%rsp
ffffffff80109b12:	5d                   	pop    %rbp
ffffffff80109b13:	c3                   	retq   
ffffffff80109b14:	66 66 66 2e 0f 1f 84 	data16 data16 nopw %cs:0x0(%rax,%rax,1)
ffffffff80109b1b:	00 00 00 00 00 

ffffffff80109b20 <sys_mkdir>:

int
sys_mkdir(void)
{
ffffffff80109b20:	55                   	push   %rbp
ffffffff80109b21:	48 89 e5             	mov    %rsp,%rbp
ffffffff80109b24:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  return -1;
ffffffff80109b29:	5d                   	pop    %rbp
ffffffff80109b2a:	c3                   	retq   
ffffffff80109b2b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

ffffffff80109b30 <sys_mknod>:
}

int
sys_mknod(void)
{
ffffffff80109b30:	55                   	push   %rbp
ffffffff80109b31:	48 89 e5             	mov    %rsp,%rbp
ffffffff80109b34:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  return -1;
ffffffff80109b39:	5d                   	pop    %rbp
ffffffff80109b3a:	c3                   	retq   
ffffffff80109b3b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

ffffffff80109b40 <sys_chdir>:
}

int
sys_chdir(void)
{
ffffffff80109b40:	55                   	push   %rbp
ffffffff80109b41:	48 89 e5             	mov    %rsp,%rbp
ffffffff80109b44:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  return -1;
ffffffff80109b49:	5d                   	pop    %rbp
ffffffff80109b4a:	c3                   	retq   
ffffffff80109b4b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

ffffffff80109b50 <sys_exec>:
}

int
sys_exec(void)
{
ffffffff80109b50:	55                   	push   %rbp
ffffffff80109b51:	48 89 e5             	mov    %rsp,%rbp
ffffffff80109b54:	48 83 ec 40          	sub    $0x40,%rsp
ffffffff80109b58:	31 c0                	xor    %eax,%eax
ffffffff80109b5a:	48 8d 4d f0          	lea    -0x10(%rbp),%rcx
  char* path;
  char* args;

  if (argstr(0, &path) < 0
ffffffff80109b5e:	31 ff                	xor    %edi,%edi
ffffffff80109b60:	48 8d 75 f0          	lea    -0x10(%rbp),%rsi
ffffffff80109b64:	89 45 e4             	mov    %eax,-0x1c(%rbp)
ffffffff80109b67:	48 89 4d d8          	mov    %rcx,-0x28(%rbp)
ffffffff80109b6b:	e8 10 f8 ff ff       	callq  ffffffff80109380 <argstr>
ffffffff80109b70:	83 f8 00             	cmp    $0x0,%eax
      || argptr(1, &args, 8) < 0) {
ffffffff80109b73:	0f 8c 38 00 00 00    	jl     ffffffff80109bb1 <sys_exec+0x61>
ffffffff80109b79:	b8 01 00 00 00       	mov    $0x1,%eax
ffffffff80109b7e:	48 8d 4d e8          	lea    -0x18(%rbp),%rcx
ffffffff80109b82:	ba 08 00 00 00       	mov    $0x8,%edx
ffffffff80109b87:	bf 01 00 00 00       	mov    $0x1,%edi
ffffffff80109b8c:	48 8d 75 e8          	lea    -0x18(%rbp),%rsi
ffffffff80109b90:	41 b8 08 00 00 00    	mov    $0x8,%r8d
ffffffff80109b96:	89 55 d4             	mov    %edx,-0x2c(%rbp)
ffffffff80109b99:	44 89 c2             	mov    %r8d,%edx
ffffffff80109b9c:	89 45 d0             	mov    %eax,-0x30(%rbp)
ffffffff80109b9f:	48 89 4d c8          	mov    %rcx,-0x38(%rbp)
ffffffff80109ba3:	e8 28 f6 ff ff       	callq  ffffffff801091d0 <argptr>
ffffffff80109ba8:	83 f8 00             	cmp    $0x0,%eax
  if (argstr(0, &path) < 0
ffffffff80109bab:	0f 8d 0c 00 00 00    	jge    ffffffff80109bbd <sys_exec+0x6d>
    return -1;
ffffffff80109bb1:	c7 45 fc ff ff ff ff 	movl   $0xffffffff,-0x4(%rbp)
ffffffff80109bb8:	e9 13 00 00 00       	jmpq   ffffffff80109bd0 <sys_exec+0x80>
  }

  return exec(path, (char**)args);
ffffffff80109bbd:	48 8b 7d f0          	mov    -0x10(%rbp),%rdi
ffffffff80109bc1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
ffffffff80109bc5:	48 89 c6             	mov    %rax,%rsi
ffffffff80109bc8:	e8 43 47 00 00       	callq  ffffffff8010e310 <exec>
ffffffff80109bcd:	89 45 fc             	mov    %eax,-0x4(%rbp)
}
ffffffff80109bd0:	8b 45 fc             	mov    -0x4(%rbp),%eax
ffffffff80109bd3:	48 83 c4 40          	add    $0x40,%rsp
ffffffff80109bd7:	5d                   	pop    %rbp
ffffffff80109bd8:	c3                   	retq   
ffffffff80109bd9:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)

ffffffff80109be0 <sys_pipe>:

int
sys_pipe(void)
{
ffffffff80109be0:	55                   	push   %rbp
ffffffff80109be1:	48 89 e5             	mov    %rsp,%rbp
ffffffff80109be4:	48 83 ec 20          	sub    $0x20,%rsp
ffffffff80109be8:	31 c0                	xor    %eax,%eax
ffffffff80109bea:	b9 08 00 00 00       	mov    $0x8,%ecx
ffffffff80109bef:	48 8d 55 f0          	lea    -0x10(%rbp),%rdx
  int * pipe_fd;

  if (argptr(0, (char **) &pipe_fd, 2 * sizeof(int)) < 0)
ffffffff80109bf3:	31 ff                	xor    %edi,%edi
ffffffff80109bf5:	be 08 00 00 00       	mov    $0x8,%esi
ffffffff80109bfa:	89 75 ec             	mov    %esi,-0x14(%rbp)
ffffffff80109bfd:	48 89 d6             	mov    %rdx,%rsi
ffffffff80109c00:	8b 55 ec             	mov    -0x14(%rbp),%edx
ffffffff80109c03:	89 45 e8             	mov    %eax,-0x18(%rbp)
ffffffff80109c06:	89 4d e4             	mov    %ecx,-0x1c(%rbp)
ffffffff80109c09:	e8 c2 f5 ff ff       	callq  ffffffff801091d0 <argptr>
ffffffff80109c0e:	83 f8 00             	cmp    $0x0,%eax
ffffffff80109c11:	0f 8d 0c 00 00 00    	jge    ffffffff80109c23 <sys_pipe+0x43>
  {
    return -1;
ffffffff80109c17:	c7 45 fc ff ff ff ff 	movl   $0xffffffff,-0x4(%rbp)
ffffffff80109c1e:	e9 0c 00 00 00       	jmpq   ffffffff80109c2f <sys_pipe+0x4f>
  }

  return kernel_sys_pipe(pipe_fd);
ffffffff80109c23:	48 8b 7d f0          	mov    -0x10(%rbp),%rdi
ffffffff80109c27:	e8 f4 3e 00 00       	callq  ffffffff8010db20 <kernel_sys_pipe>
ffffffff80109c2c:	89 45 fc             	mov    %eax,-0x4(%rbp)
}
ffffffff80109c2f:	8b 45 fc             	mov    -0x4(%rbp),%eax
ffffffff80109c32:	48 83 c4 20          	add    $0x20,%rsp
ffffffff80109c36:	5d                   	pop    %rbp
ffffffff80109c37:	c3                   	retq   
ffffffff80109c38:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
ffffffff80109c3f:	00 

ffffffff80109c40 <sys_mmap>:

int
sys_mmap(void)
{
ffffffff80109c40:	55                   	push   %rbp
ffffffff80109c41:	48 89 e5             	mov    %rsp,%rbp
ffffffff80109c44:	48 83 ec 20          	sub    $0x20,%rsp
ffffffff80109c48:	31 c0                	xor    %eax,%eax
ffffffff80109c4a:	48 8d 4d f8          	lea    -0x8(%rbp),%rcx
  int fd;

  if (argint(0, &fd) < 0) {
ffffffff80109c4e:	31 ff                	xor    %edi,%edi
ffffffff80109c50:	48 8d 75 f8          	lea    -0x8(%rbp),%rsi
ffffffff80109c54:	89 45 f4             	mov    %eax,-0xc(%rbp)
ffffffff80109c57:	48 89 4d e8          	mov    %rcx,-0x18(%rbp)
ffffffff80109c5b:	e8 30 f4 ff ff       	callq  ffffffff80109090 <argint>
ffffffff80109c60:	83 f8 00             	cmp    $0x0,%eax
ffffffff80109c63:	0f 8d 0c 00 00 00    	jge    ffffffff80109c75 <sys_mmap+0x35>
    return -1;
ffffffff80109c69:	c7 45 fc ff ff ff ff 	movl   $0xffffffff,-0x4(%rbp)
ffffffff80109c70:	e9 2b 00 00 00       	jmpq   ffffffff80109ca0 <sys_mmap+0x60>
  }

  if (fd < 0 || fd >= NOFILE) {
ffffffff80109c75:	83 7d f8 00          	cmpl   $0x0,-0x8(%rbp)
ffffffff80109c79:	0f 8c 0a 00 00 00    	jl     ffffffff80109c89 <sys_mmap+0x49>
ffffffff80109c7f:	83 7d f8 10          	cmpl   $0x10,-0x8(%rbp)
ffffffff80109c83:	0f 8c 0c 00 00 00    	jl     ffffffff80109c95 <sys_mmap+0x55>
    return -1;
ffffffff80109c89:	c7 45 fc ff ff ff ff 	movl   $0xffffffff,-0x4(%rbp)
ffffffff80109c90:	e9 0b 00 00 00       	jmpq   ffffffff80109ca0 <sys_mmap+0x60>
  }

  return kernel_mmap(fd);
ffffffff80109c95:	8b 7d f8             	mov    -0x8(%rbp),%edi
ffffffff80109c98:	e8 e3 40 00 00       	callq  ffffffff8010dd80 <kernel_mmap>
ffffffff80109c9d:	89 45 fc             	mov    %eax,-0x4(%rbp)
}
ffffffff80109ca0:	8b 45 fc             	mov    -0x4(%rbp),%eax
ffffffff80109ca3:	48 83 c4 20          	add    $0x20,%rsp
ffffffff80109ca7:	5d                   	pop    %rbp
ffffffff80109ca8:	c3                   	retq   
ffffffff80109ca9:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)

ffffffff80109cb0 <sys_munmap>:

int
sys_munmap(void)
{
ffffffff80109cb0:	55                   	push   %rbp
ffffffff80109cb1:	48 89 e5             	mov    %rsp,%rbp
ffffffff80109cb4:	48 83 ec 20          	sub    $0x20,%rsp
ffffffff80109cb8:	31 c0                	xor    %eax,%eax
ffffffff80109cba:	48 8d 4d f8          	lea    -0x8(%rbp),%rcx
  int fd;

  if (argint(0, &fd) < 0) {
ffffffff80109cbe:	31 ff                	xor    %edi,%edi
ffffffff80109cc0:	48 8d 75 f8          	lea    -0x8(%rbp),%rsi
ffffffff80109cc4:	89 45 f4             	mov    %eax,-0xc(%rbp)
ffffffff80109cc7:	48 89 4d e8          	mov    %rcx,-0x18(%rbp)
ffffffff80109ccb:	e8 c0 f3 ff ff       	callq  ffffffff80109090 <argint>
ffffffff80109cd0:	83 f8 00             	cmp    $0x0,%eax
ffffffff80109cd3:	0f 8d 0c 00 00 00    	jge    ffffffff80109ce5 <sys_munmap+0x35>
    return -1;
ffffffff80109cd9:	c7 45 fc ff ff ff ff 	movl   $0xffffffff,-0x4(%rbp)
ffffffff80109ce0:	e9 2b 00 00 00       	jmpq   ffffffff80109d10 <sys_munmap+0x60>
  }

  if (fd < 0 || fd >= NOFILE) {
ffffffff80109ce5:	83 7d f8 00          	cmpl   $0x0,-0x8(%rbp)
ffffffff80109ce9:	0f 8c 0a 00 00 00    	jl     ffffffff80109cf9 <sys_munmap+0x49>
ffffffff80109cef:	83 7d f8 10          	cmpl   $0x10,-0x8(%rbp)
ffffffff80109cf3:	0f 8c 0c 00 00 00    	jl     ffffffff80109d05 <sys_munmap+0x55>
    return -1;
ffffffff80109cf9:	c7 45 fc ff ff ff ff 	movl   $0xffffffff,-0x4(%rbp)
ffffffff80109d00:	e9 0b 00 00 00       	jmpq   ffffffff80109d10 <sys_munmap+0x60>
  }

  return kernel_munmap(fd);
ffffffff80109d05:	8b 7d f8             	mov    -0x8(%rbp),%edi
ffffffff80109d08:	e8 53 39 00 00       	callq  ffffffff8010d660 <kernel_munmap>
ffffffff80109d0d:	89 45 fc             	mov    %eax,-0x4(%rbp)
}
ffffffff80109d10:	8b 45 fc             	mov    -0x4(%rbp),%eax
ffffffff80109d13:	48 83 c4 20          	add    $0x20,%rsp
ffffffff80109d17:	5d                   	pop    %rbp
ffffffff80109d18:	c3                   	retq   
ffffffff80109d19:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)

ffffffff80109d20 <mycpu>:
{
ffffffff80109d20:	55                   	push   %rbp
ffffffff80109d21:	48 89 e5             	mov    %rsp,%rbp
  return &cpus[0];
ffffffff80109d24:	48 c7 c0 e0 7b 1f 83 	mov    $0xffffffff831f7be0,%rax
ffffffff80109d2b:	5d                   	pop    %rbp
ffffffff80109d2c:	c3                   	retq   
ffffffff80109d2d:	0f 1f 00             	nopl   (%rax)

ffffffff80109d30 <alloc_extent>:

extern size_t extent_size;
extern struct superblock sb;

size_t alloc_extent(size_t nblocks)
{
ffffffff80109d30:	55                   	push   %rbp
ffffffff80109d31:	48 89 e5             	mov    %rsp,%rbp
ffffffff80109d34:	48 83 ec 60          	sub    $0x60,%rsp
ffffffff80109d38:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  acquire(&extentinfo.lock);
ffffffff80109d3c:	48 c7 c7 10 d3 1f 83 	mov    $0xffffffff831fd310,%rdi
ffffffff80109d43:	e8 78 ba ff ff       	callq  ffffffff801057c0 <acquire>
  if (extentinfo.size == 0) {
ffffffff80109d48:	48 8b 3c 25 78 d3 1f 	mov    0xffffffff831fd378,%rdi
ffffffff80109d4f:	83 
ffffffff80109d50:	48 83 ff 00          	cmp    $0x0,%rdi
ffffffff80109d54:	0f 85 13 00 00 00    	jne    ffffffff80109d6d <alloc_extent+0x3d>
    extentinfo.size = extent_size + 1;
ffffffff80109d5a:	48 8b 04 25 80 64 1f 	mov    0xffffffff831f6480,%rax
ffffffff80109d61:	83 
ffffffff80109d62:	48 ff c0             	inc    %rax
ffffffff80109d65:	48 89 04 25 78 d3 1f 	mov    %rax,0xffffffff831fd378
ffffffff80109d6c:	83 
ffffffff80109d6d:	b8 01 00 00 00       	mov    $0x1,%eax
  }
  release(&extentinfo.lock);
ffffffff80109d72:	48 c7 c1 10 d3 1f 83 	mov    $0xffffffff831fd310,%rcx
ffffffff80109d79:	48 89 cf             	mov    %rcx,%rdi
ffffffff80109d7c:	89 45 b0             	mov    %eax,-0x50(%rbp)
ffffffff80109d7f:	48 89 4d a8          	mov    %rcx,-0x58(%rbp)
ffffffff80109d83:	e8 78 bc ff ff       	callq  ffffffff80105a00 <release>

  // Search the bitmap for the first unallocated run of `nblocks` blocks.

  //uint found_blocks = 0;
  size_t alloc_start = -1;
ffffffff80109d88:	48 c7 45 f0 ff ff ff 	movq   $0xffffffffffffffff,-0x10(%rbp)
ffffffff80109d8f:	ff 
  //size_t prev_bitmap_block = -1;
  struct buf* buf = NULL;
ffffffff80109d90:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
ffffffff80109d97:	00 
  // index into the correct extent region using extentinfo.size
  // set nblocks bits
  // increment extentinfo.size by nblocks
  // unlock
  // return alloc_start
  alloc_start = extentinfo.size;
ffffffff80109d98:	48 8b 0c 25 78 d3 1f 	mov    0xffffffff831fd378,%rcx
ffffffff80109d9f:	83 
ffffffff80109da0:	48 89 4d f0          	mov    %rcx,-0x10(%rbp)

  // index into bitmap
  acquire(&extentinfo.lock);
ffffffff80109da4:	48 8b 7d a8          	mov    -0x58(%rbp),%rdi
ffffffff80109da8:	e8 13 ba ff ff       	callq  ffffffff801057c0 <acquire>
  size_t start_alloc_block = extentinfo.size;
ffffffff80109dad:	48 8b 0c 25 78 d3 1f 	mov    0xffffffff831fd378,%rcx
ffffffff80109db4:	83 
ffffffff80109db5:	48 89 4d e0          	mov    %rcx,-0x20(%rbp)
  extentinfo.size += nblocks;
ffffffff80109db9:	48 8b 4d f8          	mov    -0x8(%rbp),%rcx
ffffffff80109dbd:	48 8b 3c 25 78 d3 1f 	mov    0xffffffff831fd378,%rdi
ffffffff80109dc4:	83 
ffffffff80109dc5:	48 01 cf             	add    %rcx,%rdi
ffffffff80109dc8:	48 89 3c 25 78 d3 1f 	mov    %rdi,0xffffffff831fd378
ffffffff80109dcf:	83 
  release(&extentinfo.lock);
ffffffff80109dd0:	48 8b 7d a8          	mov    -0x58(%rbp),%rdi
ffffffff80109dd4:	e8 27 bc ff ff       	callq  ffffffff80105a00 <release>

  size_t bitmap_idx = sb.bmapstart + (start_alloc_block / 4096);
ffffffff80109dd9:	8b 04 25 50 27 20 83 	mov    0xffffffff83202750,%eax
ffffffff80109de0:	89 c0                	mov    %eax,%eax
ffffffff80109de2:	89 c1                	mov    %eax,%ecx
ffffffff80109de4:	48 8b 7d e0          	mov    -0x20(%rbp),%rdi
ffffffff80109de8:	48 c1 ef 0c          	shr    $0xc,%rdi
ffffffff80109dec:	48 01 f9             	add    %rdi,%rcx
ffffffff80109def:	48 89 4d d8          	mov    %rcx,-0x28(%rbp)
  size_t bitmap_off = start_alloc_block % 4096; // bits per block
ffffffff80109df3:	48 8b 4d e0          	mov    -0x20(%rbp),%rcx
ffffffff80109df7:	48 81 e1 ff 0f 00 00 	and    $0xfff,%rcx
ffffffff80109dfe:	48 89 4d d0          	mov    %rcx,-0x30(%rbp)
  size_t bitmap_bytes = bitmap_off / 8;
ffffffff80109e02:	48 8b 4d d0          	mov    -0x30(%rbp),%rcx
ffffffff80109e06:	48 c1 e9 03          	shr    $0x3,%rcx
ffffffff80109e0a:	48 89 4d c8          	mov    %rcx,-0x38(%rbp)
  size_t bitmap_byte_off = bitmap_off % 8;
ffffffff80109e0e:	48 8b 4d d0          	mov    -0x30(%rbp),%rcx
ffffffff80109e12:	48 83 e1 07          	and    $0x7,%rcx
ffffffff80109e16:	48 89 4d c0          	mov    %rcx,-0x40(%rbp)
  int remain = nblocks;
ffffffff80109e1a:	48 8b 4d f8          	mov    -0x8(%rbp),%rcx
ffffffff80109e1e:	89 c8                	mov    %ecx,%eax
ffffffff80109e20:	89 45 bc             	mov    %eax,-0x44(%rbp)

  buf = bread(ROOTDEV, bitmap_idx);
ffffffff80109e23:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
ffffffff80109e27:	89 c8                	mov    %ecx,%eax
ffffffff80109e29:	bf 01 00 00 00       	mov    $0x1,%edi
ffffffff80109e2e:	89 c6                	mov    %eax,%esi
ffffffff80109e30:	e8 1b 01 00 00       	callq  ffffffff80109f50 <bread>
ffffffff80109e35:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  int j = bitmap_byte_off;
ffffffff80109e39:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
ffffffff80109e3d:	89 c6                	mov    %eax,%esi
ffffffff80109e3f:	89 75 b8             	mov    %esi,-0x48(%rbp)
  while (remain) {
ffffffff80109e42:	83 7d bc 00          	cmpl   $0x0,-0x44(%rbp)
ffffffff80109e46:	0f 84 e4 00 00 00    	je     ffffffff80109f30 <alloc_extent+0x200>
    if (bitmap_bytes == 512) {
ffffffff80109e4c:	48 81 7d c8 00 02 00 	cmpq   $0x200,-0x38(%rbp)
ffffffff80109e53:	00 
ffffffff80109e54:	0f 85 38 00 00 00    	jne    ffffffff80109e92 <alloc_extent+0x162>
      // load in next block
      bwrite(buf);
ffffffff80109e5a:	48 8b 7d e8          	mov    -0x18(%rbp),%rdi
ffffffff80109e5e:	e8 4d 01 00 00       	callq  ffffffff80109fb0 <bwrite>
      brelse(buf);
ffffffff80109e63:	48 8b 7d e8          	mov    -0x18(%rbp),%rdi
ffffffff80109e67:	e8 d4 01 00 00       	callq  ffffffff8010a040 <brelse>
ffffffff80109e6c:	b8 01 00 00 00       	mov    $0x1,%eax
      buf = bread(ROOTDEV, ++bitmap_idx);
ffffffff80109e71:	48 8b 7d d8          	mov    -0x28(%rbp),%rdi
ffffffff80109e75:	48 83 c7 01          	add    $0x1,%rdi
ffffffff80109e79:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
ffffffff80109e7d:	89 f9                	mov    %edi,%ecx
ffffffff80109e7f:	bf 01 00 00 00       	mov    $0x1,%edi
ffffffff80109e84:	89 ce                	mov    %ecx,%esi
ffffffff80109e86:	89 45 a4             	mov    %eax,-0x5c(%rbp)
ffffffff80109e89:	e8 c2 00 00 00       	callq  ffffffff80109f50 <bread>
ffffffff80109e8e:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
ffffffff80109e92:	b8 01 00 00 00       	mov    $0x1,%eax
    }

    char mask = (0x1 << j);
ffffffff80109e97:	8b 4d b8             	mov    -0x48(%rbp),%ecx
ffffffff80109e9a:	d3 e0                	shl    %cl,%eax
ffffffff80109e9c:	88 c1                	mov    %al,%cl
ffffffff80109e9e:	88 4d b7             	mov    %cl,-0x49(%rbp)
    //cprintf("block idx = %d, byte offset = %d, bit offset = %x\n",
    //    bitmap_idx, bitmap_bytes, buf->data[bitmap_bytes]);
    if((buf->data[bitmap_bytes] & mask) == 1) {
ffffffff80109ea1:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
ffffffff80109ea5:	48 8b 75 c8          	mov    -0x38(%rbp),%rsi
ffffffff80109ea9:	0f b6 84 32 b0 00 00 	movzbl 0xb0(%rdx,%rsi,1),%eax
ffffffff80109eb0:	00 
ffffffff80109eb1:	0f be 7d b7          	movsbl -0x49(%rbp),%edi
ffffffff80109eb5:	21 f8                	and    %edi,%eax
ffffffff80109eb7:	83 f8 01             	cmp    $0x1,%eax
ffffffff80109eba:	0f 85 0c 00 00 00    	jne    ffffffff80109ecc <alloc_extent+0x19c>
      panic("used!");
ffffffff80109ec0:	48 c7 c7 f0 02 11 80 	mov    $0xffffffff801102f0,%rdi
ffffffff80109ec7:	e8 a4 6f ff ff       	callq  ffffffff80100e70 <panic>
ffffffff80109ecc:	b8 08 00 00 00       	mov    $0x8,%eax
    }

    buf->data[bitmap_bytes] |= mask;
ffffffff80109ed1:	0f be 4d b7          	movsbl -0x49(%rbp),%ecx
ffffffff80109ed5:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
ffffffff80109ed9:	48 8b 75 c8          	mov    -0x38(%rbp),%rsi
ffffffff80109edd:	0f b6 bc 32 b0 00 00 	movzbl 0xb0(%rdx,%rsi,1),%edi
ffffffff80109ee4:	00 
ffffffff80109ee5:	09 cf                	or     %ecx,%edi
ffffffff80109ee7:	41 88 f8             	mov    %dil,%r8b
ffffffff80109eea:	44 88 84 32 b0 00 00 	mov    %r8b,0xb0(%rdx,%rsi,1)
ffffffff80109ef1:	00 
    --remain;
ffffffff80109ef2:	8b 4d bc             	mov    -0x44(%rbp),%ecx
ffffffff80109ef5:	83 c1 ff             	add    $0xffffffff,%ecx
ffffffff80109ef8:	89 4d bc             	mov    %ecx,-0x44(%rbp)
    if ((++j % 8) == 0) {
ffffffff80109efb:	8b 4d b8             	mov    -0x48(%rbp),%ecx
ffffffff80109efe:	83 c1 01             	add    $0x1,%ecx
ffffffff80109f01:	89 4d b8             	mov    %ecx,-0x48(%rbp)
ffffffff80109f04:	89 45 a0             	mov    %eax,-0x60(%rbp)
ffffffff80109f07:	89 c8                	mov    %ecx,%eax
ffffffff80109f09:	99                   	cltd   
ffffffff80109f0a:	8b 4d a0             	mov    -0x60(%rbp),%ecx
ffffffff80109f0d:	f7 f9                	idiv   %ecx
ffffffff80109f0f:	83 fa 00             	cmp    $0x0,%edx
ffffffff80109f12:	0f 85 13 00 00 00    	jne    ffffffff80109f2b <alloc_extent+0x1fb>
      ++bitmap_bytes;
ffffffff80109f18:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
ffffffff80109f1c:	48 83 c0 01          	add    $0x1,%rax
ffffffff80109f20:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
      j = 0;
ffffffff80109f24:	c7 45 b8 00 00 00 00 	movl   $0x0,-0x48(%rbp)
  while (remain) {
ffffffff80109f2b:	e9 12 ff ff ff       	jmpq   ffffffff80109e42 <alloc_extent+0x112>
    }
  }

  bwrite(buf);
ffffffff80109f30:	48 8b 7d e8          	mov    -0x18(%rbp),%rdi
ffffffff80109f34:	e8 77 00 00 00       	callq  ffffffff80109fb0 <bwrite>
  brelse(buf);
ffffffff80109f39:	48 8b 7d e8          	mov    -0x18(%rbp),%rdi
ffffffff80109f3d:	e8 fe 00 00 00       	callq  ffffffff8010a040 <brelse>

  return alloc_start;
ffffffff80109f42:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
ffffffff80109f46:	48 83 c4 60          	add    $0x60,%rsp
ffffffff80109f4a:	5d                   	pop    %rbp
ffffffff80109f4b:	c3                   	retq   
ffffffff80109f4c:	0f 1f 40 00          	nopl   0x0(%rax)

ffffffff80109f50 <bread>:
}

// Return a locked buf with the contents of the indicated block.
struct buf*
bread(uint dev, uint blockno)
{
ffffffff80109f50:	55                   	push   %rbp
ffffffff80109f51:	48 89 e5             	mov    %rsp,%rbp
ffffffff80109f54:	48 83 ec 10          	sub    $0x10,%rsp
ffffffff80109f58:	89 7d fc             	mov    %edi,-0x4(%rbp)
ffffffff80109f5b:	89 75 f8             	mov    %esi,-0x8(%rbp)
  num_disk_reads += 1;
ffffffff80109f5e:	8b 34 25 98 64 1f 83 	mov    0xffffffff831f6498,%esi
ffffffff80109f65:	ff c6                	inc    %esi
ffffffff80109f67:	89 34 25 98 64 1f 83 	mov    %esi,0xffffffff831f6498
  struct buf *b;

  b = bget(dev, blockno);
ffffffff80109f6e:	8b 7d fc             	mov    -0x4(%rbp),%edi
ffffffff80109f71:	8b 75 f8             	mov    -0x8(%rbp),%esi
ffffffff80109f74:	e8 b7 02 00 00       	callq  ffffffff8010a230 <bget>
ffffffff80109f79:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  if(!(b->flags & B_VALID)) {
ffffffff80109f7d:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
ffffffff80109f81:	8b 30                	mov    (%rax),%esi
ffffffff80109f83:	83 e6 02             	and    $0x2,%esi
ffffffff80109f86:	83 fe 00             	cmp    $0x0,%esi
ffffffff80109f89:	0f 85 09 00 00 00    	jne    ffffffff80109f98 <bread+0x48>
    iderw(b);
ffffffff80109f8f:	48 8b 7d f0          	mov    -0x10(%rbp),%rdi
ffffffff80109f93:	e8 a8 59 00 00       	callq  ffffffff8010f940 <iderw>
  }
  return b;
ffffffff80109f98:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
ffffffff80109f9c:	48 83 c4 10          	add    $0x10,%rsp
ffffffff80109fa0:	5d                   	pop    %rbp
ffffffff80109fa1:	c3                   	retq   
ffffffff80109fa2:	66 66 66 66 66 2e 0f 	data16 data16 data16 data16 nopw %cs:0x0(%rax,%rax,1)
ffffffff80109fa9:	1f 84 00 00 00 00 00 

ffffffff80109fb0 <bwrite>:
}

// Write b's contents to disk.  Must be locked.
void
bwrite(struct buf *b)
{
ffffffff80109fb0:	55                   	push   %rbp
ffffffff80109fb1:	48 89 e5             	mov    %rsp,%rbp
ffffffff80109fb4:	48 83 ec 10          	sub    $0x10,%rsp
ffffffff80109fb8:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  if (crashn_enable) {
ffffffff80109fbc:	8b 04 25 90 64 1f 83 	mov    0xffffffff831f6490,%eax
ffffffff80109fc3:	83 f8 00             	cmp    $0x0,%eax
ffffffff80109fc6:	0f 84 2a 00 00 00    	je     ffffffff80109ff6 <bwrite+0x46>
    crashn --;
ffffffff80109fcc:	8b 04 25 94 64 1f 83 	mov    0xffffffff831f6494,%eax
ffffffff80109fd3:	ff c8                	dec    %eax
ffffffff80109fd5:	89 04 25 94 64 1f 83 	mov    %eax,0xffffffff831f6494
    if (crashn < 0)
ffffffff80109fdc:	8b 04 25 94 64 1f 83 	mov    0xffffffff831f6494,%eax
ffffffff80109fe3:	83 f8 00             	cmp    $0x0,%eax
ffffffff80109fe6:	0f 8d 05 00 00 00    	jge    ffffffff80109ff1 <bwrite+0x41>
      reboot();
ffffffff80109fec:	e8 bf d5 ff ff       	callq  ffffffff801075b0 <reboot>
  }
ffffffff80109ff1:	e9 00 00 00 00       	jmpq   ffffffff80109ff6 <bwrite+0x46>
  if(!holdingsleep(&b->lock))
ffffffff80109ff6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
ffffffff80109ffa:	48 83 c0 10          	add    $0x10,%rax
ffffffff80109ffe:	48 89 c7             	mov    %rax,%rdi
ffffffff8010a001:	e8 0a 05 00 00       	callq  ffffffff8010a510 <holdingsleep>
ffffffff8010a006:	83 f8 00             	cmp    $0x0,%eax
ffffffff8010a009:	0f 85 0c 00 00 00    	jne    ffffffff8010a01b <bwrite+0x6b>
    panic("bwrite");
ffffffff8010a00f:	48 c7 c7 0b 03 11 80 	mov    $0xffffffff8011030b,%rdi
ffffffff8010a016:	e8 55 6e ff ff       	callq  ffffffff80100e70 <panic>
  b->flags |= B_DIRTY;
ffffffff8010a01b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
ffffffff8010a01f:	8b 08                	mov    (%rax),%ecx
ffffffff8010a021:	83 c9 04             	or     $0x4,%ecx
ffffffff8010a024:	89 08                	mov    %ecx,(%rax)
  iderw(b);
ffffffff8010a026:	48 8b 7d f8          	mov    -0x8(%rbp),%rdi
ffffffff8010a02a:	e8 11 59 00 00       	callq  ffffffff8010f940 <iderw>
}
ffffffff8010a02f:	48 83 c4 10          	add    $0x10,%rsp
ffffffff8010a033:	5d                   	pop    %rbp
ffffffff8010a034:	c3                   	retq   
ffffffff8010a035:	66 66 2e 0f 1f 84 00 	data16 nopw %cs:0x0(%rax,%rax,1)
ffffffff8010a03c:	00 00 00 00 

ffffffff8010a040 <brelse>:

// Release a locked buffer.
// Move to the head of the MRU list.
void
brelse(struct buf *b)
{
ffffffff8010a040:	55                   	push   %rbp
ffffffff8010a041:	48 89 e5             	mov    %rsp,%rbp
ffffffff8010a044:	48 83 ec 10          	sub    $0x10,%rsp
ffffffff8010a048:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  if(!holdingsleep(&b->lock))
ffffffff8010a04c:	48 8b 7d f8          	mov    -0x8(%rbp),%rdi
ffffffff8010a050:	48 83 c7 10          	add    $0x10,%rdi
ffffffff8010a054:	e8 b7 04 00 00       	callq  ffffffff8010a510 <holdingsleep>
ffffffff8010a059:	83 f8 00             	cmp    $0x0,%eax
ffffffff8010a05c:	0f 85 0c 00 00 00    	jne    ffffffff8010a06e <brelse+0x2e>
    panic("brelse");
ffffffff8010a062:	48 c7 c7 12 03 11 80 	mov    $0xffffffff80110312,%rdi
ffffffff8010a069:	e8 02 6e ff ff       	callq  ffffffff80100e70 <panic>

  releasesleep(&b->lock);
ffffffff8010a06e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
ffffffff8010a072:	48 83 c0 10          	add    $0x10,%rax
ffffffff8010a076:	48 89 c7             	mov    %rax,%rdi
ffffffff8010a079:	e8 42 04 00 00       	callq  ffffffff8010a4c0 <releasesleep>

  acquire(&bcache.lock);
ffffffff8010a07e:	48 c7 c7 80 d3 1f 83 	mov    $0xffffffff831fd380,%rdi
ffffffff8010a085:	e8 36 b7 ff ff       	callq  ffffffff801057c0 <acquire>
  b->refcnt--;
ffffffff8010a08a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
ffffffff8010a08e:	8b 88 90 00 00 00    	mov    0x90(%rax),%ecx
ffffffff8010a094:	83 c1 ff             	add    $0xffffffff,%ecx
ffffffff8010a097:	89 88 90 00 00 00    	mov    %ecx,0x90(%rax)
  if (b->refcnt == 0) {
ffffffff8010a09d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
ffffffff8010a0a1:	83 b8 90 00 00 00 00 	cmpl   $0x0,0x90(%rax)
ffffffff8010a0a8:	0f 85 73 00 00 00    	jne    ffffffff8010a121 <brelse+0xe1>
    // no one is waiting for it.
    b->next->prev = b->prev;
ffffffff8010a0ae:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
ffffffff8010a0b2:	48 8b 88 98 00 00 00 	mov    0x98(%rax),%rcx
ffffffff8010a0b9:	48 8b 80 a0 00 00 00 	mov    0xa0(%rax),%rax
ffffffff8010a0c0:	48 89 88 98 00 00 00 	mov    %rcx,0x98(%rax)
    b->prev->next = b->next;
ffffffff8010a0c7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
ffffffff8010a0cb:	48 8b 88 98 00 00 00 	mov    0x98(%rax),%rcx
ffffffff8010a0d2:	48 8b 80 a0 00 00 00 	mov    0xa0(%rax),%rax
ffffffff8010a0d9:	48 89 81 a0 00 00 00 	mov    %rax,0xa0(%rcx)
    b->next = bcache.head.next;
ffffffff8010a0e0:	48 8b 04 25 28 25 20 	mov    0xffffffff83202528,%rax
ffffffff8010a0e7:	83 
ffffffff8010a0e8:	48 8b 4d f8          	mov    -0x8(%rbp),%rcx
ffffffff8010a0ec:	48 89 81 a0 00 00 00 	mov    %rax,0xa0(%rcx)
    b->prev = &bcache.head;
ffffffff8010a0f3:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
ffffffff8010a0f7:	48 c7 80 98 00 00 00 	movq   $0xffffffff83202488,0x98(%rax)
ffffffff8010a0fe:	88 24 20 83 
    bcache.head.next->prev = b;
ffffffff8010a102:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
ffffffff8010a106:	48 8b 0c 25 28 25 20 	mov    0xffffffff83202528,%rcx
ffffffff8010a10d:	83 
ffffffff8010a10e:	48 89 81 98 00 00 00 	mov    %rax,0x98(%rcx)
    bcache.head.next = b;
ffffffff8010a115:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
ffffffff8010a119:	48 89 04 25 28 25 20 	mov    %rax,0xffffffff83202528
ffffffff8010a120:	83 
  }

  release(&bcache.lock);
ffffffff8010a121:	48 c7 c7 80 d3 1f 83 	mov    $0xffffffff831fd380,%rdi
ffffffff8010a128:	e8 d3 b8 ff ff       	callq  ffffffff80105a00 <release>
}
ffffffff8010a12d:	48 83 c4 10          	add    $0x10,%rsp
ffffffff8010a131:	5d                   	pop    %rbp
ffffffff8010a132:	c3                   	retq   
ffffffff8010a133:	66 66 66 66 2e 0f 1f 	data16 data16 data16 nopw %cs:0x0(%rax,%rax,1)
ffffffff8010a13a:	84 00 00 00 00 00 

ffffffff8010a140 <binit>:
{
ffffffff8010a140:	55                   	push   %rbp
ffffffff8010a141:	48 89 e5             	mov    %rsp,%rbp
  initlock(&bcache.lock, "bcache");
ffffffff8010a144:	48 83 ec 10          	sub    $0x10,%rsp
ffffffff8010a148:	48 c7 c7 80 d3 1f 83 	mov    $0xffffffff831fd380,%rdi
ffffffff8010a14f:	48 c7 c6 f6 02 11 80 	mov    $0xffffffff801102f6,%rsi
ffffffff8010a156:	e8 25 b6 ff ff       	callq  ffffffff80105780 <initlock>
  bcache.head.prev = &bcache.head;
ffffffff8010a15b:	48 c7 04 25 20 25 20 	movq   $0xffffffff83202488,0xffffffff83202520
ffffffff8010a162:	83 88 24 20 83 
  bcache.head.next = &bcache.head;
ffffffff8010a167:	48 c7 04 25 28 25 20 	movq   $0xffffffff83202488,0xffffffff83202528
ffffffff8010a16e:	83 88 24 20 83 
  for(b = bcache.buf; b < bcache.buf+NBUF; b++){
ffffffff8010a173:	48 c7 45 f8 e8 d3 1f 	movq   $0xffffffff831fd3e8,-0x8(%rbp)
ffffffff8010a17a:	83 
ffffffff8010a17b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
ffffffff8010a17f:	48 c7 c1 88 24 20 83 	mov    $0xffffffff83202488,%rcx
ffffffff8010a186:	48 29 c8             	sub    %rcx,%rax
ffffffff8010a189:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
ffffffff8010a18d:	0f 83 70 00 00 00    	jae    ffffffff8010a203 <binit+0xc3>
ffffffff8010a193:	e9 00 00 00 00       	jmpq   ffffffff8010a198 <binit+0x58>
    b->next = bcache.head.next;
ffffffff8010a198:	48 8b 04 25 28 25 20 	mov    0xffffffff83202528,%rax
ffffffff8010a19f:	83 
ffffffff8010a1a0:	48 8b 4d f8          	mov    -0x8(%rbp),%rcx
ffffffff8010a1a4:	48 89 81 a0 00 00 00 	mov    %rax,0xa0(%rcx)
    b->prev = &bcache.head;
ffffffff8010a1ab:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
ffffffff8010a1af:	48 c7 80 98 00 00 00 	movq   $0xffffffff83202488,0x98(%rax)
ffffffff8010a1b6:	88 24 20 83 
    initsleeplock(&b->lock, "buffer");
ffffffff8010a1ba:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
ffffffff8010a1be:	48 83 c0 10          	add    $0x10,%rax
ffffffff8010a1c2:	48 c7 c6 fd 02 11 80 	mov    $0xffffffff801102fd,%rsi
ffffffff8010a1c9:	48 89 c7             	mov    %rax,%rdi
ffffffff8010a1cc:	e8 ef 01 00 00       	callq  ffffffff8010a3c0 <initsleeplock>
    bcache.head.next->prev = b;
ffffffff8010a1d1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
ffffffff8010a1d5:	48 8b 0c 25 28 25 20 	mov    0xffffffff83202528,%rcx
ffffffff8010a1dc:	83 
ffffffff8010a1dd:	48 89 81 98 00 00 00 	mov    %rax,0x98(%rcx)
    bcache.head.next = b;
ffffffff8010a1e4:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
ffffffff8010a1e8:	48 89 04 25 28 25 20 	mov    %rax,0xffffffff83202528
ffffffff8010a1ef:	83 
  for(b = bcache.buf; b < bcache.buf+NBUF; b++){
ffffffff8010a1f0:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
ffffffff8010a1f4:	48 05 b0 02 00 00    	add    $0x2b0,%rax
ffffffff8010a1fa:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
ffffffff8010a1fe:	e9 78 ff ff ff       	jmpq   ffffffff8010a17b <binit+0x3b>
  initlock(&extentinfo.lock, "extent");
ffffffff8010a203:	48 c7 c7 10 d3 1f 83 	mov    $0xffffffff831fd310,%rdi
ffffffff8010a20a:	48 c7 c6 04 03 11 80 	mov    $0xffffffff80110304,%rsi
ffffffff8010a211:	e8 6a b5 ff ff       	callq  ffffffff80105780 <initlock>
  extentinfo.size = 0;
ffffffff8010a216:	48 c7 04 25 78 d3 1f 	movq   $0x0,0xffffffff831fd378
ffffffff8010a21d:	83 00 00 00 00 
}
ffffffff8010a222:	48 83 c4 10          	add    $0x10,%rsp
ffffffff8010a226:	5d                   	pop    %rbp
ffffffff8010a227:	c3                   	retq   
ffffffff8010a228:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
ffffffff8010a22f:	00 

ffffffff8010a230 <bget>:
{
ffffffff8010a230:	55                   	push   %rbp
ffffffff8010a231:	48 89 e5             	mov    %rsp,%rbp
ffffffff8010a234:	48 83 ec 30          	sub    $0x30,%rsp
ffffffff8010a238:	89 7d f4             	mov    %edi,-0xc(%rbp)
ffffffff8010a23b:	89 75 f0             	mov    %esi,-0x10(%rbp)
  acquire(&bcache.lock);
ffffffff8010a23e:	48 c7 c7 80 d3 1f 83 	mov    $0xffffffff831fd380,%rdi
ffffffff8010a245:	e8 76 b5 ff ff       	callq  ffffffff801057c0 <acquire>
  for(b = bcache.head.next; b != &bcache.head; b = b->next){
ffffffff8010a24a:	48 8b 3c 25 28 25 20 	mov    0xffffffff83202528,%rdi
ffffffff8010a251:	83 
ffffffff8010a252:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
ffffffff8010a256:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
ffffffff8010a25a:	48 c7 c1 88 24 20 83 	mov    $0xffffffff83202488,%rcx
ffffffff8010a261:	48 29 c8             	sub    %rcx,%rax
ffffffff8010a264:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
ffffffff8010a268:	0f 84 7a 00 00 00    	je     ffffffff8010a2e8 <bget+0xb8>
ffffffff8010a26e:	e9 00 00 00 00       	jmpq   ffffffff8010a273 <bget+0x43>
    if(b->dev == dev && b->blockno == blockno){
ffffffff8010a273:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
ffffffff8010a277:	8b 48 04             	mov    0x4(%rax),%ecx
ffffffff8010a27a:	3b 4d f4             	cmp    -0xc(%rbp),%ecx
ffffffff8010a27d:	0f 85 4c 00 00 00    	jne    ffffffff8010a2cf <bget+0x9f>
ffffffff8010a283:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
ffffffff8010a287:	8b 48 08             	mov    0x8(%rax),%ecx
ffffffff8010a28a:	3b 4d f0             	cmp    -0x10(%rbp),%ecx
ffffffff8010a28d:	0f 85 3c 00 00 00    	jne    ffffffff8010a2cf <bget+0x9f>
      b->refcnt++;
ffffffff8010a293:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
ffffffff8010a297:	8b 88 90 00 00 00    	mov    0x90(%rax),%ecx
ffffffff8010a29d:	83 c1 01             	add    $0x1,%ecx
ffffffff8010a2a0:	89 88 90 00 00 00    	mov    %ecx,0x90(%rax)
      release(&bcache.lock);
ffffffff8010a2a6:	48 c7 c7 80 d3 1f 83 	mov    $0xffffffff831fd380,%rdi
ffffffff8010a2ad:	e8 4e b7 ff ff       	callq  ffffffff80105a00 <release>
      acquiresleep(&b->lock);
ffffffff8010a2b2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
ffffffff8010a2b6:	48 83 c0 10          	add    $0x10,%rax
ffffffff8010a2ba:	48 89 c7             	mov    %rax,%rdi
ffffffff8010a2bd:	e8 5e 01 00 00       	callq  ffffffff8010a420 <acquiresleep>
      return b;
ffffffff8010a2c2:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
ffffffff8010a2c6:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
ffffffff8010a2ca:	e9 df 00 00 00       	jmpq   ffffffff8010a3ae <bget+0x17e>
  }
ffffffff8010a2cf:	e9 00 00 00 00       	jmpq   ffffffff8010a2d4 <bget+0xa4>
  for(b = bcache.head.next; b != &bcache.head; b = b->next){
ffffffff8010a2d4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
ffffffff8010a2d8:	48 8b 80 a0 00 00 00 	mov    0xa0(%rax),%rax
ffffffff8010a2df:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
ffffffff8010a2e3:	e9 6e ff ff ff       	jmpq   ffffffff8010a256 <bget+0x26>
  for(b = bcache.head.prev; b != &bcache.head; b = b->prev){
ffffffff8010a2e8:	48 8b 04 25 20 25 20 	mov    0xffffffff83202520,%rax
ffffffff8010a2ef:	83 
ffffffff8010a2f0:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
ffffffff8010a2f4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
ffffffff8010a2f8:	48 c7 c1 88 24 20 83 	mov    $0xffffffff83202488,%rcx
ffffffff8010a2ff:	48 29 c8             	sub    %rcx,%rax
ffffffff8010a302:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
ffffffff8010a306:	0f 84 96 00 00 00    	je     ffffffff8010a3a2 <bget+0x172>
ffffffff8010a30c:	e9 00 00 00 00       	jmpq   ffffffff8010a311 <bget+0xe1>
    if(b->refcnt == 0 && (b->flags & B_DIRTY) == 0) {
ffffffff8010a311:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
ffffffff8010a315:	83 b8 90 00 00 00 00 	cmpl   $0x0,0x90(%rax)
ffffffff8010a31c:	0f 85 67 00 00 00    	jne    ffffffff8010a389 <bget+0x159>
ffffffff8010a322:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
ffffffff8010a326:	8b 08                	mov    (%rax),%ecx
ffffffff8010a328:	83 e1 04             	and    $0x4,%ecx
ffffffff8010a32b:	83 f9 00             	cmp    $0x0,%ecx
ffffffff8010a32e:	0f 85 55 00 00 00    	jne    ffffffff8010a389 <bget+0x159>
      b->dev = dev;
ffffffff8010a334:	8b 45 f4             	mov    -0xc(%rbp),%eax
ffffffff8010a337:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
ffffffff8010a33b:	89 41 04             	mov    %eax,0x4(%rcx)
      b->blockno = blockno;
ffffffff8010a33e:	8b 45 f0             	mov    -0x10(%rbp),%eax
ffffffff8010a341:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
ffffffff8010a345:	89 41 08             	mov    %eax,0x8(%rcx)
      b->flags = 0;
ffffffff8010a348:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
ffffffff8010a34c:	c7 01 00 00 00 00    	movl   $0x0,(%rcx)
      b->refcnt = 1;
ffffffff8010a352:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
ffffffff8010a356:	c7 81 90 00 00 00 01 	movl   $0x1,0x90(%rcx)
ffffffff8010a35d:	00 00 00 
      release(&bcache.lock);
ffffffff8010a360:	48 c7 c7 80 d3 1f 83 	mov    $0xffffffff831fd380,%rdi
ffffffff8010a367:	e8 94 b6 ff ff       	callq  ffffffff80105a00 <release>
      acquiresleep(&b->lock);
ffffffff8010a36c:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
ffffffff8010a370:	48 83 c1 10          	add    $0x10,%rcx
ffffffff8010a374:	48 89 cf             	mov    %rcx,%rdi
ffffffff8010a377:	e8 a4 00 00 00       	callq  ffffffff8010a420 <acquiresleep>
      return b;
ffffffff8010a37c:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
ffffffff8010a380:	48 89 4d f8          	mov    %rcx,-0x8(%rbp)
ffffffff8010a384:	e9 25 00 00 00       	jmpq   ffffffff8010a3ae <bget+0x17e>
  }
ffffffff8010a389:	e9 00 00 00 00       	jmpq   ffffffff8010a38e <bget+0x15e>
  for(b = bcache.head.prev; b != &bcache.head; b = b->prev){
ffffffff8010a38e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
ffffffff8010a392:	48 8b 80 98 00 00 00 	mov    0x98(%rax),%rax
ffffffff8010a399:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
ffffffff8010a39d:	e9 52 ff ff ff       	jmpq   ffffffff8010a2f4 <bget+0xc4>
  panic("bget: no buffers");
ffffffff8010a3a2:	48 c7 c7 19 03 11 80 	mov    $0xffffffff80110319,%rdi
ffffffff8010a3a9:	e8 c2 6a ff ff       	callq  ffffffff80100e70 <panic>
}
ffffffff8010a3ae:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
ffffffff8010a3b2:	48 83 c4 30          	add    $0x30,%rsp
ffffffff8010a3b6:	5d                   	pop    %rbp
ffffffff8010a3b7:	c3                   	retq   
ffffffff8010a3b8:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
ffffffff8010a3bf:	00 

ffffffff8010a3c0 <initsleeplock>:
#include <spinlock.h>
#include <sleeplock.h>

void
initsleeplock(struct sleeplock *lk, char *name)
{
ffffffff8010a3c0:	55                   	push   %rbp
ffffffff8010a3c1:	48 89 e5             	mov    %rsp,%rbp
ffffffff8010a3c4:	48 83 ec 20          	sub    $0x20,%rsp
ffffffff8010a3c8:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
ffffffff8010a3cc:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  initlock(&lk->lk, "sleep lock");
ffffffff8010a3d0:	48 8b 75 f8          	mov    -0x8(%rbp),%rsi
ffffffff8010a3d4:	48 83 c6 08          	add    $0x8,%rsi
ffffffff8010a3d8:	48 c7 c7 2a 03 11 80 	mov    $0xffffffff8011032a,%rdi
ffffffff8010a3df:	48 89 7d e8          	mov    %rdi,-0x18(%rbp)
ffffffff8010a3e3:	48 89 f7             	mov    %rsi,%rdi
ffffffff8010a3e6:	48 8b 75 e8          	mov    -0x18(%rbp),%rsi
ffffffff8010a3ea:	e8 91 b3 ff ff       	callq  ffffffff80105780 <initlock>
  lk->name = name;
ffffffff8010a3ef:	48 8b 75 f0          	mov    -0x10(%rbp),%rsi
ffffffff8010a3f3:	48 8b 7d f8          	mov    -0x8(%rbp),%rdi
ffffffff8010a3f7:	48 89 77 70          	mov    %rsi,0x70(%rdi)
  lk->locked = 0;
ffffffff8010a3fb:	48 8b 75 f8          	mov    -0x8(%rbp),%rsi
ffffffff8010a3ff:	c7 06 00 00 00 00    	movl   $0x0,(%rsi)
  lk->pid = 0;
ffffffff8010a405:	48 8b 75 f8          	mov    -0x8(%rbp),%rsi
ffffffff8010a409:	c7 46 78 00 00 00 00 	movl   $0x0,0x78(%rsi)
}
ffffffff8010a410:	48 83 c4 20          	add    $0x20,%rsp
ffffffff8010a414:	5d                   	pop    %rbp
ffffffff8010a415:	c3                   	retq   
ffffffff8010a416:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
ffffffff8010a41d:	00 00 00 

ffffffff8010a420 <acquiresleep>:

void
acquiresleep(struct sleeplock *lk)
{
ffffffff8010a420:	55                   	push   %rbp
ffffffff8010a421:	48 89 e5             	mov    %rsp,%rbp
ffffffff8010a424:	48 83 ec 10          	sub    $0x10,%rsp
ffffffff8010a428:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  acquire(&lk->lk);
ffffffff8010a42c:	48 8b 7d f8          	mov    -0x8(%rbp),%rdi
ffffffff8010a430:	48 83 c7 08          	add    $0x8,%rdi
ffffffff8010a434:	e8 87 b3 ff ff       	callq  ffffffff801057c0 <acquire>
  while (lk->locked) {
ffffffff8010a439:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
ffffffff8010a43d:	83 38 00             	cmpl   $0x0,(%rax)
ffffffff8010a440:	0f 84 1c 00 00 00    	je     ffffffff8010a462 <acquiresleep+0x42>
    sleep(lk, &lk->lk);
ffffffff8010a446:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
ffffffff8010a44a:	48 8b 4d f8          	mov    -0x8(%rbp),%rcx
ffffffff8010a44e:	48 83 c1 08          	add    $0x8,%rcx
ffffffff8010a452:	48 89 c7             	mov    %rax,%rdi
ffffffff8010a455:	48 89 ce             	mov    %rcx,%rsi
ffffffff8010a458:	e8 c3 df ff ff       	callq  ffffffff80108420 <sleep>
  while (lk->locked) {
ffffffff8010a45d:	e9 d7 ff ff ff       	jmpq   ffffffff8010a439 <acquiresleep+0x19>
  }
  lk->locked = 1;
ffffffff8010a462:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
ffffffff8010a466:	c7 00 01 00 00 00    	movl   $0x1,(%rax)
  lk->pid = myproc()->pid;
ffffffff8010a46c:	e8 2f 00 00 00       	callq  ffffffff8010a4a0 <myproc>
ffffffff8010a471:	8b 88 04 01 00 00    	mov    0x104(%rax),%ecx
ffffffff8010a477:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
ffffffff8010a47b:	89 48 78             	mov    %ecx,0x78(%rax)
  release(&lk->lk);
ffffffff8010a47e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
ffffffff8010a482:	48 83 c0 08          	add    $0x8,%rax
ffffffff8010a486:	48 89 c7             	mov    %rax,%rdi
ffffffff8010a489:	e8 72 b5 ff ff       	callq  ffffffff80105a00 <release>
}
ffffffff8010a48e:	48 83 c4 10          	add    $0x10,%rsp
ffffffff8010a492:	5d                   	pop    %rbp
ffffffff8010a493:	c3                   	retq   
ffffffff8010a494:	66 66 66 2e 0f 1f 84 	data16 data16 nopw %cs:0x0(%rax,%rax,1)
ffffffff8010a49b:	00 00 00 00 00 

ffffffff8010a4a0 <myproc>:
{
ffffffff8010a4a0:	55                   	push   %rbp
ffffffff8010a4a1:	48 89 e5             	mov    %rsp,%rbp
  return mycpu()->proc;
ffffffff8010a4a4:	e8 a7 00 00 00       	callq  ffffffff8010a550 <mycpu>
ffffffff8010a4a9:	48 8b 80 d0 00 00 00 	mov    0xd0(%rax),%rax
ffffffff8010a4b0:	5d                   	pop    %rbp
ffffffff8010a4b1:	c3                   	retq   
ffffffff8010a4b2:	66 66 66 66 66 2e 0f 	data16 data16 data16 data16 nopw %cs:0x0(%rax,%rax,1)
ffffffff8010a4b9:	1f 84 00 00 00 00 00 

ffffffff8010a4c0 <releasesleep>:

void
releasesleep(struct sleeplock *lk)
{
ffffffff8010a4c0:	55                   	push   %rbp
ffffffff8010a4c1:	48 89 e5             	mov    %rsp,%rbp
ffffffff8010a4c4:	48 83 ec 10          	sub    $0x10,%rsp
ffffffff8010a4c8:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  acquire(&lk->lk);
ffffffff8010a4cc:	48 8b 7d f8          	mov    -0x8(%rbp),%rdi
ffffffff8010a4d0:	48 83 c7 08          	add    $0x8,%rdi
ffffffff8010a4d4:	e8 e7 b2 ff ff       	callq  ffffffff801057c0 <acquire>
  lk->locked = 0;
ffffffff8010a4d9:	48 8b 7d f8          	mov    -0x8(%rbp),%rdi
ffffffff8010a4dd:	c7 07 00 00 00 00    	movl   $0x0,(%rdi)
  lk->pid = 0;
ffffffff8010a4e3:	48 8b 7d f8          	mov    -0x8(%rbp),%rdi
ffffffff8010a4e7:	c7 47 78 00 00 00 00 	movl   $0x0,0x78(%rdi)
  wakeup(lk);
ffffffff8010a4ee:	48 8b 7d f8          	mov    -0x8(%rbp),%rdi
ffffffff8010a4f2:	e8 d9 e1 ff ff       	callq  ffffffff801086d0 <wakeup>
  release(&lk->lk);
ffffffff8010a4f7:	48 8b 7d f8          	mov    -0x8(%rbp),%rdi
ffffffff8010a4fb:	48 83 c7 08          	add    $0x8,%rdi
ffffffff8010a4ff:	e8 fc b4 ff ff       	callq  ffffffff80105a00 <release>
}
ffffffff8010a504:	48 83 c4 10          	add    $0x10,%rsp
ffffffff8010a508:	5d                   	pop    %rbp
ffffffff8010a509:	c3                   	retq   
ffffffff8010a50a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)

ffffffff8010a510 <holdingsleep>:

int
holdingsleep(struct sleeplock *lk)
{
ffffffff8010a510:	55                   	push   %rbp
ffffffff8010a511:	48 89 e5             	mov    %rsp,%rbp
ffffffff8010a514:	48 83 ec 10          	sub    $0x10,%rsp
ffffffff8010a518:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  int r;
  
  acquire(&lk->lk);
ffffffff8010a51c:	48 8b 7d f8          	mov    -0x8(%rbp),%rdi
ffffffff8010a520:	48 83 c7 08          	add    $0x8,%rdi
ffffffff8010a524:	e8 97 b2 ff ff       	callq  ffffffff801057c0 <acquire>
  r = lk->locked;
ffffffff8010a529:	48 8b 7d f8          	mov    -0x8(%rbp),%rdi
ffffffff8010a52d:	8b 07                	mov    (%rdi),%eax
ffffffff8010a52f:	89 45 f4             	mov    %eax,-0xc(%rbp)
  release(&lk->lk);
ffffffff8010a532:	48 8b 7d f8          	mov    -0x8(%rbp),%rdi
ffffffff8010a536:	48 83 c7 08          	add    $0x8,%rdi
ffffffff8010a53a:	e8 c1 b4 ff ff       	callq  ffffffff80105a00 <release>
  return r;
ffffffff8010a53f:	8b 45 f4             	mov    -0xc(%rbp),%eax
ffffffff8010a542:	48 83 c4 10          	add    $0x10,%rsp
ffffffff8010a546:	5d                   	pop    %rbp
ffffffff8010a547:	c3                   	retq   
ffffffff8010a548:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
ffffffff8010a54f:	00 

ffffffff8010a550 <mycpu>:
{
ffffffff8010a550:	55                   	push   %rbp
ffffffff8010a551:	48 89 e5             	mov    %rsp,%rbp
  return &cpus[0];
ffffffff8010a554:	48 c7 c0 e0 7b 1f 83 	mov    $0xffffffff831f7be0,%rax
ffffffff8010a55b:	5d                   	pop    %rbp
ffffffff8010a55c:	c3                   	retq   
ffffffff8010a55d:	0f 1f 00             	nopl   (%rax)

ffffffff8010a560 <ioapicinit>:
  ioapic->data = data;
}

void
ioapicinit(void)
{
ffffffff8010a560:	55                   	push   %rbp
ffffffff8010a561:	48 89 e5             	mov    %rsp,%rbp
  int i, id, maxintr;

  if(!ismp)
ffffffff8010a564:	48 83 ec 10          	sub    $0x10,%rsp
ffffffff8010a568:	8b 04 25 d4 7b 1f 83 	mov    0xffffffff831f7bd4,%eax
ffffffff8010a56f:	83 f8 00             	cmp    $0x0,%eax
ffffffff8010a572:	0f 85 05 00 00 00    	jne    ffffffff8010a57d <ioapicinit+0x1d>
    return;
ffffffff8010a578:	e9 ae 00 00 00       	jmpq   ffffffff8010a62b <ioapicinit+0xcb>

  ioapic = (volatile struct ioapic*)IO2V(IOAPIC);
ffffffff8010a57d:	48 c7 04 25 38 27 20 	movq   $0xfffffffffec00000,0xffffffff83202738
ffffffff8010a584:	83 00 00 c0 fe 
  maxintr = (ioapicread(REG_VER) >> 16) & 0xFF;
ffffffff8010a589:	bf 01 00 00 00       	mov    $0x1,%edi
ffffffff8010a58e:	e8 ad 00 00 00       	callq  ffffffff8010a640 <ioapicread>
ffffffff8010a593:	c1 e8 10             	shr    $0x10,%eax
ffffffff8010a596:	88 c1                	mov    %al,%cl
ffffffff8010a598:	0f b6 c1             	movzbl %cl,%eax
ffffffff8010a59b:	89 45 f4             	mov    %eax,-0xc(%rbp)
  id = ioapicread(REG_ID) >> 24;
ffffffff8010a59e:	31 ff                	xor    %edi,%edi
ffffffff8010a5a0:	e8 9b 00 00 00       	callq  ffffffff8010a640 <ioapicread>
ffffffff8010a5a5:	c1 e8 18             	shr    $0x18,%eax
ffffffff8010a5a8:	89 45 f8             	mov    %eax,-0x8(%rbp)
  if(id != ioapicid)
ffffffff8010a5ab:	8b 45 f8             	mov    -0x8(%rbp),%eax
ffffffff8010a5ae:	8a 0c 25 d0 7b 1f 83 	mov    0xffffffff831f7bd0,%cl
ffffffff8010a5b5:	0f b6 f9             	movzbl %cl,%edi
ffffffff8010a5b8:	39 f8                	cmp    %edi,%eax
ffffffff8010a5ba:	0f 84 12 00 00 00    	je     ffffffff8010a5d2 <ioapicinit+0x72>
    cprintf("ioapicinit: id isn't equal to ioapicid; not a MP\n");
ffffffff8010a5c0:	48 c7 c7 35 03 11 80 	mov    $0xffffffff80110335,%rdi
ffffffff8010a5c7:	31 c0                	xor    %eax,%eax
ffffffff8010a5c9:	88 c1                	mov    %al,%cl
ffffffff8010a5cb:	88 c8                	mov    %cl,%al
ffffffff8010a5cd:	e8 8e 63 ff ff       	callq  ffffffff80100960 <cprintf>

  // Mark all interrupts edge-triggered, active high, disabled,
  // and not routed to any CPUs.
  for(i = 0; i <= maxintr; i++){
ffffffff8010a5d2:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
ffffffff8010a5d9:	8b 45 fc             	mov    -0x4(%rbp),%eax
ffffffff8010a5dc:	3b 45 f4             	cmp    -0xc(%rbp),%eax
ffffffff8010a5df:	0f 8f 46 00 00 00    	jg     ffffffff8010a62b <ioapicinit+0xcb>
    ioapicwrite(REG_TABLE+2*i, INT_DISABLED | (TRAP_IRQ0 + i));
ffffffff8010a5e5:	8b 45 fc             	mov    -0x4(%rbp),%eax
ffffffff8010a5e8:	c1 e0 01             	shl    $0x1,%eax
ffffffff8010a5eb:	83 c0 10             	add    $0x10,%eax
ffffffff8010a5ee:	8b 4d fc             	mov    -0x4(%rbp),%ecx
ffffffff8010a5f1:	83 c1 20             	add    $0x20,%ecx
ffffffff8010a5f4:	81 c9 00 00 01 00    	or     $0x10000,%ecx
ffffffff8010a5fa:	89 c7                	mov    %eax,%edi
ffffffff8010a5fc:	89 ce                	mov    %ecx,%esi
ffffffff8010a5fe:	e8 6d 00 00 00       	callq  ffffffff8010a670 <ioapicwrite>
ffffffff8010a603:	31 c0                	xor    %eax,%eax
    ioapicwrite(REG_TABLE+2*i+1, 0);
ffffffff8010a605:	8b 4d fc             	mov    -0x4(%rbp),%ecx
ffffffff8010a608:	c1 e1 01             	shl    $0x1,%ecx
ffffffff8010a60b:	83 c1 10             	add    $0x10,%ecx
ffffffff8010a60e:	83 c1 01             	add    $0x1,%ecx
ffffffff8010a611:	31 f6                	xor    %esi,%esi
ffffffff8010a613:	89 cf                	mov    %ecx,%edi
ffffffff8010a615:	89 45 f0             	mov    %eax,-0x10(%rbp)
ffffffff8010a618:	e8 53 00 00 00       	callq  ffffffff8010a670 <ioapicwrite>
  for(i = 0; i <= maxintr; i++){
ffffffff8010a61d:	8b 45 fc             	mov    -0x4(%rbp),%eax
ffffffff8010a620:	83 c0 01             	add    $0x1,%eax
ffffffff8010a623:	89 45 fc             	mov    %eax,-0x4(%rbp)
ffffffff8010a626:	e9 ae ff ff ff       	jmpq   ffffffff8010a5d9 <ioapicinit+0x79>
  }
}
ffffffff8010a62b:	48 83 c4 10          	add    $0x10,%rsp
ffffffff8010a62f:	5d                   	pop    %rbp
ffffffff8010a630:	c3                   	retq   
ffffffff8010a631:	66 66 66 66 66 66 2e 	data16 data16 data16 data16 data16 nopw %cs:0x0(%rax,%rax,1)
ffffffff8010a638:	0f 1f 84 00 00 00 00 
ffffffff8010a63f:	00 

ffffffff8010a640 <ioapicread>:
{
ffffffff8010a640:	55                   	push   %rbp
ffffffff8010a641:	48 89 e5             	mov    %rsp,%rbp
ffffffff8010a644:	48 83 ec 04          	sub    $0x4,%rsp
ffffffff8010a648:	89 7d fc             	mov    %edi,-0x4(%rbp)
  ioapic->reg = reg;
ffffffff8010a64b:	8b 7d fc             	mov    -0x4(%rbp),%edi
ffffffff8010a64e:	48 8b 04 25 38 27 20 	mov    0xffffffff83202738,%rax
ffffffff8010a655:	83 
ffffffff8010a656:	89 38                	mov    %edi,(%rax)
  return ioapic->data;
ffffffff8010a658:	48 8b 04 25 38 27 20 	mov    0xffffffff83202738,%rax
ffffffff8010a65f:	83 
ffffffff8010a660:	8b 40 10             	mov    0x10(%rax),%eax
ffffffff8010a663:	48 83 c4 04          	add    $0x4,%rsp
ffffffff8010a667:	5d                   	pop    %rbp
ffffffff8010a668:	c3                   	retq   
ffffffff8010a669:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)

ffffffff8010a670 <ioapicwrite>:
{
ffffffff8010a670:	55                   	push   %rbp
ffffffff8010a671:	48 89 e5             	mov    %rsp,%rbp
ffffffff8010a674:	50                   	push   %rax
ffffffff8010a675:	89 7d fc             	mov    %edi,-0x4(%rbp)
ffffffff8010a678:	89 75 f8             	mov    %esi,-0x8(%rbp)
  ioapic->reg = reg;
ffffffff8010a67b:	8b 75 fc             	mov    -0x4(%rbp),%esi
ffffffff8010a67e:	48 8b 04 25 38 27 20 	mov    0xffffffff83202738,%rax
ffffffff8010a685:	83 
ffffffff8010a686:	89 30                	mov    %esi,(%rax)
  ioapic->data = data;
ffffffff8010a688:	8b 75 f8             	mov    -0x8(%rbp),%esi
ffffffff8010a68b:	48 8b 04 25 38 27 20 	mov    0xffffffff83202738,%rax
ffffffff8010a692:	83 
ffffffff8010a693:	89 70 10             	mov    %esi,0x10(%rax)
}
ffffffff8010a696:	48 83 c4 08          	add    $0x8,%rsp
ffffffff8010a69a:	5d                   	pop    %rbp
ffffffff8010a69b:	c3                   	retq   
ffffffff8010a69c:	0f 1f 40 00          	nopl   0x0(%rax)

ffffffff8010a6a0 <ioapicenable>:

void
ioapicenable(int irq, int cpunum)
{
ffffffff8010a6a0:	55                   	push   %rbp
ffffffff8010a6a1:	48 89 e5             	mov    %rsp,%rbp
ffffffff8010a6a4:	48 83 ec 10          	sub    $0x10,%rsp
ffffffff8010a6a8:	89 7d fc             	mov    %edi,-0x4(%rbp)
ffffffff8010a6ab:	89 75 f8             	mov    %esi,-0x8(%rbp)
  if(!ismp)
ffffffff8010a6ae:	8b 34 25 d4 7b 1f 83 	mov    0xffffffff831f7bd4,%esi
ffffffff8010a6b5:	83 fe 00             	cmp    $0x0,%esi
ffffffff8010a6b8:	0f 85 05 00 00 00    	jne    ffffffff8010a6c3 <ioapicenable+0x23>
    return;
ffffffff8010a6be:	e9 33 00 00 00       	jmpq   ffffffff8010a6f6 <ioapicenable+0x56>

  // Mark interrupt edge-triggered, active high,
  // enabled, and routed to the given cpunum,
  // which happens to be that cpu's APIC ID.
  ioapicwrite(REG_TABLE+2*irq, TRAP_IRQ0 + irq);
ffffffff8010a6c3:	8b 45 fc             	mov    -0x4(%rbp),%eax
ffffffff8010a6c6:	c1 e0 01             	shl    $0x1,%eax
ffffffff8010a6c9:	83 c0 10             	add    $0x10,%eax
ffffffff8010a6cc:	8b 4d fc             	mov    -0x4(%rbp),%ecx
ffffffff8010a6cf:	83 c1 20             	add    $0x20,%ecx
ffffffff8010a6d2:	89 c7                	mov    %eax,%edi
ffffffff8010a6d4:	89 ce                	mov    %ecx,%esi
ffffffff8010a6d6:	e8 95 ff ff ff       	callq  ffffffff8010a670 <ioapicwrite>
  ioapicwrite(REG_TABLE+2*irq+1, cpunum << 24);
ffffffff8010a6db:	8b 45 fc             	mov    -0x4(%rbp),%eax
ffffffff8010a6de:	c1 e0 01             	shl    $0x1,%eax
ffffffff8010a6e1:	83 c0 10             	add    $0x10,%eax
ffffffff8010a6e4:	83 c0 01             	add    $0x1,%eax
ffffffff8010a6e7:	8b 4d f8             	mov    -0x8(%rbp),%ecx
ffffffff8010a6ea:	c1 e1 18             	shl    $0x18,%ecx
ffffffff8010a6ed:	89 c7                	mov    %eax,%edi
ffffffff8010a6ef:	89 ce                	mov    %ecx,%esi
ffffffff8010a6f1:	e8 7a ff ff ff       	callq  ffffffff8010a670 <ioapicwrite>
ffffffff8010a6f6:	48 83 c4 10          	add    $0x10,%rsp
ffffffff8010a6fa:	5d                   	pop    %rbp
ffffffff8010a6fb:	c3                   	retq   
ffffffff8010a6fc:	0f 1f 40 00          	nopl   0x0(%rax)

ffffffff8010a700 <sys_crashn>:
#include <mmu.h>
#include <proc.h>
#include <memory.h>

int sys_crashn(void)
{
ffffffff8010a700:	55                   	push   %rbp
ffffffff8010a701:	48 89 e5             	mov    %rsp,%rbp
ffffffff8010a704:	48 83 ec 20          	sub    $0x20,%rsp
ffffffff8010a708:	31 c0                	xor    %eax,%eax
ffffffff8010a70a:	48 8d 4d f8          	lea    -0x8(%rbp),%rcx
  int n;
  if(argint(0, &n) < 0)
ffffffff8010a70e:	31 ff                	xor    %edi,%edi
ffffffff8010a710:	48 8d 75 f8          	lea    -0x8(%rbp),%rsi
ffffffff8010a714:	89 45 f4             	mov    %eax,-0xc(%rbp)
ffffffff8010a717:	48 89 4d e8          	mov    %rcx,-0x18(%rbp)
ffffffff8010a71b:	e8 70 e9 ff ff       	callq  ffffffff80109090 <argint>
ffffffff8010a720:	83 f8 00             	cmp    $0x0,%eax
ffffffff8010a723:	0f 8d 0c 00 00 00    	jge    ffffffff8010a735 <sys_crashn+0x35>
    return -1;
ffffffff8010a729:	c7 45 fc ff ff ff ff 	movl   $0xffffffff,-0x4(%rbp)
ffffffff8010a730:	e9 1c 00 00 00       	jmpq   ffffffff8010a751 <sys_crashn+0x51>

  crashn_enable = 1;
ffffffff8010a735:	c7 04 25 90 64 1f 83 	movl   $0x1,0xffffffff831f6490
ffffffff8010a73c:	01 00 00 00 
  crashn = n;
ffffffff8010a740:	8b 45 f8             	mov    -0x8(%rbp),%eax
ffffffff8010a743:	89 04 25 94 64 1f 83 	mov    %eax,0xffffffff831f6494

  return 0;
ffffffff8010a74a:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
}
ffffffff8010a751:	8b 45 fc             	mov    -0x4(%rbp),%eax
ffffffff8010a754:	48 83 c4 20          	add    $0x20,%rsp
ffffffff8010a758:	5d                   	pop    %rbp
ffffffff8010a759:	c3                   	retq   
ffffffff8010a75a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)

ffffffff8010a760 <sys_fork>:

int
sys_fork(void)
{
ffffffff8010a760:	55                   	push   %rbp
ffffffff8010a761:	48 89 e5             	mov    %rsp,%rbp
  return fork();
ffffffff8010a764:	e8 47 d5 ff ff       	callq  ffffffff80107cb0 <fork>
ffffffff8010a769:	5d                   	pop    %rbp
ffffffff8010a76a:	c3                   	retq   
ffffffff8010a76b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

ffffffff8010a770 <halt>:
}

void
halt(void) {
ffffffff8010a770:	55                   	push   %rbp
ffffffff8010a771:	48 89 e5             	mov    %rsp,%rbp
  while (1);
ffffffff8010a774:	e9 00 00 00 00       	jmpq   ffffffff8010a779 <halt+0x9>
ffffffff8010a779:	e9 fb ff ff ff       	jmpq   ffffffff8010a779 <halt+0x9>
ffffffff8010a77e:	66 90                	xchg   %ax,%ax

ffffffff8010a780 <sys_exit>:
}

int
sys_exit(void)
{
ffffffff8010a780:	55                   	push   %rbp
ffffffff8010a781:	48 89 e5             	mov    %rsp,%rbp
  exit();
ffffffff8010a784:	e8 c7 d7 ff ff       	callq  ffffffff80107f50 <exit>
  halt();
ffffffff8010a789:	e8 e2 ff ff ff       	callq  ffffffff8010a770 <halt>
ffffffff8010a78e:	31 c0                	xor    %eax,%eax
  return 0;  // not reached
ffffffff8010a790:	5d                   	pop    %rbp
ffffffff8010a791:	c3                   	retq   
ffffffff8010a792:	66 66 66 66 66 2e 0f 	data16 data16 data16 data16 nopw %cs:0x0(%rax,%rax,1)
ffffffff8010a799:	1f 84 00 00 00 00 00 

ffffffff8010a7a0 <sys_wait>:
}

int
sys_wait(void)
{
ffffffff8010a7a0:	55                   	push   %rbp
ffffffff8010a7a1:	48 89 e5             	mov    %rsp,%rbp
  return wait();
ffffffff8010a7a4:	e8 57 da ff ff       	callq  ffffffff80108200 <wait>
ffffffff8010a7a9:	5d                   	pop    %rbp
ffffffff8010a7aa:	c3                   	retq   
ffffffff8010a7ab:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

ffffffff8010a7b0 <sys_kill>:
}

int
sys_kill(void)
{
ffffffff8010a7b0:	55                   	push   %rbp
ffffffff8010a7b1:	48 89 e5             	mov    %rsp,%rbp
ffffffff8010a7b4:	48 83 ec 20          	sub    $0x20,%rsp
ffffffff8010a7b8:	31 c0                	xor    %eax,%eax
ffffffff8010a7ba:	48 8d 4d f8          	lea    -0x8(%rbp),%rcx
  int pid;

  if(argint(0, &pid) < 0)
ffffffff8010a7be:	31 ff                	xor    %edi,%edi
ffffffff8010a7c0:	48 8d 75 f8          	lea    -0x8(%rbp),%rsi
ffffffff8010a7c4:	89 45 f4             	mov    %eax,-0xc(%rbp)
ffffffff8010a7c7:	48 89 4d e8          	mov    %rcx,-0x18(%rbp)
ffffffff8010a7cb:	e8 c0 e8 ff ff       	callq  ffffffff80109090 <argint>
ffffffff8010a7d0:	83 f8 00             	cmp    $0x0,%eax
ffffffff8010a7d3:	0f 8d 0c 00 00 00    	jge    ffffffff8010a7e5 <sys_kill+0x35>
    return -1;
ffffffff8010a7d9:	c7 45 fc ff ff ff ff 	movl   $0xffffffff,-0x4(%rbp)
ffffffff8010a7e0:	e9 0b 00 00 00       	jmpq   ffffffff8010a7f0 <sys_kill+0x40>
  return kill(pid);
ffffffff8010a7e5:	8b 7d f8             	mov    -0x8(%rbp),%edi
ffffffff8010a7e8:	e8 23 df ff ff       	callq  ffffffff80108710 <kill>
ffffffff8010a7ed:	89 45 fc             	mov    %eax,-0x4(%rbp)
}
ffffffff8010a7f0:	8b 45 fc             	mov    -0x4(%rbp),%eax
ffffffff8010a7f3:	48 83 c4 20          	add    $0x20,%rsp
ffffffff8010a7f7:	5d                   	pop    %rbp
ffffffff8010a7f8:	c3                   	retq   
ffffffff8010a7f9:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)

ffffffff8010a800 <sys_getpid>:

int
sys_getpid(void)
{
ffffffff8010a800:	55                   	push   %rbp
ffffffff8010a801:	48 89 e5             	mov    %rsp,%rbp
  return myproc()->pid;
ffffffff8010a804:	e8 17 00 00 00       	callq  ffffffff8010a820 <myproc>
ffffffff8010a809:	8b 80 04 01 00 00    	mov    0x104(%rax),%eax
ffffffff8010a80f:	5d                   	pop    %rbp
ffffffff8010a810:	c3                   	retq   
ffffffff8010a811:	66 66 66 66 66 66 2e 	data16 data16 data16 data16 data16 nopw %cs:0x0(%rax,%rax,1)
ffffffff8010a818:	0f 1f 84 00 00 00 00 
ffffffff8010a81f:	00 

ffffffff8010a820 <myproc>:
{
ffffffff8010a820:	55                   	push   %rbp
ffffffff8010a821:	48 89 e5             	mov    %rsp,%rbp
  return mycpu()->proc;
ffffffff8010a824:	e8 67 01 00 00       	callq  ffffffff8010a990 <mycpu>
ffffffff8010a829:	48 8b 80 d0 00 00 00 	mov    0xd0(%rax),%rax
ffffffff8010a830:	5d                   	pop    %rbp
ffffffff8010a831:	c3                   	retq   
ffffffff8010a832:	66 66 66 66 66 2e 0f 	data16 data16 data16 data16 nopw %cs:0x0(%rax,%rax,1)
ffffffff8010a839:	1f 84 00 00 00 00 00 

ffffffff8010a840 <sys_sbrk>:
}

int
sys_sbrk(void)
{
ffffffff8010a840:	55                   	push   %rbp
ffffffff8010a841:	48 89 e5             	mov    %rsp,%rbp
ffffffff8010a844:	48 83 ec 20          	sub    $0x20,%rsp
ffffffff8010a848:	31 c0                	xor    %eax,%eax
ffffffff8010a84a:	48 8d 4d f8          	lea    -0x8(%rbp),%rcx
  int size;

  if (argint(0, &size) < 0) {
ffffffff8010a84e:	31 ff                	xor    %edi,%edi
ffffffff8010a850:	48 8d 75 f8          	lea    -0x8(%rbp),%rsi
ffffffff8010a854:	89 45 f4             	mov    %eax,-0xc(%rbp)
ffffffff8010a857:	48 89 4d e8          	mov    %rcx,-0x18(%rbp)
ffffffff8010a85b:	e8 30 e8 ff ff       	callq  ffffffff80109090 <argint>
ffffffff8010a860:	83 f8 00             	cmp    $0x0,%eax
ffffffff8010a863:	0f 8d 0c 00 00 00    	jge    ffffffff8010a875 <sys_sbrk+0x35>
    return -1;
ffffffff8010a869:	c7 45 fc ff ff ff ff 	movl   $0xffffffff,-0x4(%rbp)
ffffffff8010a870:	e9 0b 00 00 00       	jmpq   ffffffff8010a880 <sys_sbrk+0x40>
  }

  // TODO: not sure of return value
  // it calls for int here but sbrk should
  // return a Virtual Address right?
  return (int) sbrk(size);
ffffffff8010a875:	8b 7d f8             	mov    -0x8(%rbp),%edi
ffffffff8010a878:	e8 13 3e 00 00       	callq  ffffffff8010e690 <sbrk>
ffffffff8010a87d:	89 45 fc             	mov    %eax,-0x4(%rbp)
}
ffffffff8010a880:	8b 45 fc             	mov    -0x4(%rbp),%eax
ffffffff8010a883:	48 83 c4 20          	add    $0x20,%rsp
ffffffff8010a887:	5d                   	pop    %rbp
ffffffff8010a888:	c3                   	retq   
ffffffff8010a889:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)

ffffffff8010a890 <sys_sleep>:

int
sys_sleep(void)
{
ffffffff8010a890:	55                   	push   %rbp
ffffffff8010a891:	48 89 e5             	mov    %rsp,%rbp
ffffffff8010a894:	48 83 ec 20          	sub    $0x20,%rsp
ffffffff8010a898:	31 c0                	xor    %eax,%eax
ffffffff8010a89a:	48 8d 4d f8          	lea    -0x8(%rbp),%rcx
  int n;
  uint ticks0;

  if(argint(0, &n) < 0)
ffffffff8010a89e:	31 ff                	xor    %edi,%edi
ffffffff8010a8a0:	48 8d 75 f8          	lea    -0x8(%rbp),%rsi
ffffffff8010a8a4:	89 45 f0             	mov    %eax,-0x10(%rbp)
ffffffff8010a8a7:	48 89 4d e8          	mov    %rcx,-0x18(%rbp)
ffffffff8010a8ab:	e8 e0 e7 ff ff       	callq  ffffffff80109090 <argint>
ffffffff8010a8b0:	83 f8 00             	cmp    $0x0,%eax
ffffffff8010a8b3:	0f 8d 0c 00 00 00    	jge    ffffffff8010a8c5 <sys_sleep+0x35>
    return -1;
ffffffff8010a8b9:	c7 45 fc ff ff ff ff 	movl   $0xffffffff,-0x4(%rbp)
ffffffff8010a8c0:	e9 7e 00 00 00       	jmpq   ffffffff8010a943 <sys_sleep+0xb3>
  acquire(&tickslock);
ffffffff8010a8c5:	48 c7 c7 50 6b 1f 83 	mov    $0xffffffff831f6b50,%rdi
ffffffff8010a8cc:	e8 ef ae ff ff       	callq  ffffffff801057c0 <acquire>
  ticks0 = ticks;
ffffffff8010a8d1:	8b 04 25 c0 7b 1f 83 	mov    0xffffffff831f7bc0,%eax
ffffffff8010a8d8:	89 45 f4             	mov    %eax,-0xc(%rbp)
  while(ticks - ticks0 < n){
ffffffff8010a8db:	8b 04 25 c0 7b 1f 83 	mov    0xffffffff831f7bc0,%eax
ffffffff8010a8e2:	2b 45 f4             	sub    -0xc(%rbp),%eax
ffffffff8010a8e5:	3b 45 f8             	cmp    -0x8(%rbp),%eax
ffffffff8010a8e8:	0f 83 42 00 00 00    	jae    ffffffff8010a930 <sys_sleep+0xa0>
    if(myproc()->killed){
ffffffff8010a8ee:	e8 2d ff ff ff       	callq  ffffffff8010a820 <myproc>
ffffffff8010a8f3:	83 b8 28 01 00 00 00 	cmpl   $0x0,0x128(%rax)
ffffffff8010a8fa:	0f 84 18 00 00 00    	je     ffffffff8010a918 <sys_sleep+0x88>
      release(&tickslock);
ffffffff8010a900:	48 c7 c7 50 6b 1f 83 	mov    $0xffffffff831f6b50,%rdi
ffffffff8010a907:	e8 f4 b0 ff ff       	callq  ffffffff80105a00 <release>
      return -1;
ffffffff8010a90c:	c7 45 fc ff ff ff ff 	movl   $0xffffffff,-0x4(%rbp)
ffffffff8010a913:	e9 2b 00 00 00       	jmpq   ffffffff8010a943 <sys_sleep+0xb3>
    }
    sleep(&ticks, &tickslock);
ffffffff8010a918:	48 c7 c7 c0 7b 1f 83 	mov    $0xffffffff831f7bc0,%rdi
ffffffff8010a91f:	48 c7 c6 50 6b 1f 83 	mov    $0xffffffff831f6b50,%rsi
ffffffff8010a926:	e8 f5 da ff ff       	callq  ffffffff80108420 <sleep>
  while(ticks - ticks0 < n){
ffffffff8010a92b:	e9 ab ff ff ff       	jmpq   ffffffff8010a8db <sys_sleep+0x4b>
  }
  release(&tickslock);
ffffffff8010a930:	48 c7 c7 50 6b 1f 83 	mov    $0xffffffff831f6b50,%rdi
ffffffff8010a937:	e8 c4 b0 ff ff       	callq  ffffffff80105a00 <release>
  return 0;
ffffffff8010a93c:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
}
ffffffff8010a943:	8b 45 fc             	mov    -0x4(%rbp),%eax
ffffffff8010a946:	48 83 c4 20          	add    $0x20,%rsp
ffffffff8010a94a:	5d                   	pop    %rbp
ffffffff8010a94b:	c3                   	retq   
ffffffff8010a94c:	0f 1f 40 00          	nopl   0x0(%rax)

ffffffff8010a950 <sys_uptime>:

// return how many clock tick interrupts have occurred
// since start.
int
sys_uptime(void)
{
ffffffff8010a950:	55                   	push   %rbp
ffffffff8010a951:	48 89 e5             	mov    %rsp,%rbp
  uint xticks;

  acquire(&tickslock);
ffffffff8010a954:	48 83 ec 10          	sub    $0x10,%rsp
ffffffff8010a958:	48 c7 c7 50 6b 1f 83 	mov    $0xffffffff831f6b50,%rdi
ffffffff8010a95f:	e8 5c ae ff ff       	callq  ffffffff801057c0 <acquire>
  xticks = ticks;
ffffffff8010a964:	8b 04 25 c0 7b 1f 83 	mov    0xffffffff831f7bc0,%eax
ffffffff8010a96b:	89 45 fc             	mov    %eax,-0x4(%rbp)
  release(&tickslock);
ffffffff8010a96e:	48 c7 c7 50 6b 1f 83 	mov    $0xffffffff831f6b50,%rdi
ffffffff8010a975:	e8 86 b0 ff ff       	callq  ffffffff80105a00 <release>
  return xticks;
ffffffff8010a97a:	8b 45 fc             	mov    -0x4(%rbp),%eax
ffffffff8010a97d:	48 83 c4 10          	add    $0x10,%rsp
ffffffff8010a981:	5d                   	pop    %rbp
ffffffff8010a982:	c3                   	retq   
ffffffff8010a983:	66 66 66 66 2e 0f 1f 	data16 data16 data16 nopw %cs:0x0(%rax,%rax,1)
ffffffff8010a98a:	84 00 00 00 00 00 

ffffffff8010a990 <mycpu>:
{
ffffffff8010a990:	55                   	push   %rbp
ffffffff8010a991:	48 89 e5             	mov    %rsp,%rbp
  return &cpus[0];
ffffffff8010a994:	48 c7 c0 e0 7b 1f 83 	mov    $0xffffffff831f7be0,%rax
ffffffff8010a99b:	5d                   	pop    %rbp
ffffffff8010a99c:	c3                   	retq   
ffffffff8010a99d:	0f 1f 00             	nopl   (%rax)

ffffffff8010a9a0 <uartinit>:

static int uart;    // is there a uart?

void
uartinit(void)
{
ffffffff8010a9a0:	55                   	push   %rbp
ffffffff8010a9a1:	48 89 e5             	mov    %rsp,%rbp
ffffffff8010a9a4:	48 83 ec 50          	sub    $0x50,%rsp
ffffffff8010a9a8:	b8 fa 03 00 00       	mov    $0x3fa,%eax
ffffffff8010a9ad:	31 c9                	xor    %ecx,%ecx
  char *p;

  // Turn off the FIFO
  outb(COM1+2, 0);
ffffffff8010a9af:	bf fa 03 00 00       	mov    $0x3fa,%edi
ffffffff8010a9b4:	31 f6                	xor    %esi,%esi
ffffffff8010a9b6:	89 45 f4             	mov    %eax,-0xc(%rbp)
ffffffff8010a9b9:	89 4d f0             	mov    %ecx,-0x10(%rbp)
ffffffff8010a9bc:	e8 4f 01 00 00       	callq  ffffffff8010ab10 <outb>
ffffffff8010a9c1:	b8 fb 03 00 00       	mov    $0x3fb,%eax
ffffffff8010a9c6:	b9 80 00 00 00       	mov    $0x80,%ecx

  // 9600 baud, 8 data bits, 1 stop bit, parity off.
  outb(COM1+3, 0x80);    // Unlock divisor
ffffffff8010a9cb:	bf fb 03 00 00       	mov    $0x3fb,%edi
ffffffff8010a9d0:	be 80 00 00 00       	mov    $0x80,%esi
ffffffff8010a9d5:	89 45 ec             	mov    %eax,-0x14(%rbp)
ffffffff8010a9d8:	89 4d e8             	mov    %ecx,-0x18(%rbp)
ffffffff8010a9db:	e8 30 01 00 00       	callq  ffffffff8010ab10 <outb>
ffffffff8010a9e0:	b8 f8 03 00 00       	mov    $0x3f8,%eax
ffffffff8010a9e5:	b9 0c 00 00 00       	mov    $0xc,%ecx
  outb(COM1+0, 115200/9600);
ffffffff8010a9ea:	bf f8 03 00 00       	mov    $0x3f8,%edi
ffffffff8010a9ef:	be 0c 00 00 00       	mov    $0xc,%esi
ffffffff8010a9f4:	89 45 e4             	mov    %eax,-0x1c(%rbp)
ffffffff8010a9f7:	89 4d e0             	mov    %ecx,-0x20(%rbp)
ffffffff8010a9fa:	e8 11 01 00 00       	callq  ffffffff8010ab10 <outb>
ffffffff8010a9ff:	b8 f9 03 00 00       	mov    $0x3f9,%eax
ffffffff8010aa04:	31 c9                	xor    %ecx,%ecx
  outb(COM1+1, 0);
ffffffff8010aa06:	bf f9 03 00 00       	mov    $0x3f9,%edi
ffffffff8010aa0b:	31 f6                	xor    %esi,%esi
ffffffff8010aa0d:	89 45 dc             	mov    %eax,-0x24(%rbp)
ffffffff8010aa10:	89 4d d8             	mov    %ecx,-0x28(%rbp)
ffffffff8010aa13:	e8 f8 00 00 00       	callq  ffffffff8010ab10 <outb>
ffffffff8010aa18:	b8 fb 03 00 00       	mov    $0x3fb,%eax
ffffffff8010aa1d:	b9 03 00 00 00       	mov    $0x3,%ecx
  outb(COM1+3, 0x03);    // Lock divisor, 8 data bits.
ffffffff8010aa22:	bf fb 03 00 00       	mov    $0x3fb,%edi
ffffffff8010aa27:	be 03 00 00 00       	mov    $0x3,%esi
ffffffff8010aa2c:	89 45 d4             	mov    %eax,-0x2c(%rbp)
ffffffff8010aa2f:	89 4d d0             	mov    %ecx,-0x30(%rbp)
ffffffff8010aa32:	e8 d9 00 00 00       	callq  ffffffff8010ab10 <outb>
ffffffff8010aa37:	b8 fc 03 00 00       	mov    $0x3fc,%eax
ffffffff8010aa3c:	31 c9                	xor    %ecx,%ecx
  outb(COM1+4, 0);
ffffffff8010aa3e:	bf fc 03 00 00       	mov    $0x3fc,%edi
ffffffff8010aa43:	31 f6                	xor    %esi,%esi
ffffffff8010aa45:	89 45 cc             	mov    %eax,-0x34(%rbp)
ffffffff8010aa48:	89 4d c8             	mov    %ecx,-0x38(%rbp)
ffffffff8010aa4b:	e8 c0 00 00 00       	callq  ffffffff8010ab10 <outb>
ffffffff8010aa50:	b8 f9 03 00 00       	mov    $0x3f9,%eax
ffffffff8010aa55:	b9 01 00 00 00       	mov    $0x1,%ecx
  outb(COM1+1, 0x01);    // Enable receive interrupts.
ffffffff8010aa5a:	bf f9 03 00 00       	mov    $0x3f9,%edi
ffffffff8010aa5f:	be 01 00 00 00       	mov    $0x1,%esi
ffffffff8010aa64:	89 45 c4             	mov    %eax,-0x3c(%rbp)
ffffffff8010aa67:	89 4d c0             	mov    %ecx,-0x40(%rbp)
ffffffff8010aa6a:	e8 a1 00 00 00       	callq  ffffffff8010ab10 <outb>
ffffffff8010aa6f:	b8 fd 03 00 00       	mov    $0x3fd,%eax

  // If status is 0xFF, no serial port.
  if(inb(COM1+5) == 0xFF)
ffffffff8010aa74:	bf fd 03 00 00       	mov    $0x3fd,%edi
ffffffff8010aa79:	89 45 bc             	mov    %eax,-0x44(%rbp)
ffffffff8010aa7c:	e8 bf 00 00 00       	callq  ffffffff8010ab40 <inb>
ffffffff8010aa81:	0f b6 c8             	movzbl %al,%ecx
ffffffff8010aa84:	81 f9 ff 00 00 00    	cmp    $0xff,%ecx
ffffffff8010aa8a:	0f 85 05 00 00 00    	jne    ffffffff8010aa95 <uartinit+0xf5>
    return;
ffffffff8010aa90:	e9 6e 00 00 00       	jmpq   ffffffff8010ab03 <uartinit+0x163>
  uart = 1;
ffffffff8010aa95:	c7 04 25 9c 64 1f 83 	movl   $0x1,0xffffffff831f649c
ffffffff8010aa9c:	01 00 00 00 

  // Acknowledge pre-existing interrupt conditions;
  // enable interrupts.
  inb(COM1+2);
ffffffff8010aaa0:	bf fa 03 00 00       	mov    $0x3fa,%edi
ffffffff8010aaa5:	e8 96 00 00 00       	callq  ffffffff8010ab40 <inb>
  inb(COM1+0);
ffffffff8010aaaa:	bf f8 03 00 00       	mov    $0x3f8,%edi
ffffffff8010aaaf:	88 45 bb             	mov    %al,-0x45(%rbp)
ffffffff8010aab2:	e8 89 00 00 00       	callq  ffffffff8010ab40 <inb>
  picenable(IRQ_COM1);
ffffffff8010aab7:	bf 04 00 00 00       	mov    $0x4,%edi
ffffffff8010aabc:	89 7d b4             	mov    %edi,-0x4c(%rbp)
ffffffff8010aabf:	88 45 b3             	mov    %al,-0x4d(%rbp)
ffffffff8010aac2:	e8 d9 c7 ff ff       	callq  ffffffff801072a0 <picenable>
  ioapicenable(IRQ_COM1, 0);
ffffffff8010aac7:	31 f6                	xor    %esi,%esi
ffffffff8010aac9:	8b 7d b4             	mov    -0x4c(%rbp),%edi
ffffffff8010aacc:	e8 cf fb ff ff       	callq  ffffffff8010a6a0 <ioapicenable>

  // Announce that we're here.
  for(p="xk...\n"; *p; p++)
ffffffff8010aad1:	48 c7 45 f8 67 03 11 	movq   $0xffffffff80110367,-0x8(%rbp)
ffffffff8010aad8:	80 
ffffffff8010aad9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
ffffffff8010aadd:	80 38 00             	cmpb   $0x0,(%rax)
ffffffff8010aae0:	0f 84 1d 00 00 00    	je     ffffffff8010ab03 <uartinit+0x163>
    uartputc(*p);
ffffffff8010aae6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
ffffffff8010aaea:	0f be 38             	movsbl (%rax),%edi
ffffffff8010aaed:	e8 7e 00 00 00       	callq  ffffffff8010ab70 <uartputc>
  for(p="xk...\n"; *p; p++)
ffffffff8010aaf2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
ffffffff8010aaf6:	48 83 c0 01          	add    $0x1,%rax
ffffffff8010aafa:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
ffffffff8010aafe:	e9 d6 ff ff ff       	jmpq   ffffffff8010aad9 <uartinit+0x139>
}
ffffffff8010ab03:	48 83 c4 50          	add    $0x50,%rsp
ffffffff8010ab07:	5d                   	pop    %rbp
ffffffff8010ab08:	c3                   	retq   
ffffffff8010ab09:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)

ffffffff8010ab10 <outb>:
{
ffffffff8010ab10:	55                   	push   %rbp
ffffffff8010ab11:	48 89 e5             	mov    %rsp,%rbp
ffffffff8010ab14:	48 83 ec 04          	sub    $0x4,%rsp
ffffffff8010ab18:	40 88 f0             	mov    %sil,%al
ffffffff8010ab1b:	66 89 f9             	mov    %di,%cx
ffffffff8010ab1e:	66 89 4d fe          	mov    %cx,-0x2(%rbp)
ffffffff8010ab22:	88 45 fd             	mov    %al,-0x3(%rbp)
  asm volatile("out %0,%1" : : "a" (data), "d" (port));
ffffffff8010ab25:	8a 45 fd             	mov    -0x3(%rbp),%al
ffffffff8010ab28:	66 8b 55 fe          	mov    -0x2(%rbp),%dx
ffffffff8010ab2c:	ee                   	out    %al,(%dx)
}
ffffffff8010ab2d:	48 83 c4 04          	add    $0x4,%rsp
ffffffff8010ab31:	5d                   	pop    %rbp
ffffffff8010ab32:	c3                   	retq   
ffffffff8010ab33:	66 66 66 66 2e 0f 1f 	data16 data16 data16 nopw %cs:0x0(%rax,%rax,1)
ffffffff8010ab3a:	84 00 00 00 00 00 

ffffffff8010ab40 <inb>:
{
ffffffff8010ab40:	55                   	push   %rbp
ffffffff8010ab41:	48 89 e5             	mov    %rsp,%rbp
ffffffff8010ab44:	48 83 ec 04          	sub    $0x4,%rsp
ffffffff8010ab48:	66 89 f8             	mov    %di,%ax
ffffffff8010ab4b:	66 89 45 fe          	mov    %ax,-0x2(%rbp)
  asm volatile("in %1,%0" : "=a" (data) : "d" (port));
ffffffff8010ab4f:	66 8b 55 fe          	mov    -0x2(%rbp),%dx
ffffffff8010ab53:	ec                   	in     (%dx),%al
ffffffff8010ab54:	88 45 fd             	mov    %al,-0x3(%rbp)
  return data;
ffffffff8010ab57:	0f b6 45 fd          	movzbl -0x3(%rbp),%eax
ffffffff8010ab5b:	48 83 c4 04          	add    $0x4,%rsp
ffffffff8010ab5f:	5d                   	pop    %rbp
ffffffff8010ab60:	c3                   	retq   
ffffffff8010ab61:	66 66 66 66 66 66 2e 	data16 data16 data16 data16 data16 nopw %cs:0x0(%rax,%rax,1)
ffffffff8010ab68:	0f 1f 84 00 00 00 00 
ffffffff8010ab6f:	00 

ffffffff8010ab70 <uartputc>:

void
uartputc(int c)
{
ffffffff8010ab70:	55                   	push   %rbp
ffffffff8010ab71:	48 89 e5             	mov    %rsp,%rbp
ffffffff8010ab74:	48 83 ec 20          	sub    $0x20,%rsp
ffffffff8010ab78:	89 7d fc             	mov    %edi,-0x4(%rbp)
  int i;

  if(!uart)
ffffffff8010ab7b:	8b 3c 25 9c 64 1f 83 	mov    0xffffffff831f649c,%edi
ffffffff8010ab82:	83 ff 00             	cmp    $0x0,%edi
ffffffff8010ab85:	0f 85 05 00 00 00    	jne    ffffffff8010ab90 <uartputc+0x20>
    return;
ffffffff8010ab8b:	e9 88 00 00 00       	jmpq   ffffffff8010ac18 <uartputc+0xa8>
  for(i = 0; i < 128 && !(inb(COM1+5) & 0x20); i++)
ffffffff8010ab90:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%rbp)
ffffffff8010ab97:	31 c0                	xor    %eax,%eax
ffffffff8010ab99:	88 c1                	mov    %al,%cl
ffffffff8010ab9b:	81 7d f8 80 00 00 00 	cmpl   $0x80,-0x8(%rbp)
ffffffff8010aba2:	88 4d f7             	mov    %cl,-0x9(%rbp)
ffffffff8010aba5:	0f 8d 23 00 00 00    	jge    ffffffff8010abce <uartputc+0x5e>
ffffffff8010abab:	b8 fd 03 00 00       	mov    $0x3fd,%eax
ffffffff8010abb0:	bf fd 03 00 00       	mov    $0x3fd,%edi
ffffffff8010abb5:	89 45 f0             	mov    %eax,-0x10(%rbp)
ffffffff8010abb8:	e8 83 ff ff ff       	callq  ffffffff8010ab40 <inb>
ffffffff8010abbd:	0f b6 f8             	movzbl %al,%edi
ffffffff8010abc0:	83 e7 20             	and    $0x20,%edi
ffffffff8010abc3:	83 ff 00             	cmp    $0x0,%edi
ffffffff8010abc6:	0f 95 c0             	setne  %al
ffffffff8010abc9:	34 ff                	xor    $0xff,%al
ffffffff8010abcb:	88 45 f7             	mov    %al,-0x9(%rbp)
ffffffff8010abce:	8a 45 f7             	mov    -0x9(%rbp),%al
ffffffff8010abd1:	a8 01                	test   $0x1,%al
ffffffff8010abd3:	0f 85 05 00 00 00    	jne    ffffffff8010abde <uartputc+0x6e>
ffffffff8010abd9:	e9 20 00 00 00       	jmpq   ffffffff8010abfe <uartputc+0x8e>
ffffffff8010abde:	b8 0a 00 00 00       	mov    $0xa,%eax
    microdelay(10);
ffffffff8010abe3:	bf 0a 00 00 00       	mov    $0xa,%edi
ffffffff8010abe8:	89 45 ec             	mov    %eax,-0x14(%rbp)
ffffffff8010abeb:	e8 00 70 ff ff       	callq  ffffffff80101bf0 <microdelay>
  for(i = 0; i < 128 && !(inb(COM1+5) & 0x20); i++)
ffffffff8010abf0:	8b 45 f8             	mov    -0x8(%rbp),%eax
ffffffff8010abf3:	83 c0 01             	add    $0x1,%eax
ffffffff8010abf6:	89 45 f8             	mov    %eax,-0x8(%rbp)
ffffffff8010abf9:	e9 99 ff ff ff       	jmpq   ffffffff8010ab97 <uartputc+0x27>
ffffffff8010abfe:	b8 f8 03 00 00       	mov    $0x3f8,%eax
  outb(COM1+0, c);
ffffffff8010ac03:	8b 4d fc             	mov    -0x4(%rbp),%ecx
ffffffff8010ac06:	88 ca                	mov    %cl,%dl
ffffffff8010ac08:	0f b6 f2             	movzbl %dl,%esi
ffffffff8010ac0b:	bf f8 03 00 00       	mov    $0x3f8,%edi
ffffffff8010ac10:	89 45 e8             	mov    %eax,-0x18(%rbp)
ffffffff8010ac13:	e8 f8 fe ff ff       	callq  ffffffff8010ab10 <outb>
}
ffffffff8010ac18:	48 83 c4 20          	add    $0x20,%rsp
ffffffff8010ac1c:	5d                   	pop    %rbp
ffffffff8010ac1d:	c3                   	retq   
ffffffff8010ac1e:	66 90                	xchg   %ax,%ax

ffffffff8010ac20 <uartintr>:
  return inb(COM1+0);
}

void
uartintr(void)
{
ffffffff8010ac20:	55                   	push   %rbp
ffffffff8010ac21:	48 89 e5             	mov    %rsp,%rbp
  consoleintr(uartgetc);
ffffffff8010ac24:	48 c7 c7 40 ac 10 80 	mov    $0xffffffff8010ac40,%rdi
ffffffff8010ac2b:	e8 a0 65 ff ff       	callq  ffffffff801011d0 <consoleintr>
}
ffffffff8010ac30:	5d                   	pop    %rbp
ffffffff8010ac31:	c3                   	retq   
ffffffff8010ac32:	66 66 66 66 66 2e 0f 	data16 data16 data16 data16 nopw %cs:0x0(%rax,%rax,1)
ffffffff8010ac39:	1f 84 00 00 00 00 00 

ffffffff8010ac40 <uartgetc>:
{
ffffffff8010ac40:	55                   	push   %rbp
ffffffff8010ac41:	48 89 e5             	mov    %rsp,%rbp
  if(!uart)
ffffffff8010ac44:	48 83 ec 10          	sub    $0x10,%rsp
ffffffff8010ac48:	8b 04 25 9c 64 1f 83 	mov    0xffffffff831f649c,%eax
ffffffff8010ac4f:	83 f8 00             	cmp    $0x0,%eax
ffffffff8010ac52:	0f 85 0c 00 00 00    	jne    ffffffff8010ac64 <uartgetc+0x24>
    return -1;
ffffffff8010ac58:	c7 45 fc ff ff ff ff 	movl   $0xffffffff,-0x4(%rbp)
ffffffff8010ac5f:	e9 45 00 00 00       	jmpq   ffffffff8010aca9 <uartgetc+0x69>
ffffffff8010ac64:	b8 fd 03 00 00       	mov    $0x3fd,%eax
  if(!(inb(COM1+5) & 0x01))
ffffffff8010ac69:	bf fd 03 00 00       	mov    $0x3fd,%edi
ffffffff8010ac6e:	89 45 f8             	mov    %eax,-0x8(%rbp)
ffffffff8010ac71:	e8 ca fe ff ff       	callq  ffffffff8010ab40 <inb>
ffffffff8010ac76:	0f b6 f8             	movzbl %al,%edi
ffffffff8010ac79:	83 e7 01             	and    $0x1,%edi
ffffffff8010ac7c:	83 ff 00             	cmp    $0x0,%edi
ffffffff8010ac7f:	0f 85 0c 00 00 00    	jne    ffffffff8010ac91 <uartgetc+0x51>
    return -1;
ffffffff8010ac85:	c7 45 fc ff ff ff ff 	movl   $0xffffffff,-0x4(%rbp)
ffffffff8010ac8c:	e9 18 00 00 00       	jmpq   ffffffff8010aca9 <uartgetc+0x69>
ffffffff8010ac91:	b8 f8 03 00 00       	mov    $0x3f8,%eax
  return inb(COM1+0);
ffffffff8010ac96:	bf f8 03 00 00       	mov    $0x3f8,%edi
ffffffff8010ac9b:	89 45 f4             	mov    %eax,-0xc(%rbp)
ffffffff8010ac9e:	e8 9d fe ff ff       	callq  ffffffff8010ab40 <inb>
ffffffff8010aca3:	0f b6 f8             	movzbl %al,%edi
ffffffff8010aca6:	89 7d fc             	mov    %edi,-0x4(%rbp)
}
ffffffff8010aca9:	8b 45 fc             	mov    -0x4(%rbp),%eax
ffffffff8010acac:	48 83 c4 10          	add    $0x10,%rsp
ffffffff8010acb0:	5d                   	pop    %rbp
ffffffff8010acb1:	c3                   	retq   
ffffffff8010acb2:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
ffffffff8010acb9:	00 00 00 
ffffffff8010acbc:	0f 1f 40 00          	nopl   0x0(%rax)

ffffffff8010acc0 <kbdgetc>:
#include <defs.h>
#include <kbd.h>

int
kbdgetc(void)
{
ffffffff8010acc0:	55                   	push   %rbp
ffffffff8010acc1:	48 89 e5             	mov    %rsp,%rbp
ffffffff8010acc4:	48 83 ec 20          	sub    $0x20,%rsp
ffffffff8010acc8:	b8 64 00 00 00       	mov    $0x64,%eax
  static uchar *charcode[4] = {
    normalmap, shiftmap, ctlmap, ctlmap
  };
  uint st, data, c;

  st = inb(KBSTATP);
ffffffff8010accd:	bf 64 00 00 00       	mov    $0x64,%edi
ffffffff8010acd2:	89 45 ec             	mov    %eax,-0x14(%rbp)
ffffffff8010acd5:	e8 d6 01 00 00       	callq  ffffffff8010aeb0 <inb>
ffffffff8010acda:	0f b6 f8             	movzbl %al,%edi
ffffffff8010acdd:	89 7d f8             	mov    %edi,-0x8(%rbp)
  if((st & KBS_DIB) == 0)
ffffffff8010ace0:	8b 7d f8             	mov    -0x8(%rbp),%edi
ffffffff8010ace3:	83 e7 01             	and    $0x1,%edi
ffffffff8010ace6:	83 ff 00             	cmp    $0x0,%edi
ffffffff8010ace9:	0f 85 0c 00 00 00    	jne    ffffffff8010acfb <kbdgetc+0x3b>
    return -1;
ffffffff8010acef:	c7 45 fc ff ff ff ff 	movl   $0xffffffff,-0x4(%rbp)
ffffffff8010acf6:	e9 a7 01 00 00       	jmpq   ffffffff8010aea2 <kbdgetc+0x1e2>
ffffffff8010acfb:	b8 60 00 00 00       	mov    $0x60,%eax
  data = inb(KBDATAP);
ffffffff8010ad00:	bf 60 00 00 00       	mov    $0x60,%edi
ffffffff8010ad05:	89 45 e8             	mov    %eax,-0x18(%rbp)
ffffffff8010ad08:	e8 a3 01 00 00       	callq  ffffffff8010aeb0 <inb>
ffffffff8010ad0d:	0f b6 f8             	movzbl %al,%edi
ffffffff8010ad10:	89 7d f4             	mov    %edi,-0xc(%rbp)

  if(data == 0xE0){
ffffffff8010ad13:	81 7d f4 e0 00 00 00 	cmpl   $0xe0,-0xc(%rbp)
ffffffff8010ad1a:	0f 85 1c 00 00 00    	jne    ffffffff8010ad3c <kbdgetc+0x7c>
    shift |= E0ESC;
ffffffff8010ad20:	8a 04 25 a0 64 1f 83 	mov    0xffffffff831f64a0,%al
ffffffff8010ad27:	0c 40                	or     $0x40,%al
ffffffff8010ad29:	88 04 25 a0 64 1f 83 	mov    %al,0xffffffff831f64a0
    return 0;
ffffffff8010ad30:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
ffffffff8010ad37:	e9 66 01 00 00       	jmpq   ffffffff8010aea2 <kbdgetc+0x1e2>
  } else if(data & 0x80){
ffffffff8010ad3c:	8b 45 f4             	mov    -0xc(%rbp),%eax
ffffffff8010ad3f:	25 80 00 00 00       	and    $0x80,%eax
ffffffff8010ad44:	83 f8 00             	cmp    $0x0,%eax
ffffffff8010ad47:	0f 84 5a 00 00 00    	je     ffffffff8010ada7 <kbdgetc+0xe7>
    // Key released
    data = (shift & E0ESC ? data : data & 0x7F);
ffffffff8010ad4d:	8b 04 25 a0 64 1f 83 	mov    0xffffffff831f64a0,%eax
ffffffff8010ad54:	83 e0 40             	and    $0x40,%eax
ffffffff8010ad57:	83 f8 00             	cmp    $0x0,%eax
ffffffff8010ad5a:	0f 84 0b 00 00 00    	je     ffffffff8010ad6b <kbdgetc+0xab>
ffffffff8010ad60:	8b 45 f4             	mov    -0xc(%rbp),%eax
ffffffff8010ad63:	89 45 e4             	mov    %eax,-0x1c(%rbp)
ffffffff8010ad66:	e9 09 00 00 00       	jmpq   ffffffff8010ad74 <kbdgetc+0xb4>
ffffffff8010ad6b:	8b 45 f4             	mov    -0xc(%rbp),%eax
ffffffff8010ad6e:	83 e0 7f             	and    $0x7f,%eax
ffffffff8010ad71:	89 45 e4             	mov    %eax,-0x1c(%rbp)
ffffffff8010ad74:	8b 45 e4             	mov    -0x1c(%rbp),%eax
ffffffff8010ad77:	89 45 f4             	mov    %eax,-0xc(%rbp)
    shift &= ~(shiftcode[data] | E0ESC);
ffffffff8010ad7a:	8b 45 f4             	mov    -0xc(%rbp),%eax
ffffffff8010ad7d:	89 c1                	mov    %eax,%ecx
ffffffff8010ad7f:	0f b6 81 a0 1c 12 80 	movzbl -0x7fede360(%rcx),%eax
ffffffff8010ad86:	f7 d0                	not    %eax
ffffffff8010ad88:	8b 14 25 a0 64 1f 83 	mov    0xffffffff831f64a0,%edx
ffffffff8010ad8f:	21 c2                	and    %eax,%edx
ffffffff8010ad91:	83 e2 bf             	and    $0xffffffbf,%edx
ffffffff8010ad94:	89 14 25 a0 64 1f 83 	mov    %edx,0xffffffff831f64a0
    return 0;
ffffffff8010ad9b:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
ffffffff8010ada2:	e9 fb 00 00 00       	jmpq   ffffffff8010aea2 <kbdgetc+0x1e2>
  } else if(shift & E0ESC){
ffffffff8010ada7:	8b 04 25 a0 64 1f 83 	mov    0xffffffff831f64a0,%eax
ffffffff8010adae:	83 e0 40             	and    $0x40,%eax
ffffffff8010adb1:	83 f8 00             	cmp    $0x0,%eax
ffffffff8010adb4:	0f 84 18 00 00 00    	je     ffffffff8010add2 <kbdgetc+0x112>
    // Last character was an E0 escape; or with 0x80
    data |= 0x80;
ffffffff8010adba:	8a 45 f4             	mov    -0xc(%rbp),%al
ffffffff8010adbd:	0c 80                	or     $0x80,%al
ffffffff8010adbf:	88 45 f4             	mov    %al,-0xc(%rbp)
    shift &= ~E0ESC;
ffffffff8010adc2:	8a 04 25 a0 64 1f 83 	mov    0xffffffff831f64a0,%al
ffffffff8010adc9:	24 bf                	and    $0xbf,%al
ffffffff8010adcb:	88 04 25 a0 64 1f 83 	mov    %al,0xffffffff831f64a0
ffffffff8010add2:	e9 00 00 00 00       	jmpq   ffffffff8010add7 <kbdgetc+0x117>
ffffffff8010add7:	e9 00 00 00 00       	jmpq   ffffffff8010addc <kbdgetc+0x11c>
  }

  shift |= shiftcode[data];
ffffffff8010addc:	8b 45 f4             	mov    -0xc(%rbp),%eax
ffffffff8010addf:	89 c1                	mov    %eax,%ecx
ffffffff8010ade1:	0f b6 81 a0 1c 12 80 	movzbl -0x7fede360(%rcx),%eax
ffffffff8010ade8:	8b 14 25 a0 64 1f 83 	mov    0xffffffff831f64a0,%edx
ffffffff8010adef:	09 c2                	or     %eax,%edx
ffffffff8010adf1:	89 14 25 a0 64 1f 83 	mov    %edx,0xffffffff831f64a0
  shift ^= togglecode[data];
ffffffff8010adf8:	8b 45 f4             	mov    -0xc(%rbp),%eax
ffffffff8010adfb:	89 c1                	mov    %eax,%ecx
ffffffff8010adfd:	0f b6 81 a0 1d 12 80 	movzbl -0x7fede260(%rcx),%eax
ffffffff8010ae04:	8b 14 25 a0 64 1f 83 	mov    0xffffffff831f64a0,%edx
ffffffff8010ae0b:	31 c2                	xor    %eax,%edx
ffffffff8010ae0d:	89 14 25 a0 64 1f 83 	mov    %edx,0xffffffff831f64a0
  c = charcode[shift & (CTL | SHIFT)][data];
ffffffff8010ae14:	8b 04 25 a0 64 1f 83 	mov    0xffffffff831f64a0,%eax
ffffffff8010ae1b:	89 c1                	mov    %eax,%ecx
ffffffff8010ae1d:	89 c8                	mov    %ecx,%eax
ffffffff8010ae1f:	83 e0 03             	and    $0x3,%eax
ffffffff8010ae22:	89 c1                	mov    %eax,%ecx
ffffffff8010ae24:	48 8b 0c cd 80 19 12 	mov    -0x7fede680(,%rcx,8),%rcx
ffffffff8010ae2b:	80 
ffffffff8010ae2c:	8b 45 f4             	mov    -0xc(%rbp),%eax
ffffffff8010ae2f:	89 c6                	mov    %eax,%esi
ffffffff8010ae31:	0f b6 04 31          	movzbl (%rcx,%rsi,1),%eax
ffffffff8010ae35:	89 45 f0             	mov    %eax,-0x10(%rbp)
  if(shift & CAPSLOCK){
ffffffff8010ae38:	8b 04 25 a0 64 1f 83 	mov    0xffffffff831f64a0,%eax
ffffffff8010ae3f:	83 e0 08             	and    $0x8,%eax
ffffffff8010ae42:	83 f8 00             	cmp    $0x0,%eax
ffffffff8010ae45:	0f 84 51 00 00 00    	je     ffffffff8010ae9c <kbdgetc+0x1dc>
ffffffff8010ae4b:	b8 61 00 00 00       	mov    $0x61,%eax
    if('a' <= c && c <= 'z')
ffffffff8010ae50:	3b 45 f0             	cmp    -0x10(%rbp),%eax
ffffffff8010ae53:	0f 87 18 00 00 00    	ja     ffffffff8010ae71 <kbdgetc+0x1b1>
ffffffff8010ae59:	83 7d f0 7a          	cmpl   $0x7a,-0x10(%rbp)
ffffffff8010ae5d:	0f 87 0e 00 00 00    	ja     ffffffff8010ae71 <kbdgetc+0x1b1>
      c += 'A' - 'a';
ffffffff8010ae63:	8b 45 f0             	mov    -0x10(%rbp),%eax
ffffffff8010ae66:	83 c0 e0             	add    $0xffffffe0,%eax
ffffffff8010ae69:	89 45 f0             	mov    %eax,-0x10(%rbp)
ffffffff8010ae6c:	e9 26 00 00 00       	jmpq   ffffffff8010ae97 <kbdgetc+0x1d7>
ffffffff8010ae71:	b8 41 00 00 00       	mov    $0x41,%eax
    else if('A' <= c && c <= 'Z')
ffffffff8010ae76:	3b 45 f0             	cmp    -0x10(%rbp),%eax
ffffffff8010ae79:	0f 87 13 00 00 00    	ja     ffffffff8010ae92 <kbdgetc+0x1d2>
ffffffff8010ae7f:	83 7d f0 5a          	cmpl   $0x5a,-0x10(%rbp)
ffffffff8010ae83:	0f 87 09 00 00 00    	ja     ffffffff8010ae92 <kbdgetc+0x1d2>
      c += 'a' - 'A';
ffffffff8010ae89:	8b 45 f0             	mov    -0x10(%rbp),%eax
ffffffff8010ae8c:	83 c0 20             	add    $0x20,%eax
ffffffff8010ae8f:	89 45 f0             	mov    %eax,-0x10(%rbp)
ffffffff8010ae92:	e9 00 00 00 00       	jmpq   ffffffff8010ae97 <kbdgetc+0x1d7>
  }
ffffffff8010ae97:	e9 00 00 00 00       	jmpq   ffffffff8010ae9c <kbdgetc+0x1dc>
  return c;
ffffffff8010ae9c:	8b 45 f0             	mov    -0x10(%rbp),%eax
ffffffff8010ae9f:	89 45 fc             	mov    %eax,-0x4(%rbp)
}
ffffffff8010aea2:	8b 45 fc             	mov    -0x4(%rbp),%eax
ffffffff8010aea5:	48 83 c4 20          	add    $0x20,%rsp
ffffffff8010aea9:	5d                   	pop    %rbp
ffffffff8010aeaa:	c3                   	retq   
ffffffff8010aeab:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

ffffffff8010aeb0 <inb>:
{
ffffffff8010aeb0:	55                   	push   %rbp
ffffffff8010aeb1:	48 89 e5             	mov    %rsp,%rbp
ffffffff8010aeb4:	48 83 ec 04          	sub    $0x4,%rsp
ffffffff8010aeb8:	66 89 f8             	mov    %di,%ax
ffffffff8010aebb:	66 89 45 fe          	mov    %ax,-0x2(%rbp)
  asm volatile("in %1,%0" : "=a" (data) : "d" (port));
ffffffff8010aebf:	66 8b 55 fe          	mov    -0x2(%rbp),%dx
ffffffff8010aec3:	ec                   	in     (%dx),%al
ffffffff8010aec4:	88 45 fd             	mov    %al,-0x3(%rbp)
  return data;
ffffffff8010aec7:	0f b6 45 fd          	movzbl -0x3(%rbp),%eax
ffffffff8010aecb:	48 83 c4 04          	add    $0x4,%rsp
ffffffff8010aecf:	5d                   	pop    %rbp
ffffffff8010aed0:	c3                   	retq   
ffffffff8010aed1:	66 66 66 66 66 66 2e 	data16 data16 data16 data16 data16 nopw %cs:0x0(%rax,%rax,1)
ffffffff8010aed8:	0f 1f 84 00 00 00 00 
ffffffff8010aedf:	00 

ffffffff8010aee0 <kbdintr>:

void
kbdintr(void)
{
ffffffff8010aee0:	55                   	push   %rbp
ffffffff8010aee1:	48 89 e5             	mov    %rsp,%rbp
  consoleintr(kbdgetc);
ffffffff8010aee4:	48 c7 c7 c0 ac 10 80 	mov    $0xffffffff8010acc0,%rdi
ffffffff8010aeeb:	e8 e0 62 ff ff       	callq  ffffffff801011d0 <consoleintr>
ffffffff8010aef0:	5d                   	pop    %rbp
ffffffff8010aef1:	c3                   	retq   
ffffffff8010aef2:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
ffffffff8010aef9:	00 00 00 
ffffffff8010aefc:	0f 1f 40 00          	nopl   0x0(%rax)

ffffffff8010af00 <memset>:
#include <cdefs.h>
#include <x86_64.h>

void*
memset(void *dst, int c, uint n)
{
ffffffff8010af00:	55                   	push   %rbp
ffffffff8010af01:	48 89 e5             	mov    %rsp,%rbp
ffffffff8010af04:	48 83 ec 10          	sub    $0x10,%rsp
ffffffff8010af08:	b8 04 00 00 00       	mov    $0x4,%eax
ffffffff8010af0d:	89 c1                	mov    %eax,%ecx
ffffffff8010af0f:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
ffffffff8010af13:	89 75 f4             	mov    %esi,-0xc(%rbp)
ffffffff8010af16:	89 55 f0             	mov    %edx,-0x10(%rbp)
  if ((int64_t)dst%4 == 0 && n%4 == 0){
ffffffff8010af19:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
ffffffff8010af1d:	48 99                	cqto   
ffffffff8010af1f:	48 f7 f9             	idiv   %rcx
ffffffff8010af22:	48 83 fa 00          	cmp    $0x0,%rdx
ffffffff8010af26:	0f 85 4b 00 00 00    	jne    ffffffff8010af77 <memset+0x77>
ffffffff8010af2c:	8b 45 f0             	mov    -0x10(%rbp),%eax
ffffffff8010af2f:	83 e0 03             	and    $0x3,%eax
ffffffff8010af32:	83 f8 00             	cmp    $0x0,%eax
ffffffff8010af35:	0f 85 3c 00 00 00    	jne    ffffffff8010af77 <memset+0x77>
    c &= 0xFF;
ffffffff8010af3b:	8b 45 f4             	mov    -0xc(%rbp),%eax
ffffffff8010af3e:	25 ff 00 00 00       	and    $0xff,%eax
ffffffff8010af43:	89 45 f4             	mov    %eax,-0xc(%rbp)
    stosl(dst, (c<<24)|(c<<16)|(c<<8)|c, n/4);
ffffffff8010af46:	48 8b 7d f8          	mov    -0x8(%rbp),%rdi
ffffffff8010af4a:	8b 45 f4             	mov    -0xc(%rbp),%eax
ffffffff8010af4d:	c1 e0 18             	shl    $0x18,%eax
ffffffff8010af50:	8b 4d f4             	mov    -0xc(%rbp),%ecx
ffffffff8010af53:	c1 e1 10             	shl    $0x10,%ecx
ffffffff8010af56:	09 c8                	or     %ecx,%eax
ffffffff8010af58:	8b 4d f4             	mov    -0xc(%rbp),%ecx
ffffffff8010af5b:	c1 e1 08             	shl    $0x8,%ecx
ffffffff8010af5e:	09 c8                	or     %ecx,%eax
ffffffff8010af60:	0b 45 f4             	or     -0xc(%rbp),%eax
ffffffff8010af63:	8b 4d f0             	mov    -0x10(%rbp),%ecx
ffffffff8010af66:	c1 e9 02             	shr    $0x2,%ecx
ffffffff8010af69:	89 c6                	mov    %eax,%esi
ffffffff8010af6b:	89 ca                	mov    %ecx,%edx
ffffffff8010af6d:	e8 1e 00 00 00       	callq  ffffffff8010af90 <stosl>
  } else
ffffffff8010af72:	e9 0f 00 00 00       	jmpq   ffffffff8010af86 <memset+0x86>
    stosb(dst, c, n);
ffffffff8010af77:	48 8b 7d f8          	mov    -0x8(%rbp),%rdi
ffffffff8010af7b:	8b 75 f4             	mov    -0xc(%rbp),%esi
ffffffff8010af7e:	8b 55 f0             	mov    -0x10(%rbp),%edx
ffffffff8010af81:	e8 3a 00 00 00       	callq  ffffffff8010afc0 <stosb>
  return dst;
ffffffff8010af86:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
ffffffff8010af8a:	48 83 c4 10          	add    $0x10,%rsp
ffffffff8010af8e:	5d                   	pop    %rbp
ffffffff8010af8f:	c3                   	retq   

ffffffff8010af90 <stosl>:
{
ffffffff8010af90:	55                   	push   %rbp
ffffffff8010af91:	48 89 e5             	mov    %rsp,%rbp
ffffffff8010af94:	48 83 ec 10          	sub    $0x10,%rsp
ffffffff8010af98:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
ffffffff8010af9c:	89 75 f4             	mov    %esi,-0xc(%rbp)
ffffffff8010af9f:	89 55 f0             	mov    %edx,-0x10(%rbp)
               "0" (addr), "1" (cnt), "a" (data) :
ffffffff8010afa2:	48 8b 7d f8          	mov    -0x8(%rbp),%rdi
ffffffff8010afa6:	8b 55 f0             	mov    -0x10(%rbp),%edx
ffffffff8010afa9:	8b 45 f4             	mov    -0xc(%rbp),%eax
  asm volatile("cld; rep stosl" :
ffffffff8010afac:	89 d1                	mov    %edx,%ecx
ffffffff8010afae:	fc                   	cld    
ffffffff8010afaf:	f3 ab                	rep stos %eax,%es:(%rdi)
ffffffff8010afb1:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
ffffffff8010afb5:	89 4d f0             	mov    %ecx,-0x10(%rbp)
}
ffffffff8010afb8:	48 83 c4 10          	add    $0x10,%rsp
ffffffff8010afbc:	5d                   	pop    %rbp
ffffffff8010afbd:	c3                   	retq   
ffffffff8010afbe:	66 90                	xchg   %ax,%ax

ffffffff8010afc0 <stosb>:
{
ffffffff8010afc0:	55                   	push   %rbp
ffffffff8010afc1:	48 89 e5             	mov    %rsp,%rbp
ffffffff8010afc4:	48 83 ec 10          	sub    $0x10,%rsp
ffffffff8010afc8:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
ffffffff8010afcc:	89 75 f4             	mov    %esi,-0xc(%rbp)
ffffffff8010afcf:	89 55 f0             	mov    %edx,-0x10(%rbp)
               "0" (addr), "1" (cnt), "a" (data) :
ffffffff8010afd2:	48 8b 7d f8          	mov    -0x8(%rbp),%rdi
ffffffff8010afd6:	8b 55 f0             	mov    -0x10(%rbp),%edx
ffffffff8010afd9:	8b 45 f4             	mov    -0xc(%rbp),%eax
  asm volatile("cld; rep stosb" :
ffffffff8010afdc:	89 d1                	mov    %edx,%ecx
ffffffff8010afde:	fc                   	cld    
ffffffff8010afdf:	f3 aa                	rep stos %al,%es:(%rdi)
ffffffff8010afe1:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
ffffffff8010afe5:	89 4d f0             	mov    %ecx,-0x10(%rbp)
}
ffffffff8010afe8:	48 83 c4 10          	add    $0x10,%rsp
ffffffff8010afec:	5d                   	pop    %rbp
ffffffff8010afed:	c3                   	retq   
ffffffff8010afee:	66 90                	xchg   %ax,%ax

ffffffff8010aff0 <memcmp>:
}

int
memcmp(const void *v1, const void *v2, uint n)
{
ffffffff8010aff0:	55                   	push   %rbp
ffffffff8010aff1:	48 89 e5             	mov    %rsp,%rbp
ffffffff8010aff4:	48 83 ec 30          	sub    $0x30,%rsp
ffffffff8010aff8:	48 89 7d f0          	mov    %rdi,-0x10(%rbp)
ffffffff8010affc:	48 89 75 e8          	mov    %rsi,-0x18(%rbp)
ffffffff8010b000:	89 55 e4             	mov    %edx,-0x1c(%rbp)
  const uchar *s1, *s2;

  s1 = v1;
ffffffff8010b003:	48 8b 75 f0          	mov    -0x10(%rbp),%rsi
ffffffff8010b007:	48 89 75 d8          	mov    %rsi,-0x28(%rbp)
  s2 = v2;
ffffffff8010b00b:	48 8b 75 e8          	mov    -0x18(%rbp),%rsi
ffffffff8010b00f:	48 89 75 d0          	mov    %rsi,-0x30(%rbp)
  while(n-- > 0){
ffffffff8010b013:	8b 45 e4             	mov    -0x1c(%rbp),%eax
ffffffff8010b016:	89 c1                	mov    %eax,%ecx
ffffffff8010b018:	83 c1 ff             	add    $0xffffffff,%ecx
ffffffff8010b01b:	89 4d e4             	mov    %ecx,-0x1c(%rbp)
ffffffff8010b01e:	83 f8 00             	cmp    $0x0,%eax
ffffffff8010b021:	0f 86 4b 00 00 00    	jbe    ffffffff8010b072 <memcmp+0x82>
    if(*s1 != *s2)
ffffffff8010b027:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
ffffffff8010b02b:	0f b6 08             	movzbl (%rax),%ecx
ffffffff8010b02e:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
ffffffff8010b032:	0f b6 10             	movzbl (%rax),%edx
ffffffff8010b035:	39 d1                	cmp    %edx,%ecx
ffffffff8010b037:	0f 84 18 00 00 00    	je     ffffffff8010b055 <memcmp+0x65>
      return *s1 - *s2;
ffffffff8010b03d:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
ffffffff8010b041:	0f b6 08             	movzbl (%rax),%ecx
ffffffff8010b044:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
ffffffff8010b048:	0f b6 10             	movzbl (%rax),%edx
ffffffff8010b04b:	29 d1                	sub    %edx,%ecx
ffffffff8010b04d:	89 4d fc             	mov    %ecx,-0x4(%rbp)
ffffffff8010b050:	e9 24 00 00 00       	jmpq   ffffffff8010b079 <memcmp+0x89>
    s1++, s2++;
ffffffff8010b055:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
ffffffff8010b059:	48 83 c0 01          	add    $0x1,%rax
ffffffff8010b05d:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
ffffffff8010b061:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
ffffffff8010b065:	48 83 c0 01          	add    $0x1,%rax
ffffffff8010b069:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
  while(n-- > 0){
ffffffff8010b06d:	e9 a1 ff ff ff       	jmpq   ffffffff8010b013 <memcmp+0x23>
  }

  return 0;
ffffffff8010b072:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
}
ffffffff8010b079:	8b 45 fc             	mov    -0x4(%rbp),%eax
ffffffff8010b07c:	48 83 c4 30          	add    $0x30,%rsp
ffffffff8010b080:	5d                   	pop    %rbp
ffffffff8010b081:	c3                   	retq   
ffffffff8010b082:	66 66 66 66 66 2e 0f 	data16 data16 data16 data16 nopw %cs:0x0(%rax,%rax,1)
ffffffff8010b089:	1f 84 00 00 00 00 00 

ffffffff8010b090 <memmove>:

void*
memmove(void *dst, const void *src, uint n)
{
ffffffff8010b090:	55                   	push   %rbp
ffffffff8010b091:	48 89 e5             	mov    %rsp,%rbp
ffffffff8010b094:	48 83 ec 28          	sub    $0x28,%rsp
ffffffff8010b098:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
ffffffff8010b09c:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
ffffffff8010b0a0:	89 55 ec             	mov    %edx,-0x14(%rbp)
  const char *s;
  char *d;

  s = src;
ffffffff8010b0a3:	48 8b 75 f0          	mov    -0x10(%rbp),%rsi
ffffffff8010b0a7:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
  d = dst;
ffffffff8010b0ab:	48 8b 75 f8          	mov    -0x8(%rbp),%rsi
ffffffff8010b0af:	48 89 75 d8          	mov    %rsi,-0x28(%rbp)
  if(s < d && s + n > d){
ffffffff8010b0b3:	48 8b 75 e0          	mov    -0x20(%rbp),%rsi
ffffffff8010b0b7:	48 3b 75 d8          	cmp    -0x28(%rbp),%rsi
ffffffff8010b0bb:	0f 83 7c 00 00 00    	jae    ffffffff8010b13d <memmove+0xad>
ffffffff8010b0c1:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
ffffffff8010b0c5:	8b 4d ec             	mov    -0x14(%rbp),%ecx
ffffffff8010b0c8:	89 ca                	mov    %ecx,%edx
ffffffff8010b0ca:	48 01 d0             	add    %rdx,%rax
ffffffff8010b0cd:	48 3b 45 d8          	cmp    -0x28(%rbp),%rax
ffffffff8010b0d1:	0f 86 66 00 00 00    	jbe    ffffffff8010b13d <memmove+0xad>
    s += n;
ffffffff8010b0d7:	8b 45 ec             	mov    -0x14(%rbp),%eax
ffffffff8010b0da:	48 8b 4d e0          	mov    -0x20(%rbp),%rcx
ffffffff8010b0de:	89 c0                	mov    %eax,%eax
ffffffff8010b0e0:	89 c2                	mov    %eax,%edx
ffffffff8010b0e2:	48 01 d1             	add    %rdx,%rcx
ffffffff8010b0e5:	48 89 4d e0          	mov    %rcx,-0x20(%rbp)
    d += n;
ffffffff8010b0e9:	8b 45 ec             	mov    -0x14(%rbp),%eax
ffffffff8010b0ec:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
ffffffff8010b0f0:	89 c0                	mov    %eax,%eax
ffffffff8010b0f2:	89 c2                	mov    %eax,%edx
ffffffff8010b0f4:	48 01 d1             	add    %rdx,%rcx
ffffffff8010b0f7:	48 89 4d d8          	mov    %rcx,-0x28(%rbp)
    while(n-- > 0)
ffffffff8010b0fb:	8b 45 ec             	mov    -0x14(%rbp),%eax
ffffffff8010b0fe:	89 c1                	mov    %eax,%ecx
ffffffff8010b100:	83 c1 ff             	add    $0xffffffff,%ecx
ffffffff8010b103:	89 4d ec             	mov    %ecx,-0x14(%rbp)
ffffffff8010b106:	83 f8 00             	cmp    $0x0,%eax
ffffffff8010b109:	0f 86 29 00 00 00    	jbe    ffffffff8010b138 <memmove+0xa8>
      *--d = *--s;
ffffffff8010b10f:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
ffffffff8010b113:	48 89 c1             	mov    %rax,%rcx
ffffffff8010b116:	48 83 c1 ff          	add    $0xffffffffffffffff,%rcx
ffffffff8010b11a:	48 89 4d e0          	mov    %rcx,-0x20(%rbp)
ffffffff8010b11e:	8a 50 ff             	mov    -0x1(%rax),%dl
ffffffff8010b121:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
ffffffff8010b125:	48 89 c1             	mov    %rax,%rcx
ffffffff8010b128:	48 83 c1 ff          	add    $0xffffffffffffffff,%rcx
ffffffff8010b12c:	48 89 4d d8          	mov    %rcx,-0x28(%rbp)
ffffffff8010b130:	88 50 ff             	mov    %dl,-0x1(%rax)
    while(n-- > 0)
ffffffff8010b133:	e9 c3 ff ff ff       	jmpq   ffffffff8010b0fb <memmove+0x6b>
  } else
ffffffff8010b138:	e9 45 00 00 00       	jmpq   ffffffff8010b182 <memmove+0xf2>
    while(n-- > 0)
ffffffff8010b13d:	e9 00 00 00 00       	jmpq   ffffffff8010b142 <memmove+0xb2>
ffffffff8010b142:	8b 45 ec             	mov    -0x14(%rbp),%eax
ffffffff8010b145:	89 c1                	mov    %eax,%ecx
ffffffff8010b147:	83 c1 ff             	add    $0xffffffff,%ecx
ffffffff8010b14a:	89 4d ec             	mov    %ecx,-0x14(%rbp)
ffffffff8010b14d:	83 f8 00             	cmp    $0x0,%eax
ffffffff8010b150:	0f 86 27 00 00 00    	jbe    ffffffff8010b17d <memmove+0xed>
      *d++ = *s++;
ffffffff8010b156:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
ffffffff8010b15a:	48 89 c1             	mov    %rax,%rcx
ffffffff8010b15d:	48 83 c1 01          	add    $0x1,%rcx
ffffffff8010b161:	48 89 4d e0          	mov    %rcx,-0x20(%rbp)
ffffffff8010b165:	8a 10                	mov    (%rax),%dl
ffffffff8010b167:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
ffffffff8010b16b:	48 89 c1             	mov    %rax,%rcx
ffffffff8010b16e:	48 83 c1 01          	add    $0x1,%rcx
ffffffff8010b172:	48 89 4d d8          	mov    %rcx,-0x28(%rbp)
ffffffff8010b176:	88 10                	mov    %dl,(%rax)
    while(n-- > 0)
ffffffff8010b178:	e9 c5 ff ff ff       	jmpq   ffffffff8010b142 <memmove+0xb2>
ffffffff8010b17d:	e9 00 00 00 00       	jmpq   ffffffff8010b182 <memmove+0xf2>

  return dst;
ffffffff8010b182:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
ffffffff8010b186:	48 83 c4 28          	add    $0x28,%rsp
ffffffff8010b18a:	5d                   	pop    %rbp
ffffffff8010b18b:	c3                   	retq   
ffffffff8010b18c:	0f 1f 40 00          	nopl   0x0(%rax)

ffffffff8010b190 <memcpy>:
}

// memcpy exists to placate GCC.  Use memmove.
void*
memcpy(void *dst, const void *src, uint n)
{
ffffffff8010b190:	55                   	push   %rbp
ffffffff8010b191:	48 89 e5             	mov    %rsp,%rbp
ffffffff8010b194:	48 83 ec 20          	sub    $0x20,%rsp
ffffffff8010b198:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
ffffffff8010b19c:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
ffffffff8010b1a0:	89 55 ec             	mov    %edx,-0x14(%rbp)
  return memmove(dst, src, n);
ffffffff8010b1a3:	48 8b 7d f8          	mov    -0x8(%rbp),%rdi
ffffffff8010b1a7:	48 8b 75 f0          	mov    -0x10(%rbp),%rsi
ffffffff8010b1ab:	8b 55 ec             	mov    -0x14(%rbp),%edx
ffffffff8010b1ae:	e8 dd fe ff ff       	callq  ffffffff8010b090 <memmove>
ffffffff8010b1b3:	48 83 c4 20          	add    $0x20,%rsp
ffffffff8010b1b7:	5d                   	pop    %rbp
ffffffff8010b1b8:	c3                   	retq   
ffffffff8010b1b9:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)

ffffffff8010b1c0 <strncmp>:
}

int
strncmp(const char *p, const char *q, uint n)
{
ffffffff8010b1c0:	55                   	push   %rbp
ffffffff8010b1c1:	48 89 e5             	mov    %rsp,%rbp
ffffffff8010b1c4:	48 83 ec 20          	sub    $0x20,%rsp
ffffffff8010b1c8:	48 89 7d f0          	mov    %rdi,-0x10(%rbp)
ffffffff8010b1cc:	48 89 75 e8          	mov    %rsi,-0x18(%rbp)
ffffffff8010b1d0:	89 55 e4             	mov    %edx,-0x1c(%rbp)
ffffffff8010b1d3:	31 c0                	xor    %eax,%eax
ffffffff8010b1d5:	88 c1                	mov    %al,%cl
  while(n > 0 && *p && *p == *q)
ffffffff8010b1d7:	83 7d e4 00          	cmpl   $0x0,-0x1c(%rbp)
ffffffff8010b1db:	88 4d e3             	mov    %cl,-0x1d(%rbp)
ffffffff8010b1de:	0f 86 2f 00 00 00    	jbe    ffffffff8010b213 <strncmp+0x53>
ffffffff8010b1e4:	31 c0                	xor    %eax,%eax
ffffffff8010b1e6:	88 c1                	mov    %al,%cl
ffffffff8010b1e8:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
ffffffff8010b1ec:	0f be 02             	movsbl (%rdx),%eax
ffffffff8010b1ef:	83 f8 00             	cmp    $0x0,%eax
ffffffff8010b1f2:	88 4d e3             	mov    %cl,-0x1d(%rbp)
ffffffff8010b1f5:	0f 84 18 00 00 00    	je     ffffffff8010b213 <strncmp+0x53>
ffffffff8010b1fb:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
ffffffff8010b1ff:	0f be 08             	movsbl (%rax),%ecx
ffffffff8010b202:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
ffffffff8010b206:	0f be 10             	movsbl (%rax),%edx
ffffffff8010b209:	39 d1                	cmp    %edx,%ecx
ffffffff8010b20b:	40 0f 94 c6          	sete   %sil
ffffffff8010b20f:	40 88 75 e3          	mov    %sil,-0x1d(%rbp)
ffffffff8010b213:	8a 45 e3             	mov    -0x1d(%rbp),%al
ffffffff8010b216:	a8 01                	test   $0x1,%al
ffffffff8010b218:	0f 85 05 00 00 00    	jne    ffffffff8010b223 <strncmp+0x63>
ffffffff8010b21e:	e9 26 00 00 00       	jmpq   ffffffff8010b249 <strncmp+0x89>
    n--, p++, q++;
ffffffff8010b223:	8b 45 e4             	mov    -0x1c(%rbp),%eax
ffffffff8010b226:	83 c0 ff             	add    $0xffffffff,%eax
ffffffff8010b229:	89 45 e4             	mov    %eax,-0x1c(%rbp)
ffffffff8010b22c:	48 8b 4d f0          	mov    -0x10(%rbp),%rcx
ffffffff8010b230:	48 83 c1 01          	add    $0x1,%rcx
ffffffff8010b234:	48 89 4d f0          	mov    %rcx,-0x10(%rbp)
ffffffff8010b238:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
ffffffff8010b23c:	48 83 c1 01          	add    $0x1,%rcx
ffffffff8010b240:	48 89 4d e8          	mov    %rcx,-0x18(%rbp)
  while(n > 0 && *p && *p == *q)
ffffffff8010b244:	e9 8a ff ff ff       	jmpq   ffffffff8010b1d3 <strncmp+0x13>
  if(n == 0)
ffffffff8010b249:	83 7d e4 00          	cmpl   $0x0,-0x1c(%rbp)
ffffffff8010b24d:	0f 85 0c 00 00 00    	jne    ffffffff8010b25f <strncmp+0x9f>
    return 0;
ffffffff8010b253:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
ffffffff8010b25a:	e9 13 00 00 00       	jmpq   ffffffff8010b272 <strncmp+0xb2>
  return (uchar)*p - (uchar)*q;
ffffffff8010b25f:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
ffffffff8010b263:	0f b6 08             	movzbl (%rax),%ecx
ffffffff8010b266:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
ffffffff8010b26a:	0f b6 10             	movzbl (%rax),%edx
ffffffff8010b26d:	29 d1                	sub    %edx,%ecx
ffffffff8010b26f:	89 4d fc             	mov    %ecx,-0x4(%rbp)
}
ffffffff8010b272:	8b 45 fc             	mov    -0x4(%rbp),%eax
ffffffff8010b275:	48 83 c4 20          	add    $0x20,%rsp
ffffffff8010b279:	5d                   	pop    %rbp
ffffffff8010b27a:	c3                   	retq   
ffffffff8010b27b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

ffffffff8010b280 <strncpy>:

char*
strncpy(char *s, const char *t, int n)
{
ffffffff8010b280:	55                   	push   %rbp
ffffffff8010b281:	48 89 e5             	mov    %rsp,%rbp
ffffffff8010b284:	48 83 ec 28          	sub    $0x28,%rsp
ffffffff8010b288:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
ffffffff8010b28c:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
ffffffff8010b290:	89 55 ec             	mov    %edx,-0x14(%rbp)
  char *os;

  os = s;
ffffffff8010b293:	48 8b 75 f8          	mov    -0x8(%rbp),%rsi
ffffffff8010b297:	48 89 75 e0          	mov    %rsi,-0x20(%rbp)
ffffffff8010b29b:	31 c0                	xor    %eax,%eax
ffffffff8010b29d:	88 c1                	mov    %al,%cl
  while(n-- > 0 && (*s++ = *t++) != 0)
ffffffff8010b29f:	8b 45 ec             	mov    -0x14(%rbp),%eax
ffffffff8010b2a2:	89 c2                	mov    %eax,%edx
ffffffff8010b2a4:	83 c2 ff             	add    $0xffffffff,%edx
ffffffff8010b2a7:	89 55 ec             	mov    %edx,-0x14(%rbp)
ffffffff8010b2aa:	83 f8 00             	cmp    $0x0,%eax
ffffffff8010b2ad:	88 4d df             	mov    %cl,-0x21(%rbp)
ffffffff8010b2b0:	0f 8e 2e 00 00 00    	jle    ffffffff8010b2e4 <strncpy+0x64>
ffffffff8010b2b6:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
ffffffff8010b2ba:	48 89 c1             	mov    %rax,%rcx
ffffffff8010b2bd:	48 83 c1 01          	add    $0x1,%rcx
ffffffff8010b2c1:	48 89 4d f0          	mov    %rcx,-0x10(%rbp)
ffffffff8010b2c5:	8a 10                	mov    (%rax),%dl
ffffffff8010b2c7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
ffffffff8010b2cb:	48 89 c1             	mov    %rax,%rcx
ffffffff8010b2ce:	48 83 c1 01          	add    $0x1,%rcx
ffffffff8010b2d2:	48 89 4d f8          	mov    %rcx,-0x8(%rbp)
ffffffff8010b2d6:	88 10                	mov    %dl,(%rax)
ffffffff8010b2d8:	0f be f2             	movsbl %dl,%esi
ffffffff8010b2db:	83 fe 00             	cmp    $0x0,%esi
ffffffff8010b2de:	0f 95 c2             	setne  %dl
ffffffff8010b2e1:	88 55 df             	mov    %dl,-0x21(%rbp)
ffffffff8010b2e4:	8a 45 df             	mov    -0x21(%rbp),%al
ffffffff8010b2e7:	a8 01                	test   $0x1,%al
ffffffff8010b2e9:	0f 85 05 00 00 00    	jne    ffffffff8010b2f4 <strncpy+0x74>
ffffffff8010b2ef:	e9 05 00 00 00       	jmpq   ffffffff8010b2f9 <strncpy+0x79>
ffffffff8010b2f4:	e9 a2 ff ff ff       	jmpq   ffffffff8010b29b <strncpy+0x1b>
    ;
  while(n-- > 0)
ffffffff8010b2f9:	e9 00 00 00 00       	jmpq   ffffffff8010b2fe <strncpy+0x7e>
ffffffff8010b2fe:	8b 45 ec             	mov    -0x14(%rbp),%eax
ffffffff8010b301:	89 c1                	mov    %eax,%ecx
ffffffff8010b303:	83 c1 ff             	add    $0xffffffff,%ecx
ffffffff8010b306:	89 4d ec             	mov    %ecx,-0x14(%rbp)
ffffffff8010b309:	83 f8 00             	cmp    $0x0,%eax
ffffffff8010b30c:	0f 8e 17 00 00 00    	jle    ffffffff8010b329 <strncpy+0xa9>
    *s++ = 0;
ffffffff8010b312:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
ffffffff8010b316:	48 89 c1             	mov    %rax,%rcx
ffffffff8010b319:	48 83 c1 01          	add    $0x1,%rcx
ffffffff8010b31d:	48 89 4d f8          	mov    %rcx,-0x8(%rbp)
ffffffff8010b321:	c6 00 00             	movb   $0x0,(%rax)
  while(n-- > 0)
ffffffff8010b324:	e9 d5 ff ff ff       	jmpq   ffffffff8010b2fe <strncpy+0x7e>
  return os;
ffffffff8010b329:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
ffffffff8010b32d:	48 83 c4 28          	add    $0x28,%rsp
ffffffff8010b331:	5d                   	pop    %rbp
ffffffff8010b332:	c3                   	retq   
ffffffff8010b333:	66 66 66 66 2e 0f 1f 	data16 data16 data16 nopw %cs:0x0(%rax,%rax,1)
ffffffff8010b33a:	84 00 00 00 00 00 

ffffffff8010b340 <safestrcpy>:
}

// Like strncpy but guaranteed to NUL-terminate.
char*
safestrcpy(char *s, const char *t, int n)
{
ffffffff8010b340:	55                   	push   %rbp
ffffffff8010b341:	48 89 e5             	mov    %rsp,%rbp
ffffffff8010b344:	48 83 ec 30          	sub    $0x30,%rsp
ffffffff8010b348:	48 89 7d f0          	mov    %rdi,-0x10(%rbp)
ffffffff8010b34c:	48 89 75 e8          	mov    %rsi,-0x18(%rbp)
ffffffff8010b350:	89 55 e4             	mov    %edx,-0x1c(%rbp)
  char *os;

  os = s;
ffffffff8010b353:	48 8b 75 f0          	mov    -0x10(%rbp),%rsi
ffffffff8010b357:	48 89 75 d8          	mov    %rsi,-0x28(%rbp)
  if(n <= 0)
ffffffff8010b35b:	83 7d e4 00          	cmpl   $0x0,-0x1c(%rbp)
ffffffff8010b35f:	0f 8f 0d 00 00 00    	jg     ffffffff8010b372 <safestrcpy+0x32>
    return os;
ffffffff8010b365:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
ffffffff8010b369:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
ffffffff8010b36d:	e9 70 00 00 00       	jmpq   ffffffff8010b3e2 <safestrcpy+0xa2>
  while(--n > 0 && (*s++ = *t++) != 0)
ffffffff8010b372:	e9 00 00 00 00       	jmpq   ffffffff8010b377 <safestrcpy+0x37>
ffffffff8010b377:	31 c0                	xor    %eax,%eax
ffffffff8010b379:	88 c1                	mov    %al,%cl
ffffffff8010b37b:	8b 45 e4             	mov    -0x1c(%rbp),%eax
ffffffff8010b37e:	83 c0 ff             	add    $0xffffffff,%eax
ffffffff8010b381:	89 45 e4             	mov    %eax,-0x1c(%rbp)
ffffffff8010b384:	83 f8 00             	cmp    $0x0,%eax
ffffffff8010b387:	88 4d d7             	mov    %cl,-0x29(%rbp)
ffffffff8010b38a:	0f 8e 2e 00 00 00    	jle    ffffffff8010b3be <safestrcpy+0x7e>
ffffffff8010b390:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
ffffffff8010b394:	48 89 c1             	mov    %rax,%rcx
ffffffff8010b397:	48 83 c1 01          	add    $0x1,%rcx
ffffffff8010b39b:	48 89 4d e8          	mov    %rcx,-0x18(%rbp)
ffffffff8010b39f:	8a 10                	mov    (%rax),%dl
ffffffff8010b3a1:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
ffffffff8010b3a5:	48 89 c1             	mov    %rax,%rcx
ffffffff8010b3a8:	48 83 c1 01          	add    $0x1,%rcx
ffffffff8010b3ac:	48 89 4d f0          	mov    %rcx,-0x10(%rbp)
ffffffff8010b3b0:	88 10                	mov    %dl,(%rax)
ffffffff8010b3b2:	0f be f2             	movsbl %dl,%esi
ffffffff8010b3b5:	83 fe 00             	cmp    $0x0,%esi
ffffffff8010b3b8:	0f 95 c2             	setne  %dl
ffffffff8010b3bb:	88 55 d7             	mov    %dl,-0x29(%rbp)
ffffffff8010b3be:	8a 45 d7             	mov    -0x29(%rbp),%al
ffffffff8010b3c1:	a8 01                	test   $0x1,%al
ffffffff8010b3c3:	0f 85 05 00 00 00    	jne    ffffffff8010b3ce <safestrcpy+0x8e>
ffffffff8010b3c9:	e9 05 00 00 00       	jmpq   ffffffff8010b3d3 <safestrcpy+0x93>
ffffffff8010b3ce:	e9 a4 ff ff ff       	jmpq   ffffffff8010b377 <safestrcpy+0x37>
    ;
  *s = 0;
ffffffff8010b3d3:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
ffffffff8010b3d7:	c6 00 00             	movb   $0x0,(%rax)
  return os;
ffffffff8010b3da:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
ffffffff8010b3de:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
}
ffffffff8010b3e2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
ffffffff8010b3e6:	48 83 c4 30          	add    $0x30,%rsp
ffffffff8010b3ea:	5d                   	pop    %rbp
ffffffff8010b3eb:	c3                   	retq   
ffffffff8010b3ec:	0f 1f 40 00          	nopl   0x0(%rax)

ffffffff8010b3f0 <strlen>:

int
strlen(const char *s)
{
ffffffff8010b3f0:	55                   	push   %rbp
ffffffff8010b3f1:	48 89 e5             	mov    %rsp,%rbp
ffffffff8010b3f4:	48 83 ec 10          	sub    $0x10,%rsp
ffffffff8010b3f8:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  int n;

  for(n = 0; s[n]; n++)
ffffffff8010b3fc:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)
ffffffff8010b403:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
ffffffff8010b407:	48 63 4d f4          	movslq -0xc(%rbp),%rcx
ffffffff8010b40b:	80 3c 08 00          	cmpb   $0x0,(%rax,%rcx,1)
ffffffff8010b40f:	0f 84 13 00 00 00    	je     ffffffff8010b428 <strlen+0x38>
ffffffff8010b415:	e9 00 00 00 00       	jmpq   ffffffff8010b41a <strlen+0x2a>
ffffffff8010b41a:	8b 45 f4             	mov    -0xc(%rbp),%eax
ffffffff8010b41d:	83 c0 01             	add    $0x1,%eax
ffffffff8010b420:	89 45 f4             	mov    %eax,-0xc(%rbp)
ffffffff8010b423:	e9 db ff ff ff       	jmpq   ffffffff8010b403 <strlen+0x13>
    ;
  return n;
ffffffff8010b428:	8b 45 f4             	mov    -0xc(%rbp),%eax
ffffffff8010b42b:	48 83 c4 10          	add    $0x10,%rsp
ffffffff8010b42f:	5d                   	pop    %rbp
ffffffff8010b430:	c3                   	retq   
ffffffff8010b431:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
ffffffff8010b438:	00 00 00 
ffffffff8010b43b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

ffffffff8010b440 <cpuid_print>:
	return feature[bit / 32] & BIT32(bit % 32);
}

void
cpuid_print(void)
{
ffffffff8010b440:	55                   	push   %rbp
ffffffff8010b441:	48 89 e5             	mov    %rsp,%rbp
ffffffff8010b444:	53                   	push   %rbx
ffffffff8010b445:	48 81 ec 18 01 00 00 	sub    $0x118,%rsp
ffffffff8010b44c:	b8 00 00 00 80       	mov    $0x80000000,%eax
ffffffff8010b451:	48 8d 4d f4          	lea    -0xc(%rbp),%rcx
ffffffff8010b455:	31 d2                	xor    %edx,%edx
ffffffff8010b457:	89 d6                	mov    %edx,%esi
ffffffff8010b459:	31 d2                	xor    %edx,%edx
ffffffff8010b45b:	bf 14 00 00 00       	mov    $0x14,%edi
ffffffff8010b460:	41 89 f8             	mov    %edi,%r8d
ffffffff8010b463:	4c 8d 4d a0          	lea    -0x60(%rbp),%r9
	uint32_t eax, brand[12], feature[CPUID_NR_FLAGS] = {0};
ffffffff8010b467:	41 c7 41 10 00 00 00 	movl   $0x0,0x10(%r9)
ffffffff8010b46e:	00 
ffffffff8010b46f:	49 c7 41 08 00 00 00 	movq   $0x0,0x8(%r9)
ffffffff8010b476:	00 
ffffffff8010b477:	49 c7 01 00 00 00 00 	movq   $0x0,(%r9)

	cpuid(0x80000000, &eax, NULL, NULL, NULL);
ffffffff8010b47e:	31 ff                	xor    %edi,%edi
ffffffff8010b480:	41 89 f9             	mov    %edi,%r9d
ffffffff8010b483:	bf 00 00 00 80       	mov    $0x80000000,%edi
ffffffff8010b488:	4c 8d 55 f4          	lea    -0xc(%rbp),%r10
ffffffff8010b48c:	48 89 75 98          	mov    %rsi,-0x68(%rbp)
ffffffff8010b490:	4c 89 d6             	mov    %r10,%rsi
ffffffff8010b493:	89 55 94             	mov    %edx,-0x6c(%rbp)
ffffffff8010b496:	4c 89 ca             	mov    %r9,%rdx
ffffffff8010b499:	48 89 4d 88          	mov    %rcx,-0x78(%rbp)
ffffffff8010b49d:	4c 89 c9             	mov    %r9,%rcx
ffffffff8010b4a0:	4c 89 45 80          	mov    %r8,-0x80(%rbp)
ffffffff8010b4a4:	4d 89 c8             	mov    %r9,%r8
ffffffff8010b4a7:	89 85 7c ff ff ff    	mov    %eax,-0x84(%rbp)
ffffffff8010b4ad:	e8 7e 02 00 00       	callq  ffffffff8010b730 <cpuid>
	if (eax < 0x80000004)
ffffffff8010b4b2:	81 7d f4 04 00 00 80 	cmpl   $0x80000004,-0xc(%rbp)
ffffffff8010b4b9:	0f 83 0c 00 00 00    	jae    ffffffff8010b4cb <cpuid_print+0x8b>
		panic("CPU too old!");
ffffffff8010b4bf:	48 c7 c7 6e 03 11 80 	mov    $0xffffffff8011036e,%rdi
ffffffff8010b4c6:	e8 a5 59 ff ff       	callq  ffffffff80100e70 <panic>
ffffffff8010b4cb:	b8 02 00 00 80       	mov    $0x80000002,%eax
ffffffff8010b4d0:	48 8d 4d c0          	lea    -0x40(%rbp),%rcx

	cpuid(0x80000002, &brand[0], &brand[1], &brand[2], &brand[3]);
ffffffff8010b4d4:	48 89 ca             	mov    %rcx,%rdx
ffffffff8010b4d7:	48 83 c2 04          	add    $0x4,%rdx
ffffffff8010b4db:	48 89 ce             	mov    %rcx,%rsi
ffffffff8010b4de:	48 83 c6 08          	add    $0x8,%rsi
ffffffff8010b4e2:	48 89 cf             	mov    %rcx,%rdi
ffffffff8010b4e5:	48 83 c7 0c          	add    $0xc,%rdi
ffffffff8010b4e9:	41 b8 02 00 00 80    	mov    $0x80000002,%r8d
ffffffff8010b4ef:	48 89 bd 70 ff ff ff 	mov    %rdi,-0x90(%rbp)
ffffffff8010b4f6:	44 89 c7             	mov    %r8d,%edi
ffffffff8010b4f9:	48 89 b5 68 ff ff ff 	mov    %rsi,-0x98(%rbp)
ffffffff8010b500:	48 89 ce             	mov    %rcx,%rsi
ffffffff8010b503:	48 8b 8d 68 ff ff ff 	mov    -0x98(%rbp),%rcx
ffffffff8010b50a:	4c 8b 85 70 ff ff ff 	mov    -0x90(%rbp),%r8
ffffffff8010b511:	89 85 64 ff ff ff    	mov    %eax,-0x9c(%rbp)
ffffffff8010b517:	e8 14 02 00 00       	callq  ffffffff8010b730 <cpuid>
ffffffff8010b51c:	b8 03 00 00 80       	mov    $0x80000003,%eax
ffffffff8010b521:	48 8d 4d c0          	lea    -0x40(%rbp),%rcx
	cpuid(0x80000003, &brand[4], &brand[5], &brand[6], &brand[7]);
ffffffff8010b525:	48 89 ca             	mov    %rcx,%rdx
ffffffff8010b528:	48 83 c2 10          	add    $0x10,%rdx
ffffffff8010b52c:	48 89 ce             	mov    %rcx,%rsi
ffffffff8010b52f:	48 83 c6 14          	add    $0x14,%rsi
ffffffff8010b533:	49 89 c8             	mov    %rcx,%r8
ffffffff8010b536:	49 83 c0 18          	add    $0x18,%r8
ffffffff8010b53a:	48 83 c1 1c          	add    $0x1c,%rcx
ffffffff8010b53e:	bf 03 00 00 80       	mov    $0x80000003,%edi
ffffffff8010b543:	48 89 b5 58 ff ff ff 	mov    %rsi,-0xa8(%rbp)
ffffffff8010b54a:	48 89 d6             	mov    %rdx,%rsi
ffffffff8010b54d:	48 8b 95 58 ff ff ff 	mov    -0xa8(%rbp),%rdx
ffffffff8010b554:	48 89 8d 50 ff ff ff 	mov    %rcx,-0xb0(%rbp)
ffffffff8010b55b:	4c 89 c1             	mov    %r8,%rcx
ffffffff8010b55e:	4c 8b 85 50 ff ff ff 	mov    -0xb0(%rbp),%r8
ffffffff8010b565:	89 85 4c ff ff ff    	mov    %eax,-0xb4(%rbp)
ffffffff8010b56b:	e8 c0 01 00 00       	callq  ffffffff8010b730 <cpuid>
ffffffff8010b570:	b8 04 00 00 80       	mov    $0x80000004,%eax
ffffffff8010b575:	48 8d 4d c0          	lea    -0x40(%rbp),%rcx
	cpuid(0x80000004, &brand[8], &brand[9], &brand[10], &brand[11]);
ffffffff8010b579:	48 89 ca             	mov    %rcx,%rdx
ffffffff8010b57c:	48 83 c2 20          	add    $0x20,%rdx
ffffffff8010b580:	48 89 ce             	mov    %rcx,%rsi
ffffffff8010b583:	48 83 c6 24          	add    $0x24,%rsi
ffffffff8010b587:	49 89 c8             	mov    %rcx,%r8
ffffffff8010b58a:	49 83 c0 28          	add    $0x28,%r8
ffffffff8010b58e:	48 83 c1 2c          	add    $0x2c,%rcx
ffffffff8010b592:	bf 04 00 00 80       	mov    $0x80000004,%edi
ffffffff8010b597:	48 89 b5 40 ff ff ff 	mov    %rsi,-0xc0(%rbp)
ffffffff8010b59e:	48 89 d6             	mov    %rdx,%rsi
ffffffff8010b5a1:	48 8b 95 40 ff ff ff 	mov    -0xc0(%rbp),%rdx
ffffffff8010b5a8:	48 89 8d 38 ff ff ff 	mov    %rcx,-0xc8(%rbp)
ffffffff8010b5af:	4c 89 c1             	mov    %r8,%rcx
ffffffff8010b5b2:	4c 8b 85 38 ff ff ff 	mov    -0xc8(%rbp),%r8
ffffffff8010b5b9:	89 85 34 ff ff ff    	mov    %eax,-0xcc(%rbp)
ffffffff8010b5bf:	e8 6c 01 00 00       	callq  ffffffff8010b730 <cpuid>
ffffffff8010b5c4:	48 8d 75 c0          	lea    -0x40(%rbp),%rsi
	cprintf("CPU: %s\n", brand);
ffffffff8010b5c8:	48 c7 c7 7b 03 11 80 	mov    $0xffffffff8011037b,%rdi
ffffffff8010b5cf:	31 c0                	xor    %eax,%eax
ffffffff8010b5d1:	41 88 c1             	mov    %al,%r9b
ffffffff8010b5d4:	44 88 c8             	mov    %r9b,%al
ffffffff8010b5d7:	e8 84 53 ff ff       	callq  ffffffff80100960 <cprintf>
ffffffff8010b5dc:	41 ba 01 00 00 00    	mov    $0x1,%r10d
ffffffff8010b5e2:	45 31 db             	xor    %r11d,%r11d
ffffffff8010b5e5:	44 89 d9             	mov    %r11d,%ecx
ffffffff8010b5e8:	48 8d 55 a0          	lea    -0x60(%rbp),%rdx

	cpuid(1, NULL, NULL,
	      &feature[CPUID_1_ECX], &feature[CPUID_1_EDX]);
ffffffff8010b5ec:	48 89 d6             	mov    %rdx,%rsi
ffffffff8010b5ef:	48 83 c6 04          	add    $0x4,%rsi
	cpuid(1, NULL, NULL,
ffffffff8010b5f3:	45 31 db             	xor    %r11d,%r11d
ffffffff8010b5f6:	44 89 df             	mov    %r11d,%edi
ffffffff8010b5f9:	41 bb 01 00 00 00    	mov    $0x1,%r11d
ffffffff8010b5ff:	48 89 bd 28 ff ff ff 	mov    %rdi,-0xd8(%rbp)
ffffffff8010b606:	44 89 df             	mov    %r11d,%edi
ffffffff8010b609:	4c 8b 85 28 ff ff ff 	mov    -0xd8(%rbp),%r8
ffffffff8010b610:	48 89 b5 20 ff ff ff 	mov    %rsi,-0xe0(%rbp)
ffffffff8010b617:	4c 89 c6             	mov    %r8,%rsi
ffffffff8010b61a:	48 89 95 18 ff ff ff 	mov    %rdx,-0xe8(%rbp)
ffffffff8010b621:	4c 89 c2             	mov    %r8,%rdx
ffffffff8010b624:	48 8b 9d 20 ff ff ff 	mov    -0xe0(%rbp),%rbx
ffffffff8010b62b:	48 89 8d 10 ff ff ff 	mov    %rcx,-0xf0(%rbp)
ffffffff8010b632:	48 89 d9             	mov    %rbx,%rcx
ffffffff8010b635:	4c 8b 85 18 ff ff ff 	mov    -0xe8(%rbp),%r8
ffffffff8010b63c:	44 89 95 0c ff ff ff 	mov    %r10d,-0xf4(%rbp)
ffffffff8010b643:	e8 e8 00 00 00       	callq  ffffffff8010b730 <cpuid>
ffffffff8010b648:	bf 01 00 00 80       	mov    $0x80000001,%edi
ffffffff8010b64d:	45 31 d2             	xor    %r10d,%r10d
ffffffff8010b650:	44 89 d1             	mov    %r10d,%ecx
ffffffff8010b653:	48 8d 55 a0          	lea    -0x60(%rbp),%rdx
	cpuid(0x80000001, NULL, NULL,
	      &feature[CPUID_80000001_ECX], &feature[CPUID_80000001_EDX]);
ffffffff8010b657:	48 89 d6             	mov    %rdx,%rsi
ffffffff8010b65a:	48 83 c6 10          	add    $0x10,%rsi
ffffffff8010b65e:	48 83 c2 0c          	add    $0xc,%rdx
	cpuid(0x80000001, NULL, NULL,
ffffffff8010b662:	45 31 d2             	xor    %r10d,%r10d
ffffffff8010b665:	45 89 d0             	mov    %r10d,%r8d
ffffffff8010b668:	41 ba 01 00 00 80    	mov    $0x80000001,%r10d
ffffffff8010b66e:	89 bd 08 ff ff ff    	mov    %edi,-0xf8(%rbp)
ffffffff8010b674:	44 89 d7             	mov    %r10d,%edi
ffffffff8010b677:	48 89 b5 00 ff ff ff 	mov    %rsi,-0x100(%rbp)
ffffffff8010b67e:	4c 89 c6             	mov    %r8,%rsi
ffffffff8010b681:	48 89 95 f8 fe ff ff 	mov    %rdx,-0x108(%rbp)
ffffffff8010b688:	4c 89 c2             	mov    %r8,%rdx
ffffffff8010b68b:	4c 8b 85 00 ff ff ff 	mov    -0x100(%rbp),%r8
ffffffff8010b692:	48 89 8d f0 fe ff ff 	mov    %rcx,-0x110(%rbp)
ffffffff8010b699:	4c 89 c1             	mov    %r8,%rcx
ffffffff8010b69c:	4c 8b 85 f8 fe ff ff 	mov    -0x108(%rbp),%r8
ffffffff8010b6a3:	e8 88 00 00 00       	callq  ffffffff8010b730 <cpuid>
ffffffff8010b6a8:	48 8d 7d a0          	lea    -0x60(%rbp),%rdi
	print_feature(feature);
ffffffff8010b6ac:	e8 0f 01 00 00       	callq  ffffffff8010b7c0 <print_feature>
ffffffff8010b6b1:	b8 03 00 00 00       	mov    $0x3,%eax
ffffffff8010b6b6:	48 8d 7d a0          	lea    -0x60(%rbp),%rdi
	// Check feature bits.
	assert(cpuid_has(feature, CPUID_FEATURE_PSE));
ffffffff8010b6ba:	be 03 00 00 00       	mov    $0x3,%esi
ffffffff8010b6bf:	89 85 ec fe ff ff    	mov    %eax,-0x114(%rbp)
ffffffff8010b6c5:	e8 f6 01 00 00       	callq  ffffffff8010b8c0 <cpuid_has>
ffffffff8010b6ca:	a8 01                	test   $0x1,%al
ffffffff8010b6cc:	0f 85 0c 00 00 00    	jne    ffffffff8010b6de <cpuid_print+0x29e>
ffffffff8010b6d2:	48 c7 c7 15 fc 10 80 	mov    $0xffffffff8010fc15,%rdi
ffffffff8010b6d9:	e8 92 57 ff ff       	callq  ffffffff80100e70 <panic>
ffffffff8010b6de:	e9 00 00 00 00       	jmpq   ffffffff8010b6e3 <cpuid_print+0x2a3>
	assert(cpuid_has(feature, CPUID_FEATURE_APIC));
ffffffff8010b6e3:	e9 00 00 00 00       	jmpq   ffffffff8010b6e8 <cpuid_print+0x2a8>
ffffffff8010b6e8:	b8 09 00 00 00       	mov    $0x9,%eax
ffffffff8010b6ed:	48 8d 7d a0          	lea    -0x60(%rbp),%rdi
ffffffff8010b6f1:	be 09 00 00 00       	mov    $0x9,%esi
ffffffff8010b6f6:	89 85 e8 fe ff ff    	mov    %eax,-0x118(%rbp)
ffffffff8010b6fc:	e8 bf 01 00 00       	callq  ffffffff8010b8c0 <cpuid_has>
ffffffff8010b701:	a8 01                	test   $0x1,%al
ffffffff8010b703:	0f 85 0c 00 00 00    	jne    ffffffff8010b715 <cpuid_print+0x2d5>
ffffffff8010b709:	48 c7 c7 15 fc 10 80 	mov    $0xffffffff8010fc15,%rdi
ffffffff8010b710:	e8 5b 57 ff ff       	callq  ffffffff80100e70 <panic>
ffffffff8010b715:	e9 00 00 00 00       	jmpq   ffffffff8010b71a <cpuid_print+0x2da>
}
ffffffff8010b71a:	48 81 c4 18 01 00 00 	add    $0x118,%rsp
ffffffff8010b721:	5b                   	pop    %rbx
ffffffff8010b722:	5d                   	pop    %rbp
ffffffff8010b723:	c3                   	retq   
ffffffff8010b724:	66 66 66 2e 0f 1f 84 	data16 data16 nopw %cs:0x0(%rax,%rax,1)
ffffffff8010b72b:	00 00 00 00 00 

ffffffff8010b730 <cpuid>:

static inline void
cpuid(uint32_t info, uint32_t *eaxp, uint32_t *ebxp, uint32_t *ecxp, uint32_t *edxp)
{
ffffffff8010b730:	55                   	push   %rbp
ffffffff8010b731:	48 89 e5             	mov    %rsp,%rbp
ffffffff8010b734:	53                   	push   %rbx
ffffffff8010b735:	48 83 ec 38          	sub    $0x38,%rsp
ffffffff8010b739:	89 7d f4             	mov    %edi,-0xc(%rbp)
ffffffff8010b73c:	48 89 75 e8          	mov    %rsi,-0x18(%rbp)
ffffffff8010b740:	48 89 55 e0          	mov    %rdx,-0x20(%rbp)
ffffffff8010b744:	48 89 4d d8          	mov    %rcx,-0x28(%rbp)
ffffffff8010b748:	4c 89 45 d0          	mov    %r8,-0x30(%rbp)
	uint32_t eax, ebx, ecx, edx;
	asm volatile("cpuid"
		     : "=a" (eax), "=b" (ebx), "=c" (ecx), "=d" (edx)
		     : "a" (info));
ffffffff8010b74c:	8b 45 f4             	mov    -0xc(%rbp),%eax
	asm volatile("cpuid"
ffffffff8010b74f:	0f a2                	cpuid  
ffffffff8010b751:	89 45 cc             	mov    %eax,-0x34(%rbp)
ffffffff8010b754:	89 5d c8             	mov    %ebx,-0x38(%rbp)
ffffffff8010b757:	89 4d c4             	mov    %ecx,-0x3c(%rbp)
ffffffff8010b75a:	89 55 c0             	mov    %edx,-0x40(%rbp)
	if (eaxp)
ffffffff8010b75d:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
ffffffff8010b762:	0f 84 09 00 00 00    	je     ffffffff8010b771 <cpuid+0x41>
		*eaxp = eax;
ffffffff8010b768:	8b 45 cc             	mov    -0x34(%rbp),%eax
ffffffff8010b76b:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
ffffffff8010b76f:	89 01                	mov    %eax,(%rcx)
	if (ebxp)
ffffffff8010b771:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
ffffffff8010b776:	0f 84 09 00 00 00    	je     ffffffff8010b785 <cpuid+0x55>
		*ebxp = ebx;
ffffffff8010b77c:	8b 45 c8             	mov    -0x38(%rbp),%eax
ffffffff8010b77f:	48 8b 4d e0          	mov    -0x20(%rbp),%rcx
ffffffff8010b783:	89 01                	mov    %eax,(%rcx)
	if (ecxp)
ffffffff8010b785:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
ffffffff8010b78a:	0f 84 09 00 00 00    	je     ffffffff8010b799 <cpuid+0x69>
		*ecxp = ecx;
ffffffff8010b790:	8b 45 c4             	mov    -0x3c(%rbp),%eax
ffffffff8010b793:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
ffffffff8010b797:	89 01                	mov    %eax,(%rcx)
	if (edxp)
ffffffff8010b799:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
ffffffff8010b79e:	0f 84 09 00 00 00    	je     ffffffff8010b7ad <cpuid+0x7d>
		*edxp = edx;
ffffffff8010b7a4:	8b 45 c0             	mov    -0x40(%rbp),%eax
ffffffff8010b7a7:	48 8b 4d d0          	mov    -0x30(%rbp),%rcx
ffffffff8010b7ab:	89 01                	mov    %eax,(%rcx)
}
ffffffff8010b7ad:	48 83 c4 38          	add    $0x38,%rsp
ffffffff8010b7b1:	5b                   	pop    %rbx
ffffffff8010b7b2:	5d                   	pop    %rbp
ffffffff8010b7b3:	c3                   	retq   
ffffffff8010b7b4:	66 66 66 2e 0f 1f 84 	data16 data16 nopw %cs:0x0(%rax,%rax,1)
ffffffff8010b7bb:	00 00 00 00 00 

ffffffff8010b7c0 <print_feature>:
{
ffffffff8010b7c0:	55                   	push   %rbp
ffffffff8010b7c1:	48 89 e5             	mov    %rsp,%rbp
ffffffff8010b7c4:	48 83 ec 20          	sub    $0x20,%rsp
ffffffff8010b7c8:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
	for (i = 0; i < CPUID_NR_FLAGS; ++i) {
ffffffff8010b7cc:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%rbp)
ffffffff8010b7d3:	83 7d f4 05          	cmpl   $0x5,-0xc(%rbp)
ffffffff8010b7d7:	0f 8d d3 00 00 00    	jge    ffffffff8010b8b0 <print_feature+0xf0>
		if (!feature[i])
ffffffff8010b7dd:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
ffffffff8010b7e1:	48 63 4d f4          	movslq -0xc(%rbp),%rcx
ffffffff8010b7e5:	83 3c 88 00          	cmpl   $0x0,(%rax,%rcx,4)
ffffffff8010b7e9:	0f 85 05 00 00 00    	jne    ffffffff8010b7f4 <print_feature+0x34>
			continue;
ffffffff8010b7ef:	e9 ae 00 00 00       	jmpq   ffffffff8010b8a2 <print_feature+0xe2>
		cprintf(" ");
ffffffff8010b7f4:	48 c7 c7 b6 01 11 80 	mov    $0xffffffff801101b6,%rdi
ffffffff8010b7fb:	31 c0                	xor    %eax,%eax
ffffffff8010b7fd:	88 c1                	mov    %al,%cl
ffffffff8010b7ff:	88 c8                	mov    %cl,%al
ffffffff8010b801:	e8 5a 51 ff ff       	callq  ffffffff80100960 <cprintf>
		for (j = 0; j < 32; ++j) {
ffffffff8010b806:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%rbp)
ffffffff8010b80d:	83 7d f0 20          	cmpl   $0x20,-0x10(%rbp)
ffffffff8010b811:	0f 8d 79 00 00 00    	jge    ffffffff8010b890 <print_feature+0xd0>
ffffffff8010b817:	b8 01 00 00 00       	mov    $0x1,%eax
			const char *name = names[CPUID_BIT(i, j)];
ffffffff8010b81c:	8b 4d f4             	mov    -0xc(%rbp),%ecx
ffffffff8010b81f:	c1 e1 05             	shl    $0x5,%ecx
ffffffff8010b822:	8b 55 f0             	mov    -0x10(%rbp),%edx
ffffffff8010b825:	01 d1                	add    %edx,%ecx
ffffffff8010b827:	48 63 f1             	movslq %ecx,%rsi
ffffffff8010b82a:	48 8d 34 f5 a0 1e 12 	lea    -0x7fede160(,%rsi,8),%rsi
ffffffff8010b831:	80 
ffffffff8010b832:	48 8b 36             	mov    (%rsi),%rsi
ffffffff8010b835:	48 89 75 e8          	mov    %rsi,-0x18(%rbp)
			if ((feature[i] & BIT32(j)) && name)
ffffffff8010b839:	48 8b 75 f8          	mov    -0x8(%rbp),%rsi
ffffffff8010b83d:	48 63 7d f4          	movslq -0xc(%rbp),%rdi
ffffffff8010b841:	8b 0c be             	mov    (%rsi,%rdi,4),%ecx
ffffffff8010b844:	8b 55 f0             	mov    -0x10(%rbp),%edx
ffffffff8010b847:	89 4d e4             	mov    %ecx,-0x1c(%rbp)
ffffffff8010b84a:	89 d1                	mov    %edx,%ecx
ffffffff8010b84c:	d3 e0                	shl    %cl,%eax
ffffffff8010b84e:	8b 55 e4             	mov    -0x1c(%rbp),%edx
ffffffff8010b851:	21 c2                	and    %eax,%edx
ffffffff8010b853:	83 fa 00             	cmp    $0x0,%edx
ffffffff8010b856:	0f 84 21 00 00 00    	je     ffffffff8010b87d <print_feature+0xbd>
ffffffff8010b85c:	48 83 7d e8 00       	cmpq   $0x0,-0x18(%rbp)
ffffffff8010b861:	0f 84 16 00 00 00    	je     ffffffff8010b87d <print_feature+0xbd>
				cprintf(" %s", name);
ffffffff8010b867:	48 8b 75 e8          	mov    -0x18(%rbp),%rsi
ffffffff8010b86b:	48 c7 c7 c8 01 11 80 	mov    $0xffffffff801101c8,%rdi
ffffffff8010b872:	31 c0                	xor    %eax,%eax
ffffffff8010b874:	88 c1                	mov    %al,%cl
ffffffff8010b876:	88 c8                	mov    %cl,%al
ffffffff8010b878:	e8 e3 50 ff ff       	callq  ffffffff80100960 <cprintf>
		}
ffffffff8010b87d:	e9 00 00 00 00       	jmpq   ffffffff8010b882 <print_feature+0xc2>
		for (j = 0; j < 32; ++j) {
ffffffff8010b882:	8b 45 f0             	mov    -0x10(%rbp),%eax
ffffffff8010b885:	83 c0 01             	add    $0x1,%eax
ffffffff8010b888:	89 45 f0             	mov    %eax,-0x10(%rbp)
ffffffff8010b88b:	e9 7d ff ff ff       	jmpq   ffffffff8010b80d <print_feature+0x4d>
		cprintf("\n");
ffffffff8010b890:	48 c7 c7 2d fb 10 80 	mov    $0xffffffff8010fb2d,%rdi
ffffffff8010b897:	31 c0                	xor    %eax,%eax
ffffffff8010b899:	88 c1                	mov    %al,%cl
ffffffff8010b89b:	88 c8                	mov    %cl,%al
ffffffff8010b89d:	e8 be 50 ff ff       	callq  ffffffff80100960 <cprintf>
	for (i = 0; i < CPUID_NR_FLAGS; ++i) {
ffffffff8010b8a2:	8b 45 f4             	mov    -0xc(%rbp),%eax
ffffffff8010b8a5:	83 c0 01             	add    $0x1,%eax
ffffffff8010b8a8:	89 45 f4             	mov    %eax,-0xc(%rbp)
ffffffff8010b8ab:	e9 23 ff ff ff       	jmpq   ffffffff8010b7d3 <print_feature+0x13>
}
ffffffff8010b8b0:	48 83 c4 20          	add    $0x20,%rsp
ffffffff8010b8b4:	5d                   	pop    %rbp
ffffffff8010b8b5:	c3                   	retq   
ffffffff8010b8b6:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
ffffffff8010b8bd:	00 00 00 

ffffffff8010b8c0 <cpuid_has>:
{
ffffffff8010b8c0:	55                   	push   %rbp
ffffffff8010b8c1:	48 89 e5             	mov    %rsp,%rbp
ffffffff8010b8c4:	48 83 ec 10          	sub    $0x10,%rsp
ffffffff8010b8c8:	b8 01 00 00 00       	mov    $0x1,%eax
ffffffff8010b8cd:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
ffffffff8010b8d1:	89 75 f4             	mov    %esi,-0xc(%rbp)
	return feature[bit / 32] & BIT32(bit % 32);
ffffffff8010b8d4:	48 8b 7d f8          	mov    -0x8(%rbp),%rdi
ffffffff8010b8d8:	8b 75 f4             	mov    -0xc(%rbp),%esi
ffffffff8010b8db:	c1 ee 05             	shr    $0x5,%esi
ffffffff8010b8de:	89 f6                	mov    %esi,%esi
ffffffff8010b8e0:	89 f1                	mov    %esi,%ecx
ffffffff8010b8e2:	8b 34 8f             	mov    (%rdi,%rcx,4),%esi
ffffffff8010b8e5:	8b 55 f4             	mov    -0xc(%rbp),%edx
ffffffff8010b8e8:	83 e2 1f             	and    $0x1f,%edx
ffffffff8010b8eb:	89 d1                	mov    %edx,%ecx
ffffffff8010b8ed:	d3 e0                	shl    %cl,%eax
ffffffff8010b8ef:	21 c6                	and    %eax,%esi
ffffffff8010b8f1:	83 fe 00             	cmp    $0x0,%esi
ffffffff8010b8f4:	0f 95 c1             	setne  %cl
ffffffff8010b8f7:	80 e1 01             	and    $0x1,%cl
ffffffff8010b8fa:	0f b6 c1             	movzbl %cl,%eax
ffffffff8010b8fd:	48 83 c4 10          	add    $0x10,%rsp
ffffffff8010b901:	5d                   	pop    %rbp
ffffffff8010b902:	c3                   	retq   
ffffffff8010b903:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
ffffffff8010b90a:	00 00 00 
ffffffff8010b90d:	0f 1f 00             	nopl   (%rax)

ffffffff8010b910 <readsb>:
struct superblock sb;

// Read the super block.
void
readsb(int dev, struct superblock *sb)
{
ffffffff8010b910:	55                   	push   %rbp
ffffffff8010b911:	48 89 e5             	mov    %rsp,%rbp
ffffffff8010b914:	48 83 ec 30          	sub    $0x30,%rsp
ffffffff8010b918:	b8 01 00 00 00       	mov    $0x1,%eax
ffffffff8010b91d:	89 7d fc             	mov    %edi,-0x4(%rbp)
ffffffff8010b920:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  struct buf *bp;

  bp = bread(dev, 1);
ffffffff8010b924:	8b 7d fc             	mov    -0x4(%rbp),%edi
ffffffff8010b927:	be 01 00 00 00       	mov    $0x1,%esi
ffffffff8010b92c:	89 45 e4             	mov    %eax,-0x1c(%rbp)
ffffffff8010b92f:	e8 1c e6 ff ff       	callq  ffffffff80109f50 <bread>
ffffffff8010b934:	be 20 00 00 00       	mov    $0x20,%esi
ffffffff8010b939:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  memmove(sb, bp->data, sizeof(*sb));
ffffffff8010b93d:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
ffffffff8010b941:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
ffffffff8010b945:	48 81 c1 b0 00 00 00 	add    $0xb0,%rcx
ffffffff8010b94c:	ba 20 00 00 00       	mov    $0x20,%edx
ffffffff8010b951:	48 89 c7             	mov    %rax,%rdi
ffffffff8010b954:	89 75 e0             	mov    %esi,-0x20(%rbp)
ffffffff8010b957:	48 89 ce             	mov    %rcx,%rsi
ffffffff8010b95a:	e8 31 f7 ff ff       	callq  ffffffff8010b090 <memmove>
  brelse(bp);
ffffffff8010b95f:	48 8b 7d e8          	mov    -0x18(%rbp),%rdi
ffffffff8010b963:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
ffffffff8010b967:	e8 d4 e6 ff ff       	callq  ffffffff8010a040 <brelse>
}
ffffffff8010b96c:	48 83 c4 30          	add    $0x30,%rsp
ffffffff8010b970:	5d                   	pop    %rbp
ffffffff8010b971:	c3                   	retq   
ffffffff8010b972:	66 66 66 66 66 2e 0f 	data16 data16 data16 data16 nopw %cs:0x0(%rax,%rax,1)
ffffffff8010b979:	1f 84 00 00 00 00 00 

ffffffff8010b980 <iinit>:
  struct inode inodefile;
} icache;

void
iinit(int dev)
{
ffffffff8010b980:	55                   	push   %rbp
ffffffff8010b981:	48 89 e5             	mov    %rsp,%rbp
ffffffff8010b984:	48 83 ec 10          	sub    $0x10,%rsp
ffffffff8010b988:	89 7d fc             	mov    %edi,-0x4(%rbp)
  int i = 0;
ffffffff8010b98b:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%rbp)

  initlock(&icache.lock, "icache");
ffffffff8010b992:	48 c7 c7 60 27 20 83 	mov    $0xffffffff83202760,%rdi
ffffffff8010b999:	48 c7 c6 6f 05 11 80 	mov    $0xffffffff8011056f,%rsi
ffffffff8010b9a0:	e8 db 9d ff ff       	callq  ffffffff80105780 <initlock>
  for(i = 0; i < NINODE; i++) {
ffffffff8010b9a5:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%rbp)
ffffffff8010b9ac:	83 7d f8 32          	cmpl   $0x32,-0x8(%rbp)
ffffffff8010b9b0:	0f 8d 34 00 00 00    	jge    ffffffff8010b9ea <iinit+0x6a>
    initsleeplock(&icache.inode[i].lock, "inode");
ffffffff8010b9b6:	48 63 45 f8          	movslq -0x8(%rbp),%rax
ffffffff8010b9ba:	48 8d 04 40          	lea    (%rax,%rax,2),%rax
ffffffff8010b9be:	48 c1 e0 06          	shl    $0x6,%rax
ffffffff8010b9c2:	48 8d 80 c8 27 20 83 	lea    -0x7cdfd838(%rax),%rax
ffffffff8010b9c9:	48 83 c0 10          	add    $0x10,%rax
ffffffff8010b9cd:	48 c7 c6 76 05 11 80 	mov    $0xffffffff80110576,%rsi
ffffffff8010b9d4:	48 89 c7             	mov    %rax,%rdi
ffffffff8010b9d7:	e8 e4 e9 ff ff       	callq  ffffffff8010a3c0 <initsleeplock>
  for(i = 0; i < NINODE; i++) {
ffffffff8010b9dc:	8b 45 f8             	mov    -0x8(%rbp),%eax
ffffffff8010b9df:	83 c0 01             	add    $0x1,%eax
ffffffff8010b9e2:	89 45 f8             	mov    %eax,-0x8(%rbp)
ffffffff8010b9e5:	e9 c2 ff ff ff       	jmpq   ffffffff8010b9ac <iinit+0x2c>
  }
  initsleeplock(&icache.inodefile.lock, "inodefile");
ffffffff8010b9ea:	48 c7 c6 7c 05 11 80 	mov    $0xffffffff8011057c,%rsi
ffffffff8010b9f1:	48 c7 c7 58 4d 20 83 	mov    $0xffffffff83204d58,%rdi
ffffffff8010b9f8:	e8 c3 e9 ff ff       	callq  ffffffff8010a3c0 <initsleeplock>

  readsb(dev, &sb);
ffffffff8010b9fd:	8b 7d fc             	mov    -0x4(%rbp),%edi
ffffffff8010ba00:	48 c7 c6 40 27 20 83 	mov    $0xffffffff83202740,%rsi
ffffffff8010ba07:	e8 04 ff ff ff       	callq  ffffffff8010b910 <readsb>
  cprintf("sb: size %d nblocks %d bmap start %d inodestart %d extentstart: %d\n",
     sb.size, sb.nblocks, sb.bmapstart, sb.inodestart, sb.extentstart);
ffffffff8010ba0c:	8b 34 25 40 27 20 83 	mov    0xffffffff83202740,%esi
ffffffff8010ba13:	8b 14 25 44 27 20 83 	mov    0xffffffff83202744,%edx
ffffffff8010ba1a:	8b 0c 25 50 27 20 83 	mov    0xffffffff83202750,%ecx
ffffffff8010ba21:	44 8b 04 25 54 27 20 	mov    0xffffffff83202754,%r8d
ffffffff8010ba28:	83 
ffffffff8010ba29:	44 8b 0c 25 58 27 20 	mov    0xffffffff83202758,%r9d
ffffffff8010ba30:	83 
  cprintf("sb: size %d nblocks %d bmap start %d inodestart %d extentstart: %d\n",
ffffffff8010ba31:	48 c7 c7 86 05 11 80 	mov    $0xffffffff80110586,%rdi
ffffffff8010ba38:	31 c0                	xor    %eax,%eax
ffffffff8010ba3a:	41 88 c2             	mov    %al,%r10b
ffffffff8010ba3d:	44 88 d0             	mov    %r10b,%al
ffffffff8010ba40:	e8 1b 4f ff ff       	callq  ffffffff80100960 <cprintf>

  init_inodefile(dev);
ffffffff8010ba45:	8b 7d fc             	mov    -0x4(%rbp),%edi
ffffffff8010ba48:	e8 13 00 00 00       	callq  ffffffff8010ba60 <init_inodefile>
}
ffffffff8010ba4d:	48 83 c4 10          	add    $0x10,%rsp
ffffffff8010ba51:	5d                   	pop    %rbp
ffffffff8010ba52:	c3                   	retq   
ffffffff8010ba53:	66 66 66 66 2e 0f 1f 	data16 data16 data16 nopw %cs:0x0(%rax,%rax,1)
ffffffff8010ba5a:	84 00 00 00 00 00 

ffffffff8010ba60 <init_inodefile>:

// Find the inode file on the disk and load it into memory
// should only be called once, but is idempotent.
static void
init_inodefile(int dev) {
ffffffff8010ba60:	55                   	push   %rbp
ffffffff8010ba61:	48 89 e5             	mov    %rsp,%rbp
ffffffff8010ba64:	48 83 ec 70          	sub    $0x70,%rsp
ffffffff8010ba68:	48 8d 45 b0          	lea    -0x50(%rbp),%rax
ffffffff8010ba6c:	89 7d fc             	mov    %edi,-0x4(%rbp)
  struct buf *b;
  struct dinode di;

  acquiresleep(&icache.inodefile.lock);
ffffffff8010ba6f:	48 c7 c7 58 4d 20 83 	mov    $0xffffffff83204d58,%rdi
ffffffff8010ba76:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
ffffffff8010ba7a:	e8 a1 e9 ff ff       	callq  ffffffff8010a420 <acquiresleep>
  b = bread(dev, sb.inodestart);
ffffffff8010ba7f:	8b 7d fc             	mov    -0x4(%rbp),%edi
ffffffff8010ba82:	8b 34 25 54 27 20 83 	mov    0xffffffff83202754,%esi
ffffffff8010ba89:	e8 c2 e4 ff ff       	callq  ffffffff80109f50 <bread>
ffffffff8010ba8e:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  memmove(&di, b->data, sizeof(struct dinode));
ffffffff8010ba92:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
ffffffff8010ba96:	48 05 b0 00 00 00    	add    $0xb0,%rax
ffffffff8010ba9c:	48 8d 7d b0          	lea    -0x50(%rbp),%rdi
ffffffff8010baa0:	ba 40 00 00 00       	mov    $0x40,%edx
ffffffff8010baa5:	48 89 c6             	mov    %rax,%rsi
ffffffff8010baa8:	e8 e3 f5 ff ff       	callq  ffffffff8010b090 <memmove>

  icache.inodefile.inum = INODEFILEINO;
ffffffff8010baad:	c7 04 25 4c 4d 20 83 	movl   $0x0,0xffffffff83204d4c
ffffffff8010bab4:	00 00 00 00 
  icache.inodefile.dev = dev;
ffffffff8010bab8:	8b 55 fc             	mov    -0x4(%rbp),%edx
ffffffff8010babb:	89 14 25 48 4d 20 83 	mov    %edx,0xffffffff83204d48
  icache.inodefile.type = di.type;
ffffffff8010bac2:	66 8b 4d b0          	mov    -0x50(%rbp),%cx
ffffffff8010bac6:	66 89 0c 25 dc 4d 20 	mov    %cx,0xffffffff83204ddc
ffffffff8010bacd:	83 
  icache.inodefile.major = di.major;
ffffffff8010bace:	66 8b 4d b2          	mov    -0x4e(%rbp),%cx
ffffffff8010bad2:	66 89 0c 25 de 4d 20 	mov    %cx,0xffffffff83204dde
ffffffff8010bad9:	83 
  icache.inodefile.minor = di.minor;
ffffffff8010bada:	66 8b 4d b4          	mov    -0x4c(%rbp),%cx
ffffffff8010bade:	66 89 0c 25 e0 4d 20 	mov    %cx,0xffffffff83204de0
ffffffff8010bae5:	83 
  icache.inodefile.nlink = di.nlink;
ffffffff8010bae6:	66 8b 4d b6          	mov    -0x4a(%rbp),%cx
ffffffff8010baea:	66 89 0c 25 e2 4d 20 	mov    %cx,0xffffffff83204de2
ffffffff8010baf1:	83 
  icache.inodefile.size = di.size;
ffffffff8010baf2:	8b 55 b8             	mov    -0x48(%rbp),%edx
ffffffff8010baf5:	89 14 25 e4 4d 20 83 	mov    %edx,0xffffffff83204de4

  memmove(icache.inodefile.data, di.data, sizeof(di.data));
ffffffff8010bafc:	48 8b 75 a8          	mov    -0x58(%rbp),%rsi
ffffffff8010bb00:	48 83 c6 0c          	add    $0xc,%rsi
ffffffff8010bb04:	48 c7 c7 e8 4d 20 83 	mov    $0xffffffff83204de8,%rdi
ffffffff8010bb0b:	ba 20 00 00 00       	mov    $0x20,%edx
ffffffff8010bb10:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
ffffffff8010bb14:	e8 77 f5 ff ff       	callq  ffffffff8010b090 <memmove>

  brelse(b);
ffffffff8010bb19:	48 8b 7d f0          	mov    -0x10(%rbp),%rdi
ffffffff8010bb1d:	48 89 45 98          	mov    %rax,-0x68(%rbp)
ffffffff8010bb21:	e8 1a e5 ff ff       	callq  ffffffff8010a040 <brelse>
  releasesleep(&icache.inodefile.lock);
ffffffff8010bb26:	48 c7 c7 58 4d 20 83 	mov    $0xffffffff83204d58,%rdi
ffffffff8010bb2d:	e8 8e e9 ff ff       	callq  ffffffff8010a4c0 <releasesleep>
}
ffffffff8010bb32:	48 83 c4 70          	add    $0x70,%rsp
ffffffff8010bb36:	5d                   	pop    %rbp
ffffffff8010bb37:	c3                   	retq   
ffffffff8010bb38:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
ffffffff8010bb3f:	00 

ffffffff8010bb40 <touch_inode>:
  releasesleep(&icache.inodefile.lock);
}

uint
touch_inode(struct dinode* dinode)
{
ffffffff8010bb40:	55                   	push   %rbp
ffffffff8010bb41:	48 89 e5             	mov    %rsp,%rbp
ffffffff8010bb44:	48 81 ec 90 00 00 00 	sub    $0x90,%rsp
ffffffff8010bb4b:	b8 01 00 00 00       	mov    $0x1,%eax
ffffffff8010bb50:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  acquiresleep(&icache.inodefile.lock);
ffffffff8010bb54:	48 c7 c7 58 4d 20 83 	mov    $0xffffffff83204d58,%rdi
ffffffff8010bb5b:	89 45 8c             	mov    %eax,-0x74(%rbp)
ffffffff8010bb5e:	e8 bd e8 ff ff       	callq  ffffffff8010a420 <acquiresleep>
ffffffff8010bb63:	48 c7 c7 48 4d 20 83 	mov    $0xffffffff83204d48,%rdi
ffffffff8010bb6a:	48 8d 75 b8          	lea    -0x48(%rbp),%rsi
ffffffff8010bb6e:	31 c0                	xor    %eax,%eax

  struct dinode inodefileino;
  readi(&icache.inodefile, (char*) &inodefileino, INODEOFF(0), sizeof(struct dinode));
ffffffff8010bb70:	b9 40 00 00 00       	mov    $0x40,%ecx
ffffffff8010bb75:	89 c2                	mov    %eax,%edx
ffffffff8010bb77:	89 45 88             	mov    %eax,-0x78(%rbp)
ffffffff8010bb7a:	e8 51 01 00 00       	callq  ffffffff8010bcd0 <readi>

  // load in correct block (root) to append to
  uint off = inodefileino.size;
ffffffff8010bb7f:	8b 4d c0             	mov    -0x40(%rbp),%ecx
ffffffff8010bb82:	89 4d b4             	mov    %ecx,-0x4c(%rbp)
  uint inum = off / sizeof(struct dinode);
ffffffff8010bb85:	8b 4d b4             	mov    -0x4c(%rbp),%ecx
ffffffff8010bb88:	89 ce                	mov    %ecx,%esi
ffffffff8010bb8a:	48 c1 ee 06          	shr    $0x6,%rsi
ffffffff8010bb8e:	89 f1                	mov    %esi,%ecx
ffffffff8010bb90:	89 4d b0             	mov    %ecx,-0x50(%rbp)
  //int inode_data_blkn = inodefileino.data[j].startblkno + (off / BSIZE);
  //off = off % BSIZE;

  // update size via buffer

  begin_trans();
ffffffff8010bb93:	8b 4d 88             	mov    -0x78(%rbp),%ecx
ffffffff8010bb96:	41 88 c8             	mov    %cl,%r8b
ffffffff8010bb99:	89 45 84             	mov    %eax,-0x7c(%rbp)
ffffffff8010bb9c:	44 88 c0             	mov    %r8b,%al
ffffffff8010bb9f:	e8 2c 38 00 00       	callq  ffffffff8010f3d0 <begin_trans>
  struct buf* buf = bread(ROOTDEV, sb.inodestart);
ffffffff8010bba4:	8b 34 25 54 27 20 83 	mov    0xffffffff83202754,%esi
ffffffff8010bbab:	bf 01 00 00 00       	mov    $0x1,%edi
ffffffff8010bbb0:	e8 9b e3 ff ff       	callq  ffffffff80109f50 <bread>
ffffffff8010bbb5:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
  struct dinode* inodefile = (struct dinode*) buf->data;
ffffffff8010bbb9:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
ffffffff8010bbbd:	48 05 b0 00 00 00    	add    $0xb0,%rax
ffffffff8010bbc3:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
  size_t inodeblkno = inodefile->data[0].startblkno + (off / BSIZE);
ffffffff8010bbc7:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
ffffffff8010bbcb:	8b 48 0c             	mov    0xc(%rax),%ecx
ffffffff8010bbce:	8b 55 b4             	mov    -0x4c(%rbp),%edx
ffffffff8010bbd1:	c1 ea 09             	shr    $0x9,%edx
ffffffff8010bbd4:	01 d1                	add    %edx,%ecx
ffffffff8010bbd6:	89 c9                	mov    %ecx,%ecx
ffffffff8010bbd8:	89 c8                	mov    %ecx,%eax
ffffffff8010bbda:	48 89 45 98          	mov    %rax,-0x68(%rbp)


  if (inodefile->size != inodefileino.size)
ffffffff8010bbde:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
ffffffff8010bbe2:	8b 48 08             	mov    0x8(%rax),%ecx
ffffffff8010bbe5:	3b 4d c0             	cmp    -0x40(%rbp),%ecx
ffffffff8010bbe8:	0f 84 0c 00 00 00    	je     ffffffff8010bbfa <touch_inode+0xba>
    panic("not the same inode file!");
ffffffff8010bbee:	48 c7 c7 ca 05 11 80 	mov    $0xffffffff801105ca,%rdi
ffffffff8010bbf5:	e8 76 52 ff ff       	callq  ffffffff80100e70 <panic>
  inodefile->size += sizeof(struct dinode);
ffffffff8010bbfa:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
ffffffff8010bbfe:	8b 48 08             	mov    0x8(%rax),%ecx
ffffffff8010bc01:	83 c1 40             	add    $0x40,%ecx
ffffffff8010bc04:	89 48 08             	mov    %ecx,0x8(%rax)
  //inodefileino.size += sizeof(struct dinode);
  icache.inodefile.size = inodefile->size;
ffffffff8010bc07:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
ffffffff8010bc0b:	8b 48 08             	mov    0x8(%rax),%ecx
ffffffff8010bc0e:	89 0c 25 e4 4d 20 83 	mov    %ecx,0xffffffff83204de4
  log_write(buf);
ffffffff8010bc15:	48 8b 7d a8          	mov    -0x58(%rbp),%rdi
ffffffff8010bc19:	e8 c2 38 00 00       	callq  ffffffff8010f4e0 <log_write>
  brelse(buf);
ffffffff8010bc1e:	48 8b 7d a8          	mov    -0x58(%rbp),%rdi
ffffffff8010bc22:	e8 19 e4 ff ff       	callq  ffffffff8010a040 <brelse>
ffffffff8010bc27:	b9 01 00 00 00       	mov    $0x1,%ecx

  // edit inodefile
  // manual write to inodefile
  buf = bread(ROOTDEV, inodeblkno);
ffffffff8010bc2c:	48 8b 45 98          	mov    -0x68(%rbp),%rax
ffffffff8010bc30:	89 c2                	mov    %eax,%edx
ffffffff8010bc32:	bf 01 00 00 00       	mov    $0x1,%edi
ffffffff8010bc37:	89 d6                	mov    %edx,%esi
ffffffff8010bc39:	89 4d 80             	mov    %ecx,-0x80(%rbp)
ffffffff8010bc3c:	e8 0f e3 ff ff       	callq  ffffffff80109f50 <bread>
ffffffff8010bc41:	b9 40 00 00 00       	mov    $0x40,%ecx
ffffffff8010bc46:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
  struct dinode* placeholder = (struct dinode*)(buf->data + (off % BSIZE));
ffffffff8010bc4a:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
ffffffff8010bc4e:	48 05 b0 00 00 00    	add    $0xb0,%rax
ffffffff8010bc54:	8b 55 b4             	mov    -0x4c(%rbp),%edx
ffffffff8010bc57:	81 e2 ff 01 00 00    	and    $0x1ff,%edx
ffffffff8010bc5d:	89 d2                	mov    %edx,%edx
ffffffff8010bc5f:	41 89 d0             	mov    %edx,%r8d
ffffffff8010bc62:	4c 01 c0             	add    %r8,%rax
ffffffff8010bc65:	48 89 45 90          	mov    %rax,-0x70(%rbp)
  memmove(placeholder, dinode, sizeof(struct dinode));
ffffffff8010bc69:	48 8b 45 90          	mov    -0x70(%rbp),%rax
ffffffff8010bc6d:	4c 8b 45 f8          	mov    -0x8(%rbp),%r8
ffffffff8010bc71:	ba 40 00 00 00       	mov    $0x40,%edx
ffffffff8010bc76:	48 89 c7             	mov    %rax,%rdi
ffffffff8010bc79:	4c 89 c6             	mov    %r8,%rsi
ffffffff8010bc7c:	89 8d 7c ff ff ff    	mov    %ecx,-0x84(%rbp)
ffffffff8010bc82:	e8 09 f4 ff ff       	callq  ffffffff8010b090 <memmove>
  log_write(buf);
ffffffff8010bc87:	48 8b 7d a8          	mov    -0x58(%rbp),%rdi
ffffffff8010bc8b:	48 89 85 70 ff ff ff 	mov    %rax,-0x90(%rbp)
ffffffff8010bc92:	e8 49 38 00 00       	callq  ffffffff8010f4e0 <log_write>
  brelse(buf);
ffffffff8010bc97:	48 8b 7d a8          	mov    -0x58(%rbp),%rdi
ffffffff8010bc9b:	e8 a0 e3 ff ff       	callq  ffffffff8010a040 <brelse>
  commit_trans();
ffffffff8010bca0:	31 c9                	xor    %ecx,%ecx
ffffffff8010bca2:	41 88 c9             	mov    %cl,%r9b
ffffffff8010bca5:	44 88 c8             	mov    %r9b,%al
ffffffff8010bca8:	e8 83 3b 00 00       	callq  ffffffff8010f830 <commit_trans>

  releasesleep(&icache.inodefile.lock);
ffffffff8010bcad:	48 c7 c7 58 4d 20 83 	mov    $0xffffffff83204d58,%rdi
ffffffff8010bcb4:	e8 07 e8 ff ff       	callq  ffffffff8010a4c0 <releasesleep>
  return inum;
ffffffff8010bcb9:	8b 45 b0             	mov    -0x50(%rbp),%eax
ffffffff8010bcbc:	48 81 c4 90 00 00 00 	add    $0x90,%rsp
ffffffff8010bcc3:	5d                   	pop    %rbp
ffffffff8010bcc4:	c3                   	retq   
ffffffff8010bcc5:	66 66 2e 0f 1f 84 00 	data16 nopw %cs:0x0(%rax,%rax,1)
ffffffff8010bccc:	00 00 00 00 

ffffffff8010bcd0 <readi>:

//PAGEBREAK!
// Read data from inode.
int
readi(struct inode *ip, char *dst, uint off, uint n)
{
ffffffff8010bcd0:	55                   	push   %rbp
ffffffff8010bcd1:	48 89 e5             	mov    %rsp,%rbp
ffffffff8010bcd4:	48 83 ec 50          	sub    $0x50,%rsp
ffffffff8010bcd8:	48 89 7d f0          	mov    %rdi,-0x10(%rbp)
ffffffff8010bcdc:	48 89 75 e8          	mov    %rsi,-0x18(%rbp)
ffffffff8010bce0:	89 55 e4             	mov    %edx,-0x1c(%rbp)
ffffffff8010bce3:	89 4d e0             	mov    %ecx,-0x20(%rbp)
  uint tot, m;
  struct buf *bp;

  if(ip->type == T_DEV){
ffffffff8010bce6:	48 8b 75 f0          	mov    -0x10(%rbp),%rsi
ffffffff8010bcea:	0f bf 8e 94 00 00 00 	movswl 0x94(%rsi),%ecx
ffffffff8010bcf1:	83 f9 03             	cmp    $0x3,%ecx
ffffffff8010bcf4:	0f 85 84 00 00 00    	jne    ffffffff8010bd7e <readi+0xae>
    if(ip->major < 0 || ip->major >= NDEV || !devsw[ip->major].read)
ffffffff8010bcfa:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
ffffffff8010bcfe:	0f bf 88 96 00 00 00 	movswl 0x96(%rax),%ecx
ffffffff8010bd05:	83 f9 00             	cmp    $0x0,%ecx
ffffffff8010bd08:	0f 8c 35 00 00 00    	jl     ffffffff8010bd43 <readi+0x73>
ffffffff8010bd0e:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
ffffffff8010bd12:	0f bf 88 96 00 00 00 	movswl 0x96(%rax),%ecx
ffffffff8010bd19:	83 f9 0a             	cmp    $0xa,%ecx
ffffffff8010bd1c:	0f 8d 21 00 00 00    	jge    ffffffff8010bd43 <readi+0x73>
ffffffff8010bd22:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
ffffffff8010bd26:	48 0f bf 80 96 00 00 	movswq 0x96(%rax),%rax
ffffffff8010bd2d:	00 
ffffffff8010bd2e:	48 c1 e0 04          	shl    $0x4,%rax
ffffffff8010bd32:	48 8d 80 c0 54 20 83 	lea    -0x7cdfab40(%rax),%rax
ffffffff8010bd39:	48 83 38 00          	cmpq   $0x0,(%rax)
ffffffff8010bd3d:	0f 85 0c 00 00 00    	jne    ffffffff8010bd4f <readi+0x7f>
      return -1;
ffffffff8010bd43:	c7 45 fc ff ff ff ff 	movl   $0xffffffff,-0x4(%rbp)
ffffffff8010bd4a:	e9 6b 01 00 00       	jmpq   ffffffff8010beba <readi+0x1ea>
    return devsw[ip->major].read(ip, dst, n);
ffffffff8010bd4f:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
ffffffff8010bd53:	48 0f bf 80 96 00 00 	movswq 0x96(%rax),%rax
ffffffff8010bd5a:	00 
ffffffff8010bd5b:	48 c1 e0 04          	shl    $0x4,%rax
ffffffff8010bd5f:	48 8d 80 c0 54 20 83 	lea    -0x7cdfab40(%rax),%rax
ffffffff8010bd66:	48 8b 00             	mov    (%rax),%rax
ffffffff8010bd69:	48 8b 7d f0          	mov    -0x10(%rbp),%rdi
ffffffff8010bd6d:	48 8b 75 e8          	mov    -0x18(%rbp),%rsi
ffffffff8010bd71:	8b 55 e0             	mov    -0x20(%rbp),%edx
ffffffff8010bd74:	ff d0                	callq  *%rax
ffffffff8010bd76:	89 45 fc             	mov    %eax,-0x4(%rbp)
ffffffff8010bd79:	e9 3c 01 00 00       	jmpq   ffffffff8010beba <readi+0x1ea>
  }

  if(off > ip->size || off + n < off)
ffffffff8010bd7e:	8b 45 e4             	mov    -0x1c(%rbp),%eax
ffffffff8010bd81:	48 8b 4d f0          	mov    -0x10(%rbp),%rcx
ffffffff8010bd85:	3b 81 9c 00 00 00    	cmp    0x9c(%rcx),%eax
ffffffff8010bd8b:	0f 87 0f 00 00 00    	ja     ffffffff8010bda0 <readi+0xd0>
ffffffff8010bd91:	8b 45 e4             	mov    -0x1c(%rbp),%eax
ffffffff8010bd94:	03 45 e0             	add    -0x20(%rbp),%eax
ffffffff8010bd97:	3b 45 e4             	cmp    -0x1c(%rbp),%eax
ffffffff8010bd9a:	0f 83 0c 00 00 00    	jae    ffffffff8010bdac <readi+0xdc>
    return -1;
ffffffff8010bda0:	c7 45 fc ff ff ff ff 	movl   $0xffffffff,-0x4(%rbp)
ffffffff8010bda7:	e9 0e 01 00 00       	jmpq   ffffffff8010beba <readi+0x1ea>
  if(off + n > ip->size)
ffffffff8010bdac:	8b 45 e4             	mov    -0x1c(%rbp),%eax
ffffffff8010bdaf:	03 45 e0             	add    -0x20(%rbp),%eax
ffffffff8010bdb2:	48 8b 4d f0          	mov    -0x10(%rbp),%rcx
ffffffff8010bdb6:	3b 81 9c 00 00 00    	cmp    0x9c(%rcx),%eax
ffffffff8010bdbc:	0f 86 10 00 00 00    	jbe    ffffffff8010bdd2 <readi+0x102>
    n = ip->size - off;
ffffffff8010bdc2:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
ffffffff8010bdc6:	8b 88 9c 00 00 00    	mov    0x9c(%rax),%ecx
ffffffff8010bdcc:	2b 4d e4             	sub    -0x1c(%rbp),%ecx
ffffffff8010bdcf:	89 4d e0             	mov    %ecx,-0x20(%rbp)

  for(tot=0; tot<n; tot+=m, off+=m, dst+=m){
ffffffff8010bdd2:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%rbp)
ffffffff8010bdd9:	8b 45 dc             	mov    -0x24(%rbp),%eax
ffffffff8010bddc:	3b 45 e0             	cmp    -0x20(%rbp),%eax
ffffffff8010bddf:	0f 83 cf 00 00 00    	jae    ffffffff8010beb4 <readi+0x1e4>
    bp = bread(ip->dev, lookup_block(ip, off/BSIZE));
ffffffff8010bde5:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
ffffffff8010bde9:	8b 38                	mov    (%rax),%edi
ffffffff8010bdeb:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
ffffffff8010bdef:	8b 4d e4             	mov    -0x1c(%rbp),%ecx
ffffffff8010bdf2:	c1 e9 09             	shr    $0x9,%ecx
ffffffff8010bdf5:	89 7d c0             	mov    %edi,-0x40(%rbp)
ffffffff8010bdf8:	48 89 c7             	mov    %rax,%rdi
ffffffff8010bdfb:	89 ce                	mov    %ecx,%esi
ffffffff8010bdfd:	e8 ae 03 00 00       	callq  ffffffff8010c1b0 <lookup_block>
ffffffff8010be02:	8b 7d c0             	mov    -0x40(%rbp),%edi
ffffffff8010be05:	89 c6                	mov    %eax,%esi
ffffffff8010be07:	e8 44 e1 ff ff       	callq  ffffffff80109f50 <bread>
ffffffff8010be0c:	b9 00 02 00 00       	mov    $0x200,%ecx
ffffffff8010be11:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
    m = min(n - tot, BSIZE - off%BSIZE);
ffffffff8010be15:	8b 75 e0             	mov    -0x20(%rbp),%esi
ffffffff8010be18:	2b 75 dc             	sub    -0x24(%rbp),%esi
ffffffff8010be1b:	89 75 cc             	mov    %esi,-0x34(%rbp)
ffffffff8010be1e:	8b 75 e4             	mov    -0x1c(%rbp),%esi
ffffffff8010be21:	81 e6 ff 01 00 00    	and    $0x1ff,%esi
ffffffff8010be27:	29 f1                	sub    %esi,%ecx
ffffffff8010be29:	89 4d c8             	mov    %ecx,-0x38(%rbp)
ffffffff8010be2c:	8b 4d cc             	mov    -0x34(%rbp),%ecx
ffffffff8010be2f:	3b 4d c8             	cmp    -0x38(%rbp),%ecx
ffffffff8010be32:	0f 87 0b 00 00 00    	ja     ffffffff8010be43 <readi+0x173>
ffffffff8010be38:	8b 45 cc             	mov    -0x34(%rbp),%eax
ffffffff8010be3b:	89 45 bc             	mov    %eax,-0x44(%rbp)
ffffffff8010be3e:	e9 06 00 00 00       	jmpq   ffffffff8010be49 <readi+0x179>
ffffffff8010be43:	8b 45 c8             	mov    -0x38(%rbp),%eax
ffffffff8010be46:	89 45 bc             	mov    %eax,-0x44(%rbp)
ffffffff8010be49:	8b 45 bc             	mov    -0x44(%rbp),%eax
ffffffff8010be4c:	89 45 c4             	mov    %eax,-0x3c(%rbp)
ffffffff8010be4f:	8b 45 c4             	mov    -0x3c(%rbp),%eax
ffffffff8010be52:	89 45 d8             	mov    %eax,-0x28(%rbp)
    memmove(dst, bp->data + off%BSIZE, m);
ffffffff8010be55:	48 8b 7d e8          	mov    -0x18(%rbp),%rdi
ffffffff8010be59:	48 8b 4d d0          	mov    -0x30(%rbp),%rcx
ffffffff8010be5d:	48 81 c1 b0 00 00 00 	add    $0xb0,%rcx
ffffffff8010be64:	8b 45 e4             	mov    -0x1c(%rbp),%eax
ffffffff8010be67:	25 ff 01 00 00       	and    $0x1ff,%eax
ffffffff8010be6c:	89 c0                	mov    %eax,%eax
ffffffff8010be6e:	89 c2                	mov    %eax,%edx
ffffffff8010be70:	48 01 d1             	add    %rdx,%rcx
ffffffff8010be73:	8b 55 d8             	mov    -0x28(%rbp),%edx
ffffffff8010be76:	48 89 ce             	mov    %rcx,%rsi
ffffffff8010be79:	e8 12 f2 ff ff       	callq  ffffffff8010b090 <memmove>
    brelse(bp);
ffffffff8010be7e:	48 8b 7d d0          	mov    -0x30(%rbp),%rdi
ffffffff8010be82:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
ffffffff8010be86:	e8 b5 e1 ff ff       	callq  ffffffff8010a040 <brelse>
  for(tot=0; tot<n; tot+=m, off+=m, dst+=m){
ffffffff8010be8b:	8b 45 d8             	mov    -0x28(%rbp),%eax
ffffffff8010be8e:	03 45 dc             	add    -0x24(%rbp),%eax
ffffffff8010be91:	89 45 dc             	mov    %eax,-0x24(%rbp)
ffffffff8010be94:	8b 45 d8             	mov    -0x28(%rbp),%eax
ffffffff8010be97:	03 45 e4             	add    -0x1c(%rbp),%eax
ffffffff8010be9a:	89 45 e4             	mov    %eax,-0x1c(%rbp)
ffffffff8010be9d:	8b 45 d8             	mov    -0x28(%rbp),%eax
ffffffff8010bea0:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
ffffffff8010bea4:	89 c0                	mov    %eax,%eax
ffffffff8010bea6:	89 c2                	mov    %eax,%edx
ffffffff8010bea8:	48 01 d1             	add    %rdx,%rcx
ffffffff8010beab:	48 89 4d e8          	mov    %rcx,-0x18(%rbp)
ffffffff8010beaf:	e9 25 ff ff ff       	jmpq   ffffffff8010bdd9 <readi+0x109>
  }

  return n;
ffffffff8010beb4:	8b 45 e0             	mov    -0x20(%rbp),%eax
ffffffff8010beb7:	89 45 fc             	mov    %eax,-0x4(%rbp)
}
ffffffff8010beba:	8b 45 fc             	mov    -0x4(%rbp),%eax
ffffffff8010bebd:	48 83 c4 50          	add    $0x50,%rsp
ffffffff8010bec1:	5d                   	pop    %rbp
ffffffff8010bec2:	c3                   	retq   
ffffffff8010bec3:	66 66 66 66 2e 0f 1f 	data16 data16 data16 nopw %cs:0x0(%rax,%rax,1)
ffffffff8010beca:	84 00 00 00 00 00 

ffffffff8010bed0 <idup>:
{
ffffffff8010bed0:	55                   	push   %rbp
ffffffff8010bed1:	48 89 e5             	mov    %rsp,%rbp
ffffffff8010bed4:	48 83 ec 10          	sub    $0x10,%rsp
ffffffff8010bed8:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  acquire(&icache.lock);
ffffffff8010bedc:	48 c7 c7 60 27 20 83 	mov    $0xffffffff83202760,%rdi
ffffffff8010bee3:	e8 d8 98 ff ff       	callq  ffffffff801057c0 <acquire>
  ip->ref++;
ffffffff8010bee8:	48 8b 7d f8          	mov    -0x8(%rbp),%rdi
ffffffff8010beec:	8b 47 08             	mov    0x8(%rdi),%eax
ffffffff8010beef:	83 c0 01             	add    $0x1,%eax
ffffffff8010bef2:	89 47 08             	mov    %eax,0x8(%rdi)
  release(&icache.lock);
ffffffff8010bef5:	48 c7 c7 60 27 20 83 	mov    $0xffffffff83202760,%rdi
ffffffff8010befc:	e8 ff 9a ff ff       	callq  ffffffff80105a00 <release>
  return ip;
ffffffff8010bf01:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
ffffffff8010bf05:	48 83 c4 10          	add    $0x10,%rsp
ffffffff8010bf09:	5d                   	pop    %rbp
ffffffff8010bf0a:	c3                   	retq   
ffffffff8010bf0b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

ffffffff8010bf10 <iload>:
{
ffffffff8010bf10:	55                   	push   %rbp
ffffffff8010bf11:	48 89 e5             	mov    %rsp,%rbp
ffffffff8010bf14:	48 83 ec 60          	sub    $0x60,%rsp
ffffffff8010bf18:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  if(ip == 0 || ip->ref < 1)
ffffffff8010bf1c:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
ffffffff8010bf21:	0f 84 0e 00 00 00    	je     ffffffff8010bf35 <iload+0x25>
ffffffff8010bf27:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
ffffffff8010bf2b:	83 78 08 01          	cmpl   $0x1,0x8(%rax)
ffffffff8010bf2f:	0f 8d 0c 00 00 00    	jge    ffffffff8010bf41 <iload+0x31>
    panic("iload");
ffffffff8010bf35:	48 c7 c7 e3 05 11 80 	mov    $0xffffffff801105e3,%rdi
ffffffff8010bf3c:	e8 2f 4f ff ff       	callq  ffffffff80100e70 <panic>
  if(!(ip->flags & I_VALID)){
ffffffff8010bf41:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
ffffffff8010bf45:	8b 88 90 00 00 00    	mov    0x90(%rax),%ecx
ffffffff8010bf4b:	83 e1 02             	and    $0x2,%ecx
ffffffff8010bf4e:	83 f9 00             	cmp    $0x0,%ecx
ffffffff8010bf51:	0f 85 ca 00 00 00    	jne    ffffffff8010c021 <iload+0x111>
ffffffff8010bf57:	48 8d 45 b8          	lea    -0x48(%rbp),%rax
    read_dinode(ip->inum, &dip);
ffffffff8010bf5b:	48 8b 4d f8          	mov    -0x8(%rbp),%rcx
ffffffff8010bf5f:	8b 79 04             	mov    0x4(%rcx),%edi
ffffffff8010bf62:	48 8d 75 b8          	lea    -0x48(%rbp),%rsi
ffffffff8010bf66:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
ffffffff8010bf6a:	e8 c1 00 00 00       	callq  ffffffff8010c030 <read_dinode>
ffffffff8010bf6f:	bf 20 00 00 00       	mov    $0x20,%edi
ffffffff8010bf74:	48 8d 45 b8          	lea    -0x48(%rbp),%rax
    ip->type = dip.type;
ffffffff8010bf78:	66 8b 55 b8          	mov    -0x48(%rbp),%dx
ffffffff8010bf7c:	48 8b 4d f8          	mov    -0x8(%rbp),%rcx
ffffffff8010bf80:	66 89 91 94 00 00 00 	mov    %dx,0x94(%rcx)
    ip->major = dip.major;
ffffffff8010bf87:	66 8b 55 ba          	mov    -0x46(%rbp),%dx
ffffffff8010bf8b:	48 8b 4d f8          	mov    -0x8(%rbp),%rcx
ffffffff8010bf8f:	66 89 91 96 00 00 00 	mov    %dx,0x96(%rcx)
    ip->minor = dip.minor;
ffffffff8010bf96:	66 8b 55 bc          	mov    -0x44(%rbp),%dx
ffffffff8010bf9a:	48 8b 4d f8          	mov    -0x8(%rbp),%rcx
ffffffff8010bf9e:	66 89 91 98 00 00 00 	mov    %dx,0x98(%rcx)
    ip->nlink = dip.nlink;
ffffffff8010bfa5:	66 8b 55 be          	mov    -0x42(%rbp),%dx
ffffffff8010bfa9:	48 8b 4d f8          	mov    -0x8(%rbp),%rcx
ffffffff8010bfad:	66 89 91 9a 00 00 00 	mov    %dx,0x9a(%rcx)
    ip->size = dip.size;
ffffffff8010bfb4:	44 8b 45 c0          	mov    -0x40(%rbp),%r8d
ffffffff8010bfb8:	48 8b 4d f8          	mov    -0x8(%rbp),%rcx
ffffffff8010bfbc:	44 89 81 9c 00 00 00 	mov    %r8d,0x9c(%rcx)
    memmove(ip->data, dip.data, sizeof(dip.data));
ffffffff8010bfc3:	48 8b 4d f8          	mov    -0x8(%rbp),%rcx
ffffffff8010bfc7:	48 81 c1 a0 00 00 00 	add    $0xa0,%rcx
ffffffff8010bfce:	48 83 c0 0c          	add    $0xc,%rax
ffffffff8010bfd2:	ba 20 00 00 00       	mov    $0x20,%edx
ffffffff8010bfd7:	89 7d ac             	mov    %edi,-0x54(%rbp)
ffffffff8010bfda:	48 89 cf             	mov    %rcx,%rdi
ffffffff8010bfdd:	48 89 c6             	mov    %rax,%rsi
ffffffff8010bfe0:	e8 ab f0 ff ff       	callq  ffffffff8010b090 <memmove>
    ip->flags |= I_VALID;
ffffffff8010bfe5:	48 8b 4d f8          	mov    -0x8(%rbp),%rcx
ffffffff8010bfe9:	8b 91 90 00 00 00    	mov    0x90(%rcx),%edx
ffffffff8010bfef:	83 ca 02             	or     $0x2,%edx
ffffffff8010bff2:	89 91 90 00 00 00    	mov    %edx,0x90(%rcx)
    if(ip->type == 0)
ffffffff8010bff8:	48 8b 4d f8          	mov    -0x8(%rbp),%rcx
ffffffff8010bffc:	0f bf 91 94 00 00 00 	movswl 0x94(%rcx),%edx
ffffffff8010c003:	83 fa 00             	cmp    $0x0,%edx
ffffffff8010c006:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
ffffffff8010c00a:	0f 85 0c 00 00 00    	jne    ffffffff8010c01c <iload+0x10c>
      panic("iload: no type");
ffffffff8010c010:	48 c7 c7 e9 05 11 80 	mov    $0xffffffff801105e9,%rdi
ffffffff8010c017:	e8 54 4e ff ff       	callq  ffffffff80100e70 <panic>
  }
ffffffff8010c01c:	e9 00 00 00 00       	jmpq   ffffffff8010c021 <iload+0x111>
}
ffffffff8010c021:	48 83 c4 60          	add    $0x60,%rsp
ffffffff8010c025:	5d                   	pop    %rbp
ffffffff8010c026:	c3                   	retq   
ffffffff8010c027:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
ffffffff8010c02e:	00 00 

ffffffff8010c030 <read_dinode>:
{
ffffffff8010c030:	55                   	push   %rbp
ffffffff8010c031:	48 89 e5             	mov    %rsp,%rbp
ffffffff8010c034:	48 83 ec 20          	sub    $0x20,%rsp
ffffffff8010c038:	89 7d fc             	mov    %edi,-0x4(%rbp)
ffffffff8010c03b:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  acquiresleep(&icache.inodefile.lock);
ffffffff8010c03f:	48 c7 c7 58 4d 20 83 	mov    $0xffffffff83204d58,%rdi
ffffffff8010c046:	e8 d5 e3 ff ff       	callq  ffffffff8010a420 <acquiresleep>
  readi(&icache.inodefile, (char *)dip, INODEOFF(inum), sizeof(*dip));
ffffffff8010c04b:	48 8b 75 f0          	mov    -0x10(%rbp),%rsi
ffffffff8010c04f:	8b 45 fc             	mov    -0x4(%rbp),%eax
ffffffff8010c052:	89 c7                	mov    %eax,%edi
ffffffff8010c054:	48 c1 e7 06          	shl    $0x6,%rdi
ffffffff8010c058:	89 f8                	mov    %edi,%eax
ffffffff8010c05a:	48 c7 c7 48 4d 20 83 	mov    $0xffffffff83204d48,%rdi
ffffffff8010c061:	b9 40 00 00 00       	mov    $0x40,%ecx
ffffffff8010c066:	89 c2                	mov    %eax,%edx
ffffffff8010c068:	e8 63 fc ff ff       	callq  ffffffff8010bcd0 <readi>
  releasesleep(&icache.inodefile.lock);
ffffffff8010c06d:	48 c7 c7 58 4d 20 83 	mov    $0xffffffff83204d58,%rdi
ffffffff8010c074:	89 45 ec             	mov    %eax,-0x14(%rbp)
ffffffff8010c077:	e8 44 e4 ff ff       	callq  ffffffff8010a4c0 <releasesleep>
}
ffffffff8010c07c:	48 83 c4 20          	add    $0x20,%rsp
ffffffff8010c080:	5d                   	pop    %rbp
ffffffff8010c081:	c3                   	retq   
ffffffff8010c082:	66 66 66 66 66 2e 0f 	data16 data16 data16 data16 nopw %cs:0x0(%rax,%rax,1)
ffffffff8010c089:	1f 84 00 00 00 00 00 

ffffffff8010c090 <iput>:
{
ffffffff8010c090:	55                   	push   %rbp
ffffffff8010c091:	48 89 e5             	mov    %rsp,%rbp
ffffffff8010c094:	48 83 ec 10          	sub    $0x10,%rsp
ffffffff8010c098:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  acquire(&icache.lock);
ffffffff8010c09c:	48 c7 c7 60 27 20 83 	mov    $0xffffffff83202760,%rdi
ffffffff8010c0a3:	e8 18 97 ff ff       	callq  ffffffff801057c0 <acquire>
  if(ip->ref == 1 && (ip->flags & I_VALID) && ip->nlink == 0){
ffffffff8010c0a8:	48 8b 7d f8          	mov    -0x8(%rbp),%rdi
ffffffff8010c0ac:	83 7f 08 01          	cmpl   $0x1,0x8(%rdi)
ffffffff8010c0b0:	0f 85 5d 00 00 00    	jne    ffffffff8010c113 <iput+0x83>
ffffffff8010c0b6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
ffffffff8010c0ba:	8b 88 90 00 00 00    	mov    0x90(%rax),%ecx
ffffffff8010c0c0:	83 e1 02             	and    $0x2,%ecx
ffffffff8010c0c3:	83 f9 00             	cmp    $0x0,%ecx
ffffffff8010c0c6:	0f 84 47 00 00 00    	je     ffffffff8010c113 <iput+0x83>
ffffffff8010c0cc:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
ffffffff8010c0d0:	0f bf 88 9a 00 00 00 	movswl 0x9a(%rax),%ecx
ffffffff8010c0d7:	83 f9 00             	cmp    $0x0,%ecx
ffffffff8010c0da:	0f 85 33 00 00 00    	jne    ffffffff8010c113 <iput+0x83>
    release(&icache.lock);
ffffffff8010c0e0:	48 c7 c7 60 27 20 83 	mov    $0xffffffff83202760,%rdi
ffffffff8010c0e7:	e8 14 99 ff ff       	callq  ffffffff80105a00 <release>
    ip->type = 0;
ffffffff8010c0ec:	48 8b 7d f8          	mov    -0x8(%rbp),%rdi
ffffffff8010c0f0:	66 c7 87 94 00 00 00 	movw   $0x0,0x94(%rdi)
ffffffff8010c0f7:	00 00 
    acquire(&icache.lock);
ffffffff8010c0f9:	48 c7 c7 60 27 20 83 	mov    $0xffffffff83202760,%rdi
ffffffff8010c100:	e8 bb 96 ff ff       	callq  ffffffff801057c0 <acquire>
    ip->flags = 0;
ffffffff8010c105:	48 8b 7d f8          	mov    -0x8(%rbp),%rdi
ffffffff8010c109:	c7 87 90 00 00 00 00 	movl   $0x0,0x90(%rdi)
ffffffff8010c110:	00 00 00 
  ip->ref--;
ffffffff8010c113:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
ffffffff8010c117:	8b 48 08             	mov    0x8(%rax),%ecx
ffffffff8010c11a:	83 c1 ff             	add    $0xffffffff,%ecx
ffffffff8010c11d:	89 48 08             	mov    %ecx,0x8(%rax)
  release(&icache.lock);
ffffffff8010c120:	48 c7 c7 60 27 20 83 	mov    $0xffffffff83202760,%rdi
ffffffff8010c127:	e8 d4 98 ff ff       	callq  ffffffff80105a00 <release>
}
ffffffff8010c12c:	48 83 c4 10          	add    $0x10,%rsp
ffffffff8010c130:	5d                   	pop    %rbp
ffffffff8010c131:	c3                   	retq   
ffffffff8010c132:	66 66 66 66 66 2e 0f 	data16 data16 data16 data16 nopw %cs:0x0(%rax,%rax,1)
ffffffff8010c139:	1f 84 00 00 00 00 00 

ffffffff8010c140 <stati>:
{
ffffffff8010c140:	55                   	push   %rbp
ffffffff8010c141:	48 89 e5             	mov    %rsp,%rbp
ffffffff8010c144:	48 83 ec 10          	sub    $0x10,%rsp
ffffffff8010c148:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
ffffffff8010c14c:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  st->dev = ip->dev;
ffffffff8010c150:	48 8b 75 f8          	mov    -0x8(%rbp),%rsi
ffffffff8010c154:	8b 06                	mov    (%rsi),%eax
ffffffff8010c156:	48 8b 75 f0          	mov    -0x10(%rbp),%rsi
ffffffff8010c15a:	89 46 04             	mov    %eax,0x4(%rsi)
  st->ino = ip->inum;
ffffffff8010c15d:	48 8b 75 f8          	mov    -0x8(%rbp),%rsi
ffffffff8010c161:	8b 46 04             	mov    0x4(%rsi),%eax
ffffffff8010c164:	48 8b 75 f0          	mov    -0x10(%rbp),%rsi
ffffffff8010c168:	89 46 08             	mov    %eax,0x8(%rsi)
  st->type = ip->type;
ffffffff8010c16b:	48 8b 75 f8          	mov    -0x8(%rbp),%rsi
ffffffff8010c16f:	66 8b 8e 94 00 00 00 	mov    0x94(%rsi),%cx
ffffffff8010c176:	48 8b 75 f0          	mov    -0x10(%rbp),%rsi
ffffffff8010c17a:	66 89 0e             	mov    %cx,(%rsi)
  st->nlink = ip->nlink;
ffffffff8010c17d:	48 8b 75 f8          	mov    -0x8(%rbp),%rsi
ffffffff8010c181:	66 8b 8e 9a 00 00 00 	mov    0x9a(%rsi),%cx
ffffffff8010c188:	48 8b 75 f0          	mov    -0x10(%rbp),%rsi
ffffffff8010c18c:	66 89 4e 0c          	mov    %cx,0xc(%rsi)
  st->size = ip->size;
ffffffff8010c190:	48 8b 75 f8          	mov    -0x8(%rbp),%rsi
ffffffff8010c194:	8b 86 9c 00 00 00    	mov    0x9c(%rsi),%eax
ffffffff8010c19a:	48 8b 75 f0          	mov    -0x10(%rbp),%rsi
ffffffff8010c19e:	89 46 10             	mov    %eax,0x10(%rsi)
}
ffffffff8010c1a1:	48 83 c4 10          	add    $0x10,%rsp
ffffffff8010c1a5:	5d                   	pop    %rbp
ffffffff8010c1a6:	c3                   	retq   
ffffffff8010c1a7:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
ffffffff8010c1ae:	00 00 

ffffffff8010c1b0 <lookup_block>:
{
ffffffff8010c1b0:	55                   	push   %rbp
ffffffff8010c1b1:	48 89 e5             	mov    %rsp,%rbp
ffffffff8010c1b4:	48 83 ec 30          	sub    $0x30,%rsp
ffffffff8010c1b8:	48 89 7d f0          	mov    %rdi,-0x10(%rbp)
ffffffff8010c1bc:	89 75 ec             	mov    %esi,-0x14(%rbp)
  uint alloced_blocks = 0;
ffffffff8010c1bf:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%rbp)
  uint remain = blockno;
ffffffff8010c1c6:	8b 75 ec             	mov    -0x14(%rbp),%esi
ffffffff8010c1c9:	89 75 e0             	mov    %esi,-0x20(%rbp)
  for (i = 0; i < EXTENTS_PER_INODE; i++) {
ffffffff8010c1cc:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%rbp)
ffffffff8010c1d3:	83 7d e4 04          	cmpl   $0x4,-0x1c(%rbp)
ffffffff8010c1d7:	0f 8d 91 00 00 00    	jge    ffffffff8010c26e <lookup_block+0xbe>
    if (ip->data[i].nblocks != 0) {
ffffffff8010c1dd:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
ffffffff8010c1e1:	48 63 4d e4          	movslq -0x1c(%rbp),%rcx
ffffffff8010c1e5:	83 bc c8 a4 00 00 00 	cmpl   $0x0,0xa4(%rax,%rcx,8)
ffffffff8010c1ec:	00 
ffffffff8010c1ed:	0f 84 63 00 00 00    	je     ffffffff8010c256 <lookup_block+0xa6>
      if (remain < ip->data[i].nblocks) {
ffffffff8010c1f3:	8b 45 e0             	mov    -0x20(%rbp),%eax
ffffffff8010c1f6:	48 8b 4d f0          	mov    -0x10(%rbp),%rcx
ffffffff8010c1fa:	48 63 55 e4          	movslq -0x1c(%rbp),%rdx
ffffffff8010c1fe:	3b 84 d1 a4 00 00 00 	cmp    0xa4(%rcx,%rdx,8),%eax
ffffffff8010c205:	0f 83 1a 00 00 00    	jae    ffffffff8010c225 <lookup_block+0x75>
        return ip->data[i].startblkno + remain;
ffffffff8010c20b:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
ffffffff8010c20f:	48 63 4d e4          	movslq -0x1c(%rbp),%rcx
ffffffff8010c213:	8b 94 c8 a0 00 00 00 	mov    0xa0(%rax,%rcx,8),%edx
ffffffff8010c21a:	03 55 e0             	add    -0x20(%rbp),%edx
ffffffff8010c21d:	89 55 fc             	mov    %edx,-0x4(%rbp)
ffffffff8010c220:	e9 01 01 00 00       	jmpq   ffffffff8010c326 <lookup_block+0x176>
        remain -= ip->data[i].nblocks;
ffffffff8010c225:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
ffffffff8010c229:	48 63 4d e4          	movslq -0x1c(%rbp),%rcx
ffffffff8010c22d:	8b 94 c8 a4 00 00 00 	mov    0xa4(%rax,%rcx,8),%edx
ffffffff8010c234:	8b 75 e0             	mov    -0x20(%rbp),%esi
ffffffff8010c237:	29 d6                	sub    %edx,%esi
ffffffff8010c239:	89 75 e0             	mov    %esi,-0x20(%rbp)
      alloced_blocks += ip->data[i].nblocks;
ffffffff8010c23c:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
ffffffff8010c240:	48 63 4d e4          	movslq -0x1c(%rbp),%rcx
ffffffff8010c244:	8b 94 c8 a4 00 00 00 	mov    0xa4(%rax,%rcx,8),%edx
ffffffff8010c24b:	03 55 e8             	add    -0x18(%rbp),%edx
ffffffff8010c24e:	89 55 e8             	mov    %edx,-0x18(%rbp)
    } else {
ffffffff8010c251:	e9 05 00 00 00       	jmpq   ffffffff8010c25b <lookup_block+0xab>
      break;
ffffffff8010c256:	e9 13 00 00 00       	jmpq   ffffffff8010c26e <lookup_block+0xbe>
  }
ffffffff8010c25b:	e9 00 00 00 00       	jmpq   ffffffff8010c260 <lookup_block+0xb0>
  for (i = 0; i < EXTENTS_PER_INODE; i++) {
ffffffff8010c260:	8b 45 e4             	mov    -0x1c(%rbp),%eax
ffffffff8010c263:	83 c0 01             	add    $0x1,%eax
ffffffff8010c266:	89 45 e4             	mov    %eax,-0x1c(%rbp)
ffffffff8010c269:	e9 65 ff ff ff       	jmpq   ffffffff8010c1d3 <lookup_block+0x23>
  while (alloced_blocks < blockno + 1) {
ffffffff8010c26e:	e9 00 00 00 00       	jmpq   ffffffff8010c273 <lookup_block+0xc3>
ffffffff8010c273:	8b 45 e8             	mov    -0x18(%rbp),%eax
ffffffff8010c276:	8b 4d ec             	mov    -0x14(%rbp),%ecx
ffffffff8010c279:	83 c1 01             	add    $0x1,%ecx
ffffffff8010c27c:	39 c8                	cmp    %ecx,%eax
ffffffff8010c27e:	0f 83 91 00 00 00    	jae    ffffffff8010c315 <lookup_block+0x165>
    if (i >= EXTENTS_PER_INODE) {
ffffffff8010c284:	83 7d e4 04          	cmpl   $0x4,-0x1c(%rbp)
ffffffff8010c288:	0f 8c 0c 00 00 00    	jl     ffffffff8010c29a <lookup_block+0xea>
      panic("welp, allocing extent beyond capacity.");
ffffffff8010c28e:	48 c7 c7 f8 05 11 80 	mov    $0xffffffff801105f8,%rdi
ffffffff8010c295:	e8 d6 4b ff ff       	callq  ffffffff80100e70 <panic>
ffffffff8010c29a:	b8 04 00 00 00       	mov    $0x4,%eax
ffffffff8010c29f:	89 c1                	mov    %eax,%ecx
    uint start = alloc_extent(4);
ffffffff8010c2a1:	b8 04 00 00 00       	mov    $0x4,%eax
ffffffff8010c2a6:	89 c7                	mov    %eax,%edi
ffffffff8010c2a8:	48 89 4d d0          	mov    %rcx,-0x30(%rbp)
ffffffff8010c2ac:	e8 7f da ff ff       	callq  ffffffff80109d30 <alloc_extent>
ffffffff8010c2b1:	89 c2                	mov    %eax,%edx
ffffffff8010c2b3:	89 55 dc             	mov    %edx,-0x24(%rbp)
    ip->data[i].startblkno = start;
ffffffff8010c2b6:	8b 55 dc             	mov    -0x24(%rbp),%edx
ffffffff8010c2b9:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
ffffffff8010c2bd:	48 63 4d e4          	movslq -0x1c(%rbp),%rcx
ffffffff8010c2c1:	89 94 c8 a0 00 00 00 	mov    %edx,0xa0(%rax,%rcx,8)
    ip->data[i].nblocks = 4;
ffffffff8010c2c8:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
ffffffff8010c2cc:	48 63 4d e4          	movslq -0x1c(%rbp),%rcx
ffffffff8010c2d0:	c7 84 c8 a4 00 00 00 	movl   $0x4,0xa4(%rax,%rcx,8)
ffffffff8010c2d7:	04 00 00 00 
    alloced_blocks += 4;
ffffffff8010c2db:	8b 55 e8             	mov    -0x18(%rbp),%edx
ffffffff8010c2de:	83 c2 04             	add    $0x4,%edx
ffffffff8010c2e1:	89 55 e8             	mov    %edx,-0x18(%rbp)
    if (blockno < alloced_blocks) {
ffffffff8010c2e4:	8b 55 ec             	mov    -0x14(%rbp),%edx
ffffffff8010c2e7:	3b 55 e8             	cmp    -0x18(%rbp),%edx
ffffffff8010c2ea:	0f 83 0e 00 00 00    	jae    ffffffff8010c2fe <lookup_block+0x14e>
      return start + remain;
ffffffff8010c2f0:	8b 45 dc             	mov    -0x24(%rbp),%eax
ffffffff8010c2f3:	03 45 e0             	add    -0x20(%rbp),%eax
ffffffff8010c2f6:	89 45 fc             	mov    %eax,-0x4(%rbp)
ffffffff8010c2f9:	e9 28 00 00 00       	jmpq   ffffffff8010c326 <lookup_block+0x176>
    remain -= 4;
ffffffff8010c2fe:	8b 45 e0             	mov    -0x20(%rbp),%eax
ffffffff8010c301:	83 e8 04             	sub    $0x4,%eax
ffffffff8010c304:	89 45 e0             	mov    %eax,-0x20(%rbp)
    i++;
ffffffff8010c307:	8b 45 e4             	mov    -0x1c(%rbp),%eax
ffffffff8010c30a:	83 c0 01             	add    $0x1,%eax
ffffffff8010c30d:	89 45 e4             	mov    %eax,-0x1c(%rbp)
  while (alloced_blocks < blockno + 1) {
ffffffff8010c310:	e9 5e ff ff ff       	jmpq   ffffffff8010c273 <lookup_block+0xc3>
  assert(false);
ffffffff8010c315:	e9 00 00 00 00       	jmpq   ffffffff8010c31a <lookup_block+0x16a>
ffffffff8010c31a:	48 c7 c7 15 fc 10 80 	mov    $0xffffffff8010fc15,%rdi
ffffffff8010c321:	e8 4a 4b ff ff       	callq  ffffffff80100e70 <panic>
}
ffffffff8010c326:	8b 45 fc             	mov    -0x4(%rbp),%eax
ffffffff8010c329:	48 83 c4 30          	add    $0x30,%rsp
ffffffff8010c32d:	5d                   	pop    %rbp
ffffffff8010c32e:	c3                   	retq   
ffffffff8010c32f:	90                   	nop

ffffffff8010c330 <writei>:

// PAGEBREAK!
// Write data to inode.
int
writei(struct inode *ip, char *src, uint off, uint n)
{
ffffffff8010c330:	55                   	push   %rbp
ffffffff8010c331:	48 89 e5             	mov    %rsp,%rbp
ffffffff8010c334:	48 81 ec 80 00 00 00 	sub    $0x80,%rsp
ffffffff8010c33b:	48 89 7d f0          	mov    %rdi,-0x10(%rbp)
ffffffff8010c33f:	48 89 75 e8          	mov    %rsi,-0x18(%rbp)
ffffffff8010c343:	89 55 e4             	mov    %edx,-0x1c(%rbp)
ffffffff8010c346:	89 4d e0             	mov    %ecx,-0x20(%rbp)
  if(ip->type == T_DEV){
ffffffff8010c349:	48 8b 75 f0          	mov    -0x10(%rbp),%rsi
ffffffff8010c34d:	0f bf 8e 94 00 00 00 	movswl 0x94(%rsi),%ecx
ffffffff8010c354:	83 f9 03             	cmp    $0x3,%ecx
ffffffff8010c357:	0f 85 86 00 00 00    	jne    ffffffff8010c3e3 <writei+0xb3>
    if(ip->major < 0 || ip->major >= NDEV || !devsw[ip->major].write)
ffffffff8010c35d:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
ffffffff8010c361:	0f bf 88 96 00 00 00 	movswl 0x96(%rax),%ecx
ffffffff8010c368:	83 f9 00             	cmp    $0x0,%ecx
ffffffff8010c36b:	0f 8c 36 00 00 00    	jl     ffffffff8010c3a7 <writei+0x77>
ffffffff8010c371:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
ffffffff8010c375:	0f bf 88 96 00 00 00 	movswl 0x96(%rax),%ecx
ffffffff8010c37c:	83 f9 0a             	cmp    $0xa,%ecx
ffffffff8010c37f:	0f 8d 22 00 00 00    	jge    ffffffff8010c3a7 <writei+0x77>
ffffffff8010c385:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
ffffffff8010c389:	48 0f bf 80 96 00 00 	movswq 0x96(%rax),%rax
ffffffff8010c390:	00 
ffffffff8010c391:	48 c1 e0 04          	shl    $0x4,%rax
ffffffff8010c395:	48 8d 80 c0 54 20 83 	lea    -0x7cdfab40(%rax),%rax
ffffffff8010c39c:	48 83 78 08 00       	cmpq   $0x0,0x8(%rax)
ffffffff8010c3a1:	0f 85 0c 00 00 00    	jne    ffffffff8010c3b3 <writei+0x83>
      return -1;
ffffffff8010c3a7:	c7 45 fc ff ff ff ff 	movl   $0xffffffff,-0x4(%rbp)
ffffffff8010c3ae:	e9 84 02 00 00       	jmpq   ffffffff8010c637 <writei+0x307>
    return devsw[ip->major].write(ip, src, n);
ffffffff8010c3b3:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
ffffffff8010c3b7:	48 0f bf 80 96 00 00 	movswq 0x96(%rax),%rax
ffffffff8010c3be:	00 
ffffffff8010c3bf:	48 c1 e0 04          	shl    $0x4,%rax
ffffffff8010c3c3:	48 8d 80 c0 54 20 83 	lea    -0x7cdfab40(%rax),%rax
ffffffff8010c3ca:	48 8b 40 08          	mov    0x8(%rax),%rax
ffffffff8010c3ce:	48 8b 7d f0          	mov    -0x10(%rbp),%rdi
ffffffff8010c3d2:	48 8b 75 e8          	mov    -0x18(%rbp),%rsi
ffffffff8010c3d6:	8b 55 e0             	mov    -0x20(%rbp),%edx
ffffffff8010c3d9:	ff d0                	callq  *%rax
ffffffff8010c3db:	89 45 fc             	mov    %eax,-0x4(%rbp)
ffffffff8010c3de:	e9 54 02 00 00       	jmpq   ffffffff8010c637 <writei+0x307>
  }

  uint tot, m;
  struct buf* buf;

  if(off > ip->size || off + n < off)
ffffffff8010c3e3:	8b 45 e4             	mov    -0x1c(%rbp),%eax
ffffffff8010c3e6:	48 8b 4d f0          	mov    -0x10(%rbp),%rcx
ffffffff8010c3ea:	3b 81 9c 00 00 00    	cmp    0x9c(%rcx),%eax
ffffffff8010c3f0:	0f 87 0f 00 00 00    	ja     ffffffff8010c405 <writei+0xd5>
ffffffff8010c3f6:	8b 45 e4             	mov    -0x1c(%rbp),%eax
ffffffff8010c3f9:	03 45 e0             	add    -0x20(%rbp),%eax
ffffffff8010c3fc:	3b 45 e4             	cmp    -0x1c(%rbp),%eax
ffffffff8010c3ff:	0f 83 0c 00 00 00    	jae    ffffffff8010c411 <writei+0xe1>
    return -1;
ffffffff8010c405:	c7 45 fc ff ff ff ff 	movl   $0xffffffff,-0x4(%rbp)
ffffffff8010c40c:	e9 26 02 00 00       	jmpq   ffffffff8010c637 <writei+0x307>

  begin_trans();
ffffffff8010c411:	31 c0                	xor    %eax,%eax
ffffffff8010c413:	88 c1                	mov    %al,%cl
ffffffff8010c415:	88 c8                	mov    %cl,%al
ffffffff8010c417:	e8 b4 2f 00 00       	callq  ffffffff8010f3d0 <begin_trans>

  for (tot=0; tot<n; tot+=m, off+=m, src+=m){
ffffffff8010c41c:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%rbp)
ffffffff8010c423:	8b 45 dc             	mov    -0x24(%rbp),%eax
ffffffff8010c426:	3b 45 e0             	cmp    -0x20(%rbp),%eax
ffffffff8010c429:	0f 83 d8 00 00 00    	jae    ffffffff8010c507 <writei+0x1d7>
    buf = bread(ip->dev, lookup_block(ip, off/BSIZE));
ffffffff8010c42f:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
ffffffff8010c433:	8b 38                	mov    (%rax),%edi
ffffffff8010c435:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
ffffffff8010c439:	8b 4d e4             	mov    -0x1c(%rbp),%ecx
ffffffff8010c43c:	c1 e9 09             	shr    $0x9,%ecx
ffffffff8010c43f:	89 7d a0             	mov    %edi,-0x60(%rbp)
ffffffff8010c442:	48 89 c7             	mov    %rax,%rdi
ffffffff8010c445:	89 ce                	mov    %ecx,%esi
ffffffff8010c447:	e8 64 fd ff ff       	callq  ffffffff8010c1b0 <lookup_block>
ffffffff8010c44c:	8b 7d a0             	mov    -0x60(%rbp),%edi
ffffffff8010c44f:	89 c6                	mov    %eax,%esi
ffffffff8010c451:	e8 fa da ff ff       	callq  ffffffff80109f50 <bread>
ffffffff8010c456:	b9 00 02 00 00       	mov    $0x200,%ecx
ffffffff8010c45b:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
    m = min(n - tot, BSIZE - off%BSIZE);
ffffffff8010c45f:	8b 75 e0             	mov    -0x20(%rbp),%esi
ffffffff8010c462:	2b 75 dc             	sub    -0x24(%rbp),%esi
ffffffff8010c465:	89 75 cc             	mov    %esi,-0x34(%rbp)
ffffffff8010c468:	8b 75 e4             	mov    -0x1c(%rbp),%esi
ffffffff8010c46b:	81 e6 ff 01 00 00    	and    $0x1ff,%esi
ffffffff8010c471:	29 f1                	sub    %esi,%ecx
ffffffff8010c473:	89 4d c8             	mov    %ecx,-0x38(%rbp)
ffffffff8010c476:	8b 4d cc             	mov    -0x34(%rbp),%ecx
ffffffff8010c479:	3b 4d c8             	cmp    -0x38(%rbp),%ecx
ffffffff8010c47c:	0f 87 0b 00 00 00    	ja     ffffffff8010c48d <writei+0x15d>
ffffffff8010c482:	8b 45 cc             	mov    -0x34(%rbp),%eax
ffffffff8010c485:	89 45 9c             	mov    %eax,-0x64(%rbp)
ffffffff8010c488:	e9 06 00 00 00       	jmpq   ffffffff8010c493 <writei+0x163>
ffffffff8010c48d:	8b 45 c8             	mov    -0x38(%rbp),%eax
ffffffff8010c490:	89 45 9c             	mov    %eax,-0x64(%rbp)
ffffffff8010c493:	8b 45 9c             	mov    -0x64(%rbp),%eax
ffffffff8010c496:	89 45 c4             	mov    %eax,-0x3c(%rbp)
ffffffff8010c499:	8b 45 c4             	mov    -0x3c(%rbp),%eax
ffffffff8010c49c:	89 45 d8             	mov    %eax,-0x28(%rbp)
    memmove(buf->data + off%BSIZE, src, m);
ffffffff8010c49f:	48 8b 4d d0          	mov    -0x30(%rbp),%rcx
ffffffff8010c4a3:	48 81 c1 b0 00 00 00 	add    $0xb0,%rcx
ffffffff8010c4aa:	8b 45 e4             	mov    -0x1c(%rbp),%eax
ffffffff8010c4ad:	25 ff 01 00 00       	and    $0x1ff,%eax
ffffffff8010c4b2:	89 c0                	mov    %eax,%eax
ffffffff8010c4b4:	89 c2                	mov    %eax,%edx
ffffffff8010c4b6:	48 01 d1             	add    %rdx,%rcx
ffffffff8010c4b9:	48 8b 75 e8          	mov    -0x18(%rbp),%rsi
ffffffff8010c4bd:	8b 55 d8             	mov    -0x28(%rbp),%edx
ffffffff8010c4c0:	48 89 cf             	mov    %rcx,%rdi
ffffffff8010c4c3:	e8 c8 eb ff ff       	callq  ffffffff8010b090 <memmove>
    log_write(buf);
ffffffff8010c4c8:	48 8b 7d d0          	mov    -0x30(%rbp),%rdi
ffffffff8010c4cc:	48 89 45 90          	mov    %rax,-0x70(%rbp)
ffffffff8010c4d0:	e8 0b 30 00 00       	callq  ffffffff8010f4e0 <log_write>
    brelse(buf);
ffffffff8010c4d5:	48 8b 7d d0          	mov    -0x30(%rbp),%rdi
ffffffff8010c4d9:	e8 62 db ff ff       	callq  ffffffff8010a040 <brelse>
  for (tot=0; tot<n; tot+=m, off+=m, src+=m){
ffffffff8010c4de:	8b 45 d8             	mov    -0x28(%rbp),%eax
ffffffff8010c4e1:	03 45 dc             	add    -0x24(%rbp),%eax
ffffffff8010c4e4:	89 45 dc             	mov    %eax,-0x24(%rbp)
ffffffff8010c4e7:	8b 45 d8             	mov    -0x28(%rbp),%eax
ffffffff8010c4ea:	03 45 e4             	add    -0x1c(%rbp),%eax
ffffffff8010c4ed:	89 45 e4             	mov    %eax,-0x1c(%rbp)
ffffffff8010c4f0:	8b 45 d8             	mov    -0x28(%rbp),%eax
ffffffff8010c4f3:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
ffffffff8010c4f7:	89 c0                	mov    %eax,%eax
ffffffff8010c4f9:	89 c2                	mov    %eax,%edx
ffffffff8010c4fb:	48 01 d1             	add    %rdx,%rcx
ffffffff8010c4fe:	48 89 4d e8          	mov    %rcx,-0x18(%rbp)
ffffffff8010c502:	e9 1c ff ff ff       	jmpq   ffffffff8010c423 <writei+0xf3>
ffffffff8010c507:	b8 01 00 00 00       	mov    $0x1,%eax
 }

  // update inode's size field
  buf = bread(ROOTDEV, sb.inodestart);
ffffffff8010c50c:	8b 34 25 54 27 20 83 	mov    0xffffffff83202754,%esi
ffffffff8010c513:	bf 01 00 00 00       	mov    $0x1,%edi
ffffffff8010c518:	89 45 8c             	mov    %eax,-0x74(%rbp)
ffffffff8010c51b:	e8 30 da ff ff       	callq  ffffffff80109f50 <bread>
ffffffff8010c520:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
  struct dinode* inodefile = (struct dinode*) buf->data;
ffffffff8010c524:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
ffffffff8010c528:	48 05 b0 00 00 00    	add    $0xb0,%rax
ffffffff8010c52e:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
  size_t blkno = inodefile->data[0].startblkno + ((ip->inum * sizeof(struct dinode)) / BSIZE);
ffffffff8010c532:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
ffffffff8010c536:	8b 70 0c             	mov    0xc(%rax),%esi
ffffffff8010c539:	89 f0                	mov    %esi,%eax
ffffffff8010c53b:	48 8b 4d f0          	mov    -0x10(%rbp),%rcx
ffffffff8010c53f:	8b 71 04             	mov    0x4(%rcx),%esi
ffffffff8010c542:	89 f1                	mov    %esi,%ecx
ffffffff8010c544:	48 c1 e1 06          	shl    $0x6,%rcx
ffffffff8010c548:	48 c1 e9 09          	shr    $0x9,%rcx
ffffffff8010c54c:	48 01 c8             	add    %rcx,%rax
ffffffff8010c54f:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
  brelse(buf);
ffffffff8010c553:	48 8b 7d d0          	mov    -0x30(%rbp),%rdi
ffffffff8010c557:	e8 e4 da ff ff       	callq  ffffffff8010a040 <brelse>
ffffffff8010c55c:	be 01 00 00 00       	mov    $0x1,%esi

  buf = bread(ROOTDEV, blkno);
ffffffff8010c561:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
ffffffff8010c565:	89 c2                	mov    %eax,%edx
ffffffff8010c567:	bf 01 00 00 00       	mov    $0x1,%edi
ffffffff8010c56c:	89 75 88             	mov    %esi,-0x78(%rbp)
ffffffff8010c56f:	89 d6                	mov    %edx,%esi
ffffffff8010c571:	e8 da d9 ff ff       	callq  ffffffff80109f50 <bread>
ffffffff8010c576:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
  struct dinode* file = (struct dinode*) (buf->data + ((ip->inum * sizeof(struct dinode)) % BSIZE));
ffffffff8010c57a:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
ffffffff8010c57e:	48 05 b0 00 00 00    	add    $0xb0,%rax
ffffffff8010c584:	48 8b 4d f0          	mov    -0x10(%rbp),%rcx
ffffffff8010c588:	8b 51 04             	mov    0x4(%rcx),%edx
ffffffff8010c58b:	89 d1                	mov    %edx,%ecx
ffffffff8010c58d:	48 c1 e1 06          	shl    $0x6,%rcx
ffffffff8010c591:	48 81 e1 ff 01 00 00 	and    $0x1ff,%rcx
ffffffff8010c598:	48 01 c8             	add    %rcx,%rax
ffffffff8010c59b:	48 89 45 a8          	mov    %rax,-0x58(%rbp)
  file->size += n;
ffffffff8010c59f:	8b 55 e0             	mov    -0x20(%rbp),%edx
ffffffff8010c5a2:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
ffffffff8010c5a6:	03 50 08             	add    0x8(%rax),%edx
ffffffff8010c5a9:	89 50 08             	mov    %edx,0x8(%rax)
  ip->size += n;
ffffffff8010c5ac:	8b 55 e0             	mov    -0x20(%rbp),%edx
ffffffff8010c5af:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
ffffffff8010c5b3:	03 90 9c 00 00 00    	add    0x9c(%rax),%edx
ffffffff8010c5b9:	89 90 9c 00 00 00    	mov    %edx,0x9c(%rax)
  for (int i = 0; i < 4; i++) {
ffffffff8010c5bf:	c7 45 a4 00 00 00 00 	movl   $0x0,-0x5c(%rbp)
ffffffff8010c5c6:	83 7d a4 04          	cmpl   $0x4,-0x5c(%rbp)
ffffffff8010c5ca:	0f 8d 44 00 00 00    	jge    ffffffff8010c614 <writei+0x2e4>
    file->data[i].startblkno = ip->data[i].startblkno;
ffffffff8010c5d0:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
ffffffff8010c5d4:	48 63 4d a4          	movslq -0x5c(%rbp),%rcx
ffffffff8010c5d8:	8b 94 c8 a0 00 00 00 	mov    0xa0(%rax,%rcx,8),%edx
ffffffff8010c5df:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
ffffffff8010c5e3:	48 63 4d a4          	movslq -0x5c(%rbp),%rcx
ffffffff8010c5e7:	89 54 c8 0c          	mov    %edx,0xc(%rax,%rcx,8)
    file->data[i].nblocks = ip->data[i].nblocks;
ffffffff8010c5eb:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
ffffffff8010c5ef:	48 63 4d a4          	movslq -0x5c(%rbp),%rcx
ffffffff8010c5f3:	8b 94 c8 a4 00 00 00 	mov    0xa4(%rax,%rcx,8),%edx
ffffffff8010c5fa:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
ffffffff8010c5fe:	48 63 4d a4          	movslq -0x5c(%rbp),%rcx
ffffffff8010c602:	89 54 c8 10          	mov    %edx,0x10(%rax,%rcx,8)
  for (int i = 0; i < 4; i++) {
ffffffff8010c606:	8b 45 a4             	mov    -0x5c(%rbp),%eax
ffffffff8010c609:	83 c0 01             	add    $0x1,%eax
ffffffff8010c60c:	89 45 a4             	mov    %eax,-0x5c(%rbp)
ffffffff8010c60f:	e9 b2 ff ff ff       	jmpq   ffffffff8010c5c6 <writei+0x296>
  }
  log_write(buf);
ffffffff8010c614:	48 8b 7d d0          	mov    -0x30(%rbp),%rdi
ffffffff8010c618:	e8 c3 2e 00 00       	callq  ffffffff8010f4e0 <log_write>
  brelse(buf);
ffffffff8010c61d:	48 8b 7d d0          	mov    -0x30(%rbp),%rdi
ffffffff8010c621:	e8 1a da ff ff       	callq  ffffffff8010a040 <brelse>
  commit_trans();
ffffffff8010c626:	31 c0                	xor    %eax,%eax
ffffffff8010c628:	88 c1                	mov    %al,%cl
ffffffff8010c62a:	88 c8                	mov    %cl,%al
ffffffff8010c62c:	e8 ff 31 00 00       	callq  ffffffff8010f830 <commit_trans>
  return n;
ffffffff8010c631:	8b 55 e0             	mov    -0x20(%rbp),%edx
ffffffff8010c634:	89 55 fc             	mov    %edx,-0x4(%rbp)
}
ffffffff8010c637:	8b 45 fc             	mov    -0x4(%rbp),%eax
ffffffff8010c63a:	48 81 c4 80 00 00 00 	add    $0x80,%rsp
ffffffff8010c641:	5d                   	pop    %rbp
ffffffff8010c642:	c3                   	retq   
ffffffff8010c643:	66 66 66 66 2e 0f 1f 	data16 data16 data16 nopw %cs:0x0(%rax,%rax,1)
ffffffff8010c64a:	84 00 00 00 00 00 

ffffffff8010c650 <namecmp>:
//PAGEBREAK!
// Directories

int
namecmp(const char *s, const char *t)
{
ffffffff8010c650:	55                   	push   %rbp
ffffffff8010c651:	48 89 e5             	mov    %rsp,%rbp
ffffffff8010c654:	48 83 ec 20          	sub    $0x20,%rsp
ffffffff8010c658:	b8 0e 00 00 00       	mov    $0xe,%eax
ffffffff8010c65d:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
ffffffff8010c661:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  return strncmp(s, t, DIRSIZ);
ffffffff8010c665:	48 8b 7d f8          	mov    -0x8(%rbp),%rdi
ffffffff8010c669:	48 8b 75 f0          	mov    -0x10(%rbp),%rsi
ffffffff8010c66d:	ba 0e 00 00 00       	mov    $0xe,%edx
ffffffff8010c672:	89 45 ec             	mov    %eax,-0x14(%rbp)
ffffffff8010c675:	e8 46 eb ff ff       	callq  ffffffff8010b1c0 <strncmp>
ffffffff8010c67a:	48 83 c4 20          	add    $0x20,%rsp
ffffffff8010c67e:	5d                   	pop    %rbp
ffffffff8010c67f:	c3                   	retq   

ffffffff8010c680 <dirlookup>:

// Look for a directory entry in a directory.
// If found, set *poff to byte offset of entry.
struct inode*
dirlookup(struct inode *dp, char *name, uint *poff)
{
ffffffff8010c680:	55                   	push   %rbp
ffffffff8010c681:	48 89 e5             	mov    %rsp,%rbp
ffffffff8010c684:	48 83 ec 40          	sub    $0x40,%rsp
ffffffff8010c688:	48 89 7d f0          	mov    %rdi,-0x10(%rbp)
ffffffff8010c68c:	48 89 75 e8          	mov    %rsi,-0x18(%rbp)
ffffffff8010c690:	48 89 55 e0          	mov    %rdx,-0x20(%rbp)
  uint off, inum;
  struct dirent de;

  if(dp->type != T_DIR)
ffffffff8010c694:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
ffffffff8010c698:	0f bf 82 94 00 00 00 	movswl 0x94(%rdx),%eax
ffffffff8010c69f:	83 f8 01             	cmp    $0x1,%eax
ffffffff8010c6a2:	0f 84 0c 00 00 00    	je     ffffffff8010c6b4 <dirlookup+0x34>
    panic("dirlookup not DIR");
ffffffff8010c6a8:	48 c7 c7 1f 06 11 80 	mov    $0xffffffff8011061f,%rdi
ffffffff8010c6af:	e8 bc 47 ff ff       	callq  ffffffff80100e70 <panic>

  for(off = 0; off < dp->size; off += sizeof(de)){
ffffffff8010c6b4:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%rbp)
ffffffff8010c6bb:	8b 45 dc             	mov    -0x24(%rbp),%eax
ffffffff8010c6be:	48 8b 4d f0          	mov    -0x10(%rbp),%rcx
ffffffff8010c6c2:	3b 81 9c 00 00 00    	cmp    0x9c(%rcx),%eax
ffffffff8010c6c8:	0f 83 b8 00 00 00    	jae    ffffffff8010c786 <dirlookup+0x106>
ffffffff8010c6ce:	b8 10 00 00 00       	mov    $0x10,%eax
ffffffff8010c6d3:	48 8d 4d c8          	lea    -0x38(%rbp),%rcx
    if(readi(dp, (char*)&de, off, sizeof(de)) != sizeof(de))
ffffffff8010c6d7:	48 8b 7d f0          	mov    -0x10(%rbp),%rdi
ffffffff8010c6db:	8b 55 dc             	mov    -0x24(%rbp),%edx
ffffffff8010c6de:	be 10 00 00 00       	mov    $0x10,%esi
ffffffff8010c6e3:	89 75 c4             	mov    %esi,-0x3c(%rbp)
ffffffff8010c6e6:	48 89 ce             	mov    %rcx,%rsi
ffffffff8010c6e9:	8b 4d c4             	mov    -0x3c(%rbp),%ecx
ffffffff8010c6ec:	89 45 c0             	mov    %eax,-0x40(%rbp)
ffffffff8010c6ef:	e8 dc f5 ff ff       	callq  ffffffff8010bcd0 <readi>
ffffffff8010c6f4:	48 63 f0             	movslq %eax,%rsi
ffffffff8010c6f7:	48 83 fe 10          	cmp    $0x10,%rsi
ffffffff8010c6fb:	0f 84 0c 00 00 00    	je     ffffffff8010c70d <dirlookup+0x8d>
      panic("dirlink read");
ffffffff8010c701:	48 c7 c7 31 06 11 80 	mov    $0xffffffff80110631,%rdi
ffffffff8010c708:	e8 63 47 ff ff       	callq  ffffffff80100e70 <panic>
    if(de.inum == 0)
ffffffff8010c70d:	0f b7 45 c8          	movzwl -0x38(%rbp),%eax
ffffffff8010c711:	83 f8 00             	cmp    $0x0,%eax
ffffffff8010c714:	0f 85 05 00 00 00    	jne    ffffffff8010c71f <dirlookup+0x9f>
      continue;
ffffffff8010c71a:	e9 54 00 00 00       	jmpq   ffffffff8010c773 <dirlookup+0xf3>
ffffffff8010c71f:	48 8d 45 c8          	lea    -0x38(%rbp),%rax
    if(namecmp(name, de.name) == 0){
ffffffff8010c723:	48 8b 7d e8          	mov    -0x18(%rbp),%rdi
ffffffff8010c727:	48 83 c0 02          	add    $0x2,%rax
ffffffff8010c72b:	48 89 c6             	mov    %rax,%rsi
ffffffff8010c72e:	e8 1d ff ff ff       	callq  ffffffff8010c650 <namecmp>
ffffffff8010c733:	83 f8 00             	cmp    $0x0,%eax
ffffffff8010c736:	0f 85 32 00 00 00    	jne    ffffffff8010c76e <dirlookup+0xee>
      // entry matches path element
      if(poff)
ffffffff8010c73c:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
ffffffff8010c741:	0f 84 09 00 00 00    	je     ffffffff8010c750 <dirlookup+0xd0>
        *poff = off;
ffffffff8010c747:	8b 45 dc             	mov    -0x24(%rbp),%eax
ffffffff8010c74a:	48 8b 4d e0          	mov    -0x20(%rbp),%rcx
ffffffff8010c74e:	89 01                	mov    %eax,(%rcx)
      inum = de.inum;
ffffffff8010c750:	0f b7 45 c8          	movzwl -0x38(%rbp),%eax
ffffffff8010c754:	89 45 d8             	mov    %eax,-0x28(%rbp)
      return iget(dp->dev, inum);
ffffffff8010c757:	48 8b 4d f0          	mov    -0x10(%rbp),%rcx
ffffffff8010c75b:	8b 39                	mov    (%rcx),%edi
ffffffff8010c75d:	8b 75 d8             	mov    -0x28(%rbp),%esi
ffffffff8010c760:	e8 3b 00 00 00       	callq  ffffffff8010c7a0 <iget>
ffffffff8010c765:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
ffffffff8010c769:	e9 20 00 00 00       	jmpq   ffffffff8010c78e <dirlookup+0x10e>
    }
  }
ffffffff8010c76e:	e9 00 00 00 00       	jmpq   ffffffff8010c773 <dirlookup+0xf3>
  for(off = 0; off < dp->size; off += sizeof(de)){
ffffffff8010c773:	8b 45 dc             	mov    -0x24(%rbp),%eax
ffffffff8010c776:	89 c1                	mov    %eax,%ecx
ffffffff8010c778:	48 83 c1 10          	add    $0x10,%rcx
ffffffff8010c77c:	89 c8                	mov    %ecx,%eax
ffffffff8010c77e:	89 45 dc             	mov    %eax,-0x24(%rbp)
ffffffff8010c781:	e9 35 ff ff ff       	jmpq   ffffffff8010c6bb <dirlookup+0x3b>

  return 0;
ffffffff8010c786:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
ffffffff8010c78d:	00 
}
ffffffff8010c78e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
ffffffff8010c792:	48 83 c4 40          	add    $0x40,%rsp
ffffffff8010c796:	5d                   	pop    %rbp
ffffffff8010c797:	c3                   	retq   
ffffffff8010c798:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
ffffffff8010c79f:	00 

ffffffff8010c7a0 <iget>:
{
ffffffff8010c7a0:	55                   	push   %rbp
ffffffff8010c7a1:	48 89 e5             	mov    %rsp,%rbp
ffffffff8010c7a4:	48 83 ec 30          	sub    $0x30,%rsp
ffffffff8010c7a8:	89 7d f4             	mov    %edi,-0xc(%rbp)
ffffffff8010c7ab:	89 75 f0             	mov    %esi,-0x10(%rbp)
  acquire(&icache.lock);
ffffffff8010c7ae:	48 c7 c7 60 27 20 83 	mov    $0xffffffff83202760,%rdi
ffffffff8010c7b5:	e8 06 90 ff ff       	callq  ffffffff801057c0 <acquire>
  empty = 0;
ffffffff8010c7ba:	48 c7 45 e0 00 00 00 	movq   $0x0,-0x20(%rbp)
ffffffff8010c7c1:	00 
  for(ip = &icache.inode[0]; ip < &icache.inode[NINODE]; ip++){
ffffffff8010c7c2:	48 c7 45 e8 c8 27 20 	movq   $0xffffffff832027c8,-0x18(%rbp)
ffffffff8010c7c9:	83 
ffffffff8010c7ca:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
ffffffff8010c7ce:	48 c7 c1 48 4d 20 83 	mov    $0xffffffff83204d48,%rcx
ffffffff8010c7d5:	48 29 c8             	sub    %rcx,%rax
ffffffff8010c7d8:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
ffffffff8010c7dc:	0f 83 91 00 00 00    	jae    ffffffff8010c873 <iget+0xd3>
ffffffff8010c7e2:	e9 00 00 00 00       	jmpq   ffffffff8010c7e7 <iget+0x47>
    if(ip->ref > 0 && ip->dev == dev && ip->inum == inum){
ffffffff8010c7e7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
ffffffff8010c7eb:	83 78 08 00          	cmpl   $0x0,0x8(%rax)
ffffffff8010c7ef:	0f 8e 45 00 00 00    	jle    ffffffff8010c83a <iget+0x9a>
ffffffff8010c7f5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
ffffffff8010c7f9:	8b 08                	mov    (%rax),%ecx
ffffffff8010c7fb:	3b 4d f4             	cmp    -0xc(%rbp),%ecx
ffffffff8010c7fe:	0f 85 36 00 00 00    	jne    ffffffff8010c83a <iget+0x9a>
ffffffff8010c804:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
ffffffff8010c808:	8b 48 04             	mov    0x4(%rax),%ecx
ffffffff8010c80b:	3b 4d f0             	cmp    -0x10(%rbp),%ecx
ffffffff8010c80e:	0f 85 26 00 00 00    	jne    ffffffff8010c83a <iget+0x9a>
      ip->ref++;
ffffffff8010c814:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
ffffffff8010c818:	8b 48 08             	mov    0x8(%rax),%ecx
ffffffff8010c81b:	83 c1 01             	add    $0x1,%ecx
ffffffff8010c81e:	89 48 08             	mov    %ecx,0x8(%rax)
      release(&icache.lock);
ffffffff8010c821:	48 c7 c7 60 27 20 83 	mov    $0xffffffff83202760,%rdi
ffffffff8010c828:	e8 d3 91 ff ff       	callq  ffffffff80105a00 <release>
      return ip;
ffffffff8010c82d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
ffffffff8010c831:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
ffffffff8010c835:	e9 98 00 00 00       	jmpq   ffffffff8010c8d2 <iget+0x132>
    if(empty == 0 && ip->ref == 0)    // Remember empty slot.
ffffffff8010c83a:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
ffffffff8010c83f:	0f 85 16 00 00 00    	jne    ffffffff8010c85b <iget+0xbb>
ffffffff8010c845:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
ffffffff8010c849:	83 78 08 00          	cmpl   $0x0,0x8(%rax)
ffffffff8010c84d:	0f 85 08 00 00 00    	jne    ffffffff8010c85b <iget+0xbb>
      empty = ip;
ffffffff8010c853:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
ffffffff8010c857:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  }
ffffffff8010c85b:	e9 00 00 00 00       	jmpq   ffffffff8010c860 <iget+0xc0>
  for(ip = &icache.inode[0]; ip < &icache.inode[NINODE]; ip++){
ffffffff8010c860:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
ffffffff8010c864:	48 05 c0 00 00 00    	add    $0xc0,%rax
ffffffff8010c86a:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
ffffffff8010c86e:	e9 57 ff ff ff       	jmpq   ffffffff8010c7ca <iget+0x2a>
  if(empty == 0)
ffffffff8010c873:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
ffffffff8010c878:	0f 85 0c 00 00 00    	jne    ffffffff8010c88a <iget+0xea>
    panic("iget: no inodes");
ffffffff8010c87e:	48 c7 c7 3e 06 11 80 	mov    $0xffffffff8011063e,%rdi
ffffffff8010c885:	e8 e6 45 ff ff       	callq  ffffffff80100e70 <panic>
  ip = empty;
ffffffff8010c88a:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
ffffffff8010c88e:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  ip->dev = dev;
ffffffff8010c892:	8b 4d f4             	mov    -0xc(%rbp),%ecx
ffffffff8010c895:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
ffffffff8010c899:	89 08                	mov    %ecx,(%rax)
  ip->inum = inum;
ffffffff8010c89b:	8b 4d f0             	mov    -0x10(%rbp),%ecx
ffffffff8010c89e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
ffffffff8010c8a2:	89 48 04             	mov    %ecx,0x4(%rax)
  ip->ref = 1;
ffffffff8010c8a5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
ffffffff8010c8a9:	c7 40 08 01 00 00 00 	movl   $0x1,0x8(%rax)
  ip->flags = 0;
ffffffff8010c8b0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
ffffffff8010c8b4:	c7 80 90 00 00 00 00 	movl   $0x0,0x90(%rax)
ffffffff8010c8bb:	00 00 00 
  release(&icache.lock);
ffffffff8010c8be:	48 c7 c7 60 27 20 83 	mov    $0xffffffff83202760,%rdi
ffffffff8010c8c5:	e8 36 91 ff ff       	callq  ffffffff80105a00 <release>
  return ip;
ffffffff8010c8ca:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
ffffffff8010c8ce:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
}
ffffffff8010c8d2:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
ffffffff8010c8d6:	48 83 c4 30          	add    $0x30,%rsp
ffffffff8010c8da:	5d                   	pop    %rbp
ffffffff8010c8db:	c3                   	retq   
ffffffff8010c8dc:	0f 1f 40 00          	nopl   0x0(%rax)

ffffffff8010c8e0 <namei>:
  return ip;
}

struct inode*
namei(char *path)
{
ffffffff8010c8e0:	55                   	push   %rbp
ffffffff8010c8e1:	48 89 e5             	mov    %rsp,%rbp
ffffffff8010c8e4:	48 83 ec 20          	sub    $0x20,%rsp
ffffffff8010c8e8:	31 c0                	xor    %eax,%eax
ffffffff8010c8ea:	48 8d 55 ea          	lea    -0x16(%rbp),%rdx
ffffffff8010c8ee:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  char name[DIRSIZ];
  return namex(path, 0, name);
ffffffff8010c8f2:	48 8b 7d f8          	mov    -0x8(%rbp),%rdi
ffffffff8010c8f6:	31 f6                	xor    %esi,%esi
ffffffff8010c8f8:	89 45 e4             	mov    %eax,-0x1c(%rbp)
ffffffff8010c8fb:	e8 10 00 00 00       	callq  ffffffff8010c910 <namex>
ffffffff8010c900:	48 83 c4 20          	add    $0x20,%rsp
ffffffff8010c904:	5d                   	pop    %rbp
ffffffff8010c905:	c3                   	retq   
ffffffff8010c906:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
ffffffff8010c90d:	00 00 00 

ffffffff8010c910 <namex>:
{
ffffffff8010c910:	55                   	push   %rbp
ffffffff8010c911:	48 89 e5             	mov    %rsp,%rbp
ffffffff8010c914:	48 83 ec 40          	sub    $0x40,%rsp
ffffffff8010c918:	48 89 7d f0          	mov    %rdi,-0x10(%rbp)
ffffffff8010c91c:	89 75 ec             	mov    %esi,-0x14(%rbp)
ffffffff8010c91f:	48 89 55 e0          	mov    %rdx,-0x20(%rbp)
  if(*path == '/')
ffffffff8010c923:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
ffffffff8010c927:	0f be 32             	movsbl (%rdx),%esi
ffffffff8010c92a:	83 fe 2f             	cmp    $0x2f,%esi
ffffffff8010c92d:	0f 85 1f 00 00 00    	jne    ffffffff8010c952 <namex+0x42>
ffffffff8010c933:	b8 01 00 00 00       	mov    $0x1,%eax
    ip = iget(ROOTDEV, ROOTINO);
ffffffff8010c938:	b9 01 00 00 00       	mov    $0x1,%ecx
ffffffff8010c93d:	89 cf                	mov    %ecx,%edi
ffffffff8010c93f:	89 ce                	mov    %ecx,%esi
ffffffff8010c941:	89 45 cc             	mov    %eax,-0x34(%rbp)
ffffffff8010c944:	e8 57 fe ff ff       	callq  ffffffff8010c7a0 <iget>
ffffffff8010c949:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
ffffffff8010c94d:	e9 18 00 00 00       	jmpq   ffffffff8010c96a <namex+0x5a>
    ip = idup(namei("/"));
ffffffff8010c952:	48 c7 c7 4e 06 11 80 	mov    $0xffffffff8011064e,%rdi
ffffffff8010c959:	e8 82 ff ff ff       	callq  ffffffff8010c8e0 <namei>
ffffffff8010c95e:	48 89 c7             	mov    %rax,%rdi
ffffffff8010c961:	e8 6a f5 ff ff       	callq  ffffffff8010bed0 <idup>
ffffffff8010c966:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  while((path = skipelem(path, name)) != 0){
ffffffff8010c96a:	e9 00 00 00 00       	jmpq   ffffffff8010c96f <namex+0x5f>
ffffffff8010c96f:	48 8b 7d f0          	mov    -0x10(%rbp),%rdi
ffffffff8010c973:	48 8b 75 e0          	mov    -0x20(%rbp),%rsi
ffffffff8010c977:	e8 24 01 00 00       	callq  ffffffff8010caa0 <skipelem>
ffffffff8010c97c:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
ffffffff8010c980:	48 83 f8 00          	cmp    $0x0,%rax
ffffffff8010c984:	0f 84 ad 00 00 00    	je     ffffffff8010ca37 <namex+0x127>
    iload(ip);
ffffffff8010c98a:	48 8b 7d d8          	mov    -0x28(%rbp),%rdi
ffffffff8010c98e:	e8 7d f5 ff ff       	callq  ffffffff8010bf10 <iload>
    if(ip->type != T_DIR){
ffffffff8010c993:	48 8b 7d d8          	mov    -0x28(%rbp),%rdi
ffffffff8010c997:	0f bf 87 94 00 00 00 	movswl 0x94(%rdi),%eax
ffffffff8010c99e:	83 f8 01             	cmp    $0x1,%eax
ffffffff8010c9a1:	0f 84 16 00 00 00    	je     ffffffff8010c9bd <namex+0xad>
      iput(ip);
ffffffff8010c9a7:	48 8b 7d d8          	mov    -0x28(%rbp),%rdi
ffffffff8010c9ab:	e8 e0 f6 ff ff       	callq  ffffffff8010c090 <iput>
      return 0;
ffffffff8010c9b0:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
ffffffff8010c9b7:	00 
ffffffff8010c9b8:	e9 a2 00 00 00       	jmpq   ffffffff8010ca5f <namex+0x14f>
    if(nameiparent && *path == '\0'){
ffffffff8010c9bd:	83 7d ec 00          	cmpl   $0x0,-0x14(%rbp)
ffffffff8010c9c1:	0f 84 1d 00 00 00    	je     ffffffff8010c9e4 <namex+0xd4>
ffffffff8010c9c7:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
ffffffff8010c9cb:	0f be 08             	movsbl (%rax),%ecx
ffffffff8010c9ce:	83 f9 00             	cmp    $0x0,%ecx
ffffffff8010c9d1:	0f 85 0d 00 00 00    	jne    ffffffff8010c9e4 <namex+0xd4>
      return ip;
ffffffff8010c9d7:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
ffffffff8010c9db:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
ffffffff8010c9df:	e9 7b 00 00 00       	jmpq   ffffffff8010ca5f <namex+0x14f>
ffffffff8010c9e4:	31 c0                	xor    %eax,%eax
ffffffff8010c9e6:	89 c1                	mov    %eax,%ecx
    if((next = dirlookup(ip, name, 0)) == 0){
ffffffff8010c9e8:	48 8b 7d d8          	mov    -0x28(%rbp),%rdi
ffffffff8010c9ec:	48 8b 75 e0          	mov    -0x20(%rbp),%rsi
ffffffff8010c9f0:	31 c0                	xor    %eax,%eax
ffffffff8010c9f2:	89 c2                	mov    %eax,%edx
ffffffff8010c9f4:	48 89 4d c0          	mov    %rcx,-0x40(%rbp)
ffffffff8010c9f8:	e8 83 fc ff ff       	callq  ffffffff8010c680 <dirlookup>
ffffffff8010c9fd:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
ffffffff8010ca01:	48 83 f8 00          	cmp    $0x0,%rax
ffffffff8010ca05:	0f 85 16 00 00 00    	jne    ffffffff8010ca21 <namex+0x111>
      iput(ip);
ffffffff8010ca0b:	48 8b 7d d8          	mov    -0x28(%rbp),%rdi
ffffffff8010ca0f:	e8 7c f6 ff ff       	callq  ffffffff8010c090 <iput>
      return 0;
ffffffff8010ca14:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
ffffffff8010ca1b:	00 
ffffffff8010ca1c:	e9 3e 00 00 00       	jmpq   ffffffff8010ca5f <namex+0x14f>
    iput(ip);
ffffffff8010ca21:	48 8b 7d d8          	mov    -0x28(%rbp),%rdi
ffffffff8010ca25:	e8 66 f6 ff ff       	callq  ffffffff8010c090 <iput>
    ip = next;
ffffffff8010ca2a:	48 8b 7d d0          	mov    -0x30(%rbp),%rdi
ffffffff8010ca2e:	48 89 7d d8          	mov    %rdi,-0x28(%rbp)
  while((path = skipelem(path, name)) != 0){
ffffffff8010ca32:	e9 38 ff ff ff       	jmpq   ffffffff8010c96f <namex+0x5f>
  if(nameiparent){
ffffffff8010ca37:	83 7d ec 00          	cmpl   $0x0,-0x14(%rbp)
ffffffff8010ca3b:	0f 84 16 00 00 00    	je     ffffffff8010ca57 <namex+0x147>
    iput(ip);
ffffffff8010ca41:	48 8b 7d d8          	mov    -0x28(%rbp),%rdi
ffffffff8010ca45:	e8 46 f6 ff ff       	callq  ffffffff8010c090 <iput>
    return 0;
ffffffff8010ca4a:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
ffffffff8010ca51:	00 
ffffffff8010ca52:	e9 08 00 00 00       	jmpq   ffffffff8010ca5f <namex+0x14f>
  return ip;
ffffffff8010ca57:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
ffffffff8010ca5b:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
}
ffffffff8010ca5f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
ffffffff8010ca63:	48 83 c4 40          	add    $0x40,%rsp
ffffffff8010ca67:	5d                   	pop    %rbp
ffffffff8010ca68:	c3                   	retq   
ffffffff8010ca69:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)

ffffffff8010ca70 <nameiparent>:
}

struct inode*
nameiparent(char *path, char *name)
{
ffffffff8010ca70:	55                   	push   %rbp
ffffffff8010ca71:	48 89 e5             	mov    %rsp,%rbp
ffffffff8010ca74:	48 83 ec 20          	sub    $0x20,%rsp
ffffffff8010ca78:	b8 01 00 00 00       	mov    $0x1,%eax
ffffffff8010ca7d:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
ffffffff8010ca81:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  return namex(path, 1, name);
ffffffff8010ca85:	48 8b 7d f8          	mov    -0x8(%rbp),%rdi
ffffffff8010ca89:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
ffffffff8010ca8d:	be 01 00 00 00       	mov    $0x1,%esi
ffffffff8010ca92:	89 45 ec             	mov    %eax,-0x14(%rbp)
ffffffff8010ca95:	e8 76 fe ff ff       	callq  ffffffff8010c910 <namex>
ffffffff8010ca9a:	48 83 c4 20          	add    $0x20,%rsp
ffffffff8010ca9e:	5d                   	pop    %rbp
ffffffff8010ca9f:	c3                   	retq   

ffffffff8010caa0 <skipelem>:
{
ffffffff8010caa0:	55                   	push   %rbp
ffffffff8010caa1:	48 89 e5             	mov    %rsp,%rbp
ffffffff8010caa4:	48 83 ec 40          	sub    $0x40,%rsp
ffffffff8010caa8:	48 89 7d f0          	mov    %rdi,-0x10(%rbp)
ffffffff8010caac:	48 89 75 e8          	mov    %rsi,-0x18(%rbp)
  while(*path == '/')
ffffffff8010cab0:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
ffffffff8010cab4:	0f be 08             	movsbl (%rax),%ecx
ffffffff8010cab7:	83 f9 2f             	cmp    $0x2f,%ecx
ffffffff8010caba:	0f 85 11 00 00 00    	jne    ffffffff8010cad1 <skipelem+0x31>
    path++;
ffffffff8010cac0:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
ffffffff8010cac4:	48 83 c0 01          	add    $0x1,%rax
ffffffff8010cac8:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  while(*path == '/')
ffffffff8010cacc:	e9 df ff ff ff       	jmpq   ffffffff8010cab0 <skipelem+0x10>
  if(*path == 0)
ffffffff8010cad1:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
ffffffff8010cad5:	0f be 08             	movsbl (%rax),%ecx
ffffffff8010cad8:	83 f9 00             	cmp    $0x0,%ecx
ffffffff8010cadb:	0f 85 0d 00 00 00    	jne    ffffffff8010caee <skipelem+0x4e>
    return 0;
ffffffff8010cae1:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
ffffffff8010cae8:	00 
ffffffff8010cae9:	e9 db 00 00 00       	jmpq   ffffffff8010cbc9 <skipelem+0x129>
  s = path;
ffffffff8010caee:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
ffffffff8010caf2:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
ffffffff8010caf6:	31 c0                	xor    %eax,%eax
ffffffff8010caf8:	88 c1                	mov    %al,%cl
  while(*path != '/' && *path != 0)
ffffffff8010cafa:	48 8b 55 f0          	mov    -0x10(%rbp),%rdx
ffffffff8010cafe:	0f be 02             	movsbl (%rdx),%eax
ffffffff8010cb01:	83 f8 2f             	cmp    $0x2f,%eax
ffffffff8010cb04:	88 4d db             	mov    %cl,-0x25(%rbp)
ffffffff8010cb07:	0f 84 10 00 00 00    	je     ffffffff8010cb1d <skipelem+0x7d>
ffffffff8010cb0d:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
ffffffff8010cb11:	0f be 08             	movsbl (%rax),%ecx
ffffffff8010cb14:	83 f9 00             	cmp    $0x0,%ecx
ffffffff8010cb17:	0f 95 c2             	setne  %dl
ffffffff8010cb1a:	88 55 db             	mov    %dl,-0x25(%rbp)
ffffffff8010cb1d:	8a 45 db             	mov    -0x25(%rbp),%al
ffffffff8010cb20:	a8 01                	test   $0x1,%al
ffffffff8010cb22:	0f 85 05 00 00 00    	jne    ffffffff8010cb2d <skipelem+0x8d>
ffffffff8010cb28:	e9 11 00 00 00       	jmpq   ffffffff8010cb3e <skipelem+0x9e>
    path++;
ffffffff8010cb2d:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
ffffffff8010cb31:	48 83 c0 01          	add    $0x1,%rax
ffffffff8010cb35:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  while(*path != '/' && *path != 0)
ffffffff8010cb39:	e9 b8 ff ff ff       	jmpq   ffffffff8010caf6 <skipelem+0x56>
  len = path - s;
ffffffff8010cb3e:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
ffffffff8010cb42:	48 8b 4d e0          	mov    -0x20(%rbp),%rcx
ffffffff8010cb46:	48 29 c8             	sub    %rcx,%rax
ffffffff8010cb49:	89 c2                	mov    %eax,%edx
ffffffff8010cb4b:	89 55 dc             	mov    %edx,-0x24(%rbp)
  if(len >= DIRSIZ)
ffffffff8010cb4e:	83 7d dc 0e          	cmpl   $0xe,-0x24(%rbp)
ffffffff8010cb52:	0f 8c 23 00 00 00    	jl     ffffffff8010cb7b <skipelem+0xdb>
ffffffff8010cb58:	b8 0e 00 00 00       	mov    $0xe,%eax
    memmove(name, s, DIRSIZ);
ffffffff8010cb5d:	48 8b 7d e8          	mov    -0x18(%rbp),%rdi
ffffffff8010cb61:	48 8b 75 e0          	mov    -0x20(%rbp),%rsi
ffffffff8010cb65:	ba 0e 00 00 00       	mov    $0xe,%edx
ffffffff8010cb6a:	89 45 d4             	mov    %eax,-0x2c(%rbp)
ffffffff8010cb6d:	e8 1e e5 ff ff       	callq  ffffffff8010b090 <memmove>
ffffffff8010cb72:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
ffffffff8010cb76:	e9 20 00 00 00       	jmpq   ffffffff8010cb9b <skipelem+0xfb>
    memmove(name, s, len);
ffffffff8010cb7b:	48 8b 7d e8          	mov    -0x18(%rbp),%rdi
ffffffff8010cb7f:	48 8b 75 e0          	mov    -0x20(%rbp),%rsi
ffffffff8010cb83:	8b 55 dc             	mov    -0x24(%rbp),%edx
ffffffff8010cb86:	e8 05 e5 ff ff       	callq  ffffffff8010b090 <memmove>
    name[len] = 0;
ffffffff8010cb8b:	48 8b 75 e8          	mov    -0x18(%rbp),%rsi
ffffffff8010cb8f:	48 63 7d dc          	movslq -0x24(%rbp),%rdi
ffffffff8010cb93:	c6 04 3e 00          	movb   $0x0,(%rsi,%rdi,1)
ffffffff8010cb97:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
  while(*path == '/')
ffffffff8010cb9b:	e9 00 00 00 00       	jmpq   ffffffff8010cba0 <skipelem+0x100>
ffffffff8010cba0:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
ffffffff8010cba4:	0f be 08             	movsbl (%rax),%ecx
ffffffff8010cba7:	83 f9 2f             	cmp    $0x2f,%ecx
ffffffff8010cbaa:	0f 85 11 00 00 00    	jne    ffffffff8010cbc1 <skipelem+0x121>
    path++;
ffffffff8010cbb0:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
ffffffff8010cbb4:	48 83 c0 01          	add    $0x1,%rax
ffffffff8010cbb8:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  while(*path == '/')
ffffffff8010cbbc:	e9 df ff ff ff       	jmpq   ffffffff8010cba0 <skipelem+0x100>
  return path;
ffffffff8010cbc1:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
ffffffff8010cbc5:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
}
ffffffff8010cbc9:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
ffffffff8010cbcd:	48 83 c4 40          	add    $0x40,%rsp
ffffffff8010cbd1:	5d                   	pop    %rbp
ffffffff8010cbd2:	c3                   	retq   
ffffffff8010cbd3:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
ffffffff8010cbda:	00 00 00 
ffffffff8010cbdd:	0f 1f 00             	nopl   (%rax)

ffffffff8010cbe0 <gftinit>:

/**
 * Initialize the global open file description table.
 */
void gftinit(void)
{
ffffffff8010cbe0:	55                   	push   %rbp
ffffffff8010cbe1:	48 89 e5             	mov    %rsp,%rbp
  initlock(&global_files.lock, "gft_lock");
ffffffff8010cbe4:	48 c7 c7 10 4e 20 83 	mov    $0xffffffff83204e10,%rdi
ffffffff8010cbeb:	48 c7 c6 50 06 11 80 	mov    $0xffffffff80110650,%rsi
ffffffff8010cbf2:	e8 89 8b ff ff       	callq  ffffffff80105780 <initlock>
}
ffffffff8010cbf7:	5d                   	pop    %rbp
ffffffff8010cbf8:	c3                   	retq   
ffffffff8010cbf9:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)

ffffffff8010cc00 <kernel_sys_dup>:

// Needs lock in helper
int
kernel_sys_dup(int fd)
{
ffffffff8010cc00:	55                   	push   %rbp
ffffffff8010cc01:	48 89 e5             	mov    %rsp,%rbp
ffffffff8010cc04:	48 83 ec 30          	sub    $0x30,%rsp
ffffffff8010cc08:	89 7d f8             	mov    %edi,-0x8(%rbp)
  struct proc* this_proc = myproc();
ffffffff8010cc0b:	e8 20 01 00 00       	callq  ffffffff8010cd30 <myproc>
ffffffff8010cc10:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  struct open_file* this_file = &(this_proc->open_files[fd]);
ffffffff8010cc14:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
ffffffff8010cc18:	48 83 c0 38          	add    $0x38,%rax
ffffffff8010cc1c:	48 63 4d f8          	movslq -0x8(%rbp),%rcx
ffffffff8010cc20:	48 6b c9 0b          	imul   $0xb,%rcx,%rcx
ffffffff8010cc24:	48 01 c8             	add    %rcx,%rax
ffffffff8010cc27:	48 89 45 e8          	mov    %rax,-0x18(%rbp)

  // get a new fd
  int idx = next_free_table_index(this_proc);
ffffffff8010cc2b:	48 8b 7d f0          	mov    -0x10(%rbp),%rdi
ffffffff8010cc2f:	e8 1c 01 00 00       	callq  ffffffff8010cd50 <next_free_table_index>
ffffffff8010cc34:	89 c2                	mov    %eax,%edx
ffffffff8010cc36:	89 55 e4             	mov    %edx,-0x1c(%rbp)
  if (idx == -1) {
ffffffff8010cc39:	83 7d e4 ff          	cmpl   $0xffffffff,-0x1c(%rbp)
ffffffff8010cc3d:	0f 85 0c 00 00 00    	jne    ffffffff8010cc4f <kernel_sys_dup+0x4f>
    // no more space to open new fd
    return -1;
ffffffff8010cc43:	c7 45 fc ff ff ff ff 	movl   $0xffffffff,-0x4(%rbp)
ffffffff8010cc4a:	e9 cd 00 00 00       	jmpq   ffffffff8010cd1c <kernel_sys_dup+0x11c>
  }

  // copy over fields
  struct open_file* dup_file = &this_proc->open_files[idx];
ffffffff8010cc4f:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
ffffffff8010cc53:	48 83 c0 38          	add    $0x38,%rax
ffffffff8010cc57:	48 63 4d e4          	movslq -0x1c(%rbp),%rcx
ffffffff8010cc5b:	48 6b c9 0b          	imul   $0xb,%rcx,%rcx
ffffffff8010cc5f:	48 01 c8             	add    %rcx,%rax
ffffffff8010cc62:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
  dup_file->type = this_file->type;
ffffffff8010cc66:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
ffffffff8010cc6a:	8a 50 0a             	mov    0xa(%rax),%dl
ffffffff8010cc6d:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
ffffffff8010cc71:	88 50 0a             	mov    %dl,0xa(%rax)
  dup_file->mode = this_file->mode;
ffffffff8010cc74:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
ffffffff8010cc78:	66 8b 70 08          	mov    0x8(%rax),%si
ffffffff8010cc7c:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
ffffffff8010cc80:	66 89 70 08          	mov    %si,0x8(%rax)

  if (dup_file->type == FILE_INODE) {
ffffffff8010cc84:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
ffffffff8010cc88:	0f be 78 0a          	movsbl 0xa(%rax),%edi
ffffffff8010cc8c:	83 ff 01             	cmp    $0x1,%edi
ffffffff8010cc8f:	0f 85 3e 00 00 00    	jne    ffffffff8010ccd3 <kernel_sys_dup+0xd3>
    // They share the pointer in the global file table.
    dup_file->file_desc = this_file->file_desc;
ffffffff8010cc95:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
ffffffff8010cc99:	48 8b 00             	mov    (%rax),%rax
ffffffff8010cc9c:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
ffffffff8010cca0:	48 89 01             	mov    %rax,(%rcx)

    acquire(&global_files.lock);
ffffffff8010cca3:	48 c7 c7 10 4e 20 83 	mov    $0xffffffff83204e10,%rdi
ffffffff8010ccaa:	e8 11 8b ff ff       	callq  ffffffff801057c0 <acquire>
    dup_file->file_desc->refcount++;
ffffffff8010ccaf:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
ffffffff8010ccb3:	48 8b 00             	mov    (%rax),%rax
ffffffff8010ccb6:	66 8b 50 0c          	mov    0xc(%rax),%dx
ffffffff8010ccba:	66 83 c2 01          	add    $0x1,%dx
ffffffff8010ccbe:	66 89 50 0c          	mov    %dx,0xc(%rax)
    release(&global_files.lock);
ffffffff8010ccc2:	48 c7 c7 10 4e 20 83 	mov    $0xffffffff83204e10,%rdi
ffffffff8010ccc9:	e8 32 8d ff ff       	callq  ffffffff80105a00 <release>
  } else if (dup_file->type == FILE_PIPE) {
ffffffff8010ccce:	e9 43 00 00 00       	jmpq   ffffffff8010cd16 <kernel_sys_dup+0x116>
ffffffff8010ccd3:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
ffffffff8010ccd7:	0f be 48 0a          	movsbl 0xa(%rax),%ecx
ffffffff8010ccdb:	83 f9 02             	cmp    $0x2,%ecx
ffffffff8010ccde:	0f 85 1c 00 00 00    	jne    ffffffff8010cd00 <kernel_sys_dup+0x100>
    pipe_dup(this_file);
ffffffff8010cce4:	48 8b 7d e8          	mov    -0x18(%rbp),%rdi
ffffffff8010cce8:	e8 e3 00 00 00       	callq  ffffffff8010cdd0 <pipe_dup>
    dup_file->pipe = this_file->pipe;
ffffffff8010cced:	48 8b 7d e8          	mov    -0x18(%rbp),%rdi
ffffffff8010ccf1:	48 8b 3f             	mov    (%rdi),%rdi
ffffffff8010ccf4:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
ffffffff8010ccf8:	48 89 38             	mov    %rdi,(%rax)
  } else {
ffffffff8010ccfb:	e9 11 00 00 00       	jmpq   ffffffff8010cd11 <kernel_sys_dup+0x111>
    assert(false);
ffffffff8010cd00:	e9 00 00 00 00       	jmpq   ffffffff8010cd05 <kernel_sys_dup+0x105>
ffffffff8010cd05:	48 c7 c7 15 fc 10 80 	mov    $0xffffffff8010fc15,%rdi
ffffffff8010cd0c:	e8 5f 41 ff ff       	callq  ffffffff80100e70 <panic>
ffffffff8010cd11:	e9 00 00 00 00       	jmpq   ffffffff8010cd16 <kernel_sys_dup+0x116>
  }

  return idx;
ffffffff8010cd16:	8b 45 e4             	mov    -0x1c(%rbp),%eax
ffffffff8010cd19:	89 45 fc             	mov    %eax,-0x4(%rbp)
}
ffffffff8010cd1c:	8b 45 fc             	mov    -0x4(%rbp),%eax
ffffffff8010cd1f:	48 83 c4 30          	add    $0x30,%rsp
ffffffff8010cd23:	5d                   	pop    %rbp
ffffffff8010cd24:	c3                   	retq   
ffffffff8010cd25:	66 66 2e 0f 1f 84 00 	data16 nopw %cs:0x0(%rax,%rax,1)
ffffffff8010cd2c:	00 00 00 00 

ffffffff8010cd30 <myproc>:
{
ffffffff8010cd30:	55                   	push   %rbp
ffffffff8010cd31:	48 89 e5             	mov    %rsp,%rbp
  return mycpu()->proc;
ffffffff8010cd34:	e8 87 12 00 00       	callq  ffffffff8010dfc0 <mycpu>
ffffffff8010cd39:	48 8b 80 d0 00 00 00 	mov    0xd0(%rax),%rax
ffffffff8010cd40:	5d                   	pop    %rbp
ffffffff8010cd41:	c3                   	retq   
ffffffff8010cd42:	66 66 66 66 66 2e 0f 	data16 data16 data16 data16 nopw %cs:0x0(%rax,%rax,1)
ffffffff8010cd49:	1f 84 00 00 00 00 00 

ffffffff8010cd50 <next_free_table_index>:
{
ffffffff8010cd50:	55                   	push   %rbp
ffffffff8010cd51:	48 89 e5             	mov    %rsp,%rbp
ffffffff8010cd54:	48 83 ec 18          	sub    $0x18,%rsp
ffffffff8010cd58:	48 89 7d f0          	mov    %rdi,-0x10(%rbp)
  for (size_t i = 0; i < NOFILE; i++) {
ffffffff8010cd5c:	48 c7 45 e8 00 00 00 	movq   $0x0,-0x18(%rbp)
ffffffff8010cd63:	00 
ffffffff8010cd64:	48 83 7d e8 10       	cmpq   $0x10,-0x18(%rbp)
ffffffff8010cd69:	0f 83 40 00 00 00    	jae    ffffffff8010cdaf <next_free_table_index+0x5f>
    if (proc->open_files[i].type == FILE_UNUSED) {
ffffffff8010cd6f:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
ffffffff8010cd73:	48 83 c0 38          	add    $0x38,%rax
ffffffff8010cd77:	48 6b 4d e8 0b       	imul   $0xb,-0x18(%rbp),%rcx
ffffffff8010cd7c:	48 01 c8             	add    %rcx,%rax
ffffffff8010cd7f:	0f be 50 0a          	movsbl 0xa(%rax),%edx
ffffffff8010cd83:	83 fa 00             	cmp    $0x0,%edx
ffffffff8010cd86:	0f 85 0d 00 00 00    	jne    ffffffff8010cd99 <next_free_table_index+0x49>
      return i;
ffffffff8010cd8c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
ffffffff8010cd90:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
ffffffff8010cd94:	e9 1e 00 00 00       	jmpq   ffffffff8010cdb7 <next_free_table_index+0x67>
  }
ffffffff8010cd99:	e9 00 00 00 00       	jmpq   ffffffff8010cd9e <next_free_table_index+0x4e>
  for (size_t i = 0; i < NOFILE; i++) {
ffffffff8010cd9e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
ffffffff8010cda2:	48 83 c0 01          	add    $0x1,%rax
ffffffff8010cda6:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
ffffffff8010cdaa:	e9 b5 ff ff ff       	jmpq   ffffffff8010cd64 <next_free_table_index+0x14>
  return -1;
ffffffff8010cdaf:	48 c7 45 f8 ff ff ff 	movq   $0xffffffffffffffff,-0x8(%rbp)
ffffffff8010cdb6:	ff 
}
ffffffff8010cdb7:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
ffffffff8010cdbb:	48 83 c4 18          	add    $0x18,%rsp
ffffffff8010cdbf:	5d                   	pop    %rbp
ffffffff8010cdc0:	c3                   	retq   
ffffffff8010cdc1:	66 66 66 66 66 66 2e 	data16 data16 data16 data16 data16 nopw %cs:0x0(%rax,%rax,1)
ffffffff8010cdc8:	0f 1f 84 00 00 00 00 
ffffffff8010cdcf:	00 

ffffffff8010cdd0 <pipe_dup>:
{
ffffffff8010cdd0:	55                   	push   %rbp
ffffffff8010cdd1:	48 89 e5             	mov    %rsp,%rbp
ffffffff8010cdd4:	48 83 ec 10          	sub    $0x10,%rsp
ffffffff8010cdd8:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  acquire(&this_file->pipe->lock);
ffffffff8010cddc:	48 8b 7d f8          	mov    -0x8(%rbp),%rdi
ffffffff8010cde0:	48 8b 3f             	mov    (%rdi),%rdi
ffffffff8010cde3:	48 81 c7 00 08 00 00 	add    $0x800,%rdi
ffffffff8010cdea:	e8 d1 89 ff ff       	callq  ffffffff801057c0 <acquire>
  if (this_file->mode == O_RDONLY) {
ffffffff8010cdef:	48 8b 7d f8          	mov    -0x8(%rbp),%rdi
ffffffff8010cdf3:	0f bf 47 08          	movswl 0x8(%rdi),%eax
ffffffff8010cdf7:	83 f8 00             	cmp    $0x0,%eax
ffffffff8010cdfa:	0f 85 1b 00 00 00    	jne    ffffffff8010ce1b <pipe_dup+0x4b>
    this_file->pipe->r_refcount++;
ffffffff8010ce00:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
ffffffff8010ce04:	48 8b 00             	mov    (%rax),%rax
ffffffff8010ce07:	8a 88 6d 08 00 00    	mov    0x86d(%rax),%cl
ffffffff8010ce0d:	80 c1 01             	add    $0x1,%cl
ffffffff8010ce10:	88 88 6d 08 00 00    	mov    %cl,0x86d(%rax)
  } else if (this_file->mode == O_WRONLY) {
ffffffff8010ce16:	e9 2c 00 00 00       	jmpq   ffffffff8010ce47 <pipe_dup+0x77>
ffffffff8010ce1b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
ffffffff8010ce1f:	0f bf 48 08          	movswl 0x8(%rax),%ecx
ffffffff8010ce23:	83 f9 01             	cmp    $0x1,%ecx
ffffffff8010ce26:	0f 85 16 00 00 00    	jne    ffffffff8010ce42 <pipe_dup+0x72>
    this_file->pipe->w_refcount++;
ffffffff8010ce2c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
ffffffff8010ce30:	48 8b 00             	mov    (%rax),%rax
ffffffff8010ce33:	8a 88 6c 08 00 00    	mov    0x86c(%rax),%cl
ffffffff8010ce39:	80 c1 01             	add    $0x1,%cl
ffffffff8010ce3c:	88 88 6c 08 00 00    	mov    %cl,0x86c(%rax)
ffffffff8010ce42:	e9 00 00 00 00       	jmpq   ffffffff8010ce47 <pipe_dup+0x77>
  release(&this_file->pipe->lock);
ffffffff8010ce47:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
ffffffff8010ce4b:	48 8b 00             	mov    (%rax),%rax
ffffffff8010ce4e:	48 05 00 08 00 00    	add    $0x800,%rax
ffffffff8010ce54:	48 89 c7             	mov    %rax,%rdi
ffffffff8010ce57:	e8 a4 8b ff ff       	callq  ffffffff80105a00 <release>
}
ffffffff8010ce5c:	48 83 c4 10          	add    $0x10,%rsp
ffffffff8010ce60:	5d                   	pop    %rbp
ffffffff8010ce61:	c3                   	retq   
ffffffff8010ce62:	66 66 66 66 66 2e 0f 	data16 data16 data16 data16 nopw %cs:0x0(%rax,%rax,1)
ffffffff8010ce69:	1f 84 00 00 00 00 00 

ffffffff8010ce70 <kernel_sys_read>:

// Needs lock in helper
int
kernel_sys_read(int fd, char* read_buf, int num_bytes)
{
ffffffff8010ce70:	55                   	push   %rbp
ffffffff8010ce71:	48 89 e5             	mov    %rsp,%rbp
ffffffff8010ce74:	48 83 ec 30          	sub    $0x30,%rsp
ffffffff8010ce78:	89 7d f8             	mov    %edi,-0x8(%rbp)
ffffffff8010ce7b:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
ffffffff8010ce7f:	89 55 ec             	mov    %edx,-0x14(%rbp)
  struct proc* this_proc = myproc();
ffffffff8010ce82:	e8 a9 fe ff ff       	callq  ffffffff8010cd30 <myproc>
ffffffff8010ce87:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  struct open_file* this_file = &this_proc->open_files[fd];
ffffffff8010ce8b:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
ffffffff8010ce8f:	48 83 c0 38          	add    $0x38,%rax
ffffffff8010ce93:	48 63 75 f8          	movslq -0x8(%rbp),%rsi
ffffffff8010ce97:	48 6b f6 0b          	imul   $0xb,%rsi,%rsi
ffffffff8010ce9b:	48 01 f0             	add    %rsi,%rax
ffffffff8010ce9e:	48 89 45 d8          	mov    %rax,-0x28(%rbp)

  if (is_pipe(this_file)) {
ffffffff8010cea2:	48 8b 7d d8          	mov    -0x28(%rbp),%rdi
ffffffff8010cea6:	e8 d5 00 00 00       	callq  ffffffff8010cf80 <is_pipe>
ffffffff8010ceab:	a8 01                	test   $0x1,%al
ffffffff8010cead:	0f 85 05 00 00 00    	jne    ffffffff8010ceb8 <kernel_sys_read+0x48>
ffffffff8010ceb3:	e9 18 00 00 00       	jmpq   ffffffff8010ced0 <kernel_sys_read+0x60>
    return pipe_read(this_file, read_buf, num_bytes);
ffffffff8010ceb8:	48 8b 7d d8          	mov    -0x28(%rbp),%rdi
ffffffff8010cebc:	48 8b 75 f0          	mov    -0x10(%rbp),%rsi
ffffffff8010cec0:	8b 55 ec             	mov    -0x14(%rbp),%edx
ffffffff8010cec3:	e8 e8 00 00 00       	callq  ffffffff8010cfb0 <pipe_read>
ffffffff8010cec8:	89 45 fc             	mov    %eax,-0x4(%rbp)
ffffffff8010cecb:	e9 9f 00 00 00       	jmpq   ffffffff8010cf6f <kernel_sys_read+0xff>
  } else {
    // inode version

    if (!readable(this_file->mode)) {
ffffffff8010ced0:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
ffffffff8010ced4:	66 8b 48 08          	mov    0x8(%rax),%cx
ffffffff8010ced8:	0f bf f9             	movswl %cx,%edi
ffffffff8010cedb:	e8 80 02 00 00       	callq  ffffffff8010d160 <readable>
ffffffff8010cee0:	a8 01                	test   $0x1,%al
ffffffff8010cee2:	0f 85 0c 00 00 00    	jne    ffffffff8010cef4 <kernel_sys_read+0x84>
      return -1;
ffffffff8010cee8:	c7 45 fc ff ff ff ff 	movl   $0xffffffff,-0x4(%rbp)
ffffffff8010ceef:	e9 7b 00 00 00       	jmpq   ffffffff8010cf6f <kernel_sys_read+0xff>
    }

    acquiresleep(&this_file->file_desc->inode->lock);
ffffffff8010cef4:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
ffffffff8010cef8:	48 8b 00             	mov    (%rax),%rax
ffffffff8010cefb:	48 8b 00             	mov    (%rax),%rax
ffffffff8010cefe:	48 83 c0 10          	add    $0x10,%rax
ffffffff8010cf02:	48 89 c7             	mov    %rax,%rdi
ffffffff8010cf05:	e8 16 d5 ff ff       	callq  ffffffff8010a420 <acquiresleep>

    int read_bytes = readi(this_file->file_desc->inode,
ffffffff8010cf0a:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
ffffffff8010cf0e:	48 8b 00             	mov    (%rax),%rax
ffffffff8010cf11:	48 8b 38             	mov    (%rax),%rdi
     read_buf, this_file->file_desc->curr_offset, num_bytes);
ffffffff8010cf14:	48 8b 75 f0          	mov    -0x10(%rbp),%rsi
ffffffff8010cf18:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
ffffffff8010cf1c:	48 8b 00             	mov    (%rax),%rax
ffffffff8010cf1f:	8b 50 08             	mov    0x8(%rax),%edx
ffffffff8010cf22:	8b 4d ec             	mov    -0x14(%rbp),%ecx
    int read_bytes = readi(this_file->file_desc->inode,
ffffffff8010cf25:	e8 a6 ed ff ff       	callq  ffffffff8010bcd0 <readi>
ffffffff8010cf2a:	89 45 d4             	mov    %eax,-0x2c(%rbp)

    if (read_bytes == -1) {
ffffffff8010cf2d:	83 7d d4 ff          	cmpl   $0xffffffff,-0x2c(%rbp)
ffffffff8010cf31:	0f 85 0c 00 00 00    	jne    ffffffff8010cf43 <kernel_sys_read+0xd3>
      return -1;
ffffffff8010cf37:	c7 45 fc ff ff ff ff 	movl   $0xffffffff,-0x4(%rbp)
ffffffff8010cf3e:	e9 2c 00 00 00       	jmpq   ffffffff8010cf6f <kernel_sys_read+0xff>
    }

    this_file->file_desc->curr_offset += read_bytes;
ffffffff8010cf43:	8b 45 d4             	mov    -0x2c(%rbp),%eax
ffffffff8010cf46:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
ffffffff8010cf4a:	48 8b 09             	mov    (%rcx),%rcx
ffffffff8010cf4d:	03 41 08             	add    0x8(%rcx),%eax
ffffffff8010cf50:	89 41 08             	mov    %eax,0x8(%rcx)
    releasesleep(&this_file->file_desc->inode->lock);
ffffffff8010cf53:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
ffffffff8010cf57:	48 8b 09             	mov    (%rcx),%rcx
ffffffff8010cf5a:	48 8b 09             	mov    (%rcx),%rcx
ffffffff8010cf5d:	48 83 c1 10          	add    $0x10,%rcx
ffffffff8010cf61:	48 89 cf             	mov    %rcx,%rdi
ffffffff8010cf64:	e8 57 d5 ff ff       	callq  ffffffff8010a4c0 <releasesleep>

    return read_bytes;
ffffffff8010cf69:	8b 45 d4             	mov    -0x2c(%rbp),%eax
ffffffff8010cf6c:	89 45 fc             	mov    %eax,-0x4(%rbp)
  }
}
ffffffff8010cf6f:	8b 45 fc             	mov    -0x4(%rbp),%eax
ffffffff8010cf72:	48 83 c4 30          	add    $0x30,%rsp
ffffffff8010cf76:	5d                   	pop    %rbp
ffffffff8010cf77:	c3                   	retq   
ffffffff8010cf78:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
ffffffff8010cf7f:	00 

ffffffff8010cf80 <is_pipe>:
{
ffffffff8010cf80:	55                   	push   %rbp
ffffffff8010cf81:	48 89 e5             	mov    %rsp,%rbp
ffffffff8010cf84:	50                   	push   %rax
ffffffff8010cf85:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  return this_file->type == FILE_PIPE;
ffffffff8010cf89:	48 8b 7d f8          	mov    -0x8(%rbp),%rdi
ffffffff8010cf8d:	0f be 47 0a          	movsbl 0xa(%rdi),%eax
ffffffff8010cf91:	83 f8 02             	cmp    $0x2,%eax
ffffffff8010cf94:	0f 94 c1             	sete   %cl
ffffffff8010cf97:	80 e1 01             	and    $0x1,%cl
ffffffff8010cf9a:	0f b6 c1             	movzbl %cl,%eax
ffffffff8010cf9d:	48 83 c4 08          	add    $0x8,%rsp
ffffffff8010cfa1:	5d                   	pop    %rbp
ffffffff8010cfa2:	c3                   	retq   
ffffffff8010cfa3:	66 66 66 66 2e 0f 1f 	data16 data16 data16 nopw %cs:0x0(%rax,%rax,1)
ffffffff8010cfaa:	84 00 00 00 00 00 

ffffffff8010cfb0 <pipe_read>:
{
ffffffff8010cfb0:	55                   	push   %rbp
ffffffff8010cfb1:	48 89 e5             	mov    %rsp,%rbp
ffffffff8010cfb4:	48 83 ec 30          	sub    $0x30,%rsp
ffffffff8010cfb8:	48 89 7d f0          	mov    %rdi,-0x10(%rbp)
ffffffff8010cfbc:	48 89 75 e8          	mov    %rsi,-0x18(%rbp)
ffffffff8010cfc0:	89 55 e4             	mov    %edx,-0x1c(%rbp)
  struct pipe* pipe = this_file->pipe;
ffffffff8010cfc3:	48 8b 75 f0          	mov    -0x10(%rbp),%rsi
ffffffff8010cfc7:	48 8b 36             	mov    (%rsi),%rsi
ffffffff8010cfca:	48 89 75 d8          	mov    %rsi,-0x28(%rbp)
  acquire(&pipe->lock);
ffffffff8010cfce:	48 8b 75 d8          	mov    -0x28(%rbp),%rsi
ffffffff8010cfd2:	48 81 c6 00 08 00 00 	add    $0x800,%rsi
ffffffff8010cfd9:	48 89 f7             	mov    %rsi,%rdi
ffffffff8010cfdc:	e8 df 87 ff ff       	callq  ffffffff801057c0 <acquire>
  if (this_file->mode != O_RDONLY || pipe->r_refcount <= 0) {
ffffffff8010cfe1:	48 8b 75 f0          	mov    -0x10(%rbp),%rsi
ffffffff8010cfe5:	0f bf 56 08          	movswl 0x8(%rsi),%edx
ffffffff8010cfe9:	83 fa 00             	cmp    $0x0,%edx
ffffffff8010cfec:	0f 85 14 00 00 00    	jne    ffffffff8010d006 <pipe_read+0x56>
ffffffff8010cff2:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
ffffffff8010cff6:	0f b6 88 6d 08 00 00 	movzbl 0x86d(%rax),%ecx
ffffffff8010cffd:	83 f9 00             	cmp    $0x0,%ecx
ffffffff8010d000:	0f 8f 1e 00 00 00    	jg     ffffffff8010d024 <pipe_read+0x74>
    release(&pipe->lock);
ffffffff8010d006:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
ffffffff8010d00a:	48 05 00 08 00 00    	add    $0x800,%rax
ffffffff8010d010:	48 89 c7             	mov    %rax,%rdi
ffffffff8010d013:	e8 e8 89 ff ff       	callq  ffffffff80105a00 <release>
    return -1;
ffffffff8010d018:	c7 45 fc ff ff ff ff 	movl   $0xffffffff,-0x4(%rbp)
ffffffff8010d01f:	e9 2e 01 00 00       	jmpq   ffffffff8010d152 <pipe_read+0x1a2>
  while (pipe->r_offset == pipe->w_offset) {
ffffffff8010d024:	e9 00 00 00 00       	jmpq   ffffffff8010d029 <pipe_read+0x79>
ffffffff8010d029:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
ffffffff8010d02d:	0f bf 88 6a 08 00 00 	movswl 0x86a(%rax),%ecx
ffffffff8010d034:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
ffffffff8010d038:	0f bf 90 68 08 00 00 	movswl 0x868(%rax),%edx
ffffffff8010d03f:	39 d1                	cmp    %edx,%ecx
ffffffff8010d041:	0f 85 50 00 00 00    	jne    ffffffff8010d097 <pipe_read+0xe7>
    if (pipe->w_refcount == 0) {
ffffffff8010d047:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
ffffffff8010d04b:	0f b6 88 6c 08 00 00 	movzbl 0x86c(%rax),%ecx
ffffffff8010d052:	83 f9 00             	cmp    $0x0,%ecx
ffffffff8010d055:	0f 85 1e 00 00 00    	jne    ffffffff8010d079 <pipe_read+0xc9>
      release(&pipe->lock);
ffffffff8010d05b:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
ffffffff8010d05f:	48 05 00 08 00 00    	add    $0x800,%rax
ffffffff8010d065:	48 89 c7             	mov    %rax,%rdi
ffffffff8010d068:	e8 93 89 ff ff       	callq  ffffffff80105a00 <release>
      return 0;
ffffffff8010d06d:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
ffffffff8010d074:	e9 d9 00 00 00       	jmpq   ffffffff8010d152 <pipe_read+0x1a2>
    sleep(&CV_PIPE_DATA_AVAILABLE, &pipe->lock);
ffffffff8010d079:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
ffffffff8010d07d:	48 05 00 08 00 00    	add    $0x800,%rax
ffffffff8010d083:	48 c7 c7 a0 23 12 80 	mov    $0xffffffff801223a0,%rdi
ffffffff8010d08a:	48 89 c6             	mov    %rax,%rsi
ffffffff8010d08d:	e8 8e b3 ff ff       	callq  ffffffff80108420 <sleep>
  while (pipe->r_offset == pipe->w_offset) {
ffffffff8010d092:	e9 92 ff ff ff       	jmpq   ffffffff8010d029 <pipe_read+0x79>
  int read_bytes = num_bytes;
ffffffff8010d097:	8b 45 e4             	mov    -0x1c(%rbp),%eax
ffffffff8010d09a:	89 45 d4             	mov    %eax,-0x2c(%rbp)
  if (pipe->r_offset + num_bytes > pipe->w_offset) {
ffffffff8010d09d:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
ffffffff8010d0a1:	0f bf 81 6a 08 00 00 	movswl 0x86a(%rcx),%eax
ffffffff8010d0a8:	03 45 e4             	add    -0x1c(%rbp),%eax
ffffffff8010d0ab:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
ffffffff8010d0af:	0f bf 91 68 08 00 00 	movswl 0x868(%rcx),%edx
ffffffff8010d0b6:	39 d0                	cmp    %edx,%eax
ffffffff8010d0b8:	0f 8e 1b 00 00 00    	jle    ffffffff8010d0d9 <pipe_read+0x129>
    read_bytes = pipe->w_offset - pipe->r_offset;
ffffffff8010d0be:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
ffffffff8010d0c2:	0f bf 88 68 08 00 00 	movswl 0x868(%rax),%ecx
ffffffff8010d0c9:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
ffffffff8010d0cd:	0f bf 90 6a 08 00 00 	movswl 0x86a(%rax),%edx
ffffffff8010d0d4:	29 d1                	sub    %edx,%ecx
ffffffff8010d0d6:	89 4d d4             	mov    %ecx,-0x2c(%rbp)
  for (int i = 0; i < read_bytes; i++) {
ffffffff8010d0d9:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%rbp)
ffffffff8010d0e0:	8b 45 d0             	mov    -0x30(%rbp),%eax
ffffffff8010d0e3:	3b 45 d4             	cmp    -0x2c(%rbp),%eax
ffffffff8010d0e6:	0f 8d 33 00 00 00    	jge    ffffffff8010d11f <pipe_read+0x16f>
    read_buf[i] = pipe->buf[pipe->r_offset + i];
ffffffff8010d0ec:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
ffffffff8010d0f0:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
ffffffff8010d0f4:	0f bf 91 6a 08 00 00 	movswl 0x86a(%rcx),%edx
ffffffff8010d0fb:	03 55 d0             	add    -0x30(%rbp),%edx
ffffffff8010d0fe:	48 63 ca             	movslq %edx,%rcx
ffffffff8010d101:	40 8a 34 08          	mov    (%rax,%rcx,1),%sil
ffffffff8010d105:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
ffffffff8010d109:	48 63 4d d0          	movslq -0x30(%rbp),%rcx
ffffffff8010d10d:	40 88 34 08          	mov    %sil,(%rax,%rcx,1)
  for (int i = 0; i < read_bytes; i++) {
ffffffff8010d111:	8b 45 d0             	mov    -0x30(%rbp),%eax
ffffffff8010d114:	83 c0 01             	add    $0x1,%eax
ffffffff8010d117:	89 45 d0             	mov    %eax,-0x30(%rbp)
ffffffff8010d11a:	e9 c1 ff ff ff       	jmpq   ffffffff8010d0e0 <pipe_read+0x130>
  pipe->r_offset += read_bytes;
ffffffff8010d11f:	8b 45 d4             	mov    -0x2c(%rbp),%eax
ffffffff8010d122:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
ffffffff8010d126:	0f bf 91 6a 08 00 00 	movswl 0x86a(%rcx),%edx
ffffffff8010d12d:	01 c2                	add    %eax,%edx
ffffffff8010d12f:	66 89 d6             	mov    %dx,%si
ffffffff8010d132:	66 89 b1 6a 08 00 00 	mov    %si,0x86a(%rcx)
  release(&pipe->lock);
ffffffff8010d139:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
ffffffff8010d13d:	48 81 c1 00 08 00 00 	add    $0x800,%rcx
ffffffff8010d144:	48 89 cf             	mov    %rcx,%rdi
ffffffff8010d147:	e8 b4 88 ff ff       	callq  ffffffff80105a00 <release>
  return read_bytes;
ffffffff8010d14c:	8b 45 d4             	mov    -0x2c(%rbp),%eax
ffffffff8010d14f:	89 45 fc             	mov    %eax,-0x4(%rbp)
}
ffffffff8010d152:	8b 45 fc             	mov    -0x4(%rbp),%eax
ffffffff8010d155:	48 83 c4 30          	add    $0x30,%rsp
ffffffff8010d159:	5d                   	pop    %rbp
ffffffff8010d15a:	c3                   	retq   
ffffffff8010d15b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

ffffffff8010d160 <readable>:
{
ffffffff8010d160:	55                   	push   %rbp
ffffffff8010d161:	48 89 e5             	mov    %rsp,%rbp
ffffffff8010d164:	48 83 ec 06          	sub    $0x6,%rsp
ffffffff8010d168:	66 89 f8             	mov    %di,%ax
ffffffff8010d16b:	b1 01                	mov    $0x1,%cl
ffffffff8010d16d:	66 89 45 fe          	mov    %ax,-0x2(%rbp)
  short rwbits = mode & MODE_RW;
ffffffff8010d171:	0f bf 7d fe          	movswl -0x2(%rbp),%edi
ffffffff8010d175:	83 e7 03             	and    $0x3,%edi
ffffffff8010d178:	66 89 f8             	mov    %di,%ax
ffffffff8010d17b:	66 89 45 fc          	mov    %ax,-0x4(%rbp)
  return rwbits == O_RDONLY || rwbits == O_RDWR;
ffffffff8010d17f:	0f bf 7d fc          	movswl -0x4(%rbp),%edi
ffffffff8010d183:	83 ff 00             	cmp    $0x0,%edi
ffffffff8010d186:	88 4d fb             	mov    %cl,-0x5(%rbp)
ffffffff8010d189:	0f 84 0d 00 00 00    	je     ffffffff8010d19c <readable+0x3c>
ffffffff8010d18f:	0f bf 45 fc          	movswl -0x4(%rbp),%eax
ffffffff8010d193:	83 f8 02             	cmp    $0x2,%eax
ffffffff8010d196:	0f 94 c1             	sete   %cl
ffffffff8010d199:	88 4d fb             	mov    %cl,-0x5(%rbp)
ffffffff8010d19c:	8a 45 fb             	mov    -0x5(%rbp),%al
ffffffff8010d19f:	24 01                	and    $0x1,%al
ffffffff8010d1a1:	0f b6 c0             	movzbl %al,%eax
ffffffff8010d1a4:	48 83 c4 06          	add    $0x6,%rsp
ffffffff8010d1a8:	5d                   	pop    %rbp
ffffffff8010d1a9:	c3                   	retq   
ffffffff8010d1aa:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)

ffffffff8010d1b0 <kernel_sys_write>:

// Needs lock in helper
int
kernel_sys_write(int fd, char* write_buf, int num_bytes)
{
ffffffff8010d1b0:	55                   	push   %rbp
ffffffff8010d1b1:	48 89 e5             	mov    %rsp,%rbp
ffffffff8010d1b4:	48 83 ec 30          	sub    $0x30,%rsp
ffffffff8010d1b8:	89 7d f8             	mov    %edi,-0x8(%rbp)
ffffffff8010d1bb:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
ffffffff8010d1bf:	89 55 ec             	mov    %edx,-0x14(%rbp)
  struct proc* this_proc = myproc();
ffffffff8010d1c2:	e8 69 fb ff ff       	callq  ffffffff8010cd30 <myproc>
ffffffff8010d1c7:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  struct open_file* this_file = &this_proc->open_files[fd];
ffffffff8010d1cb:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
ffffffff8010d1cf:	48 83 c0 38          	add    $0x38,%rax
ffffffff8010d1d3:	48 63 75 f8          	movslq -0x8(%rbp),%rsi
ffffffff8010d1d7:	48 6b f6 0b          	imul   $0xb,%rsi,%rsi
ffffffff8010d1db:	48 01 f0             	add    %rsi,%rax
ffffffff8010d1de:	48 89 45 d8          	mov    %rax,-0x28(%rbp)

  if (is_pipe(this_file)) {
ffffffff8010d1e2:	48 8b 7d d8          	mov    -0x28(%rbp),%rdi
ffffffff8010d1e6:	e8 95 fd ff ff       	callq  ffffffff8010cf80 <is_pipe>
ffffffff8010d1eb:	a8 01                	test   $0x1,%al
ffffffff8010d1ed:	0f 85 05 00 00 00    	jne    ffffffff8010d1f8 <kernel_sys_write+0x48>
ffffffff8010d1f3:	e9 18 00 00 00       	jmpq   ffffffff8010d210 <kernel_sys_write+0x60>
    return pipe_write(this_file, write_buf, num_bytes);
ffffffff8010d1f8:	48 8b 7d d8          	mov    -0x28(%rbp),%rdi
ffffffff8010d1fc:	48 8b 75 f0          	mov    -0x10(%rbp),%rsi
ffffffff8010d200:	8b 55 ec             	mov    -0x14(%rbp),%edx
ffffffff8010d203:	e8 b8 00 00 00       	callq  ffffffff8010d2c0 <pipe_write>
ffffffff8010d208:	89 45 fc             	mov    %eax,-0x4(%rbp)
ffffffff8010d20b:	e9 9f 00 00 00       	jmpq   ffffffff8010d2af <kernel_sys_write+0xff>
  } else {
    // inode version

    if (!writable(this_file->mode)) {
ffffffff8010d210:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
ffffffff8010d214:	66 8b 48 08          	mov    0x8(%rax),%cx
ffffffff8010d218:	0f bf f9             	movswl %cx,%edi
ffffffff8010d21b:	e8 10 02 00 00       	callq  ffffffff8010d430 <writable>
ffffffff8010d220:	a8 01                	test   $0x1,%al
ffffffff8010d222:	0f 85 0c 00 00 00    	jne    ffffffff8010d234 <kernel_sys_write+0x84>
      return -1;
ffffffff8010d228:	c7 45 fc ff ff ff ff 	movl   $0xffffffff,-0x4(%rbp)
ffffffff8010d22f:	e9 7b 00 00 00       	jmpq   ffffffff8010d2af <kernel_sys_write+0xff>
    }

    acquiresleep(&this_file->file_desc->inode->lock);
ffffffff8010d234:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
ffffffff8010d238:	48 8b 00             	mov    (%rax),%rax
ffffffff8010d23b:	48 8b 00             	mov    (%rax),%rax
ffffffff8010d23e:	48 83 c0 10          	add    $0x10,%rax
ffffffff8010d242:	48 89 c7             	mov    %rax,%rdi
ffffffff8010d245:	e8 d6 d1 ff ff       	callq  ffffffff8010a420 <acquiresleep>

    int written_bytes = writei(this_file->file_desc->inode,
ffffffff8010d24a:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
ffffffff8010d24e:	48 8b 00             	mov    (%rax),%rax
ffffffff8010d251:	48 8b 38             	mov    (%rax),%rdi
     write_buf, this_file->file_desc->curr_offset, num_bytes);
ffffffff8010d254:	48 8b 75 f0          	mov    -0x10(%rbp),%rsi
ffffffff8010d258:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
ffffffff8010d25c:	48 8b 00             	mov    (%rax),%rax
ffffffff8010d25f:	8b 50 08             	mov    0x8(%rax),%edx
ffffffff8010d262:	8b 4d ec             	mov    -0x14(%rbp),%ecx
    int written_bytes = writei(this_file->file_desc->inode,
ffffffff8010d265:	e8 c6 f0 ff ff       	callq  ffffffff8010c330 <writei>
ffffffff8010d26a:	89 45 d4             	mov    %eax,-0x2c(%rbp)

    if (written_bytes == -1) {
ffffffff8010d26d:	83 7d d4 ff          	cmpl   $0xffffffff,-0x2c(%rbp)
ffffffff8010d271:	0f 85 0c 00 00 00    	jne    ffffffff8010d283 <kernel_sys_write+0xd3>
      return -1;
ffffffff8010d277:	c7 45 fc ff ff ff ff 	movl   $0xffffffff,-0x4(%rbp)
ffffffff8010d27e:	e9 2c 00 00 00       	jmpq   ffffffff8010d2af <kernel_sys_write+0xff>
    }

    this_file->file_desc->curr_offset += written_bytes;
ffffffff8010d283:	8b 45 d4             	mov    -0x2c(%rbp),%eax
ffffffff8010d286:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
ffffffff8010d28a:	48 8b 09             	mov    (%rcx),%rcx
ffffffff8010d28d:	03 41 08             	add    0x8(%rcx),%eax
ffffffff8010d290:	89 41 08             	mov    %eax,0x8(%rcx)
    releasesleep(&this_file->file_desc->inode->lock);
ffffffff8010d293:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
ffffffff8010d297:	48 8b 09             	mov    (%rcx),%rcx
ffffffff8010d29a:	48 8b 09             	mov    (%rcx),%rcx
ffffffff8010d29d:	48 83 c1 10          	add    $0x10,%rcx
ffffffff8010d2a1:	48 89 cf             	mov    %rcx,%rdi
ffffffff8010d2a4:	e8 17 d2 ff ff       	callq  ffffffff8010a4c0 <releasesleep>

    return written_bytes;
ffffffff8010d2a9:	8b 45 d4             	mov    -0x2c(%rbp),%eax
ffffffff8010d2ac:	89 45 fc             	mov    %eax,-0x4(%rbp)
  }
}
ffffffff8010d2af:	8b 45 fc             	mov    -0x4(%rbp),%eax
ffffffff8010d2b2:	48 83 c4 30          	add    $0x30,%rsp
ffffffff8010d2b6:	5d                   	pop    %rbp
ffffffff8010d2b7:	c3                   	retq   
ffffffff8010d2b8:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
ffffffff8010d2bf:	00 

ffffffff8010d2c0 <pipe_write>:
{
ffffffff8010d2c0:	55                   	push   %rbp
ffffffff8010d2c1:	48 89 e5             	mov    %rsp,%rbp
ffffffff8010d2c4:	48 83 ec 30          	sub    $0x30,%rsp
ffffffff8010d2c8:	48 89 7d f0          	mov    %rdi,-0x10(%rbp)
ffffffff8010d2cc:	48 89 75 e8          	mov    %rsi,-0x18(%rbp)
ffffffff8010d2d0:	89 55 e4             	mov    %edx,-0x1c(%rbp)
  struct pipe* pipe = this_file->pipe;
ffffffff8010d2d3:	48 8b 75 f0          	mov    -0x10(%rbp),%rsi
ffffffff8010d2d7:	48 8b 36             	mov    (%rsi),%rsi
ffffffff8010d2da:	48 89 75 d8          	mov    %rsi,-0x28(%rbp)
  acquire(&pipe->lock);
ffffffff8010d2de:	48 8b 75 d8          	mov    -0x28(%rbp),%rsi
ffffffff8010d2e2:	48 81 c6 00 08 00 00 	add    $0x800,%rsi
ffffffff8010d2e9:	48 89 f7             	mov    %rsi,%rdi
ffffffff8010d2ec:	e8 cf 84 ff ff       	callq  ffffffff801057c0 <acquire>
  if (this_file->mode != O_WRONLY || pipe->w_refcount <= 0) {
ffffffff8010d2f1:	48 8b 75 f0          	mov    -0x10(%rbp),%rsi
ffffffff8010d2f5:	0f bf 56 08          	movswl 0x8(%rsi),%edx
ffffffff8010d2f9:	83 fa 01             	cmp    $0x1,%edx
ffffffff8010d2fc:	0f 85 14 00 00 00    	jne    ffffffff8010d316 <pipe_write+0x56>
ffffffff8010d302:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
ffffffff8010d306:	0f b6 88 6c 08 00 00 	movzbl 0x86c(%rax),%ecx
ffffffff8010d30d:	83 f9 00             	cmp    $0x0,%ecx
ffffffff8010d310:	0f 8f 1e 00 00 00    	jg     ffffffff8010d334 <pipe_write+0x74>
    release(&pipe->lock);
ffffffff8010d316:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
ffffffff8010d31a:	48 05 00 08 00 00    	add    $0x800,%rax
ffffffff8010d320:	48 89 c7             	mov    %rax,%rdi
ffffffff8010d323:	e8 d8 86 ff ff       	callq  ffffffff80105a00 <release>
    return -1;
ffffffff8010d328:	c7 45 fc ff ff ff ff 	movl   $0xffffffff,-0x4(%rbp)
ffffffff8010d32f:	e9 ec 00 00 00       	jmpq   ffffffff8010d420 <pipe_write+0x160>
  if (pipe->w_offset >= PIPE_BUF_MAX) {
ffffffff8010d334:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
ffffffff8010d338:	0f bf 88 68 08 00 00 	movswl 0x868(%rax),%ecx
ffffffff8010d33f:	81 f9 00 08 00 00    	cmp    $0x800,%ecx
ffffffff8010d345:	0f 8c 1e 00 00 00    	jl     ffffffff8010d369 <pipe_write+0xa9>
    release(&pipe->lock);
ffffffff8010d34b:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
ffffffff8010d34f:	48 05 00 08 00 00    	add    $0x800,%rax
ffffffff8010d355:	48 89 c7             	mov    %rax,%rdi
ffffffff8010d358:	e8 a3 86 ff ff       	callq  ffffffff80105a00 <release>
    return -1;
ffffffff8010d35d:	c7 45 fc ff ff ff ff 	movl   $0xffffffff,-0x4(%rbp)
ffffffff8010d364:	e9 b7 00 00 00       	jmpq   ffffffff8010d420 <pipe_write+0x160>
  int written_bytes = num_bytes;
ffffffff8010d369:	8b 45 e4             	mov    -0x1c(%rbp),%eax
ffffffff8010d36c:	89 45 d4             	mov    %eax,-0x2c(%rbp)
  if (pipe->w_offset + num_bytes >= PIPE_BUF_MAX) {
ffffffff8010d36f:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
ffffffff8010d373:	0f bf 81 68 08 00 00 	movswl 0x868(%rcx),%eax
ffffffff8010d37a:	03 45 e4             	add    -0x1c(%rbp),%eax
ffffffff8010d37d:	3d 00 08 00 00       	cmp    $0x800,%eax
ffffffff8010d382:	0f 8c 15 00 00 00    	jl     ffffffff8010d39d <pipe_write+0xdd>
ffffffff8010d388:	b8 00 08 00 00       	mov    $0x800,%eax
    written_bytes = PIPE_BUF_MAX - pipe->w_offset;
ffffffff8010d38d:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
ffffffff8010d391:	0f bf 91 68 08 00 00 	movswl 0x868(%rcx),%edx
ffffffff8010d398:	29 d0                	sub    %edx,%eax
ffffffff8010d39a:	89 45 d4             	mov    %eax,-0x2c(%rbp)
  for (int i = 0; i < written_bytes; i++) {
ffffffff8010d39d:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%rbp)
ffffffff8010d3a4:	8b 45 d0             	mov    -0x30(%rbp),%eax
ffffffff8010d3a7:	3b 45 d4             	cmp    -0x2c(%rbp),%eax
ffffffff8010d3aa:	0f 8d 31 00 00 00    	jge    ffffffff8010d3e1 <pipe_write+0x121>
    pipe->buf[pipe->w_offset + i] = write_buf[i];
ffffffff8010d3b0:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
ffffffff8010d3b4:	48 63 4d d0          	movslq -0x30(%rbp),%rcx
ffffffff8010d3b8:	8a 14 08             	mov    (%rax,%rcx,1),%dl
ffffffff8010d3bb:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
ffffffff8010d3bf:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
ffffffff8010d3c3:	0f bf b1 68 08 00 00 	movswl 0x868(%rcx),%esi
ffffffff8010d3ca:	03 75 d0             	add    -0x30(%rbp),%esi
ffffffff8010d3cd:	48 63 ce             	movslq %esi,%rcx
ffffffff8010d3d0:	88 14 08             	mov    %dl,(%rax,%rcx,1)
  for (int i = 0; i < written_bytes; i++) {
ffffffff8010d3d3:	8b 45 d0             	mov    -0x30(%rbp),%eax
ffffffff8010d3d6:	83 c0 01             	add    $0x1,%eax
ffffffff8010d3d9:	89 45 d0             	mov    %eax,-0x30(%rbp)
ffffffff8010d3dc:	e9 c3 ff ff ff       	jmpq   ffffffff8010d3a4 <pipe_write+0xe4>
  pipe->w_offset += written_bytes;
ffffffff8010d3e1:	8b 45 d4             	mov    -0x2c(%rbp),%eax
ffffffff8010d3e4:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
ffffffff8010d3e8:	0f bf 91 68 08 00 00 	movswl 0x868(%rcx),%edx
ffffffff8010d3ef:	01 c2                	add    %eax,%edx
ffffffff8010d3f1:	66 89 d6             	mov    %dx,%si
ffffffff8010d3f4:	66 89 b1 68 08 00 00 	mov    %si,0x868(%rcx)
  wakeup(&CV_PIPE_DATA_AVAILABLE);
ffffffff8010d3fb:	48 c7 c7 a0 23 12 80 	mov    $0xffffffff801223a0,%rdi
ffffffff8010d402:	e8 c9 b2 ff ff       	callq  ffffffff801086d0 <wakeup>
  release(&pipe->lock);
ffffffff8010d407:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
ffffffff8010d40b:	48 81 c1 00 08 00 00 	add    $0x800,%rcx
ffffffff8010d412:	48 89 cf             	mov    %rcx,%rdi
ffffffff8010d415:	e8 e6 85 ff ff       	callq  ffffffff80105a00 <release>
  return written_bytes;
ffffffff8010d41a:	8b 45 d4             	mov    -0x2c(%rbp),%eax
ffffffff8010d41d:	89 45 fc             	mov    %eax,-0x4(%rbp)
}
ffffffff8010d420:	8b 45 fc             	mov    -0x4(%rbp),%eax
ffffffff8010d423:	48 83 c4 30          	add    $0x30,%rsp
ffffffff8010d427:	5d                   	pop    %rbp
ffffffff8010d428:	c3                   	retq   
ffffffff8010d429:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)

ffffffff8010d430 <writable>:
{
ffffffff8010d430:	55                   	push   %rbp
ffffffff8010d431:	48 89 e5             	mov    %rsp,%rbp
ffffffff8010d434:	48 83 ec 06          	sub    $0x6,%rsp
ffffffff8010d438:	66 89 f8             	mov    %di,%ax
ffffffff8010d43b:	b1 01                	mov    $0x1,%cl
ffffffff8010d43d:	66 89 45 fe          	mov    %ax,-0x2(%rbp)
  short rwbits = mode & MODE_RW;
ffffffff8010d441:	0f bf 7d fe          	movswl -0x2(%rbp),%edi
ffffffff8010d445:	83 e7 03             	and    $0x3,%edi
ffffffff8010d448:	66 89 f8             	mov    %di,%ax
ffffffff8010d44b:	66 89 45 fc          	mov    %ax,-0x4(%rbp)
  return rwbits == O_WRONLY || rwbits == O_RDWR;
ffffffff8010d44f:	0f bf 7d fc          	movswl -0x4(%rbp),%edi
ffffffff8010d453:	83 ff 01             	cmp    $0x1,%edi
ffffffff8010d456:	88 4d fb             	mov    %cl,-0x5(%rbp)
ffffffff8010d459:	0f 84 0d 00 00 00    	je     ffffffff8010d46c <writable+0x3c>
ffffffff8010d45f:	0f bf 45 fc          	movswl -0x4(%rbp),%eax
ffffffff8010d463:	83 f8 02             	cmp    $0x2,%eax
ffffffff8010d466:	0f 94 c1             	sete   %cl
ffffffff8010d469:	88 4d fb             	mov    %cl,-0x5(%rbp)
ffffffff8010d46c:	8a 45 fb             	mov    -0x5(%rbp),%al
ffffffff8010d46f:	24 01                	and    $0x1,%al
ffffffff8010d471:	0f b6 c0             	movzbl %al,%eax
ffffffff8010d474:	48 83 c4 06          	add    $0x6,%rsp
ffffffff8010d478:	5d                   	pop    %rbp
ffffffff8010d479:	c3                   	retq   
ffffffff8010d47a:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)

ffffffff8010d480 <kernel_sys_close>:

// Needs lock in helper
int kernel_sys_close(int fd)
{
ffffffff8010d480:	55                   	push   %rbp
ffffffff8010d481:	48 89 e5             	mov    %rsp,%rbp
ffffffff8010d484:	48 83 ec 20          	sub    $0x20,%rsp
ffffffff8010d488:	89 7d fc             	mov    %edi,-0x4(%rbp)
  struct proc* this_proc = myproc();
ffffffff8010d48b:	e8 a0 f8 ff ff       	callq  ffffffff8010cd30 <myproc>
ffffffff8010d490:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  struct open_file* this_file = &this_proc->open_files[fd];
ffffffff8010d494:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
ffffffff8010d498:	48 83 c0 38          	add    $0x38,%rax
ffffffff8010d49c:	48 63 4d fc          	movslq -0x4(%rbp),%rcx
ffffffff8010d4a0:	48 6b c9 0b          	imul   $0xb,%rcx,%rcx
ffffffff8010d4a4:	48 01 c8             	add    %rcx,%rax
ffffffff8010d4a7:	48 89 45 e8          	mov    %rax,-0x18(%rbp)

  if (is_pipe(this_file)) {
ffffffff8010d4ab:	48 8b 7d e8          	mov    -0x18(%rbp),%rdi
ffffffff8010d4af:	e8 cc fa ff ff       	callq  ffffffff8010cf80 <is_pipe>
ffffffff8010d4b4:	a8 01                	test   $0x1,%al
ffffffff8010d4b6:	0f 85 05 00 00 00    	jne    ffffffff8010d4c1 <kernel_sys_close+0x41>
ffffffff8010d4bc:	e9 0e 00 00 00       	jmpq   ffffffff8010d4cf <kernel_sys_close+0x4f>
    pipe_close(this_file);
ffffffff8010d4c1:	48 8b 7d e8          	mov    -0x18(%rbp),%rdi
ffffffff8010d4c5:	e8 96 00 00 00       	callq  ffffffff8010d560 <pipe_close>
  } else {
ffffffff8010d4ca:	e9 76 00 00 00       	jmpq   ffffffff8010d545 <kernel_sys_close+0xc5>
    // A file.

    if (this_proc->mapinfo.mapped_file != NULL && this_proc->mapinfo.fd == fd) {
ffffffff8010d4cf:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
ffffffff8010d4d3:	48 83 b8 e8 00 00 00 	cmpq   $0x0,0xe8(%rax)
ffffffff8010d4da:	00 
ffffffff8010d4db:	0f 84 1e 00 00 00    	je     ffffffff8010d4ff <kernel_sys_close+0x7f>
ffffffff8010d4e1:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
ffffffff8010d4e5:	8b 88 f0 00 00 00    	mov    0xf0(%rax),%ecx
ffffffff8010d4eb:	3b 4d fc             	cmp    -0x4(%rbp),%ecx
ffffffff8010d4ee:	0f 85 0b 00 00 00    	jne    ffffffff8010d4ff <kernel_sys_close+0x7f>
      // This process has the file mapped. Unmap it first.
      kernel_munmap(fd);
ffffffff8010d4f4:	8b 7d fc             	mov    -0x4(%rbp),%edi
ffffffff8010d4f7:	e8 64 01 00 00       	callq  ffffffff8010d660 <kernel_munmap>
ffffffff8010d4fc:	89 45 e4             	mov    %eax,-0x1c(%rbp)
    }

    acquire(&global_files.lock);
ffffffff8010d4ff:	48 c7 c7 10 4e 20 83 	mov    $0xffffffff83204e10,%rdi
ffffffff8010d506:	e8 b5 82 ff ff       	callq  ffffffff801057c0 <acquire>
    if (--this_file->file_desc->refcount == 0) {
ffffffff8010d50b:	48 8b 7d e8          	mov    -0x18(%rbp),%rdi
ffffffff8010d50f:	48 8b 3f             	mov    (%rdi),%rdi
ffffffff8010d512:	66 8b 47 0c          	mov    0xc(%rdi),%ax
ffffffff8010d516:	66 83 c0 ff          	add    $0xffff,%ax
ffffffff8010d51a:	66 89 47 0c          	mov    %ax,0xc(%rdi)
ffffffff8010d51e:	0f b7 c8             	movzwl %ax,%ecx
ffffffff8010d521:	83 f9 00             	cmp    $0x0,%ecx
ffffffff8010d524:	0f 85 0f 00 00 00    	jne    ffffffff8010d539 <kernel_sys_close+0xb9>
      // Refcount of 0 effectively releases the GFT entry; one less entry
      // holding a pointer to the inode.
      iput(this_file->file_desc->inode);
ffffffff8010d52a:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
ffffffff8010d52e:	48 8b 00             	mov    (%rax),%rax
ffffffff8010d531:	48 8b 38             	mov    (%rax),%rdi
ffffffff8010d534:	e8 57 eb ff ff       	callq  ffffffff8010c090 <iput>
    }
    release(&global_files.lock);
ffffffff8010d539:	48 c7 c7 10 4e 20 83 	mov    $0xffffffff83204e10,%rdi
ffffffff8010d540:	e8 bb 84 ff ff       	callq  ffffffff80105a00 <release>
ffffffff8010d545:	31 c0                	xor    %eax,%eax
  }

  // Invalidating type will allow reuse of this file descriptor.
  this_file->type = FILE_UNUSED;
ffffffff8010d547:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
ffffffff8010d54b:	c6 41 0a 00          	movb   $0x0,0xa(%rcx)
  return 0;
ffffffff8010d54f:	48 83 c4 20          	add    $0x20,%rsp
ffffffff8010d553:	5d                   	pop    %rbp
ffffffff8010d554:	c3                   	retq   
ffffffff8010d555:	66 66 2e 0f 1f 84 00 	data16 nopw %cs:0x0(%rax,%rax,1)
ffffffff8010d55c:	00 00 00 00 

ffffffff8010d560 <pipe_close>:
{
ffffffff8010d560:	55                   	push   %rbp
ffffffff8010d561:	48 89 e5             	mov    %rsp,%rbp
ffffffff8010d564:	48 83 ec 10          	sub    $0x10,%rsp
ffffffff8010d568:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  acquire(&this_file->pipe->lock);
ffffffff8010d56c:	48 8b 7d f8          	mov    -0x8(%rbp),%rdi
ffffffff8010d570:	48 8b 3f             	mov    (%rdi),%rdi
ffffffff8010d573:	48 81 c7 00 08 00 00 	add    $0x800,%rdi
ffffffff8010d57a:	e8 41 82 ff ff       	callq  ffffffff801057c0 <acquire>
  if (this_file->mode == O_RDONLY) {
ffffffff8010d57f:	48 8b 7d f8          	mov    -0x8(%rbp),%rdi
ffffffff8010d583:	0f bf 47 08          	movswl 0x8(%rdi),%eax
ffffffff8010d587:	83 f8 00             	cmp    $0x0,%eax
ffffffff8010d58a:	0f 85 1b 00 00 00    	jne    ffffffff8010d5ab <pipe_close+0x4b>
    this_file->pipe->r_refcount--;
ffffffff8010d590:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
ffffffff8010d594:	48 8b 00             	mov    (%rax),%rax
ffffffff8010d597:	8a 88 6d 08 00 00    	mov    0x86d(%rax),%cl
ffffffff8010d59d:	80 c1 ff             	add    $0xff,%cl
ffffffff8010d5a0:	88 88 6d 08 00 00    	mov    %cl,0x86d(%rax)
  } else if (this_file->mode == O_WRONLY) {
ffffffff8010d5a6:	e9 38 00 00 00       	jmpq   ffffffff8010d5e3 <pipe_close+0x83>
ffffffff8010d5ab:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
ffffffff8010d5af:	0f bf 48 08          	movswl 0x8(%rax),%ecx
ffffffff8010d5b3:	83 f9 01             	cmp    $0x1,%ecx
ffffffff8010d5b6:	0f 85 22 00 00 00    	jne    ffffffff8010d5de <pipe_close+0x7e>
    this_file->pipe->w_refcount--;
ffffffff8010d5bc:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
ffffffff8010d5c0:	48 8b 00             	mov    (%rax),%rax
ffffffff8010d5c3:	8a 88 6c 08 00 00    	mov    0x86c(%rax),%cl
ffffffff8010d5c9:	80 c1 ff             	add    $0xff,%cl
ffffffff8010d5cc:	88 88 6c 08 00 00    	mov    %cl,0x86c(%rax)
    wakeup(&CV_PIPE_DATA_AVAILABLE);
ffffffff8010d5d2:	48 c7 c7 a0 23 12 80 	mov    $0xffffffff801223a0,%rdi
ffffffff8010d5d9:	e8 f2 b0 ff ff       	callq  ffffffff801086d0 <wakeup>
ffffffff8010d5de:	e9 00 00 00 00       	jmpq   ffffffff8010d5e3 <pipe_close+0x83>
ffffffff8010d5e3:	31 c0                	xor    %eax,%eax
ffffffff8010d5e5:	88 c1                	mov    %al,%cl
  bool can_free = this_file->pipe->r_refcount == 0
ffffffff8010d5e7:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
ffffffff8010d5eb:	48 8b 12             	mov    (%rdx),%rdx
ffffffff8010d5ee:	0f b6 82 6d 08 00 00 	movzbl 0x86d(%rdx),%eax
ffffffff8010d5f5:	83 f8 00             	cmp    $0x0,%eax
   && this_file->pipe->w_refcount == 0;
ffffffff8010d5f8:	88 4d f6             	mov    %cl,-0xa(%rbp)
ffffffff8010d5fb:	0f 85 17 00 00 00    	jne    ffffffff8010d618 <pipe_close+0xb8>
ffffffff8010d601:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
ffffffff8010d605:	48 8b 00             	mov    (%rax),%rax
ffffffff8010d608:	0f b6 88 6c 08 00 00 	movzbl 0x86c(%rax),%ecx
ffffffff8010d60f:	83 f9 00             	cmp    $0x0,%ecx
ffffffff8010d612:	0f 94 c2             	sete   %dl
ffffffff8010d615:	88 55 f6             	mov    %dl,-0xa(%rbp)
ffffffff8010d618:	8a 45 f6             	mov    -0xa(%rbp),%al
  bool can_free = this_file->pipe->r_refcount == 0
ffffffff8010d61b:	24 01                	and    $0x1,%al
ffffffff8010d61d:	88 45 f7             	mov    %al,-0x9(%rbp)
  release(&this_file->pipe->lock);
ffffffff8010d620:	48 8b 4d f8          	mov    -0x8(%rbp),%rcx
ffffffff8010d624:	48 8b 09             	mov    (%rcx),%rcx
ffffffff8010d627:	48 81 c1 00 08 00 00 	add    $0x800,%rcx
ffffffff8010d62e:	48 89 cf             	mov    %rcx,%rdi
ffffffff8010d631:	e8 ca 83 ff ff       	callq  ffffffff80105a00 <release>
  if (can_free) {
ffffffff8010d636:	f6 45 f7 01          	testb  $0x1,-0x9(%rbp)
ffffffff8010d63a:	0f 84 0f 00 00 00    	je     ffffffff8010d64f <pipe_close+0xef>
    kfree((char*) this_file->pipe);
ffffffff8010d640:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
ffffffff8010d644:	48 8b 00             	mov    (%rax),%rax
ffffffff8010d647:	48 89 c7             	mov    %rax,%rdi
ffffffff8010d64a:	e8 21 2f ff ff       	callq  ffffffff80100570 <kfree>
}
ffffffff8010d64f:	48 83 c4 10          	add    $0x10,%rsp
ffffffff8010d653:	5d                   	pop    %rbp
ffffffff8010d654:	c3                   	retq   
ffffffff8010d655:	66 66 2e 0f 1f 84 00 	data16 nopw %cs:0x0(%rax,%rax,1)
ffffffff8010d65c:	00 00 00 00 

ffffffff8010d660 <kernel_munmap>:

  return inode->size;
}

int kernel_munmap(int fd)
{
ffffffff8010d660:	55                   	push   %rbp
ffffffff8010d661:	48 89 e5             	mov    %rsp,%rbp
ffffffff8010d664:	48 83 ec 60          	sub    $0x60,%rsp
ffffffff8010d668:	89 7d f8             	mov    %edi,-0x8(%rbp)
  struct proc* proc = myproc();
ffffffff8010d66b:	e8 c0 f6 ff ff       	callq  ffffffff8010cd30 <myproc>
ffffffff8010d670:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

  if (proc->mapinfo.mapped_file == NULL || proc->mapinfo.fd != fd) {
ffffffff8010d674:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
ffffffff8010d678:	48 83 b8 e8 00 00 00 	cmpq   $0x0,0xe8(%rax)
ffffffff8010d67f:	00 
ffffffff8010d680:	0f 84 13 00 00 00    	je     ffffffff8010d699 <kernel_munmap+0x39>
ffffffff8010d686:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
ffffffff8010d68a:	8b 88 f0 00 00 00    	mov    0xf0(%rax),%ecx
ffffffff8010d690:	3b 4d f8             	cmp    -0x8(%rbp),%ecx
ffffffff8010d693:	0f 84 0c 00 00 00    	je     ffffffff8010d6a5 <kernel_munmap+0x45>
    return -1;
ffffffff8010d699:	c7 45 fc ff ff ff ff 	movl   $0xffffffff,-0x4(%rbp)
ffffffff8010d6a0:	e9 31 01 00 00       	jmpq   ffffffff8010d7d6 <kernel_munmap+0x176>
  }

  struct mapped_file* mapped_file = proc->mapinfo.mapped_file;
ffffffff8010d6a5:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
ffffffff8010d6a9:	48 8b 80 e8 00 00 00 	mov    0xe8(%rax),%rax
ffffffff8010d6b0:	48 89 45 e8          	mov    %rax,-0x18(%rbp)

  acquire(&mapped_file->lock);
ffffffff8010d6b4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
ffffffff8010d6b8:	48 83 c0 08          	add    $0x8,%rax
ffffffff8010d6bc:	48 89 c7             	mov    %rax,%rdi
ffffffff8010d6bf:	e8 fc 80 ff ff       	callq  ffffffff801057c0 <acquire>
ffffffff8010d6c4:	31 c9                	xor    %ecx,%ecx
  bool should_cleanup = (0 == --mapped_file->refcount);
ffffffff8010d6c6:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
ffffffff8010d6ca:	8a 50 74             	mov    0x74(%rax),%dl
ffffffff8010d6cd:	80 c2 ff             	add    $0xff,%dl
ffffffff8010d6d0:	88 50 74             	mov    %dl,0x74(%rax)
ffffffff8010d6d3:	0f b6 f2             	movzbl %dl,%esi
ffffffff8010d6d6:	39 f1                	cmp    %esi,%ecx
ffffffff8010d6d8:	0f 94 c2             	sete   %dl
ffffffff8010d6db:	80 e2 01             	and    $0x1,%dl
ffffffff8010d6de:	88 55 e7             	mov    %dl,-0x19(%rbp)
  release(&mapped_file->lock);
ffffffff8010d6e1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
ffffffff8010d6e5:	48 83 c0 08          	add    $0x8,%rax
ffffffff8010d6e9:	48 89 c7             	mov    %rax,%rdi
ffffffff8010d6ec:	e8 0f 83 ff ff       	callq  ffffffff80105a00 <release>

  if (should_cleanup) {
ffffffff8010d6f1:	f6 45 e7 01          	testb  $0x1,-0x19(%rbp)
ffffffff8010d6f5:	0f 84 6b 00 00 00    	je     ffffffff8010d766 <kernel_munmap+0x106>
ffffffff8010d6fb:	b8 00 00 00 80       	mov    $0x80000000,%eax
ffffffff8010d700:	89 c1                	mov    %eax,%ecx
ffffffff8010d702:	31 c0                	xor    %eax,%eax
ffffffff8010d704:	89 c2                	mov    %eax,%edx
    // Unmap the memory for this process AND free phys mem.
    deallocuvm(proc->pml4, MAPPED_FILE_VADDR,
ffffffff8010d706:	48 8b 75 f0          	mov    -0x10(%rbp),%rsi
ffffffff8010d70a:	48 8b 3e             	mov    (%rsi),%rdi
     mapped_file->inode->size, 0, proc->pid);
ffffffff8010d70d:	48 8b 75 e8          	mov    -0x18(%rbp),%rsi
ffffffff8010d711:	48 8b 36             	mov    (%rsi),%rsi
ffffffff8010d714:	8b 86 9c 00 00 00    	mov    0x9c(%rsi),%eax
ffffffff8010d71a:	89 c6                	mov    %eax,%esi
ffffffff8010d71c:	4c 8b 45 f0          	mov    -0x10(%rbp),%r8
ffffffff8010d720:	45 8b 80 04 01 00 00 	mov    0x104(%r8),%r8d
    deallocuvm(proc->pml4, MAPPED_FILE_VADDR,
ffffffff8010d727:	b8 00 00 00 80       	mov    $0x80000000,%eax
ffffffff8010d72c:	41 89 c1             	mov    %eax,%r9d
ffffffff8010d72f:	31 c0                	xor    %eax,%eax
ffffffff8010d731:	41 89 c2             	mov    %eax,%r10d
ffffffff8010d734:	48 89 75 d8          	mov    %rsi,-0x28(%rbp)
ffffffff8010d738:	4c 89 ce             	mov    %r9,%rsi
ffffffff8010d73b:	4c 8b 4d d8          	mov    -0x28(%rbp),%r9
ffffffff8010d73f:	48 89 55 d0          	mov    %rdx,-0x30(%rbp)
ffffffff8010d743:	4c 89 ca             	mov    %r9,%rdx
ffffffff8010d746:	48 89 4d c8          	mov    %rcx,-0x38(%rbp)
ffffffff8010d74a:	4c 89 d1             	mov    %r10,%rcx
ffffffff8010d74d:	e8 1e 67 ff ff       	callq  ffffffff80103e70 <deallocuvm>

    kfree((char*) mapped_file);
ffffffff8010d752:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
ffffffff8010d756:	48 89 cf             	mov    %rcx,%rdi
ffffffff8010d759:	89 45 c4             	mov    %eax,-0x3c(%rbp)
ffffffff8010d75c:	e8 0f 2e ff ff       	callq  ffffffff80100570 <kfree>
  } else {
ffffffff8010d761:	e9 5a 00 00 00       	jmpq   ffffffff8010d7c0 <kernel_munmap+0x160>
ffffffff8010d766:	b8 00 00 00 80       	mov    $0x80000000,%eax
ffffffff8010d76b:	89 c1                	mov    %eax,%ecx
ffffffff8010d76d:	31 c0                	xor    %eax,%eax
ffffffff8010d76f:	89 c2                	mov    %eax,%edx
    // Just unmap the memory for this process.
    unmapuvm(proc->pml4, MAPPED_FILE_VADDR,
ffffffff8010d771:	48 8b 75 f0          	mov    -0x10(%rbp),%rsi
ffffffff8010d775:	48 8b 3e             	mov    (%rsi),%rdi
     mapped_file->inode->size, 0, proc->pid);
ffffffff8010d778:	48 8b 75 e8          	mov    -0x18(%rbp),%rsi
ffffffff8010d77c:	48 8b 36             	mov    (%rsi),%rsi
ffffffff8010d77f:	8b 86 9c 00 00 00    	mov    0x9c(%rsi),%eax
ffffffff8010d785:	89 c6                	mov    %eax,%esi
ffffffff8010d787:	4c 8b 45 f0          	mov    -0x10(%rbp),%r8
ffffffff8010d78b:	45 8b 80 04 01 00 00 	mov    0x104(%r8),%r8d
    unmapuvm(proc->pml4, MAPPED_FILE_VADDR,
ffffffff8010d792:	b8 00 00 00 80       	mov    $0x80000000,%eax
ffffffff8010d797:	41 89 c1             	mov    %eax,%r9d
ffffffff8010d79a:	31 c0                	xor    %eax,%eax
ffffffff8010d79c:	41 89 c2             	mov    %eax,%r10d
ffffffff8010d79f:	48 89 75 b8          	mov    %rsi,-0x48(%rbp)
ffffffff8010d7a3:	4c 89 ce             	mov    %r9,%rsi
ffffffff8010d7a6:	4c 8b 4d b8          	mov    -0x48(%rbp),%r9
ffffffff8010d7aa:	48 89 55 b0          	mov    %rdx,-0x50(%rbp)
ffffffff8010d7ae:	4c 89 ca             	mov    %r9,%rdx
ffffffff8010d7b1:	48 89 4d a8          	mov    %rcx,-0x58(%rbp)
ffffffff8010d7b5:	4c 89 d1             	mov    %r10,%rcx
ffffffff8010d7b8:	e8 83 6e ff ff       	callq  ffffffff80104640 <unmapuvm>
ffffffff8010d7bd:	89 45 a4             	mov    %eax,-0x5c(%rbp)
  }

  proc->mapinfo.mapped_file = NULL;
ffffffff8010d7c0:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
ffffffff8010d7c4:	48 c7 80 e8 00 00 00 	movq   $0x0,0xe8(%rax)
ffffffff8010d7cb:	00 00 00 00 
  return 0;
ffffffff8010d7cf:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
}
ffffffff8010d7d6:	8b 45 fc             	mov    -0x4(%rbp),%eax
ffffffff8010d7d9:	48 83 c4 60          	add    $0x60,%rsp
ffffffff8010d7dd:	5d                   	pop    %rbp
ffffffff8010d7de:	c3                   	retq   
ffffffff8010d7df:	90                   	nop

ffffffff8010d7e0 <kernel_sys_open>:
{
ffffffff8010d7e0:	55                   	push   %rbp
ffffffff8010d7e1:	48 89 e5             	mov    %rsp,%rbp
ffffffff8010d7e4:	48 81 ec 00 01 00 00 	sub    $0x100,%rsp
ffffffff8010d7eb:	48 89 7d f0          	mov    %rdi,-0x10(%rbp)
ffffffff8010d7ef:	89 75 ec             	mov    %esi,-0x14(%rbp)
  struct proc* this_proc = myproc();
ffffffff8010d7f2:	e8 39 f5 ff ff       	callq  ffffffff8010cd30 <myproc>
ffffffff8010d7f7:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  int idx = next_free_table_index(this_proc);
ffffffff8010d7fb:	48 8b 7d e0          	mov    -0x20(%rbp),%rdi
ffffffff8010d7ff:	e8 4c f5 ff ff       	callq  ffffffff8010cd50 <next_free_table_index>
ffffffff8010d804:	89 c6                	mov    %eax,%esi
ffffffff8010d806:	89 75 dc             	mov    %esi,-0x24(%rbp)
  if (idx == -1) {
ffffffff8010d809:	83 7d dc ff          	cmpl   $0xffffffff,-0x24(%rbp)
ffffffff8010d80d:	0f 85 0b 00 00 00    	jne    ffffffff8010d81e <kernel_sys_open+0x3e>
    return idx;
ffffffff8010d813:	8b 45 dc             	mov    -0x24(%rbp),%eax
ffffffff8010d816:	89 45 fc             	mov    %eax,-0x4(%rbp)
ffffffff8010d819:	e9 f4 02 00 00       	jmpq   ffffffff8010db12 <kernel_sys_open+0x332>
  if (mode & O_CREATE) {
ffffffff8010d81e:	8b 45 ec             	mov    -0x14(%rbp),%eax
ffffffff8010d821:	25 00 02 00 00       	and    $0x200,%eax
ffffffff8010d826:	83 f8 00             	cmp    $0x0,%eax
ffffffff8010d829:	0f 84 fd 01 00 00    	je     ffffffff8010da2c <kernel_sys_open+0x24c>
    din.type = T_FILE;
ffffffff8010d82f:	66 c7 45 90 02 00    	movw   $0x2,-0x70(%rbp)
    din.nlink = 1;
ffffffff8010d835:	66 c7 45 96 01 00    	movw   $0x1,-0x6a(%rbp)
    din.size = 0;
ffffffff8010d83b:	c7 45 98 00 00 00 00 	movl   $0x0,-0x68(%rbp)
    for(int i = 0; i < 4; i++) {
ffffffff8010d842:	c7 45 8c 00 00 00 00 	movl   $0x0,-0x74(%rbp)
ffffffff8010d849:	83 7d 8c 04          	cmpl   $0x4,-0x74(%rbp)
ffffffff8010d84d:	0f 8d 26 00 00 00    	jge    ffffffff8010d879 <kernel_sys_open+0x99>
      din.data[i].startblkno = 0;
ffffffff8010d853:	48 63 45 8c          	movslq -0x74(%rbp),%rax
ffffffff8010d857:	c7 44 c5 9c 00 00 00 	movl   $0x0,-0x64(%rbp,%rax,8)
ffffffff8010d85e:	00 
      din.data[i].nblocks = 0;
ffffffff8010d85f:	48 63 45 8c          	movslq -0x74(%rbp),%rax
ffffffff8010d863:	c7 44 c5 a0 00 00 00 	movl   $0x0,-0x60(%rbp,%rax,8)
ffffffff8010d86a:	00 
    for(int i = 0; i < 4; i++) {
ffffffff8010d86b:	8b 45 8c             	mov    -0x74(%rbp),%eax
ffffffff8010d86e:	83 c0 01             	add    $0x1,%eax
ffffffff8010d871:	89 45 8c             	mov    %eax,-0x74(%rbp)
ffffffff8010d874:	e9 d0 ff ff ff       	jmpq   ffffffff8010d849 <kernel_sys_open+0x69>
ffffffff8010d879:	b8 01 00 00 00       	mov    $0x1,%eax
ffffffff8010d87e:	48 8d 7d 90          	lea    -0x70(%rbp),%rdi
    de.inum = touch_inode(&din);
ffffffff8010d882:	89 85 3c ff ff ff    	mov    %eax,-0xc4(%rbp)
ffffffff8010d888:	e8 b3 e2 ff ff       	callq  ffffffff8010bb40 <touch_inode>
ffffffff8010d88d:	66 89 c1             	mov    %ax,%cx
ffffffff8010d890:	66 89 8d 78 ff ff ff 	mov    %cx,-0x88(%rbp)
    strncpy(de.name, path, DIRSIZ);
ffffffff8010d897:	48 8d bd 7a ff ff ff 	lea    -0x86(%rbp),%rdi
ffffffff8010d89e:	48 8b 75 f0          	mov    -0x10(%rbp),%rsi
ffffffff8010d8a2:	ba 0e 00 00 00       	mov    $0xe,%edx
ffffffff8010d8a7:	e8 d4 d9 ff ff       	callq  ffffffff8010b280 <strncpy>
    struct buf* buf = bread(ROOTDEV, sb.inodestart);
ffffffff8010d8ac:	8b 34 25 54 27 20 83 	mov    0xffffffff83202754,%esi
ffffffff8010d8b3:	bf 01 00 00 00       	mov    $0x1,%edi
ffffffff8010d8b8:	48 89 85 30 ff ff ff 	mov    %rax,-0xd0(%rbp)
ffffffff8010d8bf:	e8 8c c6 ff ff       	callq  ffffffff80109f50 <bread>
ffffffff8010d8c4:	48 89 85 70 ff ff ff 	mov    %rax,-0x90(%rbp)
    struct dinode* rootino = (struct dinode*) (buf->data + sizeof(struct dinode));
ffffffff8010d8cb:	48 8b 85 70 ff ff ff 	mov    -0x90(%rbp),%rax
ffffffff8010d8d2:	48 05 b0 00 00 00    	add    $0xb0,%rax
ffffffff8010d8d8:	48 83 c0 40          	add    $0x40,%rax
ffffffff8010d8dc:	48 89 85 68 ff ff ff 	mov    %rax,-0x98(%rbp)
    size_t rootblkno = rootino->data[0].startblkno;
ffffffff8010d8e3:	48 8b 85 68 ff ff ff 	mov    -0x98(%rbp),%rax
ffffffff8010d8ea:	8b 50 0c             	mov    0xc(%rax),%edx
ffffffff8010d8ed:	89 d0                	mov    %edx,%eax
ffffffff8010d8ef:	48 89 85 60 ff ff ff 	mov    %rax,-0xa0(%rbp)
    brelse(buf);
ffffffff8010d8f6:	48 8b bd 70 ff ff ff 	mov    -0x90(%rbp),%rdi
ffffffff8010d8fd:	e8 3e c7 ff ff       	callq  ffffffff8010a040 <brelse>
    begin_trans();
ffffffff8010d902:	31 d2                	xor    %edx,%edx
ffffffff8010d904:	41 88 d0             	mov    %dl,%r8b
ffffffff8010d907:	44 88 c0             	mov    %r8b,%al
ffffffff8010d90a:	e8 c1 1a 00 00       	callq  ffffffff8010f3d0 <begin_trans>
ffffffff8010d90f:	ba 01 00 00 00       	mov    $0x1,%edx
    buf = bread(ROOTDEV, rootblkno);
ffffffff8010d914:	48 8b bd 60 ff ff ff 	mov    -0xa0(%rbp),%rdi
ffffffff8010d91b:	89 fe                	mov    %edi,%esi
ffffffff8010d91d:	bf 01 00 00 00       	mov    $0x1,%edi
ffffffff8010d922:	89 95 2c ff ff ff    	mov    %edx,-0xd4(%rbp)
ffffffff8010d928:	e8 23 c6 ff ff       	callq  ffffffff80109f50 <bread>
ffffffff8010d92d:	ba 10 00 00 00       	mov    $0x10,%edx
ffffffff8010d932:	4c 8d 8d 78 ff ff ff 	lea    -0x88(%rbp),%r9
ffffffff8010d939:	48 89 85 70 ff ff ff 	mov    %rax,-0x90(%rbp)
    memmove(buf->data + (de.inum * sizeof(struct dirent)), &de, sizeof(struct dirent));
ffffffff8010d940:	48 8b 85 70 ff ff ff 	mov    -0x90(%rbp),%rax
ffffffff8010d947:	48 05 b0 00 00 00    	add    $0xb0,%rax
ffffffff8010d94d:	0f b7 b5 78 ff ff ff 	movzwl -0x88(%rbp),%esi
ffffffff8010d954:	41 89 f2             	mov    %esi,%r10d
ffffffff8010d957:	49 c1 e2 04          	shl    $0x4,%r10
ffffffff8010d95b:	4c 01 d0             	add    %r10,%rax
ffffffff8010d95e:	be 10 00 00 00       	mov    $0x10,%esi
ffffffff8010d963:	48 89 c7             	mov    %rax,%rdi
ffffffff8010d966:	89 b5 28 ff ff ff    	mov    %esi,-0xd8(%rbp)
ffffffff8010d96c:	4c 89 ce             	mov    %r9,%rsi
ffffffff8010d96f:	44 8b 9d 28 ff ff ff 	mov    -0xd8(%rbp),%r11d
ffffffff8010d976:	89 95 24 ff ff ff    	mov    %edx,-0xdc(%rbp)
ffffffff8010d97c:	44 89 da             	mov    %r11d,%edx
ffffffff8010d97f:	e8 0c d7 ff ff       	callq  ffffffff8010b090 <memmove>
    log_write(buf);
ffffffff8010d984:	48 8b bd 70 ff ff ff 	mov    -0x90(%rbp),%rdi
ffffffff8010d98b:	48 89 85 18 ff ff ff 	mov    %rax,-0xe8(%rbp)
ffffffff8010d992:	e8 49 1b 00 00       	callq  ffffffff8010f4e0 <log_write>
    brelse(buf);
ffffffff8010d997:	48 8b bd 70 ff ff ff 	mov    -0x90(%rbp),%rdi
ffffffff8010d99e:	e8 9d c6 ff ff       	callq  ffffffff8010a040 <brelse>
    commit_trans();
ffffffff8010d9a3:	31 d2                	xor    %edx,%edx
ffffffff8010d9a5:	41 88 d0             	mov    %dl,%r8b
ffffffff8010d9a8:	44 88 c0             	mov    %r8b,%al
ffffffff8010d9ab:	e8 80 1e 00 00       	callq  ffffffff8010f830 <commit_trans>
ffffffff8010d9b0:	ba 0d 00 00 00       	mov    $0xd,%edx
ffffffff8010d9b5:	48 8d b5 52 ff ff ff 	lea    -0xae(%rbp),%rsi
    newpath[0] = '/';
ffffffff8010d9bc:	c6 85 52 ff ff ff 2f 	movb   $0x2f,-0xae(%rbp)
    strncpy(newpath+1, path, DIRSIZ - 1);
ffffffff8010d9c3:	48 83 c6 01          	add    $0x1,%rsi
ffffffff8010d9c7:	48 8b 7d f0          	mov    -0x10(%rbp),%rdi
ffffffff8010d9cb:	41 bb 0d 00 00 00    	mov    $0xd,%r11d
ffffffff8010d9d1:	48 89 bd 10 ff ff ff 	mov    %rdi,-0xf0(%rbp)
ffffffff8010d9d8:	48 89 f7             	mov    %rsi,%rdi
ffffffff8010d9db:	48 8b b5 10 ff ff ff 	mov    -0xf0(%rbp),%rsi
ffffffff8010d9e2:	89 95 0c ff ff ff    	mov    %edx,-0xf4(%rbp)
ffffffff8010d9e8:	44 89 da             	mov    %r11d,%edx
ffffffff8010d9eb:	e8 90 d8 ff ff       	callq  ffffffff8010b280 <strncpy>
ffffffff8010d9f0:	48 8d bd 52 ff ff ff 	lea    -0xae(%rbp),%rdi
    filei = namei(newpath);
ffffffff8010d9f7:	48 89 85 00 ff ff ff 	mov    %rax,-0x100(%rbp)
ffffffff8010d9fe:	e8 dd ee ff ff       	callq  ffffffff8010c8e0 <namei>
ffffffff8010da03:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
    if (filei == NULL) {
ffffffff8010da07:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
ffffffff8010da0c:	0f 85 0c 00 00 00    	jne    ffffffff8010da1e <kernel_sys_open+0x23e>
      return -1;
ffffffff8010da12:	c7 45 fc ff ff ff ff 	movl   $0xffffffff,-0x4(%rbp)
ffffffff8010da19:	e9 f4 00 00 00       	jmpq   ffffffff8010db12 <kernel_sys_open+0x332>
    iload(filei);
ffffffff8010da1e:	48 8b 7d d0          	mov    -0x30(%rbp),%rdi
ffffffff8010da22:	e8 e9 e4 ff ff       	callq  ffffffff8010bf10 <iload>
  } else {
ffffffff8010da27:	e9 2d 00 00 00       	jmpq   ffffffff8010da59 <kernel_sys_open+0x279>
    filei = namei(path);
ffffffff8010da2c:	48 8b 7d f0          	mov    -0x10(%rbp),%rdi
ffffffff8010da30:	e8 ab ee ff ff       	callq  ffffffff8010c8e0 <namei>
ffffffff8010da35:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
    if (filei == NULL) {
ffffffff8010da39:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
ffffffff8010da3e:	0f 85 0c 00 00 00    	jne    ffffffff8010da50 <kernel_sys_open+0x270>
      return -1;
ffffffff8010da44:	c7 45 fc ff ff ff ff 	movl   $0xffffffff,-0x4(%rbp)
ffffffff8010da4b:	e9 c2 00 00 00       	jmpq   ffffffff8010db12 <kernel_sys_open+0x332>
    iload(filei);
ffffffff8010da50:	48 8b 7d d0          	mov    -0x30(%rbp),%rdi
ffffffff8010da54:	e8 b7 e4 ff ff       	callq  ffffffff8010bf10 <iload>
  acquire(&global_files.lock);
ffffffff8010da59:	48 c7 c7 10 4e 20 83 	mov    $0xffffffff83204e10,%rdi
ffffffff8010da60:	e8 5b 7d ff ff       	callq  ffffffff801057c0 <acquire>
  struct file_desc* file_desc = alloc_file_desc();
ffffffff8010da65:	e8 66 05 00 00       	callq  ffffffff8010dfd0 <alloc_file_desc>
ffffffff8010da6a:	48 89 85 48 ff ff ff 	mov    %rax,-0xb8(%rbp)
  if (file_desc == NULL) {
ffffffff8010da71:	48 83 bd 48 ff ff ff 	cmpq   $0x0,-0xb8(%rbp)
ffffffff8010da78:	00 
ffffffff8010da79:	0f 85 18 00 00 00    	jne    ffffffff8010da97 <kernel_sys_open+0x2b7>
    release(&global_files.lock);
ffffffff8010da7f:	48 c7 c7 10 4e 20 83 	mov    $0xffffffff83204e10,%rdi
ffffffff8010da86:	e8 75 7f ff ff       	callq  ffffffff80105a00 <release>
    return -1;
ffffffff8010da8b:	c7 45 fc ff ff ff ff 	movl   $0xffffffff,-0x4(%rbp)
ffffffff8010da92:	e9 7b 00 00 00       	jmpq   ffffffff8010db12 <kernel_sys_open+0x332>
  file_desc->inode = filei;
ffffffff8010da97:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
ffffffff8010da9b:	48 8b 8d 48 ff ff ff 	mov    -0xb8(%rbp),%rcx
ffffffff8010daa2:	48 89 01             	mov    %rax,(%rcx)
  file_desc->curr_offset = 0;
ffffffff8010daa5:	48 8b 85 48 ff ff ff 	mov    -0xb8(%rbp),%rax
ffffffff8010daac:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%rax)
  release(&global_files.lock);
ffffffff8010dab3:	48 c7 c7 10 4e 20 83 	mov    $0xffffffff83204e10,%rdi
ffffffff8010daba:	e8 41 7f ff ff       	callq  ffffffff80105a00 <release>
  struct open_file* opened_file_slot = &this_proc->open_files[idx];
ffffffff8010dabf:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
ffffffff8010dac3:	48 83 c0 38          	add    $0x38,%rax
ffffffff8010dac7:	48 63 4d dc          	movslq -0x24(%rbp),%rcx
ffffffff8010dacb:	48 6b c9 0b          	imul   $0xb,%rcx,%rcx
ffffffff8010dacf:	48 01 c8             	add    %rcx,%rax
ffffffff8010dad2:	48 89 85 40 ff ff ff 	mov    %rax,-0xc0(%rbp)
  opened_file_slot->type = FILE_INODE;
ffffffff8010dad9:	48 8b 85 40 ff ff ff 	mov    -0xc0(%rbp),%rax
ffffffff8010dae0:	c6 40 0a 01          	movb   $0x1,0xa(%rax)
  opened_file_slot->mode = (mode & ~O_CREATE);
ffffffff8010dae4:	8b 55 ec             	mov    -0x14(%rbp),%edx
ffffffff8010dae7:	81 e2 ff fd ff ff    	and    $0xfffffdff,%edx
ffffffff8010daed:	66 89 d6             	mov    %dx,%si
ffffffff8010daf0:	48 8b 85 40 ff ff ff 	mov    -0xc0(%rbp),%rax
ffffffff8010daf7:	66 89 70 08          	mov    %si,0x8(%rax)
  opened_file_slot->file_desc = file_desc;
ffffffff8010dafb:	48 8b 85 48 ff ff ff 	mov    -0xb8(%rbp),%rax
ffffffff8010db02:	48 8b 8d 40 ff ff ff 	mov    -0xc0(%rbp),%rcx
ffffffff8010db09:	48 89 01             	mov    %rax,(%rcx)
  return idx;
ffffffff8010db0c:	8b 55 dc             	mov    -0x24(%rbp),%edx
ffffffff8010db0f:	89 55 fc             	mov    %edx,-0x4(%rbp)
}
ffffffff8010db12:	8b 45 fc             	mov    -0x4(%rbp),%eax
ffffffff8010db15:	48 81 c4 00 01 00 00 	add    $0x100,%rsp
ffffffff8010db1c:	5d                   	pop    %rbp
ffffffff8010db1d:	c3                   	retq   
ffffffff8010db1e:	66 90                	xchg   %ax,%ax

ffffffff8010db20 <kernel_sys_pipe>:
{
ffffffff8010db20:	55                   	push   %rbp
ffffffff8010db21:	48 89 e5             	mov    %rsp,%rbp
ffffffff8010db24:	48 83 ec 40          	sub    $0x40,%rsp
ffffffff8010db28:	48 89 7d f0          	mov    %rdi,-0x10(%rbp)
  struct proc* this_proc = myproc();
ffffffff8010db2c:	e8 ff f1 ff ff       	callq  ffffffff8010cd30 <myproc>
ffffffff8010db31:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  int read_idx = next_free_table_index(this_proc);
ffffffff8010db35:	48 8b 7d e8          	mov    -0x18(%rbp),%rdi
ffffffff8010db39:	e8 12 f2 ff ff       	callq  ffffffff8010cd50 <next_free_table_index>
ffffffff8010db3e:	89 c1                	mov    %eax,%ecx
ffffffff8010db40:	89 4d e4             	mov    %ecx,-0x1c(%rbp)
  if (read_idx != -1) {
ffffffff8010db43:	83 7d e4 ff          	cmpl   $0xffffffff,-0x1c(%rbp)
ffffffff8010db47:	0f 84 2e 00 00 00    	je     ffffffff8010db7b <kernel_sys_pipe+0x5b>
    read_file = &this_proc->open_files[read_idx];
ffffffff8010db4d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
ffffffff8010db51:	48 83 c0 38          	add    $0x38,%rax
ffffffff8010db55:	48 63 4d e4          	movslq -0x1c(%rbp),%rcx
ffffffff8010db59:	48 6b c9 0b          	imul   $0xb,%rcx,%rcx
ffffffff8010db5d:	48 01 c8             	add    %rcx,%rax
ffffffff8010db60:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
    read_file->type = FILE_PIPE;
ffffffff8010db64:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
ffffffff8010db68:	c6 40 0a 02          	movb   $0x2,0xa(%rax)
    read_file->mode = O_RDONLY;
ffffffff8010db6c:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
ffffffff8010db70:	66 c7 40 08 00 00    	movw   $0x0,0x8(%rax)
  } else {
ffffffff8010db76:	e9 0c 00 00 00       	jmpq   ffffffff8010db87 <kernel_sys_pipe+0x67>
    return -1;
ffffffff8010db7b:	c7 45 fc ff ff ff ff 	movl   $0xffffffff,-0x4(%rbp)
ffffffff8010db82:	e9 03 01 00 00       	jmpq   ffffffff8010dc8a <kernel_sys_pipe+0x16a>
  int write_idx = next_free_table_index(this_proc);
ffffffff8010db87:	48 8b 7d e8          	mov    -0x18(%rbp),%rdi
ffffffff8010db8b:	e8 c0 f1 ff ff       	callq  ffffffff8010cd50 <next_free_table_index>
ffffffff8010db90:	89 c1                	mov    %eax,%ecx
ffffffff8010db92:	89 4d d4             	mov    %ecx,-0x2c(%rbp)
  if (write_idx != -1) {
ffffffff8010db95:	83 7d d4 ff          	cmpl   $0xffffffff,-0x2c(%rbp)
ffffffff8010db99:	0f 84 2e 00 00 00    	je     ffffffff8010dbcd <kernel_sys_pipe+0xad>
    write_file = &this_proc->open_files[write_idx];
ffffffff8010db9f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
ffffffff8010dba3:	48 83 c0 38          	add    $0x38,%rax
ffffffff8010dba7:	48 63 4d d4          	movslq -0x2c(%rbp),%rcx
ffffffff8010dbab:	48 6b c9 0b          	imul   $0xb,%rcx,%rcx
ffffffff8010dbaf:	48 01 c8             	add    %rcx,%rax
ffffffff8010dbb2:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
    write_file->type = FILE_PIPE;
ffffffff8010dbb6:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
ffffffff8010dbba:	c6 40 0a 02          	movb   $0x2,0xa(%rax)
    write_file->mode = O_WRONLY;
ffffffff8010dbbe:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
ffffffff8010dbc2:	66 c7 40 08 01 00    	movw   $0x1,0x8(%rax)
  } else {
ffffffff8010dbc8:	e9 14 00 00 00       	jmpq   ffffffff8010dbe1 <kernel_sys_pipe+0xc1>
    read_file->type = FILE_UNUSED;
ffffffff8010dbcd:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
ffffffff8010dbd1:	c6 40 0a 00          	movb   $0x0,0xa(%rax)
    return -1;
ffffffff8010dbd5:	c7 45 fc ff ff ff ff 	movl   $0xffffffff,-0x4(%rbp)
ffffffff8010dbdc:	e9 a9 00 00 00       	jmpq   ffffffff8010dc8a <kernel_sys_pipe+0x16a>
  struct pipe* shared_pipe = (struct pipe*) kalloc();
ffffffff8010dbe1:	e8 9a 2b ff ff       	callq  ffffffff80100780 <kalloc>
ffffffff8010dbe6:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
  if (shared_pipe != NULL) {
ffffffff8010dbea:	48 83 7d c0 00       	cmpq   $0x0,-0x40(%rbp)
ffffffff8010dbef:	0f 84 7e 00 00 00    	je     ffffffff8010dc73 <kernel_sys_pipe+0x153>
    initlock(&shared_pipe->lock, "pipe lock");
ffffffff8010dbf5:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
ffffffff8010dbf9:	48 05 00 08 00 00    	add    $0x800,%rax
ffffffff8010dbff:	48 c7 c6 59 06 11 80 	mov    $0xffffffff80110659,%rsi
ffffffff8010dc06:	48 89 c7             	mov    %rax,%rdi
ffffffff8010dc09:	e8 72 7b ff ff       	callq  ffffffff80105780 <initlock>
    shared_pipe->w_offset = 0;
ffffffff8010dc0e:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
ffffffff8010dc12:	66 c7 80 68 08 00 00 	movw   $0x0,0x868(%rax)
ffffffff8010dc19:	00 00 
    shared_pipe->r_offset = 0;
ffffffff8010dc1b:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
ffffffff8010dc1f:	66 c7 80 6a 08 00 00 	movw   $0x0,0x86a(%rax)
ffffffff8010dc26:	00 00 
    shared_pipe->w_refcount = 1;
ffffffff8010dc28:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
ffffffff8010dc2c:	c6 80 6c 08 00 00 01 	movb   $0x1,0x86c(%rax)
    shared_pipe->r_refcount = 1;
ffffffff8010dc33:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
ffffffff8010dc37:	c6 80 6d 08 00 00 01 	movb   $0x1,0x86d(%rax)
    read_file->pipe = shared_pipe;
ffffffff8010dc3e:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
ffffffff8010dc42:	48 8b 75 d8          	mov    -0x28(%rbp),%rsi
ffffffff8010dc46:	48 89 06             	mov    %rax,(%rsi)
    write_file->pipe = shared_pipe;
ffffffff8010dc49:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
ffffffff8010dc4d:	48 8b 75 c8          	mov    -0x38(%rbp),%rsi
ffffffff8010dc51:	48 89 06             	mov    %rax,(%rsi)
    pipe_fd[0] = read_idx;
ffffffff8010dc54:	8b 4d e4             	mov    -0x1c(%rbp),%ecx
ffffffff8010dc57:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
ffffffff8010dc5b:	89 08                	mov    %ecx,(%rax)
    pipe_fd[1] = write_idx;
ffffffff8010dc5d:	8b 4d d4             	mov    -0x2c(%rbp),%ecx
ffffffff8010dc60:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
ffffffff8010dc64:	89 48 04             	mov    %ecx,0x4(%rax)
    return 0;
ffffffff8010dc67:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
ffffffff8010dc6e:	e9 17 00 00 00       	jmpq   ffffffff8010dc8a <kernel_sys_pipe+0x16a>
    read_file->type = FILE_UNUSED;
ffffffff8010dc73:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
ffffffff8010dc77:	c6 40 0a 00          	movb   $0x0,0xa(%rax)
    write_file->type = FILE_UNUSED;
ffffffff8010dc7b:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
ffffffff8010dc7f:	c6 40 0a 00          	movb   $0x0,0xa(%rax)
    return -1;
ffffffff8010dc83:	c7 45 fc ff ff ff ff 	movl   $0xffffffff,-0x4(%rbp)
}
ffffffff8010dc8a:	8b 45 fc             	mov    -0x4(%rbp),%eax
ffffffff8010dc8d:	48 83 c4 40          	add    $0x40,%rsp
ffffffff8010dc91:	5d                   	pop    %rbp
ffffffff8010dc92:	c3                   	retq   
ffffffff8010dc93:	66 66 66 66 2e 0f 1f 	data16 data16 data16 nopw %cs:0x0(%rax,%rax,1)
ffffffff8010dc9a:	84 00 00 00 00 00 

ffffffff8010dca0 <kernel_duplicate_open_files>:
{
ffffffff8010dca0:	55                   	push   %rbp
ffffffff8010dca1:	48 89 e5             	mov    %rsp,%rbp
ffffffff8010dca4:	48 83 ec 30          	sub    $0x30,%rsp
ffffffff8010dca8:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
ffffffff8010dcac:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  for (int i = 0; i < NOFILE; ++i) {
ffffffff8010dcb0:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%rbp)
ffffffff8010dcb7:	83 7d ec 10          	cmpl   $0x10,-0x14(%rbp)
ffffffff8010dcbb:	0f 8d b9 00 00 00    	jge    ffffffff8010dd7a <kernel_duplicate_open_files+0xda>
    struct open_file* source = &source_table[i];
ffffffff8010dcc1:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
ffffffff8010dcc5:	48 63 4d ec          	movslq -0x14(%rbp),%rcx
ffffffff8010dcc9:	48 6b c9 0b          	imul   $0xb,%rcx,%rcx
ffffffff8010dccd:	48 01 c8             	add    %rcx,%rax
ffffffff8010dcd0:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
    struct open_file* dest = &dest_table[i];
ffffffff8010dcd4:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
ffffffff8010dcd8:	48 63 4d ec          	movslq -0x14(%rbp),%rcx
ffffffff8010dcdc:	48 6b c9 0b          	imul   $0xb,%rcx,%rcx
ffffffff8010dce0:	48 01 c8             	add    %rcx,%rax
ffffffff8010dce3:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
    *dest = *source;
ffffffff8010dce7:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
ffffffff8010dceb:	48 8b 4d e0          	mov    -0x20(%rbp),%rcx
ffffffff8010dcef:	48 8b 11             	mov    (%rcx),%rdx
ffffffff8010dcf2:	48 89 10             	mov    %rdx,(%rax)
ffffffff8010dcf5:	66 8b 71 08          	mov    0x8(%rcx),%si
ffffffff8010dcf9:	66 89 70 08          	mov    %si,0x8(%rax)
ffffffff8010dcfd:	40 8a 79 0a          	mov    0xa(%rcx),%dil
ffffffff8010dd01:	40 88 78 0a          	mov    %dil,0xa(%rax)
    if (dest->type == FILE_INODE) {
ffffffff8010dd05:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
ffffffff8010dd09:	44 0f be 40 0a       	movsbl 0xa(%rax),%r8d
ffffffff8010dd0e:	41 83 f8 01          	cmp    $0x1,%r8d
ffffffff8010dd12:	0f 85 30 00 00 00    	jne    ffffffff8010dd48 <kernel_duplicate_open_files+0xa8>
      acquire(&global_files.lock);
ffffffff8010dd18:	48 c7 c7 10 4e 20 83 	mov    $0xffffffff83204e10,%rdi
ffffffff8010dd1f:	e8 9c 7a ff ff       	callq  ffffffff801057c0 <acquire>
      dest->file_desc->refcount++;
ffffffff8010dd24:	48 8b 7d d8          	mov    -0x28(%rbp),%rdi
ffffffff8010dd28:	48 8b 3f             	mov    (%rdi),%rdi
ffffffff8010dd2b:	66 8b 47 0c          	mov    0xc(%rdi),%ax
ffffffff8010dd2f:	66 83 c0 01          	add    $0x1,%ax
ffffffff8010dd33:	66 89 47 0c          	mov    %ax,0xc(%rdi)
      release(&global_files.lock);
ffffffff8010dd37:	48 c7 c7 10 4e 20 83 	mov    $0xffffffff83204e10,%rdi
ffffffff8010dd3e:	e8 bd 7c ff ff       	callq  ffffffff80105a00 <release>
    } else if (dest->type == FILE_PIPE) {
ffffffff8010dd43:	e9 1f 00 00 00       	jmpq   ffffffff8010dd67 <kernel_duplicate_open_files+0xc7>
ffffffff8010dd48:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
ffffffff8010dd4c:	0f be 48 0a          	movsbl 0xa(%rax),%ecx
ffffffff8010dd50:	83 f9 02             	cmp    $0x2,%ecx
ffffffff8010dd53:	0f 85 09 00 00 00    	jne    ffffffff8010dd62 <kernel_duplicate_open_files+0xc2>
      pipe_dup(dest);
ffffffff8010dd59:	48 8b 7d d8          	mov    -0x28(%rbp),%rdi
ffffffff8010dd5d:	e8 6e f0 ff ff       	callq  ffffffff8010cdd0 <pipe_dup>
ffffffff8010dd62:	e9 00 00 00 00       	jmpq   ffffffff8010dd67 <kernel_duplicate_open_files+0xc7>
  }
ffffffff8010dd67:	e9 00 00 00 00       	jmpq   ffffffff8010dd6c <kernel_duplicate_open_files+0xcc>
  for (int i = 0; i < NOFILE; ++i) {
ffffffff8010dd6c:	8b 45 ec             	mov    -0x14(%rbp),%eax
ffffffff8010dd6f:	83 c0 01             	add    $0x1,%eax
ffffffff8010dd72:	89 45 ec             	mov    %eax,-0x14(%rbp)
ffffffff8010dd75:	e9 3d ff ff ff       	jmpq   ffffffff8010dcb7 <kernel_duplicate_open_files+0x17>
}
ffffffff8010dd7a:	48 83 c4 30          	add    $0x30,%rsp
ffffffff8010dd7e:	5d                   	pop    %rbp
ffffffff8010dd7f:	c3                   	retq   

ffffffff8010dd80 <kernel_mmap>:
{
ffffffff8010dd80:	55                   	push   %rbp
ffffffff8010dd81:	48 89 e5             	mov    %rsp,%rbp
ffffffff8010dd84:	48 83 ec 70          	sub    $0x70,%rsp
ffffffff8010dd88:	89 7d f8             	mov    %edi,-0x8(%rbp)
  struct proc* proc = myproc();
ffffffff8010dd8b:	e8 a0 ef ff ff       	callq  ffffffff8010cd30 <myproc>
ffffffff8010dd90:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  if (proc->mapinfo.mapped_file != NULL) {
ffffffff8010dd94:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
ffffffff8010dd98:	48 83 b8 e8 00 00 00 	cmpq   $0x0,0xe8(%rax)
ffffffff8010dd9f:	00 
ffffffff8010dda0:	0f 84 0c 00 00 00    	je     ffffffff8010ddb2 <kernel_mmap+0x32>
    return -1;
ffffffff8010dda6:	c7 45 fc ff ff ff ff 	movl   $0xffffffff,-0x4(%rbp)
ffffffff8010ddad:	e9 fa 01 00 00       	jmpq   ffffffff8010dfac <kernel_mmap+0x22c>
  struct open_file* file = &proc->open_files[fd];
ffffffff8010ddb2:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
ffffffff8010ddb6:	48 83 c0 38          	add    $0x38,%rax
ffffffff8010ddba:	48 63 4d f8          	movslq -0x8(%rbp),%rcx
ffffffff8010ddbe:	48 6b c9 0b          	imul   $0xb,%rcx,%rcx
ffffffff8010ddc2:	48 01 c8             	add    %rcx,%rax
ffffffff8010ddc5:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  if (file->type != FILE_INODE) {
ffffffff8010ddc9:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
ffffffff8010ddcd:	0f be 50 0a          	movsbl 0xa(%rax),%edx
ffffffff8010ddd1:	83 fa 01             	cmp    $0x1,%edx
ffffffff8010ddd4:	0f 84 0c 00 00 00    	je     ffffffff8010dde6 <kernel_mmap+0x66>
    return -1;
ffffffff8010ddda:	c7 45 fc ff ff ff ff 	movl   $0xffffffff,-0x4(%rbp)
ffffffff8010dde1:	e9 c6 01 00 00       	jmpq   ffffffff8010dfac <kernel_mmap+0x22c>
ffffffff8010dde6:	48 8d 45 d8          	lea    -0x28(%rbp),%rax
  struct inode* inode = file->file_desc->inode;
ffffffff8010ddea:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
ffffffff8010ddee:	48 8b 09             	mov    (%rcx),%rcx
ffffffff8010ddf1:	48 8b 09             	mov    (%rcx),%rcx
ffffffff8010ddf4:	48 89 4d e0          	mov    %rcx,-0x20(%rbp)
   find_mapped_file(inode->inum, &mapping_proc);
ffffffff8010ddf8:	48 8b 4d e0          	mov    -0x20(%rbp),%rcx
ffffffff8010ddfc:	8b 79 04             	mov    0x4(%rcx),%edi
ffffffff8010ddff:	48 8d 75 d8          	lea    -0x28(%rbp),%rsi
ffffffff8010de03:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
ffffffff8010de07:	e8 84 98 ff ff       	callq  ffffffff80107690 <find_mapped_file>
  struct mapped_file* existing_mapped_file =
ffffffff8010de0c:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
  if (existing_mapped_file == NULL) {
ffffffff8010de10:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
ffffffff8010de15:	0f 85 4c 01 00 00    	jne    ffffffff8010df67 <kernel_mmap+0x1e7>
    mapped_file = (struct mapped_file*) kalloc();
ffffffff8010de1b:	e8 60 29 ff ff       	callq  ffffffff80100780 <kalloc>
ffffffff8010de20:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
    mapped_file->inode = inode;
ffffffff8010de24:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
ffffffff8010de28:	48 8b 4d c8          	mov    -0x38(%rbp),%rcx
ffffffff8010de2c:	48 89 01             	mov    %rax,(%rcx)
    mapped_file->refcount = 1;
ffffffff8010de2f:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
ffffffff8010de33:	c6 40 74 01          	movb   $0x1,0x74(%rax)
    initlock(&mapped_file->lock, "mapped_file");
ffffffff8010de37:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
ffffffff8010de3b:	48 83 c0 08          	add    $0x8,%rax
ffffffff8010de3f:	48 c7 c6 63 06 11 80 	mov    $0xffffffff80110663,%rsi
ffffffff8010de46:	48 89 c7             	mov    %rax,%rdi
ffffffff8010de49:	e8 32 79 ff ff       	callq  ffffffff80105780 <initlock>
    if (inode->size > 0) {
ffffffff8010de4e:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
ffffffff8010de52:	83 b8 9c 00 00 00 00 	cmpl   $0x0,0x9c(%rax)
ffffffff8010de59:	0f 86 f8 00 00 00    	jbe    ffffffff8010df57 <kernel_mmap+0x1d7>
ffffffff8010de5f:	b8 00 00 00 80       	mov    $0x80000000,%eax
ffffffff8010de64:	89 c1                	mov    %eax,%ecx
ffffffff8010de66:	31 c0                	xor    %eax,%eax
ffffffff8010de68:	89 c2                	mov    %eax,%edx
      mapped_file->pages = (inode->size / PGSIZE) + 1;
ffffffff8010de6a:	48 8b 75 e0          	mov    -0x20(%rbp),%rsi
ffffffff8010de6e:	8b 86 9c 00 00 00    	mov    0x9c(%rsi),%eax
ffffffff8010de74:	c1 e8 0c             	shr    $0xc,%eax
ffffffff8010de77:	83 c0 01             	add    $0x1,%eax
ffffffff8010de7a:	48 8b 75 c8          	mov    -0x38(%rbp),%rsi
ffffffff8010de7e:	89 46 70             	mov    %eax,0x70(%rsi)
      if (allocuvm(proc->pml4, MAPPED_FILE_VADDR, 0, inode->size, proc->pid) < 0) {
ffffffff8010de81:	48 8b 75 f0          	mov    -0x10(%rbp),%rsi
ffffffff8010de85:	48 8b 3e             	mov    (%rsi),%rdi
ffffffff8010de88:	48 8b 75 e0          	mov    -0x20(%rbp),%rsi
ffffffff8010de8c:	8b 86 9c 00 00 00    	mov    0x9c(%rsi),%eax
ffffffff8010de92:	89 c6                	mov    %eax,%esi
ffffffff8010de94:	4c 8b 45 f0          	mov    -0x10(%rbp),%r8
ffffffff8010de98:	45 8b 80 04 01 00 00 	mov    0x104(%r8),%r8d
ffffffff8010de9f:	b8 00 00 00 80       	mov    $0x80000000,%eax
ffffffff8010dea4:	41 89 c1             	mov    %eax,%r9d
ffffffff8010dea7:	31 c0                	xor    %eax,%eax
ffffffff8010dea9:	41 89 c2             	mov    %eax,%r10d
ffffffff8010deac:	48 89 75 b8          	mov    %rsi,-0x48(%rbp)
ffffffff8010deb0:	4c 89 ce             	mov    %r9,%rsi
ffffffff8010deb3:	48 89 55 b0          	mov    %rdx,-0x50(%rbp)
ffffffff8010deb7:	4c 89 d2             	mov    %r10,%rdx
ffffffff8010deba:	4c 8b 4d b8          	mov    -0x48(%rbp),%r9
ffffffff8010debe:	48 89 4d a8          	mov    %rcx,-0x58(%rbp)
ffffffff8010dec2:	4c 89 c9             	mov    %r9,%rcx
ffffffff8010dec5:	e8 e6 5d ff ff       	callq  ffffffff80103cb0 <allocuvm>
ffffffff8010deca:	83 f8 00             	cmp    $0x0,%eax
ffffffff8010decd:	0f 8d 18 00 00 00    	jge    ffffffff8010deeb <kernel_mmap+0x16b>
        kfree((char*) mapped_file);
ffffffff8010ded3:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
ffffffff8010ded7:	48 89 c7             	mov    %rax,%rdi
ffffffff8010deda:	e8 91 26 ff ff       	callq  ffffffff80100570 <kfree>
        return -1;
ffffffff8010dedf:	c7 45 fc ff ff ff ff 	movl   $0xffffffff,-0x4(%rbp)
ffffffff8010dee6:	e9 c1 00 00 00       	jmpq   ffffffff8010dfac <kernel_mmap+0x22c>
ffffffff8010deeb:	b8 00 00 00 80       	mov    $0x80000000,%eax
ffffffff8010def0:	89 c1                	mov    %eax,%ecx
ffffffff8010def2:	31 c0                	xor    %eax,%eax
      if (readi(inode, MAPPED_FILE_VADDR, 0, inode->size) != inode->size) {
ffffffff8010def4:	48 8b 7d e0          	mov    -0x20(%rbp),%rdi
ffffffff8010def8:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
ffffffff8010defc:	8b b2 9c 00 00 00    	mov    0x9c(%rdx),%esi
ffffffff8010df02:	41 b8 00 00 00 80    	mov    $0x80000000,%r8d
ffffffff8010df08:	44 89 c2             	mov    %r8d,%edx
ffffffff8010df0b:	45 31 c0             	xor    %r8d,%r8d
ffffffff8010df0e:	89 75 a4             	mov    %esi,-0x5c(%rbp)
ffffffff8010df11:	48 89 d6             	mov    %rdx,%rsi
ffffffff8010df14:	44 89 c2             	mov    %r8d,%edx
ffffffff8010df17:	44 8b 45 a4          	mov    -0x5c(%rbp),%r8d
ffffffff8010df1b:	48 89 4d 98          	mov    %rcx,-0x68(%rbp)
ffffffff8010df1f:	44 89 c1             	mov    %r8d,%ecx
ffffffff8010df22:	89 45 94             	mov    %eax,-0x6c(%rbp)
ffffffff8010df25:	e8 a6 dd ff ff       	callq  ffffffff8010bcd0 <readi>
ffffffff8010df2a:	48 8b 75 e0          	mov    -0x20(%rbp),%rsi
ffffffff8010df2e:	3b 86 9c 00 00 00    	cmp    0x9c(%rsi),%eax
ffffffff8010df34:	0f 84 18 00 00 00    	je     ffffffff8010df52 <kernel_mmap+0x1d2>
        kfree((char*) mapped_file);
ffffffff8010df3a:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
ffffffff8010df3e:	48 89 c7             	mov    %rax,%rdi
ffffffff8010df41:	e8 2a 26 ff ff       	callq  ffffffff80100570 <kfree>
        return -1;
ffffffff8010df46:	c7 45 fc ff ff ff ff 	movl   $0xffffffff,-0x4(%rbp)
ffffffff8010df4d:	e9 5a 00 00 00       	jmpq   ffffffff8010dfac <kernel_mmap+0x22c>
    } else {
ffffffff8010df52:	e9 0b 00 00 00       	jmpq   ffffffff8010df62 <kernel_mmap+0x1e2>
      mapped_file->pages = 0;
ffffffff8010df57:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
ffffffff8010df5b:	c7 40 70 00 00 00 00 	movl   $0x0,0x70(%rax)
  } else {
ffffffff8010df62:	e9 1c 00 00 00       	jmpq   ffffffff8010df83 <kernel_mmap+0x203>
    mapped_file = mapping_proc->mapinfo.mapped_file;
ffffffff8010df67:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
ffffffff8010df6b:	48 8b 80 e8 00 00 00 	mov    0xe8(%rax),%rax
ffffffff8010df72:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
    kernel_duplicate_mapped_file(mapping_proc, proc);
ffffffff8010df76:	48 8b 7d d8          	mov    -0x28(%rbp),%rdi
ffffffff8010df7a:	48 8b 75 f0          	mov    -0x10(%rbp),%rsi
ffffffff8010df7e:	e8 ed 97 ff ff       	callq  ffffffff80107770 <kernel_duplicate_mapped_file>
  proc->mapinfo.mapped_file = mapped_file;
ffffffff8010df83:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
ffffffff8010df87:	48 8b 4d f0          	mov    -0x10(%rbp),%rcx
ffffffff8010df8b:	48 89 81 e8 00 00 00 	mov    %rax,0xe8(%rcx)
  proc->mapinfo.fd = fd;
ffffffff8010df92:	8b 55 f8             	mov    -0x8(%rbp),%edx
ffffffff8010df95:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
ffffffff8010df99:	89 90 f0 00 00 00    	mov    %edx,0xf0(%rax)
  return inode->size;
ffffffff8010df9f:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
ffffffff8010dfa3:	8b 90 9c 00 00 00    	mov    0x9c(%rax),%edx
ffffffff8010dfa9:	89 55 fc             	mov    %edx,-0x4(%rbp)
}
ffffffff8010dfac:	8b 45 fc             	mov    -0x4(%rbp),%eax
ffffffff8010dfaf:	48 83 c4 70          	add    $0x70,%rsp
ffffffff8010dfb3:	5d                   	pop    %rbp
ffffffff8010dfb4:	c3                   	retq   
ffffffff8010dfb5:	66 66 2e 0f 1f 84 00 	data16 nopw %cs:0x0(%rax,%rax,1)
ffffffff8010dfbc:	00 00 00 00 

ffffffff8010dfc0 <mycpu>:
{
ffffffff8010dfc0:	55                   	push   %rbp
ffffffff8010dfc1:	48 89 e5             	mov    %rsp,%rbp
  return &cpus[0];
ffffffff8010dfc4:	48 c7 c0 e0 7b 1f 83 	mov    $0xffffffff831f7be0,%rax
ffffffff8010dfcb:	5d                   	pop    %rbp
ffffffff8010dfcc:	c3                   	retq   
ffffffff8010dfcd:	0f 1f 00             	nopl   (%rax)

ffffffff8010dfd0 <alloc_file_desc>:
{
ffffffff8010dfd0:	55                   	push   %rbp
ffffffff8010dfd1:	48 89 e5             	mov    %rsp,%rbp
  for (size_t i = 0; i < NFILE; i++) {
ffffffff8010dfd4:	48 83 ec 10          	sub    $0x10,%rsp
ffffffff8010dfd8:	48 c7 45 f0 00 00 00 	movq   $0x0,-0x10(%rbp)
ffffffff8010dfdf:	00 
ffffffff8010dfe0:	48 83 7d f0 64       	cmpq   $0x64,-0x10(%rbp)
ffffffff8010dfe5:	0f 83 5b 00 00 00    	jae    ffffffff8010e046 <alloc_file_desc+0x76>
    if (global_files.files[i].refcount == 0) {
ffffffff8010dfeb:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
ffffffff8010dfef:	48 c1 e0 04          	shl    $0x4,%rax
ffffffff8010dff3:	48 8d 80 78 4e 20 83 	lea    -0x7cdfb188(%rax),%rax
ffffffff8010dffa:	0f b7 48 0c          	movzwl 0xc(%rax),%ecx
ffffffff8010dffe:	83 f9 00             	cmp    $0x0,%ecx
ffffffff8010e001:	0f 85 29 00 00 00    	jne    ffffffff8010e030 <alloc_file_desc+0x60>
      global_files.files[i].refcount = 1;
ffffffff8010e007:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
ffffffff8010e00b:	48 c1 e0 04          	shl    $0x4,%rax
ffffffff8010e00f:	66 c7 80 84 4e 20 83 	movw   $0x1,-0x7cdfb17c(%rax)
ffffffff8010e016:	01 00 
      return &global_files.files[i];
ffffffff8010e018:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
ffffffff8010e01c:	48 c1 e0 04          	shl    $0x4,%rax
ffffffff8010e020:	48 8d 80 78 4e 20 83 	lea    -0x7cdfb188(%rax),%rax
ffffffff8010e027:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
ffffffff8010e02b:	e9 1e 00 00 00       	jmpq   ffffffff8010e04e <alloc_file_desc+0x7e>
  }
ffffffff8010e030:	e9 00 00 00 00       	jmpq   ffffffff8010e035 <alloc_file_desc+0x65>
  for (size_t i = 0; i < NFILE; i++) {
ffffffff8010e035:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
ffffffff8010e039:	48 83 c0 01          	add    $0x1,%rax
ffffffff8010e03d:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
ffffffff8010e041:	e9 9a ff ff ff       	jmpq   ffffffff8010dfe0 <alloc_file_desc+0x10>
  return NULL;
ffffffff8010e046:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
ffffffff8010e04d:	00 
}
ffffffff8010e04e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
ffffffff8010e052:	48 83 c4 10          	add    $0x10,%rsp
ffffffff8010e056:	5d                   	pop    %rbp
ffffffff8010e057:	c3                   	retq   
ffffffff8010e058:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
ffffffff8010e05f:	00 

ffffffff8010e060 <load_program_from_disk>:
#include <defs.h>
#include <x86_64.h>
#include <elf.h>
#include <trap.h>

int load_program_from_disk(pml4e_t *pml4, char *path, uint64_t *rip) {
ffffffff8010e060:	55                   	push   %rbp
ffffffff8010e061:	48 89 e5             	mov    %rsp,%rbp
ffffffff8010e064:	48 81 ec 00 01 00 00 	sub    $0x100,%rsp
ffffffff8010e06b:	48 89 7d f0          	mov    %rdi,-0x10(%rbp)
ffffffff8010e06f:	48 89 75 e8          	mov    %rsi,-0x18(%rbp)
ffffffff8010e073:	48 89 55 e0          	mov    %rdx,-0x20(%rbp)
  int off;
  uint64_t sz;
  struct elfhdr elf;
  int i;

  if((ip = namei(path)) == 0){
ffffffff8010e077:	48 8b 7d e8          	mov    -0x18(%rbp),%rdi
ffffffff8010e07b:	e8 60 e8 ff ff       	callq  ffffffff8010c8e0 <namei>
ffffffff8010e080:	48 89 45 d8          	mov    %rax,-0x28(%rbp)
ffffffff8010e084:	48 83 f8 00          	cmp    $0x0,%rax
ffffffff8010e088:	0f 85 0c 00 00 00    	jne    ffffffff8010e09a <load_program_from_disk+0x3a>
    return 0;
ffffffff8010e08e:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
ffffffff8010e095:	e9 46 02 00 00       	jmpq   ffffffff8010e2e0 <load_program_from_disk+0x280>
  }

  iload(ip);
ffffffff8010e09a:	48 8b 7d d8          	mov    -0x28(%rbp),%rdi
ffffffff8010e09e:	e8 6d de ff ff       	callq  ffffffff8010bf10 <iload>
ffffffff8010e0a3:	31 c0                	xor    %eax,%eax
ffffffff8010e0a5:	b9 40 00 00 00       	mov    $0x40,%ecx
ffffffff8010e0aa:	48 8d bd 50 ff ff ff 	lea    -0xb0(%rbp),%rdi

  // Check ELF header
  if(readi(ip, (char*)&elf, 0, sizeof(elf)) != sizeof(elf))
ffffffff8010e0b1:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
ffffffff8010e0b5:	31 f6                	xor    %esi,%esi
ffffffff8010e0b7:	41 b8 40 00 00 00    	mov    $0x40,%r8d
ffffffff8010e0bd:	48 89 bd 40 ff ff ff 	mov    %rdi,-0xc0(%rbp)
ffffffff8010e0c4:	48 89 d7             	mov    %rdx,%rdi
ffffffff8010e0c7:	48 8b 95 40 ff ff ff 	mov    -0xc0(%rbp),%rdx
ffffffff8010e0ce:	89 b5 3c ff ff ff    	mov    %esi,-0xc4(%rbp)
ffffffff8010e0d4:	48 89 d6             	mov    %rdx,%rsi
ffffffff8010e0d7:	8b 95 3c ff ff ff    	mov    -0xc4(%rbp),%edx
ffffffff8010e0dd:	89 8d 38 ff ff ff    	mov    %ecx,-0xc8(%rbp)
ffffffff8010e0e3:	44 89 c1             	mov    %r8d,%ecx
ffffffff8010e0e6:	89 85 34 ff ff ff    	mov    %eax,-0xcc(%rbp)
ffffffff8010e0ec:	e8 df db ff ff       	callq  ffffffff8010bcd0 <readi>
ffffffff8010e0f1:	48 63 f0             	movslq %eax,%rsi
ffffffff8010e0f4:	48 83 fe 40          	cmp    $0x40,%rsi
ffffffff8010e0f8:	0f 84 05 00 00 00    	je     ffffffff8010e103 <load_program_from_disk+0xa3>
    goto elf_failure;
ffffffff8010e0fe:	e9 c2 01 00 00       	jmpq   ffffffff8010e2c5 <load_program_from_disk+0x265>
  if(elf.magic != ELF_MAGIC)
ffffffff8010e103:	81 bd 50 ff ff ff 7f 	cmpl   $0x464c457f,-0xb0(%rbp)
ffffffff8010e10a:	45 4c 46 
ffffffff8010e10d:	0f 84 05 00 00 00    	je     ffffffff8010e118 <load_program_from_disk+0xb8>
    goto elf_failure;
ffffffff8010e113:	e9 ad 01 00 00       	jmpq   ffffffff8010e2c5 <load_program_from_disk+0x265>

  // Load program into memory.
  sz = 0;
ffffffff8010e118:	48 c7 45 90 00 00 00 	movq   $0x0,-0x70(%rbp)
ffffffff8010e11f:	00 
  for(i=0, off=elf.phoff; i<elf.phnum; i++, off+=sizeof(ph)){
ffffffff8010e120:	c7 85 4c ff ff ff 00 	movl   $0x0,-0xb4(%rbp)
ffffffff8010e127:	00 00 00 
ffffffff8010e12a:	48 8b 85 70 ff ff ff 	mov    -0x90(%rbp),%rax
ffffffff8010e131:	89 c1                	mov    %eax,%ecx
ffffffff8010e133:	89 4d 9c             	mov    %ecx,-0x64(%rbp)
ffffffff8010e136:	8b 85 4c ff ff ff    	mov    -0xb4(%rbp),%eax
ffffffff8010e13c:	0f b7 4d 88          	movzwl -0x78(%rbp),%ecx
ffffffff8010e140:	39 c8                	cmp    %ecx,%eax
ffffffff8010e142:	0f 8d 58 01 00 00    	jge    ffffffff8010e2a0 <load_program_from_disk+0x240>
ffffffff8010e148:	b8 38 00 00 00       	mov    $0x38,%eax
ffffffff8010e14d:	48 8d 4d a0          	lea    -0x60(%rbp),%rcx
    if(readi(ip, (char*)&ph, off, sizeof(ph)) != sizeof(ph))
ffffffff8010e151:	48 8b 7d d8          	mov    -0x28(%rbp),%rdi
ffffffff8010e155:	8b 55 9c             	mov    -0x64(%rbp),%edx
ffffffff8010e158:	be 38 00 00 00       	mov    $0x38,%esi
ffffffff8010e15d:	89 b5 30 ff ff ff    	mov    %esi,-0xd0(%rbp)
ffffffff8010e163:	48 89 ce             	mov    %rcx,%rsi
ffffffff8010e166:	8b 8d 30 ff ff ff    	mov    -0xd0(%rbp),%ecx
ffffffff8010e16c:	89 85 2c ff ff ff    	mov    %eax,-0xd4(%rbp)
ffffffff8010e172:	e8 59 db ff ff       	callq  ffffffff8010bcd0 <readi>
ffffffff8010e177:	48 63 f0             	movslq %eax,%rsi
ffffffff8010e17a:	48 83 fe 38          	cmp    $0x38,%rsi
ffffffff8010e17e:	0f 84 05 00 00 00    	je     ffffffff8010e189 <load_program_from_disk+0x129>
      goto elf_failure;
ffffffff8010e184:	e9 3c 01 00 00       	jmpq   ffffffff8010e2c5 <load_program_from_disk+0x265>
    if(ph.type != ELF_PROG_LOAD)
ffffffff8010e189:	83 7d a0 01          	cmpl   $0x1,-0x60(%rbp)
ffffffff8010e18d:	0f 84 05 00 00 00    	je     ffffffff8010e198 <load_program_from_disk+0x138>
      continue;
ffffffff8010e193:	e9 e7 00 00 00       	jmpq   ffffffff8010e27f <load_program_from_disk+0x21f>
    if(ph.memsz < ph.filesz)
ffffffff8010e198:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
ffffffff8010e19c:	48 3b 45 c0          	cmp    -0x40(%rbp),%rax
ffffffff8010e1a0:	0f 83 05 00 00 00    	jae    ffffffff8010e1ab <load_program_from_disk+0x14b>
      goto elf_failure;
ffffffff8010e1a6:	e9 1a 01 00 00       	jmpq   ffffffff8010e2c5 <load_program_from_disk+0x265>
    if(ph.vaddr + ph.memsz < ph.vaddr)
ffffffff8010e1ab:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
ffffffff8010e1af:	48 03 45 c8          	add    -0x38(%rbp),%rax
ffffffff8010e1b3:	48 3b 45 b0          	cmp    -0x50(%rbp),%rax
ffffffff8010e1b7:	0f 83 05 00 00 00    	jae    ffffffff8010e1c2 <load_program_from_disk+0x162>
      goto elf_failure;
ffffffff8010e1bd:	e9 03 01 00 00       	jmpq   ffffffff8010e2c5 <load_program_from_disk+0x265>


    if((sz = allocuvm(pml4, 0, sz, ph.vaddr + ph.memsz, myproc()->pid)) == -1)
ffffffff8010e1c2:	48 8b 7d f0          	mov    -0x10(%rbp),%rdi
ffffffff8010e1c6:	48 8b 55 90          	mov    -0x70(%rbp),%rdx
ffffffff8010e1ca:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
ffffffff8010e1ce:	48 03 45 c8          	add    -0x38(%rbp),%rax
ffffffff8010e1d2:	48 89 bd 20 ff ff ff 	mov    %rdi,-0xe0(%rbp)
ffffffff8010e1d9:	48 89 95 18 ff ff ff 	mov    %rdx,-0xe8(%rbp)
ffffffff8010e1e0:	48 89 85 10 ff ff ff 	mov    %rax,-0xf0(%rbp)
ffffffff8010e1e7:	e8 04 01 00 00       	callq  ffffffff8010e2f0 <myproc>
ffffffff8010e1ec:	31 c9                	xor    %ecx,%ecx
ffffffff8010e1ee:	89 ca                	mov    %ecx,%edx
ffffffff8010e1f0:	44 8b 80 04 01 00 00 	mov    0x104(%rax),%r8d
ffffffff8010e1f7:	31 c9                	xor    %ecx,%ecx
ffffffff8010e1f9:	89 ce                	mov    %ecx,%esi
ffffffff8010e1fb:	48 8b bd 20 ff ff ff 	mov    -0xe0(%rbp),%rdi
ffffffff8010e202:	48 8b 85 18 ff ff ff 	mov    -0xe8(%rbp),%rax
ffffffff8010e209:	48 89 95 08 ff ff ff 	mov    %rdx,-0xf8(%rbp)
ffffffff8010e210:	48 89 c2             	mov    %rax,%rdx
ffffffff8010e213:	48 8b 8d 10 ff ff ff 	mov    -0xf0(%rbp),%rcx
ffffffff8010e21a:	e8 91 5a ff ff       	callq  ffffffff80103cb0 <allocuvm>
ffffffff8010e21f:	48 63 c8             	movslq %eax,%rcx
ffffffff8010e222:	48 89 4d 90          	mov    %rcx,-0x70(%rbp)
ffffffff8010e226:	48 83 f9 ff          	cmp    $0xffffffffffffffff,%rcx
ffffffff8010e22a:	0f 85 05 00 00 00    	jne    ffffffff8010e235 <load_program_from_disk+0x1d5>
     goto elf_failure;
ffffffff8010e230:	e9 90 00 00 00       	jmpq   ffffffff8010e2c5 <load_program_from_disk+0x265>
    if(ph.vaddr % PGSIZE != 0)
ffffffff8010e235:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
ffffffff8010e239:	48 25 ff 0f 00 00    	and    $0xfff,%rax
ffffffff8010e23f:	48 83 f8 00          	cmp    $0x0,%rax
ffffffff8010e243:	0f 84 05 00 00 00    	je     ffffffff8010e24e <load_program_from_disk+0x1ee>
      goto elf_failure;
ffffffff8010e249:	e9 77 00 00 00       	jmpq   ffffffff8010e2c5 <load_program_from_disk+0x265>


    if(loaduvm(pml4, (char*)ph.vaddr, ip, ph.off, ph.filesz) < 0)
ffffffff8010e24e:	48 8b 7d f0          	mov    -0x10(%rbp),%rdi
ffffffff8010e252:	48 8b 75 b0          	mov    -0x50(%rbp),%rsi
ffffffff8010e256:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
ffffffff8010e25a:	48 8b 45 a8          	mov    -0x58(%rbp),%rax
ffffffff8010e25e:	89 c1                	mov    %eax,%ecx
ffffffff8010e260:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
ffffffff8010e264:	41 89 c0             	mov    %eax,%r8d
ffffffff8010e267:	e8 34 57 ff ff       	callq  ffffffff801039a0 <loaduvm>
ffffffff8010e26c:	83 f8 00             	cmp    $0x0,%eax
ffffffff8010e26f:	0f 8d 05 00 00 00    	jge    ffffffff8010e27a <load_program_from_disk+0x21a>
     goto elf_failure;
ffffffff8010e275:	e9 4b 00 00 00       	jmpq   ffffffff8010e2c5 <load_program_from_disk+0x265>
  }
ffffffff8010e27a:	e9 00 00 00 00       	jmpq   ffffffff8010e27f <load_program_from_disk+0x21f>
  for(i=0, off=elf.phoff; i<elf.phnum; i++, off+=sizeof(ph)){
ffffffff8010e27f:	8b 85 4c ff ff ff    	mov    -0xb4(%rbp),%eax
ffffffff8010e285:	83 c0 01             	add    $0x1,%eax
ffffffff8010e288:	89 85 4c ff ff ff    	mov    %eax,-0xb4(%rbp)
ffffffff8010e28e:	48 63 4d 9c          	movslq -0x64(%rbp),%rcx
ffffffff8010e292:	48 83 c1 38          	add    $0x38,%rcx
ffffffff8010e296:	89 c8                	mov    %ecx,%eax
ffffffff8010e298:	89 45 9c             	mov    %eax,-0x64(%rbp)
ffffffff8010e29b:	e9 96 fe ff ff       	jmpq   ffffffff8010e136 <load_program_from_disk+0xd6>
  iput(ip);
ffffffff8010e2a0:	48 8b 7d d8          	mov    -0x28(%rbp),%rdi
ffffffff8010e2a4:	e8 e7 dd ff ff       	callq  ffffffff8010c090 <iput>
  *rip = elf.entry;
ffffffff8010e2a9:	48 8b bd 68 ff ff ff 	mov    -0x98(%rbp),%rdi
ffffffff8010e2b0:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
ffffffff8010e2b4:	48 89 38             	mov    %rdi,(%rax)
  return sz;
ffffffff8010e2b7:	48 8b 45 90          	mov    -0x70(%rbp),%rax
ffffffff8010e2bb:	89 c1                	mov    %eax,%ecx
ffffffff8010e2bd:	89 4d fc             	mov    %ecx,-0x4(%rbp)
ffffffff8010e2c0:	e9 1b 00 00 00       	jmpq   ffffffff8010e2e0 <load_program_from_disk+0x280>
elf_failure:
  if(ip){
ffffffff8010e2c5:	48 83 7d d8 00       	cmpq   $0x0,-0x28(%rbp)
ffffffff8010e2ca:	0f 84 09 00 00 00    	je     ffffffff8010e2d9 <load_program_from_disk+0x279>
    iput(ip);
ffffffff8010e2d0:	48 8b 7d d8          	mov    -0x28(%rbp),%rdi
ffffffff8010e2d4:	e8 b7 dd ff ff       	callq  ffffffff8010c090 <iput>
  }
  return 0;
ffffffff8010e2d9:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
}
ffffffff8010e2e0:	8b 45 fc             	mov    -0x4(%rbp),%eax
ffffffff8010e2e3:	48 81 c4 00 01 00 00 	add    $0x100,%rsp
ffffffff8010e2ea:	5d                   	pop    %rbp
ffffffff8010e2eb:	c3                   	retq   
ffffffff8010e2ec:	0f 1f 40 00          	nopl   0x0(%rax)

ffffffff8010e2f0 <myproc>:
{
ffffffff8010e2f0:	55                   	push   %rbp
ffffffff8010e2f1:	48 89 e5             	mov    %rsp,%rbp
  return mycpu()->proc;
ffffffff8010e2f4:	e8 87 03 00 00       	callq  ffffffff8010e680 <mycpu>
ffffffff8010e2f9:	48 8b 80 d0 00 00 00 	mov    0xd0(%rax),%rax
ffffffff8010e300:	5d                   	pop    %rbp
ffffffff8010e301:	c3                   	retq   
ffffffff8010e302:	66 66 66 66 66 2e 0f 	data16 data16 data16 data16 nopw %cs:0x0(%rax,%rax,1)
ffffffff8010e309:	1f 84 00 00 00 00 00 

ffffffff8010e310 <exec>:

int
exec(char *path, char **argv)
{
ffffffff8010e310:	55                   	push   %rbp
ffffffff8010e311:	48 89 e5             	mov    %rsp,%rbp
ffffffff8010e314:	48 81 ec b0 01 00 00 	sub    $0x1b0,%rsp
ffffffff8010e31b:	48 89 7d f0          	mov    %rdi,-0x10(%rbp)
ffffffff8010e31f:	48 89 75 e8          	mov    %rsi,-0x18(%rbp)
  pml4e_t* pml4 = setupkvm();
ffffffff8010e323:	e8 68 50 ff ff       	callq  ffffffff80103390 <setupkvm>
ffffffff8010e328:	48 89 45 e0          	mov    %rax,-0x20(%rbp)

  if (pml4 == 0) {
ffffffff8010e32c:	48 83 7d e0 00       	cmpq   $0x0,-0x20(%rbp)
ffffffff8010e331:	0f 85 0c 00 00 00    	jne    ffffffff8010e343 <exec+0x33>
    return -1;
ffffffff8010e337:	c7 45 fc ff ff ff ff 	movl   $0xffffffff,-0x4(%rbp)
ffffffff8010e33e:	e9 28 03 00 00       	jmpq   ffffffff8010e66b <exec+0x35b>
ffffffff8010e343:	48 8d 45 d8          	lea    -0x28(%rbp),%rax
  }

  uint64_t rip;
  int sz = load_program_from_disk(pml4, path, &rip);
ffffffff8010e347:	48 8b 7d e0          	mov    -0x20(%rbp),%rdi
ffffffff8010e34b:	48 8b 75 f0          	mov    -0x10(%rbp),%rsi
ffffffff8010e34f:	48 8d 55 d8          	lea    -0x28(%rbp),%rdx
ffffffff8010e353:	48 89 85 58 fe ff ff 	mov    %rax,-0x1a8(%rbp)
ffffffff8010e35a:	e8 01 fd ff ff       	callq  ffffffff8010e060 <load_program_from_disk>
ffffffff8010e35f:	89 45 d4             	mov    %eax,-0x2c(%rbp)

  if (sz == 0) {
ffffffff8010e362:	83 7d d4 00          	cmpl   $0x0,-0x2c(%rbp)
ffffffff8010e366:	0f 85 1f 00 00 00    	jne    ffffffff8010e38b <exec+0x7b>
ffffffff8010e36c:	31 c0                	xor    %eax,%eax
    freevm(pml4, 0);
ffffffff8010e36e:	48 8b 7d e0          	mov    -0x20(%rbp),%rdi
ffffffff8010e372:	31 f6                	xor    %esi,%esi
ffffffff8010e374:	89 85 54 fe ff ff    	mov    %eax,-0x1ac(%rbp)
ffffffff8010e37a:	e8 d1 65 ff ff       	callq  ffffffff80104950 <freevm>
    return -1;
ffffffff8010e37f:	c7 45 fc ff ff ff ff 	movl   $0xffffffff,-0x4(%rbp)
ffffffff8010e386:	e9 e0 02 00 00       	jmpq   ffffffff8010e66b <exec+0x35b>
  }

  struct proc* proc = myproc();
ffffffff8010e38b:	e8 60 ff ff ff       	callq  ffffffff8010e2f0 <myproc>
ffffffff8010e390:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
  proc->mem_regions[CODE].start = 0;
ffffffff8010e394:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
ffffffff8010e398:	48 c7 40 08 00 00 00 	movq   $0x0,0x8(%rax)
ffffffff8010e39f:	00 
  proc->mem_regions[CODE].size = sz;
ffffffff8010e3a0:	48 63 45 d4          	movslq -0x2c(%rbp),%rax
ffffffff8010e3a4:	48 8b 4d c8          	mov    -0x38(%rbp),%rcx
ffffffff8010e3a8:	48 89 41 10          	mov    %rax,0x10(%rcx)

  void* heap_start = (void*) (long) PGROUNDUP(sz);
ffffffff8010e3ac:	8b 55 d4             	mov    -0x2c(%rbp),%edx
ffffffff8010e3af:	81 c2 00 10 00 00    	add    $0x1000,%edx
ffffffff8010e3b5:	83 ea 01             	sub    $0x1,%edx
ffffffff8010e3b8:	81 e2 00 f0 ff ff    	and    $0xfffff000,%edx
ffffffff8010e3be:	48 63 c2             	movslq %edx,%rax
ffffffff8010e3c1:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
  proc->mem_regions[HEAP].start = heap_start;
ffffffff8010e3c5:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
ffffffff8010e3c9:	48 8b 4d c8          	mov    -0x38(%rbp),%rcx
ffffffff8010e3cd:	48 89 41 18          	mov    %rax,0x18(%rcx)
  proc->mem_regions[HEAP].size = 0;
ffffffff8010e3d1:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
ffffffff8010e3d5:	48 c7 40 20 00 00 00 	movq   $0x0,0x20(%rax)
ffffffff8010e3dc:	00 

  initustack(pml4, &proc->mem_regions[USTACK], proc->pid);
ffffffff8010e3dd:	48 8b 7d e0          	mov    -0x20(%rbp),%rdi
ffffffff8010e3e1:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
ffffffff8010e3e5:	48 83 c0 08          	add    $0x8,%rax
ffffffff8010e3e9:	48 83 c0 20          	add    $0x20,%rax
ffffffff8010e3ed:	48 8b 4d c8          	mov    -0x38(%rbp),%rcx
ffffffff8010e3f1:	8b 91 04 01 00 00    	mov    0x104(%rcx),%edx
ffffffff8010e3f7:	48 89 c6             	mov    %rax,%rsi
ffffffff8010e3fa:	e8 d1 57 ff ff       	callq  ffffffff80103bd0 <initustack>

  char* stack_addr =
    proc->mem_regions[USTACK].size + proc->mem_regions[USTACK].start;
ffffffff8010e3ff:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
ffffffff8010e403:	48 8b 40 30          	mov    0x30(%rax),%rax
ffffffff8010e407:	48 8b 4d c8          	mov    -0x38(%rbp),%rcx
ffffffff8010e40b:	48 03 41 28          	add    0x28(%rcx),%rax
  char* stack_addr =
ffffffff8010e40f:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
  // Alloc local space for NULL terminator, arg array, argv pointer, and
  // dummy return addr. We'll copy it into the real user stack later.
  uint64_t user_stack[MAXARG + 3];
  int i;

  for (i = 0; argv[i] != NULL; ++i) {
ffffffff8010e413:	c7 85 9c fe ff ff 00 	movl   $0x0,-0x164(%rbp)
ffffffff8010e41a:	00 00 00 
ffffffff8010e41d:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
ffffffff8010e421:	48 63 8d 9c fe ff ff 	movslq -0x164(%rbp),%rcx
ffffffff8010e428:	48 83 3c c8 00       	cmpq   $0x0,(%rax,%rcx,8)
ffffffff8010e42d:	0f 84 cc 00 00 00    	je     ffffffff8010e4ff <exec+0x1ef>
    if (i >= MAXARG) {
ffffffff8010e433:	83 bd 9c fe ff ff 20 	cmpl   $0x20,-0x164(%rbp)
ffffffff8010e43a:	0f 8c 0c 00 00 00    	jl     ffffffff8010e44c <exec+0x13c>
      return -1;
ffffffff8010e440:	c7 45 fc ff ff ff ff 	movl   $0xffffffff,-0x4(%rbp)
ffffffff8010e447:	e9 1f 02 00 00       	jmpq   ffffffff8010e66b <exec+0x35b>
    }

    char* arg = argv[i];
ffffffff8010e44c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
ffffffff8010e450:	48 63 8d 9c fe ff ff 	movslq -0x164(%rbp),%rcx
ffffffff8010e457:	48 8b 04 c8          	mov    (%rax,%rcx,8),%rax
ffffffff8010e45b:	48 89 85 90 fe ff ff 	mov    %rax,-0x170(%rbp)
    int len = strlen(arg) + 1; // account for NULL terminator.
ffffffff8010e462:	48 8b bd 90 fe ff ff 	mov    -0x170(%rbp),%rdi
ffffffff8010e469:	e8 82 cf ff ff       	callq  ffffffff8010b3f0 <strlen>
ffffffff8010e46e:	31 d2                	xor    %edx,%edx
ffffffff8010e470:	89 d1                	mov    %edx,%ecx
ffffffff8010e472:	83 c0 01             	add    $0x1,%eax
ffffffff8010e475:	89 85 8c fe ff ff    	mov    %eax,-0x174(%rbp)
    int len_aligned = WORDROUNDUP(len);
ffffffff8010e47b:	8b 85 8c fe ff ff    	mov    -0x174(%rbp),%eax
ffffffff8010e481:	83 c0 07             	add    $0x7,%eax
ffffffff8010e484:	83 e0 f8             	and    $0xfffffff8,%eax
ffffffff8010e487:	89 85 88 fe ff ff    	mov    %eax,-0x178(%rbp)
    stack_addr -= len_aligned;
ffffffff8010e48d:	8b 85 88 fe ff ff    	mov    -0x178(%rbp),%eax
ffffffff8010e493:	48 8b 7d b8          	mov    -0x48(%rbp),%rdi
ffffffff8010e497:	48 63 f0             	movslq %eax,%rsi
ffffffff8010e49a:	48 29 f1             	sub    %rsi,%rcx
ffffffff8010e49d:	48 01 cf             	add    %rcx,%rdi
ffffffff8010e4a0:	48 89 7d b8          	mov    %rdi,-0x48(%rbp)

    if (copyout(pml4, (uint64_t) stack_addr, arg, len) == -1) {
ffffffff8010e4a4:	48 8b 7d e0          	mov    -0x20(%rbp),%rdi
ffffffff8010e4a8:	48 8b 75 b8          	mov    -0x48(%rbp),%rsi
ffffffff8010e4ac:	48 8b 95 90 fe ff ff 	mov    -0x170(%rbp),%rdx
ffffffff8010e4b3:	8b 8d 8c fe ff ff    	mov    -0x174(%rbp),%ecx
ffffffff8010e4b9:	e8 b2 6e ff ff       	callq  ffffffff80105370 <copyout>
ffffffff8010e4be:	83 f8 ff             	cmp    $0xffffffff,%eax
ffffffff8010e4c1:	0f 85 0c 00 00 00    	jne    ffffffff8010e4d3 <exec+0x1c3>
      return -1;
ffffffff8010e4c7:	c7 45 fc ff ff ff ff 	movl   $0xffffffff,-0x4(%rbp)
ffffffff8010e4ce:	e9 98 01 00 00       	jmpq   ffffffff8010e66b <exec+0x35b>
    }

    user_stack[2 + i] = (uint64_t) stack_addr;
ffffffff8010e4d3:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
ffffffff8010e4d7:	8b 8d 9c fe ff ff    	mov    -0x164(%rbp),%ecx
ffffffff8010e4dd:	83 c1 02             	add    $0x2,%ecx
ffffffff8010e4e0:	48 63 d1             	movslq %ecx,%rdx
ffffffff8010e4e3:	48 89 84 d5 a0 fe ff 	mov    %rax,-0x160(%rbp,%rdx,8)
ffffffff8010e4ea:	ff 
  for (i = 0; argv[i] != NULL; ++i) {
ffffffff8010e4eb:	8b 85 9c fe ff ff    	mov    -0x164(%rbp),%eax
ffffffff8010e4f1:	83 c0 01             	add    $0x1,%eax
ffffffff8010e4f4:	89 85 9c fe ff ff    	mov    %eax,-0x164(%rbp)
ffffffff8010e4fa:	e9 1e ff ff ff       	jmpq   ffffffff8010e41d <exec+0x10d>
ffffffff8010e4ff:	48 8d 85 a0 fe ff ff 	lea    -0x160(%rbp),%rax
ffffffff8010e506:	31 c9                	xor    %ecx,%ecx
ffffffff8010e508:	89 ca                	mov    %ecx,%edx
ffffffff8010e50a:	b9 be ba fe ca       	mov    $0xcafebabe,%ecx
ffffffff8010e50f:	89 ce                	mov    %ecx,%esi
  }

  uint64_t argc = i;
ffffffff8010e511:	48 63 bd 9c fe ff ff 	movslq -0x164(%rbp),%rdi
ffffffff8010e518:	48 89 bd 80 fe ff ff 	mov    %rdi,-0x180(%rbp)
  // Calculate virtual address of argv.
  uint64_t argv_addr = (uint64_t) (stack_addr - (argc + 1) * 8);
ffffffff8010e51f:	48 8b 7d b8          	mov    -0x48(%rbp),%rdi
ffffffff8010e523:	4c 8b 85 80 fe ff ff 	mov    -0x180(%rbp),%r8
ffffffff8010e52a:	49 83 c0 01          	add    $0x1,%r8
ffffffff8010e52e:	49 c1 e0 03          	shl    $0x3,%r8
ffffffff8010e532:	49 89 d1             	mov    %rdx,%r9
ffffffff8010e535:	4d 29 c1             	sub    %r8,%r9
ffffffff8010e538:	4c 01 cf             	add    %r9,%rdi
ffffffff8010e53b:	48 89 bd 78 fe ff ff 	mov    %rdi,-0x188(%rbp)

  user_stack[0] = 0xcafebabe; // dummy return ptr
ffffffff8010e542:	48 89 b5 a0 fe ff ff 	mov    %rsi,-0x160(%rbp)
  user_stack[1] = argv_addr;
ffffffff8010e549:	48 8b b5 78 fe ff ff 	mov    -0x188(%rbp),%rsi
ffffffff8010e550:	48 89 b5 a8 fe ff ff 	mov    %rsi,-0x158(%rbp)
  user_stack[2 + argc] = 0UL; // Terminate argv.
ffffffff8010e557:	48 8b b5 80 fe ff ff 	mov    -0x180(%rbp),%rsi
ffffffff8010e55e:	48 83 c6 02          	add    $0x2,%rsi
ffffffff8010e562:	48 c7 84 f5 a0 fe ff 	movq   $0x0,-0x160(%rbp,%rsi,8)
ffffffff8010e569:	ff 00 00 00 00 

  // Now copy our temp user_stack into the actual usermode stack.
  int copylen = (3 + argc) * 8;
ffffffff8010e56e:	48 8b b5 80 fe ff ff 	mov    -0x180(%rbp),%rsi
ffffffff8010e575:	48 83 c6 03          	add    $0x3,%rsi
ffffffff8010e579:	48 c1 e6 03          	shl    $0x3,%rsi
ffffffff8010e57d:	89 f1                	mov    %esi,%ecx
ffffffff8010e57f:	89 8d 74 fe ff ff    	mov    %ecx,-0x18c(%rbp)
  stack_addr -= copylen;
ffffffff8010e585:	8b 8d 74 fe ff ff    	mov    -0x18c(%rbp),%ecx
ffffffff8010e58b:	48 8b 75 b8          	mov    -0x48(%rbp),%rsi
ffffffff8010e58f:	48 63 f9             	movslq %ecx,%rdi
ffffffff8010e592:	48 29 fa             	sub    %rdi,%rdx
ffffffff8010e595:	48 01 d6             	add    %rdx,%rsi
ffffffff8010e598:	48 89 75 b8          	mov    %rsi,-0x48(%rbp)

  if (copyout(pml4, (uint64_t) stack_addr, user_stack, copylen) == -1) {
ffffffff8010e59c:	48 8b 7d e0          	mov    -0x20(%rbp),%rdi
ffffffff8010e5a0:	48 8b 75 b8          	mov    -0x48(%rbp),%rsi
ffffffff8010e5a4:	8b 8d 74 fe ff ff    	mov    -0x18c(%rbp),%ecx
ffffffff8010e5aa:	48 89 c2             	mov    %rax,%rdx
ffffffff8010e5ad:	e8 be 6d ff ff       	callq  ffffffff80105370 <copyout>
ffffffff8010e5b2:	83 f8 ff             	cmp    $0xffffffff,%eax
ffffffff8010e5b5:	0f 85 0c 00 00 00    	jne    ffffffff8010e5c7 <exec+0x2b7>
    return -1;
ffffffff8010e5bb:	c7 45 fc ff ff ff ff 	movl   $0xffffffff,-0x4(%rbp)
ffffffff8010e5c2:	e9 a4 00 00 00       	jmpq   ffffffff8010e66b <exec+0x35b>
  }

  struct trap_frame* tf = proc->tf;
ffffffff8010e5c7:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
ffffffff8010e5cb:	48 8b 80 10 01 00 00 	mov    0x110(%rax),%rax
ffffffff8010e5d2:	48 89 85 68 fe ff ff 	mov    %rax,-0x198(%rbp)
  tf->rdi = argc;
ffffffff8010e5d9:	48 8b 85 80 fe ff ff 	mov    -0x180(%rbp),%rax
ffffffff8010e5e0:	48 8b 8d 68 fe ff ff 	mov    -0x198(%rbp),%rcx
ffffffff8010e5e7:	48 89 41 30          	mov    %rax,0x30(%rcx)
  tf->rsi = argv_addr;
ffffffff8010e5eb:	48 8b 85 78 fe ff ff 	mov    -0x188(%rbp),%rax
ffffffff8010e5f2:	48 8b 8d 68 fe ff ff 	mov    -0x198(%rbp),%rcx
ffffffff8010e5f9:	48 89 41 28          	mov    %rax,0x28(%rcx)

  tf->rbp = tf->rsp = (uint64_t) stack_addr;
ffffffff8010e5fd:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
ffffffff8010e601:	48 8b 8d 68 fe ff ff 	mov    -0x198(%rbp),%rcx
ffffffff8010e608:	48 89 81 a0 00 00 00 	mov    %rax,0xa0(%rcx)
ffffffff8010e60f:	48 8b 8d 68 fe ff ff 	mov    -0x198(%rbp),%rcx
ffffffff8010e616:	48 89 41 20          	mov    %rax,0x20(%rcx)
  tf->rip = rip;
ffffffff8010e61a:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
ffffffff8010e61e:	48 8b 8d 68 fe ff ff 	mov    -0x198(%rbp),%rcx
ffffffff8010e625:	48 89 81 88 00 00 00 	mov    %rax,0x88(%rcx)

  pml4e_t* oldpml4 = proc->pml4;
ffffffff8010e62c:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
ffffffff8010e630:	48 8b 00             	mov    (%rax),%rax
ffffffff8010e633:	48 89 85 60 fe ff ff 	mov    %rax,-0x1a0(%rbp)
  proc->pml4 = pml4;
ffffffff8010e63a:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
ffffffff8010e63e:	48 8b 4d c8          	mov    -0x38(%rbp),%rcx
ffffffff8010e642:	48 89 01             	mov    %rax,(%rcx)
  switchuvm(proc);
ffffffff8010e645:	48 8b 7d c8          	mov    -0x38(%rbp),%rdi
ffffffff8010e649:	e8 a2 4f ff ff       	callq  ffffffff801035f0 <switchuvm>
  freevm(oldpml4, proc->pid);
ffffffff8010e64e:	48 8b bd 60 fe ff ff 	mov    -0x1a0(%rbp),%rdi
ffffffff8010e655:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
ffffffff8010e659:	8b b0 04 01 00 00    	mov    0x104(%rax),%esi
ffffffff8010e65f:	e8 ec 62 ff ff       	callq  ffffffff80104950 <freevm>
  return 0;
ffffffff8010e664:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%rbp)
}
ffffffff8010e66b:	8b 45 fc             	mov    -0x4(%rbp),%eax
ffffffff8010e66e:	48 81 c4 b0 01 00 00 	add    $0x1b0,%rsp
ffffffff8010e675:	5d                   	pop    %rbp
ffffffff8010e676:	c3                   	retq   
ffffffff8010e677:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
ffffffff8010e67e:	00 00 

ffffffff8010e680 <mycpu>:
{
ffffffff8010e680:	55                   	push   %rbp
ffffffff8010e681:	48 89 e5             	mov    %rsp,%rbp
  return &cpus[0];
ffffffff8010e684:	48 c7 c0 e0 7b 1f 83 	mov    $0xffffffff831f7be0,%rax
ffffffff8010e68b:	5d                   	pop    %rbp
ffffffff8010e68c:	c3                   	retq   
ffffffff8010e68d:	0f 1f 00             	nopl   (%rax)

ffffffff8010e690 <sbrk>:
#include <proc.h>
#include <defs.h>
#include <memlayout.h>

int sbrk(int size)
{
ffffffff8010e690:	55                   	push   %rbp
ffffffff8010e691:	48 89 e5             	mov    %rsp,%rbp
ffffffff8010e694:	48 83 ec 30          	sub    $0x30,%rsp
ffffffff8010e698:	89 7d f8             	mov    %edi,-0x8(%rbp)
  struct proc* proc = myproc();
ffffffff8010e69b:	e8 50 01 00 00       	callq  ffffffff8010e7f0 <myproc>
ffffffff8010e6a0:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  struct mem_region* heap = &proc->mem_regions[HEAP];
ffffffff8010e6a4:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
ffffffff8010e6a8:	48 83 c0 08          	add    $0x8,%rax
ffffffff8010e6ac:	48 83 c0 10          	add    $0x10,%rax
ffffffff8010e6b0:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  struct mem_region* stack = &proc->mem_regions[USTACK];
ffffffff8010e6b4:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
ffffffff8010e6b8:	48 83 c0 08          	add    $0x8,%rax
ffffffff8010e6bc:	48 83 c0 20          	add    $0x20,%rax
ffffffff8010e6c0:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  int old_extent = (int) (uint64_t) heap->start + heap->size;
ffffffff8010e6c4:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
ffffffff8010e6c8:	48 8b 00             	mov    (%rax),%rax
ffffffff8010e6cb:	89 c7                	mov    %eax,%edi
ffffffff8010e6cd:	48 63 c7             	movslq %edi,%rax
ffffffff8010e6d0:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
ffffffff8010e6d4:	48 03 41 08          	add    0x8(%rcx),%rax
ffffffff8010e6d8:	89 c7                	mov    %eax,%edi
ffffffff8010e6da:	89 7d dc             	mov    %edi,-0x24(%rbp)

  if (size == 0) {
ffffffff8010e6dd:	83 7d f8 00          	cmpl   $0x0,-0x8(%rbp)
ffffffff8010e6e1:	0f 85 05 00 00 00    	jne    ffffffff8010e6ec <sbrk+0x5c>
    // Nothing.
  } else if (size < 0) {
ffffffff8010e6e7:	e9 ed 00 00 00       	jmpq   ffffffff8010e7d9 <sbrk+0x149>
ffffffff8010e6ec:	83 7d f8 00          	cmpl   $0x0,-0x8(%rbp)
ffffffff8010e6f0:	0f 8d 48 00 00 00    	jge    ffffffff8010e73e <sbrk+0xae>
    // Shrink Case
    heap->size = deallocuvm(proc->pml4, heap->start,
ffffffff8010e6f6:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
ffffffff8010e6fa:	48 8b 38             	mov    (%rax),%rdi
ffffffff8010e6fd:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
ffffffff8010e701:	48 8b 30             	mov    (%rax),%rsi
      heap->size, heap->size + size, proc->pid);
ffffffff8010e704:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
ffffffff8010e708:	48 8b 50 08          	mov    0x8(%rax),%rdx
ffffffff8010e70c:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
ffffffff8010e710:	48 8b 40 08          	mov    0x8(%rax),%rax
ffffffff8010e714:	48 63 4d f8          	movslq -0x8(%rbp),%rcx
ffffffff8010e718:	48 01 c8             	add    %rcx,%rax
ffffffff8010e71b:	48 8b 4d f0          	mov    -0x10(%rbp),%rcx
ffffffff8010e71f:	44 8b 81 04 01 00 00 	mov    0x104(%rcx),%r8d
    heap->size = deallocuvm(proc->pml4, heap->start,
ffffffff8010e726:	48 89 c1             	mov    %rax,%rcx
ffffffff8010e729:	e8 42 57 ff ff       	callq  ffffffff80103e70 <deallocuvm>
ffffffff8010e72e:	48 63 c8             	movslq %eax,%rcx
ffffffff8010e731:	48 8b 55 e8          	mov    -0x18(%rbp),%rdx
ffffffff8010e735:	48 89 4a 08          	mov    %rcx,0x8(%rdx)
  } else {
ffffffff8010e739:	e9 96 00 00 00       	jmpq   ffffffff8010e7d4 <sbrk+0x144>
    // Grow Case
    if (heap->start + heap->size + size < stack->start) {
ffffffff8010e73e:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
ffffffff8010e742:	48 8b 00             	mov    (%rax),%rax
ffffffff8010e745:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
ffffffff8010e749:	48 03 41 08          	add    0x8(%rcx),%rax
ffffffff8010e74d:	48 63 4d f8          	movslq -0x8(%rbp),%rcx
ffffffff8010e751:	48 01 c8             	add    %rcx,%rax
ffffffff8010e754:	48 8b 4d e0          	mov    -0x20(%rbp),%rcx
ffffffff8010e758:	48 3b 01             	cmp    (%rcx),%rax
ffffffff8010e75b:	0f 83 62 00 00 00    	jae    ffffffff8010e7c3 <sbrk+0x133>
      int newsize = allocuvm(proc->pml4, heap->start,
ffffffff8010e761:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
ffffffff8010e765:	48 8b 38             	mov    (%rax),%rdi
ffffffff8010e768:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
ffffffff8010e76c:	48 8b 30             	mov    (%rax),%rsi
        heap->size, heap->size + size, proc->pid);
ffffffff8010e76f:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
ffffffff8010e773:	48 8b 50 08          	mov    0x8(%rax),%rdx
ffffffff8010e777:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
ffffffff8010e77b:	48 8b 40 08          	mov    0x8(%rax),%rax
ffffffff8010e77f:	48 63 4d f8          	movslq -0x8(%rbp),%rcx
ffffffff8010e783:	48 01 c8             	add    %rcx,%rax
ffffffff8010e786:	48 8b 4d f0          	mov    -0x10(%rbp),%rcx
ffffffff8010e78a:	44 8b 81 04 01 00 00 	mov    0x104(%rcx),%r8d
      int newsize = allocuvm(proc->pml4, heap->start,
ffffffff8010e791:	48 89 c1             	mov    %rax,%rcx
ffffffff8010e794:	e8 17 55 ff ff       	callq  ffffffff80103cb0 <allocuvm>
ffffffff8010e799:	89 45 d8             	mov    %eax,-0x28(%rbp)

      if (newsize == -1) {
ffffffff8010e79c:	83 7d d8 ff          	cmpl   $0xffffffff,-0x28(%rbp)
ffffffff8010e7a0:	0f 85 0c 00 00 00    	jne    ffffffff8010e7b2 <sbrk+0x122>
        return -1;
ffffffff8010e7a6:	c7 45 fc ff ff ff ff 	movl   $0xffffffff,-0x4(%rbp)
ffffffff8010e7ad:	e9 2d 00 00 00       	jmpq   ffffffff8010e7df <sbrk+0x14f>
      }

      heap->size = newsize;
ffffffff8010e7b2:	48 63 45 d8          	movslq -0x28(%rbp),%rax
ffffffff8010e7b6:	48 8b 4d e8          	mov    -0x18(%rbp),%rcx
ffffffff8010e7ba:	48 89 41 08          	mov    %rax,0x8(%rcx)
    } else {
ffffffff8010e7be:	e9 0c 00 00 00       	jmpq   ffffffff8010e7cf <sbrk+0x13f>
      // growing into Stack region
      return -1;
ffffffff8010e7c3:	c7 45 fc ff ff ff ff 	movl   $0xffffffff,-0x4(%rbp)
ffffffff8010e7ca:	e9 10 00 00 00       	jmpq   ffffffff8010e7df <sbrk+0x14f>
ffffffff8010e7cf:	e9 00 00 00 00       	jmpq   ffffffff8010e7d4 <sbrk+0x144>
ffffffff8010e7d4:	e9 00 00 00 00       	jmpq   ffffffff8010e7d9 <sbrk+0x149>
    }
  }

  return old_extent;
ffffffff8010e7d9:	8b 45 dc             	mov    -0x24(%rbp),%eax
ffffffff8010e7dc:	89 45 fc             	mov    %eax,-0x4(%rbp)
}
ffffffff8010e7df:	8b 45 fc             	mov    -0x4(%rbp),%eax
ffffffff8010e7e2:	48 83 c4 30          	add    $0x30,%rsp
ffffffff8010e7e6:	5d                   	pop    %rbp
ffffffff8010e7e7:	c3                   	retq   
ffffffff8010e7e8:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
ffffffff8010e7ef:	00 

ffffffff8010e7f0 <myproc>:
{
ffffffff8010e7f0:	55                   	push   %rbp
ffffffff8010e7f1:	48 89 e5             	mov    %rsp,%rbp
  return mycpu()->proc;
ffffffff8010e7f4:	e8 17 00 00 00       	callq  ffffffff8010e810 <mycpu>
ffffffff8010e7f9:	48 8b 80 d0 00 00 00 	mov    0xd0(%rax),%rax
ffffffff8010e800:	5d                   	pop    %rbp
ffffffff8010e801:	c3                   	retq   
ffffffff8010e802:	66 66 66 66 66 2e 0f 	data16 data16 data16 data16 nopw %cs:0x0(%rax,%rax,1)
ffffffff8010e809:	1f 84 00 00 00 00 00 

ffffffff8010e810 <mycpu>:
{
ffffffff8010e810:	55                   	push   %rbp
ffffffff8010e811:	48 89 e5             	mov    %rsp,%rbp
  return &cpus[0];
ffffffff8010e814:	48 c7 c0 e0 7b 1f 83 	mov    $0xffffffff831f7be0,%rax
ffffffff8010e81b:	5d                   	pop    %rbp
ffffffff8010e81c:	c3                   	retq   
ffffffff8010e81d:	0f 1f 00             	nopl   (%rax)

ffffffff8010e820 <swapinit>:

struct swap_man sm;
size_t clock_hand;

void swapinit()
{
ffffffff8010e820:	55                   	push   %rbp
ffffffff8010e821:	48 89 e5             	mov    %rsp,%rbp
  clock_hand = 0;
ffffffff8010e824:	48 c7 04 25 60 55 20 	movq   $0x0,0xffffffff83205560
ffffffff8010e82b:	83 00 00 00 00 
  initlock(&sm.lock, "swap lock");
ffffffff8010e830:	48 c7 c6 72 06 11 80 	mov    $0xffffffff80110672,%rsi
ffffffff8010e837:	48 c7 c7 68 55 22 83 	mov    $0xffffffff83225568,%rdi
ffffffff8010e83e:	e8 3d 6f ff ff       	callq  ffffffff80105780 <initlock>
}
ffffffff8010e843:	5d                   	pop    %rbp
ffffffff8010e844:	c3                   	retq   
ffffffff8010e845:	66 66 2e 0f 1f 84 00 	data16 nopw %cs:0x0(%rax,%rax,1)
ffffffff8010e84c:	00 00 00 00 

ffffffff8010e850 <fetch_free_index>:

// Assumes holding the lock
int
fetch_free_index()
{
ffffffff8010e850:	55                   	push   %rbp
ffffffff8010e851:	48 89 e5             	mov    %rsp,%rbp
  for (int i = 0; i < SWAP_PAGES; i++) {
ffffffff8010e854:	50                   	push   %rax
ffffffff8010e855:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%rbp)
ffffffff8010e85c:	81 7d f8 00 20 00 00 	cmpl   $0x2000,-0x8(%rbp)
ffffffff8010e863:	0f 8d 3a 00 00 00    	jge    ffffffff8010e8a3 <fetch_free_index+0x53>
    if (sm.map[i].ref_count == 0) {
ffffffff8010e869:	48 63 45 f8          	movslq -0x8(%rbp),%rax
ffffffff8010e86d:	48 c1 e0 04          	shl    $0x4,%rax
ffffffff8010e871:	48 8d 80 68 55 20 83 	lea    -0x7cdfaa98(%rax),%rax
ffffffff8010e878:	0f b6 48 0c          	movzbl 0xc(%rax),%ecx
ffffffff8010e87c:	83 f9 00             	cmp    $0x0,%ecx
ffffffff8010e87f:	0f 85 0b 00 00 00    	jne    ffffffff8010e890 <fetch_free_index+0x40>
      return i;
ffffffff8010e885:	8b 45 f8             	mov    -0x8(%rbp),%eax
ffffffff8010e888:	89 45 fc             	mov    %eax,-0x4(%rbp)
ffffffff8010e88b:	e9 1a 00 00 00       	jmpq   ffffffff8010e8aa <fetch_free_index+0x5a>
    }
  }
ffffffff8010e890:	e9 00 00 00 00       	jmpq   ffffffff8010e895 <fetch_free_index+0x45>
  for (int i = 0; i < SWAP_PAGES; i++) {
ffffffff8010e895:	8b 45 f8             	mov    -0x8(%rbp),%eax
ffffffff8010e898:	83 c0 01             	add    $0x1,%eax
ffffffff8010e89b:	89 45 f8             	mov    %eax,-0x8(%rbp)
ffffffff8010e89e:	e9 b9 ff ff ff       	jmpq   ffffffff8010e85c <fetch_free_index+0xc>
  return -1;
ffffffff8010e8a3:	c7 45 fc ff ff ff ff 	movl   $0xffffffff,-0x4(%rbp)
}
ffffffff8010e8aa:	8b 45 fc             	mov    -0x4(%rbp),%eax
ffffffff8010e8ad:	48 83 c4 08          	add    $0x8,%rsp
ffffffff8010e8b1:	5d                   	pop    %rbp
ffffffff8010e8b2:	c3                   	retq   
ffffffff8010e8b3:	66 66 66 66 2e 0f 1f 	data16 data16 data16 nopw %cs:0x0(%rax,%rax,1)
ffffffff8010e8ba:	84 00 00 00 00 00 

ffffffff8010e8c0 <incr_swap_entry_ref>:

void
incr_swap_entry_ref(uint64_t idx)
{
ffffffff8010e8c0:	55                   	push   %rbp
ffffffff8010e8c1:	48 89 e5             	mov    %rsp,%rbp
ffffffff8010e8c4:	48 83 ec 10          	sub    $0x10,%rsp
ffffffff8010e8c8:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  // Check if valid idx
  if (idx >= 8192) {
ffffffff8010e8cc:	48 81 7d f8 00 20 00 	cmpq   $0x2000,-0x8(%rbp)
ffffffff8010e8d3:	00 
ffffffff8010e8d4:	0f 82 0c 00 00 00    	jb     ffffffff8010e8e6 <incr_swap_entry_ref+0x26>
    panic("invalid index into swap manager");
ffffffff8010e8da:	48 c7 c7 7c 06 11 80 	mov    $0xffffffff8011067c,%rdi
ffffffff8010e8e1:	e8 8a 25 ff ff       	callq  ffffffff80100e70 <panic>
  }

  acquire(&sm.lock);
ffffffff8010e8e6:	48 c7 c7 68 55 22 83 	mov    $0xffffffff83225568,%rdi
ffffffff8010e8ed:	e8 ce 6e ff ff       	callq  ffffffff801057c0 <acquire>

  sm.map[idx].ref_count++;
ffffffff8010e8f2:	48 8b 7d f8          	mov    -0x8(%rbp),%rdi
ffffffff8010e8f6:	48 c1 e7 04          	shl    $0x4,%rdi
ffffffff8010e8fa:	48 8d bf 68 55 20 83 	lea    -0x7cdfaa98(%rdi),%rdi
ffffffff8010e901:	8a 47 0c             	mov    0xc(%rdi),%al
ffffffff8010e904:	04 01                	add    $0x1,%al
ffffffff8010e906:	88 47 0c             	mov    %al,0xc(%rdi)

  release(&sm.lock);
ffffffff8010e909:	48 c7 c7 68 55 22 83 	mov    $0xffffffff83225568,%rdi
ffffffff8010e910:	e8 eb 70 ff ff       	callq  ffffffff80105a00 <release>
}
ffffffff8010e915:	48 83 c4 10          	add    $0x10,%rsp
ffffffff8010e919:	5d                   	pop    %rbp
ffffffff8010e91a:	c3                   	retq   
ffffffff8010e91b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

ffffffff8010e920 <decr_swap_entry_ref>:

void
decr_swap_entry_ref(uint64_t idx)
{
ffffffff8010e920:	55                   	push   %rbp
ffffffff8010e921:	48 89 e5             	mov    %rsp,%rbp
ffffffff8010e924:	48 83 ec 10          	sub    $0x10,%rsp
ffffffff8010e928:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  // Check if valid idx
  if (idx >= 8192) {
ffffffff8010e92c:	48 81 7d f8 00 20 00 	cmpq   $0x2000,-0x8(%rbp)
ffffffff8010e933:	00 
ffffffff8010e934:	0f 82 0c 00 00 00    	jb     ffffffff8010e946 <decr_swap_entry_ref+0x26>
    panic("invalid index into swap manager");
ffffffff8010e93a:	48 c7 c7 7c 06 11 80 	mov    $0xffffffff8011067c,%rdi
ffffffff8010e941:	e8 2a 25 ff ff       	callq  ffffffff80100e70 <panic>
  }

  acquire(&sm.lock);
ffffffff8010e946:	48 c7 c7 68 55 22 83 	mov    $0xffffffff83225568,%rdi
ffffffff8010e94d:	e8 6e 6e ff ff       	callq  ffffffff801057c0 <acquire>

  if (sm.map[idx].ref_count == 0) {
ffffffff8010e952:	48 8b 7d f8          	mov    -0x8(%rbp),%rdi
ffffffff8010e956:	48 c1 e7 04          	shl    $0x4,%rdi
ffffffff8010e95a:	48 8d bf 68 55 20 83 	lea    -0x7cdfaa98(%rdi),%rdi
ffffffff8010e961:	0f b6 47 0c          	movzbl 0xc(%rdi),%eax
ffffffff8010e965:	83 f8 00             	cmp    $0x0,%eax
ffffffff8010e968:	0f 85 0c 00 00 00    	jne    ffffffff8010e97a <decr_swap_entry_ref+0x5a>
    panic("decreasing refcount on 0-refcount swapman struct.");
ffffffff8010e96e:	48 c7 c7 9c 06 11 80 	mov    $0xffffffff8011069c,%rdi
ffffffff8010e975:	e8 f6 24 ff ff       	callq  ffffffff80100e70 <panic>
  }

  if (--sm.map[idx].ref_count == 0) {
ffffffff8010e97a:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
ffffffff8010e97e:	48 c1 e0 04          	shl    $0x4,%rax
ffffffff8010e982:	48 8d 80 68 55 20 83 	lea    -0x7cdfaa98(%rax),%rax
ffffffff8010e989:	8a 48 0c             	mov    0xc(%rax),%cl
ffffffff8010e98c:	80 c1 ff             	add    $0xff,%cl
ffffffff8010e98f:	88 48 0c             	mov    %cl,0xc(%rax)
ffffffff8010e992:	0f b6 d1             	movzbl %cl,%edx
ffffffff8010e995:	83 fa 00             	cmp    $0x0,%edx
ffffffff8010e998:	0f 85 10 00 00 00    	jne    ffffffff8010e9ae <decr_swap_entry_ref+0x8e>
    pages_in_swap--;
ffffffff8010e99e:	8b 04 25 a8 65 1f 83 	mov    0xffffffff831f65a8,%eax
ffffffff8010e9a5:	ff c8                	dec    %eax
ffffffff8010e9a7:	89 04 25 a8 65 1f 83 	mov    %eax,0xffffffff831f65a8
  }

  release(&sm.lock);
ffffffff8010e9ae:	48 c7 c7 68 55 22 83 	mov    $0xffffffff83225568,%rdi
ffffffff8010e9b5:	e8 46 70 ff ff       	callq  ffffffff80105a00 <release>
}
ffffffff8010e9ba:	48 83 c4 10          	add    $0x10,%rsp
ffffffff8010e9be:	5d                   	pop    %rbp
ffffffff8010e9bf:	c3                   	retq   

ffffffff8010e9c0 <swap_out>:

void
swap_out(struct core_map_entry* coremapentry, struct proc* proc)
{
ffffffff8010e9c0:	55                   	push   %rbp
ffffffff8010e9c1:	48 89 e5             	mov    %rsp,%rbp
ffffffff8010e9c4:	48 83 ec 70          	sub    $0x70,%rsp
ffffffff8010e9c8:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
ffffffff8010e9cc:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  acquire(&sm.lock);
ffffffff8010e9d0:	48 c7 c7 68 55 22 83 	mov    $0xffffffff83225568,%rdi
ffffffff8010e9d7:	e8 e4 6d ff ff       	callq  ffffffff801057c0 <acquire>

  int next = fetch_free_index();
ffffffff8010e9dc:	e8 6f fe ff ff       	callq  ffffffff8010e850 <fetch_free_index>
ffffffff8010e9e1:	89 45 ec             	mov    %eax,-0x14(%rbp)

  if (next == -1) {
ffffffff8010e9e4:	83 7d ec ff          	cmpl   $0xffffffff,-0x14(%rbp)
ffffffff8010e9e8:	0f 85 0c 00 00 00    	jne    ffffffff8010e9fa <swap_out+0x3a>
    panic("no free swap entry");
ffffffff8010e9ee:	48 c7 c7 ce 06 11 80 	mov    $0xffffffff801106ce,%rdi
ffffffff8010e9f5:	e8 76 24 ff ff       	callq  ffffffff80100e70 <panic>
  }

  // copy over the coremap into the backup
  sm.map[next].va = coremapentry->va;
ffffffff8010e9fa:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
ffffffff8010e9fe:	48 8b 40 08          	mov    0x8(%rax),%rax
ffffffff8010ea02:	48 63 4d ec          	movslq -0x14(%rbp),%rcx
ffffffff8010ea06:	48 c1 e1 04          	shl    $0x4,%rcx
ffffffff8010ea0a:	48 89 81 68 55 20 83 	mov    %rax,-0x7cdfaa98(%rcx)
  sm.map[next].pid = coremapentry->pid;
ffffffff8010ea11:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
ffffffff8010ea15:	8b 50 14             	mov    0x14(%rax),%edx
ffffffff8010ea18:	48 63 45 ec          	movslq -0x14(%rbp),%rax
ffffffff8010ea1c:	48 c1 e0 04          	shl    $0x4,%rax
ffffffff8010ea20:	89 90 70 55 20 83    	mov    %edx,-0x7cdfaa90(%rax)
  sm.map[next].ref_count = coremapentry->ref_count;
ffffffff8010ea26:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
ffffffff8010ea2a:	40 8a 70 18          	mov    0x18(%rax),%sil
ffffffff8010ea2e:	48 63 45 ec          	movslq -0x14(%rbp),%rax
ffffffff8010ea32:	48 c1 e0 04          	shl    $0x4,%rax
ffffffff8010ea36:	40 88 b0 74 55 20 83 	mov    %sil,-0x7cdfaa8c(%rax)

  pages_in_swap++;
ffffffff8010ea3d:	8b 14 25 a8 65 1f 83 	mov    0xffffffff831f65a8,%edx
ffffffff8010ea44:	ff c2                	inc    %edx
ffffffff8010ea46:	89 14 25 a8 65 1f 83 	mov    %edx,0xffffffff831f65a8

  release(&sm.lock);
ffffffff8010ea4d:	48 c7 c7 68 55 22 83 	mov    $0xffffffff83225568,%rdi
ffffffff8010ea54:	e8 a7 6f ff ff       	callq  ffffffff80105a00 <release>

  // Invalidate PTE before moving on
  // update PTE to !PTE_P and PTE_Swap
  // set PPN = index into sm
  uint64_t ppn = next;
ffffffff8010ea59:	48 63 45 ec          	movslq -0x14(%rbp),%rax
ffffffff8010ea5d:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
  ppn = ppn << PT_SHIFT;
ffffffff8010ea61:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
ffffffff8010ea65:	48 c1 e0 0c          	shl    $0xc,%rax
ffffffff8010ea69:	48 89 45 e0          	mov    %rax,-0x20(%rbp)

  // Write to disk
  char* ka = uva2ka(proc->pml4, (char*) coremapentry->va);
ffffffff8010ea6d:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
ffffffff8010ea71:	48 8b 38             	mov    (%rax),%rdi
ffffffff8010ea74:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
ffffffff8010ea78:	48 8b 70 08          	mov    0x8(%rax),%rsi
ffffffff8010ea7c:	e8 8f 67 ff ff       	callq  ffffffff80105210 <uva2ka>
ffffffff8010ea81:	48 89 45 d8          	mov    %rax,-0x28(%rbp)

  for (int i = 0; i < BLOCKS_PER_PAGE; i++) {
ffffffff8010ea85:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%rbp)
ffffffff8010ea8c:	83 7d d4 08          	cmpl   $0x8,-0x2c(%rbp)
ffffffff8010ea90:	0f 8d 80 00 00 00    	jge    ffffffff8010eb16 <swap_out+0x156>
ffffffff8010ea96:	b8 01 00 00 00       	mov    $0x1,%eax
    struct buf* buf = bread(ROOTDEV, 2 + next * BLOCKS_PER_PAGE + i);
ffffffff8010ea9b:	8b 4d ec             	mov    -0x14(%rbp),%ecx
ffffffff8010ea9e:	c1 e1 03             	shl    $0x3,%ecx
ffffffff8010eaa1:	83 c1 02             	add    $0x2,%ecx
ffffffff8010eaa4:	03 4d d4             	add    -0x2c(%rbp),%ecx
ffffffff8010eaa7:	bf 01 00 00 00       	mov    $0x1,%edi
ffffffff8010eaac:	89 ce                	mov    %ecx,%esi
ffffffff8010eaae:	89 45 ac             	mov    %eax,-0x54(%rbp)
ffffffff8010eab1:	e8 9a b4 ff ff       	callq  ffffffff80109f50 <bread>
ffffffff8010eab6:	b9 00 02 00 00       	mov    $0x200,%ecx
ffffffff8010eabb:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
    memmove(buf->data, (void*)(ka + (i * BSIZE)), BSIZE);
ffffffff8010eabf:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
ffffffff8010eac3:	48 05 b0 00 00 00    	add    $0xb0,%rax
ffffffff8010eac9:	48 8b 55 d8          	mov    -0x28(%rbp),%rdx
ffffffff8010eacd:	8b 75 d4             	mov    -0x2c(%rbp),%esi
ffffffff8010ead0:	c1 e6 09             	shl    $0x9,%esi
ffffffff8010ead3:	4c 63 c6             	movslq %esi,%r8
ffffffff8010ead6:	4c 01 c2             	add    %r8,%rdx
ffffffff8010ead9:	be 00 02 00 00       	mov    $0x200,%esi
ffffffff8010eade:	48 89 c7             	mov    %rax,%rdi
ffffffff8010eae1:	89 75 a8             	mov    %esi,-0x58(%rbp)
ffffffff8010eae4:	48 89 d6             	mov    %rdx,%rsi
ffffffff8010eae7:	8b 55 a8             	mov    -0x58(%rbp),%edx
ffffffff8010eaea:	89 4d a4             	mov    %ecx,-0x5c(%rbp)
ffffffff8010eaed:	e8 9e c5 ff ff       	callq  ffffffff8010b090 <memmove>
    bwrite(buf);
ffffffff8010eaf2:	48 8b 7d c8          	mov    -0x38(%rbp),%rdi
ffffffff8010eaf6:	48 89 45 98          	mov    %rax,-0x68(%rbp)
ffffffff8010eafa:	e8 b1 b4 ff ff       	callq  ffffffff80109fb0 <bwrite>
    brelse(buf);
ffffffff8010eaff:	48 8b 7d c8          	mov    -0x38(%rbp),%rdi
ffffffff8010eb03:	e8 38 b5 ff ff       	callq  ffffffff8010a040 <brelse>
  for (int i = 0; i < BLOCKS_PER_PAGE; i++) {
ffffffff8010eb08:	8b 45 d4             	mov    -0x2c(%rbp),%eax
ffffffff8010eb0b:	83 c0 01             	add    $0x1,%eax
ffffffff8010eb0e:	89 45 d4             	mov    %eax,-0x2c(%rbp)
ffffffff8010eb11:	e9 76 ff ff ff       	jmpq   ffffffff8010ea8c <swap_out+0xcc>
  }

  // For any processes having this page mapped, turn off present bit and set
  // swapped bit.

  for (size_t i = 0; i < NPROC; ++i) {
ffffffff8010eb16:	48 c7 45 c0 00 00 00 	movq   $0x0,-0x40(%rbp)
ffffffff8010eb1d:	00 
ffffffff8010eb1e:	48 83 7d c0 40       	cmpq   $0x40,-0x40(%rbp)
ffffffff8010eb23:	0f 83 8a 00 00 00    	jae    ffffffff8010ebb3 <swap_out+0x1f3>
    struct proc* mapping_proc = get_proc_by_ordinal(i);
ffffffff8010eb29:	48 8b 7d c0          	mov    -0x40(%rbp),%rdi
ffffffff8010eb2d:	e8 ee 8d ff ff       	callq  ffffffff80107920 <get_proc_by_ordinal>
ffffffff8010eb32:	48 89 45 b8          	mov    %rax,-0x48(%rbp)

    if (mapping_proc->state != UNUSED) {
ffffffff8010eb36:	48 8b 45 b8          	mov    -0x48(%rbp),%rax
ffffffff8010eb3a:	83 b8 00 01 00 00 00 	cmpl   $0x0,0x100(%rax)
ffffffff8010eb41:	0f 84 56 00 00 00    	je     ffffffff8010eb9d <swap_out+0x1dd>
ffffffff8010eb47:	31 c0                	xor    %eax,%eax
      pte_t* pte = walkpml4(mapping_proc->pml4, (char*) coremapentry->va, 0);
ffffffff8010eb49:	48 8b 4d b8          	mov    -0x48(%rbp),%rcx
ffffffff8010eb4d:	48 8b 39             	mov    (%rcx),%rdi
ffffffff8010eb50:	48 8b 4d f8          	mov    -0x8(%rbp),%rcx
ffffffff8010eb54:	48 8b 71 08          	mov    0x8(%rcx),%rsi
ffffffff8010eb58:	31 d2                	xor    %edx,%edx
ffffffff8010eb5a:	89 45 94             	mov    %eax,-0x6c(%rbp)
ffffffff8010eb5d:	e8 0e 41 ff ff       	callq  ffffffff80102c70 <walkpml4>
ffffffff8010eb62:	48 89 45 b0          	mov    %rax,-0x50(%rbp)

      if (pte != NULL) {
ffffffff8010eb66:	48 83 7d b0 00       	cmpq   $0x0,-0x50(%rbp)
ffffffff8010eb6b:	0f 84 27 00 00 00    	je     ffffffff8010eb98 <swap_out+0x1d8>
        *pte = PTE(ppn, (PTE_FLAGS(*pte) & ~PTE_P) | PTE_S);
ffffffff8010eb71:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
ffffffff8010eb75:	48 8b 4d b0          	mov    -0x50(%rbp),%rcx
ffffffff8010eb79:	48 8b 09             	mov    (%rcx),%rcx
ffffffff8010eb7c:	48 81 e1 ff 0f 00 00 	and    $0xfff,%rcx
ffffffff8010eb83:	48 83 e1 fe          	and    $0xfffffffffffffffe,%rcx
ffffffff8010eb87:	48 81 c9 00 02 00 00 	or     $0x200,%rcx
ffffffff8010eb8e:	48 09 c8             	or     %rcx,%rax
ffffffff8010eb91:	48 8b 4d b0          	mov    -0x50(%rbp),%rcx
ffffffff8010eb95:	48 89 01             	mov    %rax,(%rcx)
      }
    }
ffffffff8010eb98:	e9 00 00 00 00       	jmpq   ffffffff8010eb9d <swap_out+0x1dd>
  }
ffffffff8010eb9d:	e9 00 00 00 00       	jmpq   ffffffff8010eba2 <swap_out+0x1e2>
  for (size_t i = 0; i < NPROC; ++i) {
ffffffff8010eba2:	48 8b 45 c0          	mov    -0x40(%rbp),%rax
ffffffff8010eba6:	48 83 c0 01          	add    $0x1,%rax
ffffffff8010ebaa:	48 89 45 c0          	mov    %rax,-0x40(%rbp)
ffffffff8010ebae:	e9 6b ff ff ff       	jmpq   ffffffff8010eb1e <swap_out+0x15e>

  acquire_entry_lock();
ffffffff8010ebb3:	31 c0                	xor    %eax,%eax
ffffffff8010ebb5:	88 c1                	mov    %al,%cl
ffffffff8010ebb7:	88 c8                	mov    %cl,%al
ffffffff8010ebb9:	e8 02 18 ff ff       	callq  ffffffff801003c0 <acquire_entry_lock>
  kfree(ka);
ffffffff8010ebbe:	48 8b 7d d8          	mov    -0x28(%rbp),%rdi
ffffffff8010ebc2:	e8 a9 19 ff ff       	callq  ffffffff80100570 <kfree>
  switchuvm(myproc());
ffffffff8010ebc7:	e8 24 00 00 00       	callq  ffffffff8010ebf0 <myproc>
ffffffff8010ebcc:	48 89 c7             	mov    %rax,%rdi
ffffffff8010ebcf:	e8 1c 4a ff ff       	callq  ffffffff801035f0 <switchuvm>
  release_entry_lock();
ffffffff8010ebd4:	31 d2                	xor    %edx,%edx
ffffffff8010ebd6:	88 d1                	mov    %dl,%cl
ffffffff8010ebd8:	88 c8                	mov    %cl,%al
ffffffff8010ebda:	e8 01 18 ff ff       	callq  ffffffff801003e0 <release_entry_lock>
}
ffffffff8010ebdf:	48 83 c4 70          	add    $0x70,%rsp
ffffffff8010ebe3:	5d                   	pop    %rbp
ffffffff8010ebe4:	c3                   	retq   
ffffffff8010ebe5:	66 66 2e 0f 1f 84 00 	data16 nopw %cs:0x0(%rax,%rax,1)
ffffffff8010ebec:	00 00 00 00 

ffffffff8010ebf0 <myproc>:
{
ffffffff8010ebf0:	55                   	push   %rbp
ffffffff8010ebf1:	48 89 e5             	mov    %rsp,%rbp
  return mycpu()->proc;
ffffffff8010ebf4:	e8 a7 07 00 00       	callq  ffffffff8010f3a0 <mycpu>
ffffffff8010ebf9:	48 8b 80 d0 00 00 00 	mov    0xd0(%rax),%rax
ffffffff8010ec00:	5d                   	pop    %rbp
ffffffff8010ec01:	c3                   	retq   
ffffffff8010ec02:	66 66 66 66 66 2e 0f 	data16 data16 data16 data16 nopw %cs:0x0(%rax,%rax,1)
ffffffff8010ec09:	1f 84 00 00 00 00 00 

ffffffff8010ec10 <swap_in>:

void
swap_in(pte_t* pte)
{
ffffffff8010ec10:	55                   	push   %rbp
ffffffff8010ec11:	48 89 e5             	mov    %rsp,%rbp
ffffffff8010ec14:	48 81 ec 00 01 00 00 	sub    $0x100,%rsp
ffffffff8010ec1b:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  // Find an open page in PA
  uint64_t new_va = (uint64_t) kalloc();
ffffffff8010ec1f:	e8 5c 1b ff ff       	callq  ffffffff80100780 <kalloc>
ffffffff8010ec24:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  if (new_va == 0) {
ffffffff8010ec28:	48 83 7d f0 00       	cmpq   $0x0,-0x10(%rbp)
ffffffff8010ec2d:	0f 85 0c 00 00 00    	jne    ffffffff8010ec3f <swap_in+0x2f>
    panic("swap_in: not enough memory");
ffffffff8010ec33:	48 c7 c7 e1 06 11 80 	mov    $0xffffffff801106e1,%rdi
ffffffff8010ec3a:	e8 31 22 ff ff       	callq  ffffffff80100e70 <panic>
  }

  int index = PTE_ADDR(*pte) >> PT_SHIFT;
ffffffff8010ec3f:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
ffffffff8010ec43:	48 8b 00             	mov    (%rax),%rax
ffffffff8010ec46:	c7 45 e8 33 00 00 00 	movl   $0x33,-0x18(%rbp)
ffffffff8010ec4d:	c7 45 e4 0c 00 00 00 	movl   $0xc,-0x1c(%rbp)
ffffffff8010ec54:	8b 4d e8             	mov    -0x18(%rbp),%ecx
ffffffff8010ec57:	3b 4d e4             	cmp    -0x1c(%rbp),%ecx
ffffffff8010ec5a:	48 89 85 60 ff ff ff 	mov    %rax,-0xa0(%rbp)
ffffffff8010ec61:	0f 8c 0e 00 00 00    	jl     ffffffff8010ec75 <swap_in+0x65>
ffffffff8010ec67:	8b 45 e8             	mov    -0x18(%rbp),%eax
ffffffff8010ec6a:	89 85 5c ff ff ff    	mov    %eax,-0xa4(%rbp)
ffffffff8010ec70:	e9 09 00 00 00       	jmpq   ffffffff8010ec7e <swap_in+0x6e>
ffffffff8010ec75:	8b 45 e4             	mov    -0x1c(%rbp),%eax
ffffffff8010ec78:	89 85 5c ff ff ff    	mov    %eax,-0xa4(%rbp)
ffffffff8010ec7e:	8b 85 5c ff ff ff    	mov    -0xa4(%rbp),%eax
ffffffff8010ec84:	89 45 e0             	mov    %eax,-0x20(%rbp)
ffffffff8010ec87:	8b 45 e0             	mov    -0x20(%rbp),%eax
ffffffff8010ec8a:	c7 45 dc 33 00 00 00 	movl   $0x33,-0x24(%rbp)
ffffffff8010ec91:	c7 45 d8 0c 00 00 00 	movl   $0xc,-0x28(%rbp)
ffffffff8010ec98:	8b 4d dc             	mov    -0x24(%rbp),%ecx
ffffffff8010ec9b:	3b 4d d8             	cmp    -0x28(%rbp),%ecx
ffffffff8010ec9e:	89 85 58 ff ff ff    	mov    %eax,-0xa8(%rbp)
ffffffff8010eca4:	0f 8f 0e 00 00 00    	jg     ffffffff8010ecb8 <swap_in+0xa8>
ffffffff8010ecaa:	8b 45 dc             	mov    -0x24(%rbp),%eax
ffffffff8010ecad:	89 85 54 ff ff ff    	mov    %eax,-0xac(%rbp)
ffffffff8010ecb3:	e9 09 00 00 00       	jmpq   ffffffff8010ecc1 <swap_in+0xb1>
ffffffff8010ecb8:	8b 45 d8             	mov    -0x28(%rbp),%eax
ffffffff8010ecbb:	89 85 54 ff ff ff    	mov    %eax,-0xac(%rbp)
ffffffff8010ecc1:	8b 85 54 ff ff ff    	mov    -0xac(%rbp),%eax
ffffffff8010ecc7:	b9 01 00 00 00       	mov    $0x1,%ecx
ffffffff8010eccc:	89 ca                	mov    %ecx,%edx
ffffffff8010ecce:	89 45 d4             	mov    %eax,-0x2c(%rbp)
ffffffff8010ecd1:	8b 85 58 ff ff ff    	mov    -0xa8(%rbp),%eax
ffffffff8010ecd7:	2b 45 d4             	sub    -0x2c(%rbp),%eax
ffffffff8010ecda:	89 c0                	mov    %eax,%eax
ffffffff8010ecdc:	89 c1                	mov    %eax,%ecx
ffffffff8010ecde:	48 d3 e2             	shl    %cl,%rdx
ffffffff8010ece1:	48 c1 e2 01          	shl    $0x1,%rdx
ffffffff8010ece5:	48 83 ea 01          	sub    $0x1,%rdx
ffffffff8010ece9:	c7 45 d0 33 00 00 00 	movl   $0x33,-0x30(%rbp)
ffffffff8010ecf0:	c7 45 cc 0c 00 00 00 	movl   $0xc,-0x34(%rbp)
ffffffff8010ecf7:	8b 45 d0             	mov    -0x30(%rbp),%eax
ffffffff8010ecfa:	3b 45 cc             	cmp    -0x34(%rbp),%eax
ffffffff8010ecfd:	48 89 95 48 ff ff ff 	mov    %rdx,-0xb8(%rbp)
ffffffff8010ed04:	0f 8f 0e 00 00 00    	jg     ffffffff8010ed18 <swap_in+0x108>
ffffffff8010ed0a:	8b 45 d0             	mov    -0x30(%rbp),%eax
ffffffff8010ed0d:	89 85 44 ff ff ff    	mov    %eax,-0xbc(%rbp)
ffffffff8010ed13:	e9 09 00 00 00       	jmpq   ffffffff8010ed21 <swap_in+0x111>
ffffffff8010ed18:	8b 45 cc             	mov    -0x34(%rbp),%eax
ffffffff8010ed1b:	89 85 44 ff ff ff    	mov    %eax,-0xbc(%rbp)
ffffffff8010ed21:	8b 85 44 ff ff ff    	mov    -0xbc(%rbp),%eax
ffffffff8010ed27:	89 45 c8             	mov    %eax,-0x38(%rbp)
ffffffff8010ed2a:	8b 45 c8             	mov    -0x38(%rbp),%eax
ffffffff8010ed2d:	89 c1                	mov    %eax,%ecx
ffffffff8010ed2f:	48 8b 95 48 ff ff ff 	mov    -0xb8(%rbp),%rdx
ffffffff8010ed36:	48 d3 e2             	shl    %cl,%rdx
ffffffff8010ed39:	48 8b b5 60 ff ff ff 	mov    -0xa0(%rbp),%rsi
ffffffff8010ed40:	48 21 d6             	and    %rdx,%rsi
ffffffff8010ed43:	48 c1 ee 0c          	shr    $0xc,%rsi
ffffffff8010ed47:	89 f0                	mov    %esi,%eax
ffffffff8010ed49:	89 45 ec             	mov    %eax,-0x14(%rbp)

  for (int i = 0; i < BLOCKS_PER_PAGE; i++) {
ffffffff8010ed4c:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%rbp)
ffffffff8010ed53:	83 7d c4 08          	cmpl   $0x8,-0x3c(%rbp)
ffffffff8010ed57:	0f 8d 87 00 00 00    	jge    ffffffff8010ede4 <swap_in+0x1d4>
ffffffff8010ed5d:	b8 01 00 00 00       	mov    $0x1,%eax
    struct buf* buf = bread(ROOTDEV, 2 + index * BLOCKS_PER_PAGE + i);
ffffffff8010ed62:	8b 4d ec             	mov    -0x14(%rbp),%ecx
ffffffff8010ed65:	c1 e1 03             	shl    $0x3,%ecx
ffffffff8010ed68:	83 c1 02             	add    $0x2,%ecx
ffffffff8010ed6b:	03 4d c4             	add    -0x3c(%rbp),%ecx
ffffffff8010ed6e:	bf 01 00 00 00       	mov    $0x1,%edi
ffffffff8010ed73:	89 ce                	mov    %ecx,%esi
ffffffff8010ed75:	89 85 40 ff ff ff    	mov    %eax,-0xc0(%rbp)
ffffffff8010ed7b:	e8 d0 b1 ff ff       	callq  ffffffff80109f50 <bread>
ffffffff8010ed80:	b9 00 02 00 00       	mov    $0x200,%ecx
ffffffff8010ed85:	48 89 45 b8          	mov    %rax,-0x48(%rbp)
    memmove((void*)(new_va + (i * BSIZE)), buf->data, BSIZE);
ffffffff8010ed89:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
ffffffff8010ed8d:	8b 75 c4             	mov    -0x3c(%rbp),%esi
ffffffff8010ed90:	c1 e6 09             	shl    $0x9,%esi
ffffffff8010ed93:	48 63 d6             	movslq %esi,%rdx
ffffffff8010ed96:	48 01 d0             	add    %rdx,%rax
ffffffff8010ed99:	48 8b 55 b8          	mov    -0x48(%rbp),%rdx
ffffffff8010ed9d:	48 81 c2 b0 00 00 00 	add    $0xb0,%rdx
ffffffff8010eda4:	be 00 02 00 00       	mov    $0x200,%esi
ffffffff8010eda9:	48 89 c7             	mov    %rax,%rdi
ffffffff8010edac:	89 b5 3c ff ff ff    	mov    %esi,-0xc4(%rbp)
ffffffff8010edb2:	48 89 d6             	mov    %rdx,%rsi
ffffffff8010edb5:	8b 95 3c ff ff ff    	mov    -0xc4(%rbp),%edx
ffffffff8010edbb:	89 8d 38 ff ff ff    	mov    %ecx,-0xc8(%rbp)
ffffffff8010edc1:	e8 ca c2 ff ff       	callq  ffffffff8010b090 <memmove>
    brelse(buf);
ffffffff8010edc6:	48 8b 7d b8          	mov    -0x48(%rbp),%rdi
ffffffff8010edca:	48 89 85 30 ff ff ff 	mov    %rax,-0xd0(%rbp)
ffffffff8010edd1:	e8 6a b2 ff ff       	callq  ffffffff8010a040 <brelse>
  for (int i = 0; i < BLOCKS_PER_PAGE; i++) {
ffffffff8010edd6:	8b 45 c4             	mov    -0x3c(%rbp),%eax
ffffffff8010edd9:	83 c0 01             	add    $0x1,%eax
ffffffff8010eddc:	89 45 c4             	mov    %eax,-0x3c(%rbp)
ffffffff8010eddf:	e9 6f ff ff ff       	jmpq   ffffffff8010ed53 <swap_in+0x143>
  }

  acquire(&sm.lock);
ffffffff8010ede4:	48 c7 c7 68 55 22 83 	mov    $0xffffffff83225568,%rdi
ffffffff8010edeb:	e8 d0 69 ff ff       	callq  ffffffff801057c0 <acquire>

  // validity check
  if (sm.map[index].ref_count == 0) {
ffffffff8010edf0:	48 63 7d ec          	movslq -0x14(%rbp),%rdi
ffffffff8010edf4:	48 c1 e7 04          	shl    $0x4,%rdi
ffffffff8010edf8:	48 8d bf 68 55 20 83 	lea    -0x7cdfaa98(%rdi),%rdi
ffffffff8010edff:	0f b6 47 0c          	movzbl 0xc(%rdi),%eax
ffffffff8010ee03:	83 f8 00             	cmp    $0x0,%eax
ffffffff8010ee06:	0f 85 0c 00 00 00    	jne    ffffffff8010ee18 <swap_in+0x208>
    panic("swapping in invalid swap entry");
ffffffff8010ee0c:	48 c7 c7 fc 06 11 80 	mov    $0xffffffff801106fc,%rdi
ffffffff8010ee13:	e8 58 20 ff ff       	callq  ffffffff80100e70 <panic>
  }

  struct core_map_entry* coremapentry = pa2page(V2P((void*) new_va));
ffffffff8010ee18:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
ffffffff8010ee1c:	48 2d 00 00 00 80    	sub    $0xffffffff80000000,%rax
ffffffff8010ee22:	48 89 c7             	mov    %rax,%rdi
ffffffff8010ee25:	e8 26 13 ff ff       	callq  ffffffff80100150 <pa2page>
ffffffff8010ee2a:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
  coremapentry->va = sm.map[index].va;
ffffffff8010ee2e:	48 63 45 ec          	movslq -0x14(%rbp),%rax
ffffffff8010ee32:	48 c1 e0 04          	shl    $0x4,%rax
ffffffff8010ee36:	48 8b 80 68 55 20 83 	mov    -0x7cdfaa98(%rax),%rax
ffffffff8010ee3d:	48 8b 7d b0          	mov    -0x50(%rbp),%rdi
ffffffff8010ee41:	48 89 47 08          	mov    %rax,0x8(%rdi)
  coremapentry->pid = sm.map[index].pid;
ffffffff8010ee45:	48 63 45 ec          	movslq -0x14(%rbp),%rax
ffffffff8010ee49:	48 c1 e0 04          	shl    $0x4,%rax
ffffffff8010ee4d:	8b 88 70 55 20 83    	mov    -0x7cdfaa90(%rax),%ecx
ffffffff8010ee53:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
ffffffff8010ee57:	89 48 14             	mov    %ecx,0x14(%rax)
  coremapentry->ref_count = sm.map[index].ref_count;
ffffffff8010ee5a:	48 63 45 ec          	movslq -0x14(%rbp),%rax
ffffffff8010ee5e:	48 c1 e0 04          	shl    $0x4,%rax
ffffffff8010ee62:	8a 90 74 55 20 83    	mov    -0x7cdfaa8c(%rax),%dl
ffffffff8010ee68:	48 8b 45 b0          	mov    -0x50(%rbp),%rax
ffffffff8010ee6c:	88 50 18             	mov    %dl,0x18(%rax)
  sm.map[index].ref_count = 0;
ffffffff8010ee6f:	48 63 45 ec          	movslq -0x14(%rbp),%rax
ffffffff8010ee73:	48 c1 e0 04          	shl    $0x4,%rax
ffffffff8010ee77:	c6 80 74 55 20 83 00 	movb   $0x0,-0x7cdfaa8c(%rax)
  pages_in_swap--;
ffffffff8010ee7e:	8b 0c 25 a8 65 1f 83 	mov    0xffffffff831f65a8,%ecx
ffffffff8010ee85:	ff c9                	dec    %ecx
ffffffff8010ee87:	89 0c 25 a8 65 1f 83 	mov    %ecx,0xffffffff831f65a8

  // For any processes mapping this address, update the PPN to the new PA we
  // assigned, and chang PTE bits to PTE_P and ~PTE_Swap.
  uint64_t flags = (*pte & (PTE_W | PTE_RO)) | PTE_U | PTE_P;
ffffffff8010ee8e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
ffffffff8010ee92:	48 8b 00             	mov    (%rax),%rax
ffffffff8010ee95:	48 25 02 08 00 00    	and    $0x802,%rax
ffffffff8010ee9b:	48 83 c8 04          	or     $0x4,%rax
ffffffff8010ee9f:	48 83 c8 01          	or     $0x1,%rax
ffffffff8010eea3:	48 89 45 a8          	mov    %rax,-0x58(%rbp)

  for (size_t i = 0; i < NPROC; ++i) {
ffffffff8010eea7:	48 c7 45 a0 00 00 00 	movq   $0x0,-0x60(%rbp)
ffffffff8010eeae:	00 
ffffffff8010eeaf:	48 83 7d a0 40       	cmpq   $0x40,-0x60(%rbp)
ffffffff8010eeb4:	0f 83 9f 01 00 00    	jae    ffffffff8010f059 <swap_in+0x449>
    struct proc* proc = get_proc_by_ordinal(i);
ffffffff8010eeba:	48 8b 7d a0          	mov    -0x60(%rbp),%rdi
ffffffff8010eebe:	e8 5d 8a ff ff       	callq  ffffffff80107920 <get_proc_by_ordinal>
ffffffff8010eec3:	48 89 45 98          	mov    %rax,-0x68(%rbp)

    if (proc->state != UNUSED) {
ffffffff8010eec7:	48 8b 45 98          	mov    -0x68(%rbp),%rax
ffffffff8010eecb:	83 b8 00 01 00 00 00 	cmpl   $0x0,0x100(%rax)
ffffffff8010eed2:	0f 84 6b 01 00 00    	je     ffffffff8010f043 <swap_in+0x433>
ffffffff8010eed8:	31 c0                	xor    %eax,%eax
      pte_t* pte = walkpml4(proc->pml4, (char*) coremapentry->va, 0);
ffffffff8010eeda:	48 8b 4d 98          	mov    -0x68(%rbp),%rcx
ffffffff8010eede:	48 8b 39             	mov    (%rcx),%rdi
ffffffff8010eee1:	48 8b 4d b0          	mov    -0x50(%rbp),%rcx
ffffffff8010eee5:	48 8b 71 08          	mov    0x8(%rcx),%rsi
ffffffff8010eee9:	31 d2                	xor    %edx,%edx
ffffffff8010eeeb:	89 85 2c ff ff ff    	mov    %eax,-0xd4(%rbp)
ffffffff8010eef1:	e8 7a 3d ff ff       	callq  ffffffff80102c70 <walkpml4>
ffffffff8010eef6:	48 89 45 90          	mov    %rax,-0x70(%rbp)

      if (pte != NULL) {
ffffffff8010eefa:	48 83 7d 90 00       	cmpq   $0x0,-0x70(%rbp)
ffffffff8010eeff:	0f 84 39 01 00 00    	je     ffffffff8010f03e <swap_in+0x42e>
        *pte = PTE(PTE_ADDR(V2P(new_va)), flags);
ffffffff8010ef05:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
ffffffff8010ef09:	48 2d 00 00 00 80    	sub    $0xffffffff80000000,%rax
ffffffff8010ef0f:	c7 45 8c 33 00 00 00 	movl   $0x33,-0x74(%rbp)
ffffffff8010ef16:	c7 45 88 0c 00 00 00 	movl   $0xc,-0x78(%rbp)
ffffffff8010ef1d:	8b 4d 8c             	mov    -0x74(%rbp),%ecx
ffffffff8010ef20:	3b 4d 88             	cmp    -0x78(%rbp),%ecx
ffffffff8010ef23:	48 89 85 20 ff ff ff 	mov    %rax,-0xe0(%rbp)
ffffffff8010ef2a:	0f 8c 0e 00 00 00    	jl     ffffffff8010ef3e <swap_in+0x32e>
ffffffff8010ef30:	8b 45 8c             	mov    -0x74(%rbp),%eax
ffffffff8010ef33:	89 85 1c ff ff ff    	mov    %eax,-0xe4(%rbp)
ffffffff8010ef39:	e9 09 00 00 00       	jmpq   ffffffff8010ef47 <swap_in+0x337>
ffffffff8010ef3e:	8b 45 88             	mov    -0x78(%rbp),%eax
ffffffff8010ef41:	89 85 1c ff ff ff    	mov    %eax,-0xe4(%rbp)
ffffffff8010ef47:	8b 85 1c ff ff ff    	mov    -0xe4(%rbp),%eax
ffffffff8010ef4d:	89 45 84             	mov    %eax,-0x7c(%rbp)
ffffffff8010ef50:	8b 45 84             	mov    -0x7c(%rbp),%eax
ffffffff8010ef53:	c7 45 80 33 00 00 00 	movl   $0x33,-0x80(%rbp)
ffffffff8010ef5a:	c7 85 7c ff ff ff 0c 	movl   $0xc,-0x84(%rbp)
ffffffff8010ef61:	00 00 00 
ffffffff8010ef64:	8b 4d 80             	mov    -0x80(%rbp),%ecx
ffffffff8010ef67:	3b 8d 7c ff ff ff    	cmp    -0x84(%rbp),%ecx
ffffffff8010ef6d:	89 85 18 ff ff ff    	mov    %eax,-0xe8(%rbp)
ffffffff8010ef73:	0f 8f 0e 00 00 00    	jg     ffffffff8010ef87 <swap_in+0x377>
ffffffff8010ef79:	8b 45 80             	mov    -0x80(%rbp),%eax
ffffffff8010ef7c:	89 85 14 ff ff ff    	mov    %eax,-0xec(%rbp)
ffffffff8010ef82:	e9 0c 00 00 00       	jmpq   ffffffff8010ef93 <swap_in+0x383>
ffffffff8010ef87:	8b 85 7c ff ff ff    	mov    -0x84(%rbp),%eax
ffffffff8010ef8d:	89 85 14 ff ff ff    	mov    %eax,-0xec(%rbp)
ffffffff8010ef93:	8b 85 14 ff ff ff    	mov    -0xec(%rbp),%eax
ffffffff8010ef99:	b9 01 00 00 00       	mov    $0x1,%ecx
ffffffff8010ef9e:	89 ca                	mov    %ecx,%edx
ffffffff8010efa0:	89 85 78 ff ff ff    	mov    %eax,-0x88(%rbp)
ffffffff8010efa6:	8b 85 18 ff ff ff    	mov    -0xe8(%rbp),%eax
ffffffff8010efac:	2b 85 78 ff ff ff    	sub    -0x88(%rbp),%eax
ffffffff8010efb2:	89 c0                	mov    %eax,%eax
ffffffff8010efb4:	89 c1                	mov    %eax,%ecx
ffffffff8010efb6:	48 d3 e2             	shl    %cl,%rdx
ffffffff8010efb9:	48 c1 e2 01          	shl    $0x1,%rdx
ffffffff8010efbd:	48 83 ea 01          	sub    $0x1,%rdx
ffffffff8010efc1:	c7 85 74 ff ff ff 33 	movl   $0x33,-0x8c(%rbp)
ffffffff8010efc8:	00 00 00 
ffffffff8010efcb:	c7 85 70 ff ff ff 0c 	movl   $0xc,-0x90(%rbp)
ffffffff8010efd2:	00 00 00 
ffffffff8010efd5:	8b 85 74 ff ff ff    	mov    -0x8c(%rbp),%eax
ffffffff8010efdb:	3b 85 70 ff ff ff    	cmp    -0x90(%rbp),%eax
ffffffff8010efe1:	48 89 95 08 ff ff ff 	mov    %rdx,-0xf8(%rbp)
ffffffff8010efe8:	0f 8f 11 00 00 00    	jg     ffffffff8010efff <swap_in+0x3ef>
ffffffff8010efee:	8b 85 74 ff ff ff    	mov    -0x8c(%rbp),%eax
ffffffff8010eff4:	89 85 04 ff ff ff    	mov    %eax,-0xfc(%rbp)
ffffffff8010effa:	e9 0c 00 00 00       	jmpq   ffffffff8010f00b <swap_in+0x3fb>
ffffffff8010efff:	8b 85 70 ff ff ff    	mov    -0x90(%rbp),%eax
ffffffff8010f005:	89 85 04 ff ff ff    	mov    %eax,-0xfc(%rbp)
ffffffff8010f00b:	8b 85 04 ff ff ff    	mov    -0xfc(%rbp),%eax
ffffffff8010f011:	89 85 6c ff ff ff    	mov    %eax,-0x94(%rbp)
ffffffff8010f017:	8b 85 6c ff ff ff    	mov    -0x94(%rbp),%eax
ffffffff8010f01d:	89 c1                	mov    %eax,%ecx
ffffffff8010f01f:	48 8b 95 08 ff ff ff 	mov    -0xf8(%rbp),%rdx
ffffffff8010f026:	48 d3 e2             	shl    %cl,%rdx
ffffffff8010f029:	48 8b b5 20 ff ff ff 	mov    -0xe0(%rbp),%rsi
ffffffff8010f030:	48 21 d6             	and    %rdx,%rsi
ffffffff8010f033:	48 0b 75 a8          	or     -0x58(%rbp),%rsi
ffffffff8010f037:	48 8b 55 90          	mov    -0x70(%rbp),%rdx
ffffffff8010f03b:	48 89 32             	mov    %rsi,(%rdx)
      }
    }
ffffffff8010f03e:	e9 00 00 00 00       	jmpq   ffffffff8010f043 <swap_in+0x433>
  }
ffffffff8010f043:	e9 00 00 00 00       	jmpq   ffffffff8010f048 <swap_in+0x438>
  for (size_t i = 0; i < NPROC; ++i) {
ffffffff8010f048:	48 8b 45 a0          	mov    -0x60(%rbp),%rax
ffffffff8010f04c:	48 83 c0 01          	add    $0x1,%rax
ffffffff8010f050:	48 89 45 a0          	mov    %rax,-0x60(%rbp)
ffffffff8010f054:	e9 56 fe ff ff       	jmpq   ffffffff8010eeaf <swap_in+0x29f>
  switchuvm(myproc());
ffffffff8010f059:	e8 92 fb ff ff       	callq  ffffffff8010ebf0 <myproc>
ffffffff8010f05e:	48 89 c7             	mov    %rax,%rdi
ffffffff8010f061:	e8 8a 45 ff ff       	callq  ffffffff801035f0 <switchuvm>
  release(&sm.lock);
ffffffff8010f066:	48 c7 c7 68 55 22 83 	mov    $0xffffffff83225568,%rdi
ffffffff8010f06d:	e8 8e 69 ff ff       	callq  ffffffff80105a00 <release>
}
ffffffff8010f072:	48 81 c4 00 01 00 00 	add    $0x100,%rsp
ffffffff8010f079:	5d                   	pop    %rbp
ffffffff8010f07a:	c3                   	retq   
ffffffff8010f07b:	0f 1f 44 00 00       	nopl   0x0(%rax,%rax,1)

ffffffff8010f080 <swap_choose_eviction>:

struct core_map_entry* swap_choose_eviction()
{
ffffffff8010f080:	55                   	push   %rbp
ffffffff8010f081:	48 89 e5             	mov    %rsp,%rbp
  acquire_entry_lock();
ffffffff8010f084:	48 83 ec 20          	sub    $0x20,%rsp
ffffffff8010f088:	31 c0                	xor    %eax,%eax
ffffffff8010f08a:	88 c1                	mov    %al,%cl
ffffffff8010f08c:	88 c8                	mov    %cl,%al
ffffffff8010f08e:	e8 2d 13 ff ff       	callq  ffffffff801003c0 <acquire_entry_lock>

  // To approximate LRU, choose the core map entry w/ lowest refbits.

  struct core_map_entry* best = NULL;
ffffffff8010f093:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
ffffffff8010f09a:	00 

  for (size_t j = 1; j < npages; j++) {
ffffffff8010f09b:	48 c7 45 f0 01 00 00 	movq   $0x1,-0x10(%rbp)
ffffffff8010f0a2:	00 
ffffffff8010f0a3:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
ffffffff8010f0a7:	8b 0c 25 e0 63 1f 83 	mov    0xffffffff831f63e0,%ecx
ffffffff8010f0ae:	48 63 d1             	movslq %ecx,%rdx
ffffffff8010f0b1:	48 39 d0             	cmp    %rdx,%rax
ffffffff8010f0b4:	0f 83 86 00 00 00    	jae    ffffffff8010f140 <swap_choose_eviction+0xc0>
    struct core_map_entry* core = core_map_entry_get(j);
ffffffff8010f0ba:	48 8b 7d f0          	mov    -0x10(%rbp),%rdi
ffffffff8010f0be:	e8 2d 11 ff ff       	callq  ffffffff801001f0 <core_map_entry_get>
ffffffff8010f0c3:	48 89 45 e8          	mov    %rax,-0x18(%rbp)

    if (core->pid != -1 && core->ref_count > 0) {
ffffffff8010f0c7:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
ffffffff8010f0cb:	83 78 14 ff          	cmpl   $0xffffffff,0x14(%rax)
ffffffff8010f0cf:	0f 84 55 00 00 00    	je     ffffffff8010f12a <swap_choose_eviction+0xaa>
ffffffff8010f0d5:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
ffffffff8010f0d9:	0f b6 48 18          	movzbl 0x18(%rax),%ecx
ffffffff8010f0dd:	83 f9 00             	cmp    $0x0,%ecx
ffffffff8010f0e0:	0f 8e 44 00 00 00    	jle    ffffffff8010f12a <swap_choose_eviction+0xaa>
      if (best == NULL || core->refbits < best->refbits) {
ffffffff8010f0e6:	48 83 7d f8 00       	cmpq   $0x0,-0x8(%rbp)
ffffffff8010f0eb:	0f 84 14 00 00 00    	je     ffffffff8010f105 <swap_choose_eviction+0x85>
ffffffff8010f0f1:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
ffffffff8010f0f5:	8b 48 10             	mov    0x10(%rax),%ecx
ffffffff8010f0f8:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
ffffffff8010f0fc:	3b 48 10             	cmp    0x10(%rax),%ecx
ffffffff8010f0ff:	0f 83 20 00 00 00    	jae    ffffffff8010f125 <swap_choose_eviction+0xa5>
        best = core;
ffffffff8010f105:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
ffffffff8010f109:	48 89 45 f8          	mov    %rax,-0x8(%rbp)

        if (best->refbits == 0) {
ffffffff8010f10d:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
ffffffff8010f111:	83 78 10 00          	cmpl   $0x0,0x10(%rax)
ffffffff8010f115:	0f 85 05 00 00 00    	jne    ffffffff8010f120 <swap_choose_eviction+0xa0>
          // We won't do better than this.
          break;
ffffffff8010f11b:	e9 20 00 00 00       	jmpq   ffffffff8010f140 <swap_choose_eviction+0xc0>
        }
      }
ffffffff8010f120:	e9 00 00 00 00       	jmpq   ffffffff8010f125 <swap_choose_eviction+0xa5>
    }
ffffffff8010f125:	e9 00 00 00 00       	jmpq   ffffffff8010f12a <swap_choose_eviction+0xaa>
  }
ffffffff8010f12a:	e9 00 00 00 00       	jmpq   ffffffff8010f12f <swap_choose_eviction+0xaf>
  for (size_t j = 1; j < npages; j++) {
ffffffff8010f12f:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
ffffffff8010f133:	48 83 c0 01          	add    $0x1,%rax
ffffffff8010f137:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
ffffffff8010f13b:	e9 63 ff ff ff       	jmpq   ffffffff8010f0a3 <swap_choose_eviction+0x23>

  release_entry_lock();
ffffffff8010f140:	31 c0                	xor    %eax,%eax
ffffffff8010f142:	88 c1                	mov    %al,%cl
ffffffff8010f144:	88 c8                	mov    %cl,%al
ffffffff8010f146:	e8 95 12 ff ff       	callq  ffffffff801003e0 <release_entry_lock>
  return best;
ffffffff8010f14b:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
ffffffff8010f14f:	48 83 c4 20          	add    $0x20,%rsp
ffffffff8010f153:	5d                   	pop    %rbp
ffffffff8010f154:	c3                   	retq   
ffffffff8010f155:	66 66 2e 0f 1f 84 00 	data16 nopw %cs:0x0(%rax,%rax,1)
ffffffff8010f15c:	00 00 00 00 

ffffffff8010f160 <swap_evict_if_needed>:
}

void swap_evict_if_needed()
{
ffffffff8010f160:	55                   	push   %rbp
ffffffff8010f161:	48 89 e5             	mov    %rsp,%rbp
ffffffff8010f164:	48 83 ec 10          	sub    $0x10,%rsp
  while (free_pages < SWAP_THRESHOLD) {
ffffffff8010f168:	8b 04 25 98 65 1f 83 	mov    0xffffffff831f6598,%eax
ffffffff8010f16f:	83 f8 08             	cmp    $0x8,%eax
ffffffff8010f172:	0f 8d 30 00 00 00    	jge    ffffffff8010f1a8 <swap_evict_if_needed+0x48>
    struct core_map_entry* entry = swap_choose_eviction();
ffffffff8010f178:	e8 03 ff ff ff       	callq  ffffffff8010f080 <swap_choose_eviction>
ffffffff8010f17d:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
    swap_out(entry, get_proc(entry->pid));
ffffffff8010f181:	48 8b 7d f8          	mov    -0x8(%rbp),%rdi
ffffffff8010f185:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
ffffffff8010f189:	8b 48 14             	mov    0x14(%rax),%ecx
ffffffff8010f18c:	48 89 7d f0          	mov    %rdi,-0x10(%rbp)
ffffffff8010f190:	89 cf                	mov    %ecx,%edi
ffffffff8010f192:	e8 09 87 ff ff       	callq  ffffffff801078a0 <get_proc>
ffffffff8010f197:	48 8b 7d f0          	mov    -0x10(%rbp),%rdi
ffffffff8010f19b:	48 89 c6             	mov    %rax,%rsi
ffffffff8010f19e:	e8 1d f8 ff ff       	callq  ffffffff8010e9c0 <swap_out>
  while (free_pages < SWAP_THRESHOLD) {
ffffffff8010f1a3:	e9 c0 ff ff ff       	jmpq   ffffffff8010f168 <swap_evict_if_needed+0x8>
  }
}
ffffffff8010f1a8:	48 83 c4 10          	add    $0x10,%rsp
ffffffff8010f1ac:	5d                   	pop    %rbp
ffffffff8010f1ad:	c3                   	retq   
ffffffff8010f1ae:	66 90                	xchg   %ax,%ax

ffffffff8010f1b0 <swap_restore_page>:

// Brings a page back from the swap region.
void swap_restore_page(struct proc* proc, uint64_t uva)
{
ffffffff8010f1b0:	55                   	push   %rbp
ffffffff8010f1b1:	48 89 e5             	mov    %rsp,%rbp
ffffffff8010f1b4:	48 83 ec 20          	sub    $0x20,%rsp
ffffffff8010f1b8:	31 c0                	xor    %eax,%eax
ffffffff8010f1ba:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
ffffffff8010f1be:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  pte_t* pte = walkpml4(proc->pml4, (char*)uva, 0);
ffffffff8010f1c2:	48 8b 75 f8          	mov    -0x8(%rbp),%rsi
ffffffff8010f1c6:	48 8b 3e             	mov    (%rsi),%rdi
ffffffff8010f1c9:	48 8b 75 f0          	mov    -0x10(%rbp),%rsi
ffffffff8010f1cd:	31 d2                	xor    %edx,%edx
ffffffff8010f1cf:	89 45 e4             	mov    %eax,-0x1c(%rbp)
ffffffff8010f1d2:	e8 99 3a ff ff       	callq  ffffffff80102c70 <walkpml4>
ffffffff8010f1d7:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  swap_in(pte);
ffffffff8010f1db:	48 8b 7d e8          	mov    -0x18(%rbp),%rdi
ffffffff8010f1df:	e8 2c fa ff ff       	callq  ffffffff8010ec10 <swap_in>
}
ffffffff8010f1e4:	48 83 c4 20          	add    $0x20,%rsp
ffffffff8010f1e8:	5d                   	pop    %rbp
ffffffff8010f1e9:	c3                   	retq   
ffffffff8010f1ea:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)

ffffffff8010f1f0 <swap_timer>:
// Called by the interrupt timer to evaluate a portion of the core map for
// having been accessed. For each core map entry, we keep an access history of
// many bits. When we need to evict a page, we choose the one with the lowest
// refbits.
void swap_timer()
{
ffffffff8010f1f0:	55                   	push   %rbp
ffffffff8010f1f1:	48 89 e5             	mov    %rsp,%rbp
  acquire_entry_lock();
ffffffff8010f1f4:	48 83 ec 40          	sub    $0x40,%rsp
ffffffff8010f1f8:	31 c0                	xor    %eax,%eax
ffffffff8010f1fa:	88 c1                	mov    %al,%cl
ffffffff8010f1fc:	88 c8                	mov    %cl,%al
ffffffff8010f1fe:	e8 bd 11 ff ff       	callq  ffffffff801003c0 <acquire_entry_lock>

  for (size_t j = 0; j < SWAP_TIMER_STRIDE; j++) {
ffffffff8010f203:	48 c7 45 f8 00 00 00 	movq   $0x0,-0x8(%rbp)
ffffffff8010f20a:	00 
ffffffff8010f20b:	48 81 7d f8 80 00 00 	cmpq   $0x80,-0x8(%rbp)
ffffffff8010f212:	00 
ffffffff8010f213:	0f 83 74 01 00 00    	jae    ffffffff8010f38d <swap_timer+0x19d>
    if (++clock_hand >= npages) {
ffffffff8010f219:	48 8b 04 25 60 55 20 	mov    0xffffffff83205560,%rax
ffffffff8010f220:	83 
ffffffff8010f221:	48 ff c0             	inc    %rax
ffffffff8010f224:	48 89 04 25 60 55 20 	mov    %rax,0xffffffff83205560
ffffffff8010f22b:	83 
ffffffff8010f22c:	8b 0c 25 e0 63 1f 83 	mov    0xffffffff831f63e0,%ecx
ffffffff8010f233:	48 63 d1             	movslq %ecx,%rdx
ffffffff8010f236:	48 39 d0             	cmp    %rdx,%rax
ffffffff8010f239:	0f 82 0c 00 00 00    	jb     ffffffff8010f24b <swap_timer+0x5b>
      clock_hand = 0;
ffffffff8010f23f:	48 c7 04 25 60 55 20 	movq   $0x0,0xffffffff83205560
ffffffff8010f246:	83 00 00 00 00 
    }

    struct core_map_entry* core = core_map_entry_get(clock_hand);
ffffffff8010f24b:	48 8b 3c 25 60 55 20 	mov    0xffffffff83205560,%rdi
ffffffff8010f252:	83 
ffffffff8010f253:	e8 98 0f ff ff       	callq  ffffffff801001f0 <core_map_entry_get>
ffffffff8010f258:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

    if (core->pid != -1 && core->ref_count > 0) {
ffffffff8010f25c:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
ffffffff8010f260:	83 78 14 ff          	cmpl   $0xffffffff,0x14(%rax)
ffffffff8010f264:	0f 84 0d 01 00 00    	je     ffffffff8010f377 <swap_timer+0x187>
ffffffff8010f26a:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
ffffffff8010f26e:	0f b6 48 18          	movzbl 0x18(%rax),%ecx
ffffffff8010f272:	83 f9 00             	cmp    $0x0,%ecx
ffffffff8010f275:	0f 8e fc 00 00 00    	jle    ffffffff8010f377 <swap_timer+0x187>
      uint8_t mapping_processes = core->ref_count;
ffffffff8010f27b:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
ffffffff8010f27f:	8a 48 18             	mov    0x18(%rax),%cl
ffffffff8010f282:	88 4d ef             	mov    %cl,-0x11(%rbp)
      bool accessed = false;
ffffffff8010f285:	c6 45 ee 00          	movb   $0x0,-0x12(%rbp)

      for (size_t i = 0; i < NPROC; ++i) {
ffffffff8010f289:	48 c7 45 e0 00 00 00 	movq   $0x0,-0x20(%rbp)
ffffffff8010f290:	00 
ffffffff8010f291:	48 83 7d e0 40       	cmpq   $0x40,-0x20(%rbp)
ffffffff8010f296:	0f 83 b6 00 00 00    	jae    ffffffff8010f352 <swap_timer+0x162>
        struct proc* proc = get_proc_by_ordinal(i);
ffffffff8010f29c:	48 8b 7d e0          	mov    -0x20(%rbp),%rdi
ffffffff8010f2a0:	e8 7b 86 ff ff       	callq  ffffffff80107920 <get_proc_by_ordinal>
ffffffff8010f2a5:	48 89 45 d8          	mov    %rax,-0x28(%rbp)

        if (proc->state != UNUSED) {
ffffffff8010f2a9:	48 8b 45 d8          	mov    -0x28(%rbp),%rax
ffffffff8010f2ad:	83 b8 00 01 00 00 00 	cmpl   $0x0,0x100(%rax)
ffffffff8010f2b4:	0f 84 82 00 00 00    	je     ffffffff8010f33c <swap_timer+0x14c>
ffffffff8010f2ba:	31 c0                	xor    %eax,%eax
          pte_t* entry = walkpml4(proc->pml4, (char*) core->va, 0);
ffffffff8010f2bc:	48 8b 4d d8          	mov    -0x28(%rbp),%rcx
ffffffff8010f2c0:	48 8b 39             	mov    (%rcx),%rdi
ffffffff8010f2c3:	48 8b 4d f0          	mov    -0x10(%rbp),%rcx
ffffffff8010f2c7:	48 8b 71 08          	mov    0x8(%rcx),%rsi
ffffffff8010f2cb:	31 d2                	xor    %edx,%edx
ffffffff8010f2cd:	89 45 cc             	mov    %eax,-0x34(%rbp)
ffffffff8010f2d0:	e8 9b 39 ff ff       	callq  ffffffff80102c70 <walkpml4>
ffffffff8010f2d5:	48 89 45 d0          	mov    %rax,-0x30(%rbp)

          if (entry != NULL) {
ffffffff8010f2d9:	48 83 7d d0 00       	cmpq   $0x0,-0x30(%rbp)
ffffffff8010f2de:	0f 84 53 00 00 00    	je     ffffffff8010f337 <swap_timer+0x147>
            accessed |= (*entry & (PTE_A | PTE_P));
ffffffff8010f2e4:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
ffffffff8010f2e8:	48 8b 00             	mov    (%rax),%rax
ffffffff8010f2eb:	48 83 e0 21          	and    $0x21,%rax
ffffffff8010f2ef:	8a 4d ee             	mov    -0x12(%rbp),%cl
ffffffff8010f2f2:	80 e1 01             	and    $0x1,%cl
ffffffff8010f2f5:	0f b6 d1             	movzbl %cl,%edx
ffffffff8010f2f8:	89 d6                	mov    %edx,%esi
ffffffff8010f2fa:	48 09 c6             	or     %rax,%rsi
ffffffff8010f2fd:	48 83 fe 00          	cmp    $0x0,%rsi
ffffffff8010f301:	0f 95 c1             	setne  %cl
ffffffff8010f304:	80 e1 01             	and    $0x1,%cl
ffffffff8010f307:	88 4d ee             	mov    %cl,-0x12(%rbp)
            *entry &= ~PTE_A;
ffffffff8010f30a:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
ffffffff8010f30e:	48 8b 30             	mov    (%rax),%rsi
ffffffff8010f311:	48 83 e6 df          	and    $0xffffffffffffffdf,%rsi
ffffffff8010f315:	48 89 30             	mov    %rsi,(%rax)

            if (--mapping_processes == 0) {
ffffffff8010f318:	8a 4d ef             	mov    -0x11(%rbp),%cl
ffffffff8010f31b:	80 c1 ff             	add    $0xff,%cl
ffffffff8010f31e:	88 4d ef             	mov    %cl,-0x11(%rbp)
ffffffff8010f321:	0f b6 d1             	movzbl %cl,%edx
ffffffff8010f324:	83 fa 00             	cmp    $0x0,%edx
ffffffff8010f327:	0f 85 05 00 00 00    	jne    ffffffff8010f332 <swap_timer+0x142>
              // No other mapping processes, so we can stop searching.
              break;
ffffffff8010f32d:	e9 20 00 00 00       	jmpq   ffffffff8010f352 <swap_timer+0x162>
            }
          }
ffffffff8010f332:	e9 00 00 00 00       	jmpq   ffffffff8010f337 <swap_timer+0x147>
        }
ffffffff8010f337:	e9 00 00 00 00       	jmpq   ffffffff8010f33c <swap_timer+0x14c>
      }
ffffffff8010f33c:	e9 00 00 00 00       	jmpq   ffffffff8010f341 <swap_timer+0x151>
      for (size_t i = 0; i < NPROC; ++i) {
ffffffff8010f341:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
ffffffff8010f345:	48 83 c0 01          	add    $0x1,%rax
ffffffff8010f349:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
ffffffff8010f34d:	e9 3f ff ff ff       	jmpq   ffffffff8010f291 <swap_timer+0xa1>

      // Shift everything to the right by one, and set the MSB if one of the
      // processes mapping the page has accessed it.
      core->refbits = (core->refbits >> 1)
ffffffff8010f352:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
ffffffff8010f356:	8b 48 10             	mov    0x10(%rax),%ecx
ffffffff8010f359:	c1 e9 01             	shr    $0x1,%ecx
       | (!!accessed << (sizeof(RefBitsType) * CHAR_BIT - 1));
ffffffff8010f35c:	8a 55 ee             	mov    -0x12(%rbp),%dl
ffffffff8010f35f:	80 f2 ff             	xor    $0xff,%dl
ffffffff8010f362:	80 f2 ff             	xor    $0xff,%dl
ffffffff8010f365:	80 e2 01             	and    $0x1,%dl
ffffffff8010f368:	0f b6 f2             	movzbl %dl,%esi
ffffffff8010f36b:	c1 e6 1f             	shl    $0x1f,%esi
ffffffff8010f36e:	09 f1                	or     %esi,%ecx
      core->refbits = (core->refbits >> 1)
ffffffff8010f370:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
ffffffff8010f374:	89 48 10             	mov    %ecx,0x10(%rax)
    }
  }
ffffffff8010f377:	e9 00 00 00 00       	jmpq   ffffffff8010f37c <swap_timer+0x18c>
  for (size_t j = 0; j < SWAP_TIMER_STRIDE; j++) {
ffffffff8010f37c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
ffffffff8010f380:	48 83 c0 01          	add    $0x1,%rax
ffffffff8010f384:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
ffffffff8010f388:	e9 7e fe ff ff       	jmpq   ffffffff8010f20b <swap_timer+0x1b>

  release_entry_lock();
ffffffff8010f38d:	31 c0                	xor    %eax,%eax
ffffffff8010f38f:	88 c1                	mov    %al,%cl
ffffffff8010f391:	88 c8                	mov    %cl,%al
ffffffff8010f393:	e8 48 10 ff ff       	callq  ffffffff801003e0 <release_entry_lock>
}
ffffffff8010f398:	48 83 c4 40          	add    $0x40,%rsp
ffffffff8010f39c:	5d                   	pop    %rbp
ffffffff8010f39d:	c3                   	retq   
ffffffff8010f39e:	66 90                	xchg   %ax,%ax

ffffffff8010f3a0 <mycpu>:
{
ffffffff8010f3a0:	55                   	push   %rbp
ffffffff8010f3a1:	48 89 e5             	mov    %rsp,%rbp
  return &cpus[0];
ffffffff8010f3a4:	48 c7 c0 e0 7b 1f 83 	mov    $0xffffffff831f7be0,%rax
ffffffff8010f3ab:	5d                   	pop    %rbp
ffffffff8010f3ac:	c3                   	retq   
ffffffff8010f3ad:	0f 1f 00             	nopl   (%rax)

ffffffff8010f3b0 <journal_init>:
} txinfo;

extern struct superblock sb;

void journal_init()
{
ffffffff8010f3b0:	55                   	push   %rbp
ffffffff8010f3b1:	48 89 e5             	mov    %rsp,%rbp
  initsleeplock(&txinfo.lock, "journal");
ffffffff8010f3b4:	48 c7 c6 1b 07 11 80 	mov    $0xffffffff8011071b,%rsi
ffffffff8010f3bb:	48 c7 c7 e0 55 22 83 	mov    $0xffffffff832255e0,%rdi
ffffffff8010f3c2:	e8 f9 af ff ff       	callq  ffffffff8010a3c0 <initsleeplock>
}
ffffffff8010f3c7:	5d                   	pop    %rbp
ffffffff8010f3c8:	c3                   	retq   
ffffffff8010f3c9:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)

ffffffff8010f3d0 <begin_trans>:

void begin_trans()
{
ffffffff8010f3d0:	55                   	push   %rbp
ffffffff8010f3d1:	48 89 e5             	mov    %rsp,%rbp
  acquiresleep(&txinfo.lock);
ffffffff8010f3d4:	48 83 ec 20          	sub    $0x20,%rsp
ffffffff8010f3d8:	48 c7 c7 e0 55 22 83 	mov    $0xffffffff832255e0,%rdi
ffffffff8010f3df:	e8 3c b0 ff ff       	callq  ffffffff8010a420 <acquiresleep>

  struct journal_begin record = {
ffffffff8010f3e4:	c6 45 f8 00          	movb   $0x0,-0x8(%rbp)
    .type = JOURNAL_BEGIN,
    .transaction_id = txinfo.transaction_id,
ffffffff8010f3e8:	66 8b 04 25 d0 55 22 	mov    0xffffffff832255d0,%ax
ffffffff8010f3ef:	83 
  struct journal_begin record = {
ffffffff8010f3f0:	66 89 45 fa          	mov    %ax,-0x6(%rbp)
ffffffff8010f3f4:	c6 45 fc 00          	movb   $0x0,-0x4(%rbp)
ffffffff8010f3f8:	c6 45 fd 00          	movb   $0x0,-0x3(%rbp)
    .committed = false,
    .executed = false
  };

  // begin record always goes at position 0 in the log.
  struct buf* buf = bread(ROOTDEV, sb.logstart);
ffffffff8010f3fc:	8b 34 25 4c 27 20 83 	mov    0xffffffff8320274c,%esi
ffffffff8010f403:	bf 01 00 00 00       	mov    $0x1,%edi
ffffffff8010f408:	e8 43 ab ff ff       	callq  ffffffff80109f50 <bread>
ffffffff8010f40d:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  memmove(buf->data, &record, sizeof(record));
ffffffff8010f411:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
ffffffff8010f415:	48 05 b0 00 00 00    	add    $0xb0,%rax
ffffffff8010f41b:	48 8d 75 f8          	lea    -0x8(%rbp),%rsi
ffffffff8010f41f:	ba 06 00 00 00       	mov    $0x6,%edx
ffffffff8010f424:	48 89 c7             	mov    %rax,%rdi
ffffffff8010f427:	e8 64 bc ff ff       	callq  ffffffff8010b090 <memmove>
  bwrite(buf);
ffffffff8010f42c:	48 8b 7d f0          	mov    -0x10(%rbp),%rdi
ffffffff8010f430:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
ffffffff8010f434:	e8 77 ab ff ff       	callq  ffffffff80109fb0 <bwrite>
  brelse(buf);
ffffffff8010f439:	48 8b 7d f0          	mov    -0x10(%rbp),%rdi
ffffffff8010f43d:	e8 fe ab ff ff       	callq  ffffffff8010a040 <brelse>

  txinfo.log_block_offset = 1;
ffffffff8010f442:	48 c7 04 25 d8 55 22 	movq   $0x1,0xffffffff832255d8
ffffffff8010f449:	83 01 00 00 00 
}
ffffffff8010f44e:	48 83 c4 20          	add    $0x20,%rsp
ffffffff8010f452:	5d                   	pop    %rbp
ffffffff8010f453:	c3                   	retq   
ffffffff8010f454:	66 66 66 2e 0f 1f 84 	data16 data16 nopw %cs:0x0(%rax,%rax,1)
ffffffff8010f45b:	00 00 00 00 00 

ffffffff8010f460 <append_log_block>:

void append_log_block(void* record, size_t bytes)
{
ffffffff8010f460:	55                   	push   %rbp
ffffffff8010f461:	48 89 e5             	mov    %rsp,%rbp
ffffffff8010f464:	48 83 ec 20          	sub    $0x20,%rsp
ffffffff8010f468:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
ffffffff8010f46c:	48 89 75 f0          	mov    %rsi,-0x10(%rbp)
  struct buf* buf = bread(ROOTDEV, sb.logstart + txinfo.log_block_offset);
ffffffff8010f470:	8b 04 25 4c 27 20 83 	mov    0xffffffff8320274c,%eax
ffffffff8010f477:	8b 0c 25 d8 55 22 83 	mov    0xffffffff832255d8,%ecx
ffffffff8010f47e:	01 c8                	add    %ecx,%eax
ffffffff8010f480:	bf 01 00 00 00       	mov    $0x1,%edi
ffffffff8010f485:	89 c6                	mov    %eax,%esi
ffffffff8010f487:	e8 c4 aa ff ff       	callq  ffffffff80109f50 <bread>
ffffffff8010f48c:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  memmove(buf->data, record, bytes);
ffffffff8010f490:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
ffffffff8010f494:	48 05 b0 00 00 00    	add    $0xb0,%rax
ffffffff8010f49a:	48 8b 75 f8          	mov    -0x8(%rbp),%rsi
ffffffff8010f49e:	8b 55 f0             	mov    -0x10(%rbp),%edx
ffffffff8010f4a1:	48 89 c7             	mov    %rax,%rdi
ffffffff8010f4a4:	e8 e7 bb ff ff       	callq  ffffffff8010b090 <memmove>
  bwrite(buf);
ffffffff8010f4a9:	48 8b 7d e8          	mov    -0x18(%rbp),%rdi
ffffffff8010f4ad:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
ffffffff8010f4b1:	e8 fa aa ff ff       	callq  ffffffff80109fb0 <bwrite>
  brelse(buf);
ffffffff8010f4b6:	48 8b 7d e8          	mov    -0x18(%rbp),%rdi
ffffffff8010f4ba:	e8 81 ab ff ff       	callq  ffffffff8010a040 <brelse>

  txinfo.log_block_offset++;
ffffffff8010f4bf:	48 8b 04 25 d8 55 22 	mov    0xffffffff832255d8,%rax
ffffffff8010f4c6:	83 
ffffffff8010f4c7:	48 ff c0             	inc    %rax
ffffffff8010f4ca:	48 89 04 25 d8 55 22 	mov    %rax,0xffffffff832255d8
ffffffff8010f4d1:	83 
}
ffffffff8010f4d2:	48 83 c4 20          	add    $0x20,%rsp
ffffffff8010f4d6:	5d                   	pop    %rbp
ffffffff8010f4d7:	c3                   	retq   
ffffffff8010f4d8:	0f 1f 84 00 00 00 00 	nopl   0x0(%rax,%rax,1)
ffffffff8010f4df:	00 

ffffffff8010f4e0 <log_write>:

void log_write(struct buf* b)
{
ffffffff8010f4e0:	55                   	push   %rbp
ffffffff8010f4e1:	48 89 e5             	mov    %rsp,%rbp
ffffffff8010f4e4:	48 83 ec 20          	sub    $0x20,%rsp
ffffffff8010f4e8:	b8 08 00 00 00       	mov    $0x8,%eax
ffffffff8010f4ed:	89 c1                	mov    %eax,%ecx
ffffffff8010f4ef:	48 8d 55 f0          	lea    -0x10(%rbp),%rdx
ffffffff8010f4f3:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  // Keep block cache entry from being evicted.
  b->flags |= B_DIRTY;
ffffffff8010f4f7:	48 8b 7d f8          	mov    -0x8(%rbp),%rdi
ffffffff8010f4fb:	8b 07                	mov    (%rdi),%eax
ffffffff8010f4fd:	83 c8 04             	or     $0x4,%eax
ffffffff8010f500:	89 07                	mov    %eax,(%rdi)

  struct journal_write record = {
ffffffff8010f502:	c6 45 f0 01          	movb   $0x1,-0x10(%rbp)
    .type = JOURNAL_WRITE,
    .blockno = b->blockno
ffffffff8010f506:	48 8b 7d f8          	mov    -0x8(%rbp),%rdi
ffffffff8010f50a:	8b 47 08             	mov    0x8(%rdi),%eax
  struct journal_write record = {
ffffffff8010f50d:	89 45 f4             	mov    %eax,-0xc(%rbp)
  };

  // Writes get logged as a pair of blocks: The metadata struct followed by the
  // payload.

  append_log_block(&record, sizeof record);
ffffffff8010f510:	b8 08 00 00 00       	mov    $0x8,%eax
ffffffff8010f515:	89 c6                	mov    %eax,%esi
ffffffff8010f517:	48 89 d7             	mov    %rdx,%rdi
ffffffff8010f51a:	48 89 4d e8          	mov    %rcx,-0x18(%rbp)
ffffffff8010f51e:	e8 3d ff ff ff       	callq  ffffffff8010f460 <append_log_block>
ffffffff8010f523:	b8 00 02 00 00       	mov    $0x200,%eax
ffffffff8010f528:	89 c1                	mov    %eax,%ecx
  append_log_block(b->data, sizeof b->data);
ffffffff8010f52a:	48 8b 55 f8          	mov    -0x8(%rbp),%rdx
ffffffff8010f52e:	48 81 c2 b0 00 00 00 	add    $0xb0,%rdx
ffffffff8010f535:	b8 00 02 00 00       	mov    $0x200,%eax
ffffffff8010f53a:	89 c6                	mov    %eax,%esi
ffffffff8010f53c:	48 89 d7             	mov    %rdx,%rdi
ffffffff8010f53f:	48 89 4d e0          	mov    %rcx,-0x20(%rbp)
ffffffff8010f543:	e8 18 ff ff ff       	callq  ffffffff8010f460 <append_log_block>
}
ffffffff8010f548:	48 83 c4 20          	add    $0x20,%rsp
ffffffff8010f54c:	5d                   	pop    %rbp
ffffffff8010f54d:	c3                   	retq   
ffffffff8010f54e:	66 90                	xchg   %ax,%ax

ffffffff8010f550 <__recover_trans>:

// Internal routine. Must call with lock held.
void __recover_trans()
{
ffffffff8010f550:	55                   	push   %rbp
ffffffff8010f551:	48 89 e5             	mov    %rsp,%rbp
ffffffff8010f554:	48 83 ec 70          	sub    $0x70,%rsp
ffffffff8010f558:	b8 01 00 00 00       	mov    $0x1,%eax
  // First read the single begin record.

  struct buf* begin_buf = bread(ROOTDEV, sb.logstart);
ffffffff8010f55d:	8b 34 25 4c 27 20 83 	mov    0xffffffff8320274c,%esi
ffffffff8010f564:	bf 01 00 00 00       	mov    $0x1,%edi
ffffffff8010f569:	89 45 c4             	mov    %eax,-0x3c(%rbp)
ffffffff8010f56c:	e8 df a9 ff ff       	callq  ffffffff80109f50 <bread>
ffffffff8010f571:	48 89 45 f8          	mov    %rax,-0x8(%rbp)
  struct journal_begin* begin_record =
   (struct journal_begin*) begin_buf->data;
ffffffff8010f575:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
ffffffff8010f579:	48 05 b0 00 00 00    	add    $0xb0,%rax
  struct journal_begin* begin_record =
ffffffff8010f57f:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  TransactionIdType transaction_id = begin_record->transaction_id;
ffffffff8010f583:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
ffffffff8010f587:	66 8b 48 02          	mov    0x2(%rax),%cx
ffffffff8010f58b:	66 89 4d ee          	mov    %cx,-0x12(%rbp)

  if (begin_record->type != JOURNAL_BEGIN ||
ffffffff8010f58f:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
ffffffff8010f593:	0f b6 30             	movzbl (%rax),%esi
ffffffff8010f596:	83 fe 00             	cmp    $0x0,%esi
ffffffff8010f599:	0f 85 1c 00 00 00    	jne    ffffffff8010f5bb <__recover_trans+0x6b>
     !begin_record->committed || begin_record->executed) {
ffffffff8010f59f:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
ffffffff8010f5a3:	f6 40 04 01          	testb  $0x1,0x4(%rax)
ffffffff8010f5a7:	0f 84 0e 00 00 00    	je     ffffffff8010f5bb <__recover_trans+0x6b>
ffffffff8010f5ad:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
  if (begin_record->type != JOURNAL_BEGIN ||
ffffffff8010f5b1:	f6 40 05 01          	testb  $0x1,0x5(%rax)
ffffffff8010f5b5:	0f 84 0e 00 00 00    	je     ffffffff8010f5c9 <__recover_trans+0x79>
    // Not a transaction that requires playback. We're done.
    brelse(begin_buf);
ffffffff8010f5bb:	48 8b 7d f8          	mov    -0x8(%rbp),%rdi
ffffffff8010f5bf:	e8 7c aa ff ff       	callq  ffffffff8010a040 <brelse>
    return;
ffffffff8010f5c4:	e9 5e 02 00 00       	jmpq   ffffffff8010f827 <__recover_trans+0x2d7>
  }

  // Read the remainder of the log.

  uint8_t record_type = JOURNAL_BEGIN;
ffffffff8010f5c9:	c6 45 ed 00          	movb   $0x0,-0x13(%rbp)
  uint8_t prev_record_type = JOURNAL_BEGIN;
ffffffff8010f5cd:	c6 45 ec 00          	movb   $0x0,-0x14(%rbp)
  uint logblockno = 1;
ffffffff8010f5d1:	c7 45 e8 01 00 00 00 	movl   $0x1,-0x18(%rbp)

  while (record_type != JOURNAL_COMMIT) {
ffffffff8010f5d8:	0f b6 45 ed          	movzbl -0x13(%rbp),%eax
ffffffff8010f5dc:	83 f8 02             	cmp    $0x2,%eax
ffffffff8010f5df:	0f 84 28 02 00 00    	je     ffffffff8010f80d <__recover_trans+0x2bd>
    assert(logblockno < LOGSIZE);
ffffffff8010f5e5:	e9 00 00 00 00       	jmpq   ffffffff8010f5ea <__recover_trans+0x9a>
ffffffff8010f5ea:	83 7d e8 1e          	cmpl   $0x1e,-0x18(%rbp)
ffffffff8010f5ee:	0f 82 0c 00 00 00    	jb     ffffffff8010f600 <__recover_trans+0xb0>
ffffffff8010f5f4:	48 c7 c7 15 fc 10 80 	mov    $0xffffffff8010fc15,%rdi
ffffffff8010f5fb:	e8 70 18 ff ff       	callq  ffffffff80100e70 <panic>
ffffffff8010f600:	e9 00 00 00 00       	jmpq   ffffffff8010f605 <__recover_trans+0xb5>
ffffffff8010f605:	b8 01 00 00 00       	mov    $0x1,%eax
    struct buf* buf = bread(ROOTDEV, sb.logstart + logblockno);
ffffffff8010f60a:	8b 0c 25 4c 27 20 83 	mov    0xffffffff8320274c,%ecx
ffffffff8010f611:	03 4d e8             	add    -0x18(%rbp),%ecx
ffffffff8010f614:	bf 01 00 00 00       	mov    $0x1,%edi
ffffffff8010f619:	89 ce                	mov    %ecx,%esi
ffffffff8010f61b:	89 45 c0             	mov    %eax,-0x40(%rbp)
ffffffff8010f61e:	e8 2d a9 ff ff       	callq  ffffffff80109f50 <bread>
ffffffff8010f623:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
    record_type = *(uint8_t*) buf->data;
ffffffff8010f627:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
ffffffff8010f62b:	8a 90 b0 00 00 00    	mov    0xb0(%rax),%dl
ffffffff8010f631:	88 55 ed             	mov    %dl,-0x13(%rbp)

    if (record_type == JOURNAL_WRITE) {
ffffffff8010f634:	0f b6 4d ed          	movzbl -0x13(%rbp),%ecx
ffffffff8010f638:	83 f9 01             	cmp    $0x1,%ecx
ffffffff8010f63b:	0f 85 1c 01 00 00    	jne    ffffffff8010f75d <__recover_trans+0x20d>
      assert(JOURNAL_BEGIN == prev_record_type
ffffffff8010f641:	e9 00 00 00 00       	jmpq   ffffffff8010f646 <__recover_trans+0xf6>
ffffffff8010f646:	31 c0                	xor    %eax,%eax
ffffffff8010f648:	0f b6 4d ec          	movzbl -0x14(%rbp),%ecx
ffffffff8010f64c:	39 c8                	cmp    %ecx,%eax
ffffffff8010f64e:	0f 84 1d 00 00 00    	je     ffffffff8010f671 <__recover_trans+0x121>
ffffffff8010f654:	b8 01 00 00 00       	mov    $0x1,%eax
ffffffff8010f659:	0f b6 4d ec          	movzbl -0x14(%rbp),%ecx
ffffffff8010f65d:	39 c8                	cmp    %ecx,%eax
ffffffff8010f65f:	0f 84 0c 00 00 00    	je     ffffffff8010f671 <__recover_trans+0x121>
ffffffff8010f665:	48 c7 c7 15 fc 10 80 	mov    $0xffffffff8010fc15,%rdi
ffffffff8010f66c:	e8 ff 17 ff ff       	callq  ffffffff80100e70 <panic>
ffffffff8010f671:	e9 00 00 00 00       	jmpq   ffffffff8010f676 <__recover_trans+0x126>
ffffffff8010f676:	b8 08 00 00 00       	mov    $0x8,%eax
ffffffff8010f67b:	48 8d 4d d8          	lea    -0x28(%rbp),%rcx
          || JOURNAL_WRITE == prev_record_type);
      // Writes have a metadata block followed by a payload block. Save the
      // write record and advance `buf` to read the payload.

      struct journal_write write_record;
      memmove(&write_record, buf->data, sizeof(struct journal_write));
ffffffff8010f67f:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
ffffffff8010f683:	48 81 c2 b0 00 00 00 	add    $0xb0,%rdx
ffffffff8010f68a:	be 08 00 00 00       	mov    $0x8,%esi
ffffffff8010f68f:	48 89 cf             	mov    %rcx,%rdi
ffffffff8010f692:	89 75 bc             	mov    %esi,-0x44(%rbp)
ffffffff8010f695:	48 89 d6             	mov    %rdx,%rsi
ffffffff8010f698:	8b 55 bc             	mov    -0x44(%rbp),%edx
ffffffff8010f69b:	89 45 b8             	mov    %eax,-0x48(%rbp)
ffffffff8010f69e:	e8 ed b9 ff ff       	callq  ffffffff8010b090 <memmove>

      brelse(buf);
ffffffff8010f6a3:	48 8b 7d e0          	mov    -0x20(%rbp),%rdi
ffffffff8010f6a7:	48 89 45 b0          	mov    %rax,-0x50(%rbp)
ffffffff8010f6ab:	e8 90 a9 ff ff       	callq  ffffffff8010a040 <brelse>
      logblockno++;
ffffffff8010f6b0:	8b 55 e8             	mov    -0x18(%rbp),%edx
ffffffff8010f6b3:	83 c2 01             	add    $0x1,%edx
ffffffff8010f6b6:	89 55 e8             	mov    %edx,-0x18(%rbp)
      assert(logblockno < LOGSIZE);
ffffffff8010f6b9:	83 7d e8 1e          	cmpl   $0x1e,-0x18(%rbp)
ffffffff8010f6bd:	0f 82 0c 00 00 00    	jb     ffffffff8010f6cf <__recover_trans+0x17f>
ffffffff8010f6c3:	48 c7 c7 15 fc 10 80 	mov    $0xffffffff8010fc15,%rdi
ffffffff8010f6ca:	e8 a1 17 ff ff       	callq  ffffffff80100e70 <panic>
ffffffff8010f6cf:	e9 00 00 00 00       	jmpq   ffffffff8010f6d4 <__recover_trans+0x184>
ffffffff8010f6d4:	b8 01 00 00 00       	mov    $0x1,%eax
      buf = bread(ROOTDEV, sb.logstart + logblockno);
ffffffff8010f6d9:	8b 0c 25 4c 27 20 83 	mov    0xffffffff8320274c,%ecx
ffffffff8010f6e0:	03 4d e8             	add    -0x18(%rbp),%ecx
ffffffff8010f6e3:	bf 01 00 00 00       	mov    $0x1,%edi
ffffffff8010f6e8:	89 ce                	mov    %ecx,%esi
ffffffff8010f6ea:	89 45 ac             	mov    %eax,-0x54(%rbp)
ffffffff8010f6ed:	e8 5e a8 ff ff       	callq  ffffffff80109f50 <bread>
ffffffff8010f6f2:	b9 01 00 00 00       	mov    $0x1,%ecx
ffffffff8010f6f7:	48 89 45 e0          	mov    %rax,-0x20(%rbp)

      // Apply the write.
      struct buf* writebuf = bread(ROOTDEV, write_record.blockno);
ffffffff8010f6fb:	8b 75 dc             	mov    -0x24(%rbp),%esi
ffffffff8010f6fe:	bf 01 00 00 00       	mov    $0x1,%edi
ffffffff8010f703:	89 4d a8             	mov    %ecx,-0x58(%rbp)
ffffffff8010f706:	e8 45 a8 ff ff       	callq  ffffffff80109f50 <bread>
ffffffff8010f70b:	b9 00 02 00 00       	mov    $0x200,%ecx
ffffffff8010f710:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
      memmove(writebuf->data, buf->data, sizeof(writebuf->data));
ffffffff8010f714:	48 8b 45 d0          	mov    -0x30(%rbp),%rax
ffffffff8010f718:	48 05 b0 00 00 00    	add    $0xb0,%rax
ffffffff8010f71e:	48 8b 55 e0          	mov    -0x20(%rbp),%rdx
ffffffff8010f722:	48 81 c2 b0 00 00 00 	add    $0xb0,%rdx
ffffffff8010f729:	be 00 02 00 00       	mov    $0x200,%esi
ffffffff8010f72e:	48 89 c7             	mov    %rax,%rdi
ffffffff8010f731:	89 75 a4             	mov    %esi,-0x5c(%rbp)
ffffffff8010f734:	48 89 d6             	mov    %rdx,%rsi
ffffffff8010f737:	8b 55 a4             	mov    -0x5c(%rbp),%edx
ffffffff8010f73a:	89 4d a0             	mov    %ecx,-0x60(%rbp)
ffffffff8010f73d:	e8 4e b9 ff ff       	callq  ffffffff8010b090 <memmove>
      bwrite(writebuf);
ffffffff8010f742:	48 8b 7d d0          	mov    -0x30(%rbp),%rdi
ffffffff8010f746:	48 89 45 98          	mov    %rax,-0x68(%rbp)
ffffffff8010f74a:	e8 61 a8 ff ff       	callq  ffffffff80109fb0 <bwrite>
      brelse(writebuf);
ffffffff8010f74f:	48 8b 7d d0          	mov    -0x30(%rbp),%rdi
ffffffff8010f753:	e8 e8 a8 ff ff       	callq  ffffffff8010a040 <brelse>

    } else if (record_type == JOURNAL_COMMIT) {
ffffffff8010f758:	e9 93 00 00 00       	jmpq   ffffffff8010f7f0 <__recover_trans+0x2a0>
ffffffff8010f75d:	0f b6 45 ed          	movzbl -0x13(%rbp),%eax
ffffffff8010f761:	83 f8 02             	cmp    $0x2,%eax
ffffffff8010f764:	0f 85 5f 00 00 00    	jne    ffffffff8010f7c9 <__recover_trans+0x279>
      assert(JOURNAL_WRITE == prev_record_type);
ffffffff8010f76a:	e9 00 00 00 00       	jmpq   ffffffff8010f76f <__recover_trans+0x21f>
ffffffff8010f76f:	b8 01 00 00 00       	mov    $0x1,%eax
ffffffff8010f774:	0f b6 4d ec          	movzbl -0x14(%rbp),%ecx
ffffffff8010f778:	39 c8                	cmp    %ecx,%eax
ffffffff8010f77a:	0f 84 0c 00 00 00    	je     ffffffff8010f78c <__recover_trans+0x23c>
ffffffff8010f780:	48 c7 c7 15 fc 10 80 	mov    $0xffffffff8010fc15,%rdi
ffffffff8010f787:	e8 e4 16 ff ff       	callq  ffffffff80100e70 <panic>
ffffffff8010f78c:	e9 00 00 00 00       	jmpq   ffffffff8010f791 <__recover_trans+0x241>
      struct journal_commit* commit_record =
       (struct journal_commit*) buf->data;
ffffffff8010f791:	48 8b 45 e0          	mov    -0x20(%rbp),%rax
ffffffff8010f795:	48 05 b0 00 00 00    	add    $0xb0,%rax
      struct journal_commit* commit_record =
ffffffff8010f79b:	48 89 45 c8          	mov    %rax,-0x38(%rbp)
      assert(commit_record->transaction_id == transaction_id);
ffffffff8010f79f:	48 8b 45 c8          	mov    -0x38(%rbp),%rax
ffffffff8010f7a3:	0f b7 48 02          	movzwl 0x2(%rax),%ecx
ffffffff8010f7a7:	0f b7 55 ee          	movzwl -0x12(%rbp),%edx
ffffffff8010f7ab:	39 d1                	cmp    %edx,%ecx
ffffffff8010f7ad:	0f 84 0c 00 00 00    	je     ffffffff8010f7bf <__recover_trans+0x26f>
ffffffff8010f7b3:	48 c7 c7 15 fc 10 80 	mov    $0xffffffff8010fc15,%rdi
ffffffff8010f7ba:	e8 b1 16 ff ff       	callq  ffffffff80100e70 <panic>
ffffffff8010f7bf:	e9 00 00 00 00       	jmpq   ffffffff8010f7c4 <__recover_trans+0x274>

    } else {
ffffffff8010f7c4:	e9 22 00 00 00       	jmpq   ffffffff8010f7eb <__recover_trans+0x29b>
      cprintf("Encountered invalid journal log type=0x%x.\n", record_type);
ffffffff8010f7c9:	0f b6 75 ed          	movzbl -0x13(%rbp),%esi
ffffffff8010f7cd:	48 c7 c7 23 07 11 80 	mov    $0xffffffff80110723,%rdi
ffffffff8010f7d4:	31 c0                	xor    %eax,%eax
ffffffff8010f7d6:	88 c1                	mov    %al,%cl
ffffffff8010f7d8:	88 c8                	mov    %cl,%al
ffffffff8010f7da:	e8 81 11 ff ff       	callq  ffffffff80100960 <cprintf>
      assert(false);
ffffffff8010f7df:	48 c7 c7 15 fc 10 80 	mov    $0xffffffff8010fc15,%rdi
ffffffff8010f7e6:	e8 85 16 ff ff       	callq  ffffffff80100e70 <panic>
ffffffff8010f7eb:	e9 00 00 00 00       	jmpq   ffffffff8010f7f0 <__recover_trans+0x2a0>
    }

    brelse(buf);
ffffffff8010f7f0:	48 8b 7d e0          	mov    -0x20(%rbp),%rdi
ffffffff8010f7f4:	e8 47 a8 ff ff       	callq  ffffffff8010a040 <brelse>
    prev_record_type = record_type;
ffffffff8010f7f9:	8a 45 ed             	mov    -0x13(%rbp),%al
ffffffff8010f7fc:	88 45 ec             	mov    %al,-0x14(%rbp)
    logblockno++;
ffffffff8010f7ff:	8b 4d e8             	mov    -0x18(%rbp),%ecx
ffffffff8010f802:	83 c1 01             	add    $0x1,%ecx
ffffffff8010f805:	89 4d e8             	mov    %ecx,-0x18(%rbp)
  while (record_type != JOURNAL_COMMIT) {
ffffffff8010f808:	e9 cb fd ff ff       	jmpq   ffffffff8010f5d8 <__recover_trans+0x88>
  }

  // Mark the begin record as executed.
  begin_record->executed = true;
ffffffff8010f80d:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
ffffffff8010f811:	c6 40 05 01          	movb   $0x1,0x5(%rax)
  bwrite(begin_buf);
ffffffff8010f815:	48 8b 7d f8          	mov    -0x8(%rbp),%rdi
ffffffff8010f819:	e8 92 a7 ff ff       	callq  ffffffff80109fb0 <bwrite>
  brelse(begin_buf);
ffffffff8010f81e:	48 8b 7d f8          	mov    -0x8(%rbp),%rdi
ffffffff8010f822:	e8 19 a8 ff ff       	callq  ffffffff8010a040 <brelse>
}
ffffffff8010f827:	48 83 c4 70          	add    $0x70,%rsp
ffffffff8010f82b:	5d                   	pop    %rbp
ffffffff8010f82c:	c3                   	retq   
ffffffff8010f82d:	0f 1f 00             	nopl   (%rax)

ffffffff8010f830 <commit_trans>:

void commit_trans()
{
ffffffff8010f830:	55                   	push   %rbp
ffffffff8010f831:	48 89 e5             	mov    %rsp,%rbp
ffffffff8010f834:	48 83 ec 20          	sub    $0x20,%rsp
ffffffff8010f838:	b8 01 00 00 00       	mov    $0x1,%eax
  struct journal_commit record = {
ffffffff8010f83d:	c6 45 f8 02          	movb   $0x2,-0x8(%rbp)
    .type = JOURNAL_COMMIT,
    .transaction_id = txinfo.transaction_id
ffffffff8010f841:	66 8b 0c 25 d0 55 22 	mov    0xffffffff832255d0,%cx
ffffffff8010f848:	83 
  struct journal_commit record = {
ffffffff8010f849:	66 89 4d fa          	mov    %cx,-0x6(%rbp)
  };

  append_log_block(&record, sizeof record);
ffffffff8010f84d:	ba 04 00 00 00       	mov    $0x4,%edx
ffffffff8010f852:	89 d6                	mov    %edx,%esi
ffffffff8010f854:	48 8d 7d f8          	lea    -0x8(%rbp),%rdi
ffffffff8010f858:	89 45 e4             	mov    %eax,-0x1c(%rbp)
ffffffff8010f85b:	e8 00 fc ff ff       	callq  ffffffff8010f460 <append_log_block>
  txinfo.transaction_id++;
ffffffff8010f860:	66 8b 0c 25 d0 55 22 	mov    0xffffffff832255d0,%cx
ffffffff8010f867:	83 
ffffffff8010f868:	66 ff c1             	inc    %cx
ffffffff8010f86b:	66 89 0c 25 d0 55 22 	mov    %cx,0xffffffff832255d0
ffffffff8010f872:	83 

  // Mark the begin record as committed.
  struct buf* buf = bread(ROOTDEV, sb.logstart);
ffffffff8010f873:	8b 34 25 4c 27 20 83 	mov    0xffffffff8320274c,%esi
ffffffff8010f87a:	bf 01 00 00 00       	mov    $0x1,%edi
ffffffff8010f87f:	e8 cc a6 ff ff       	callq  ffffffff80109f50 <bread>
ffffffff8010f884:	48 89 45 f0          	mov    %rax,-0x10(%rbp)
  struct journal_begin* begin_record = (struct journal_begin*) buf->data;
ffffffff8010f888:	48 8b 45 f0          	mov    -0x10(%rbp),%rax
ffffffff8010f88c:	48 05 b0 00 00 00    	add    $0xb0,%rax
ffffffff8010f892:	48 89 45 e8          	mov    %rax,-0x18(%rbp)
  begin_record->committed = true;
ffffffff8010f896:	48 8b 45 e8          	mov    -0x18(%rbp),%rax
ffffffff8010f89a:	c6 40 04 01          	movb   $0x1,0x4(%rax)
  bwrite(buf);
ffffffff8010f89e:	48 8b 7d f0          	mov    -0x10(%rbp),%rdi
ffffffff8010f8a2:	e8 09 a7 ff ff       	callq  ffffffff80109fb0 <bwrite>
  brelse(buf);
ffffffff8010f8a7:	48 8b 7d f0          	mov    -0x10(%rbp),%rdi
ffffffff8010f8ab:	e8 90 a7 ff ff       	callq  ffffffff8010a040 <brelse>

  // Replay the transaction.
  __recover_trans();
ffffffff8010f8b0:	e8 9b fc ff ff       	callq  ffffffff8010f550 <__recover_trans>

  releasesleep(&txinfo.lock);
ffffffff8010f8b5:	48 c7 c7 e0 55 22 83 	mov    $0xffffffff832255e0,%rdi
ffffffff8010f8bc:	e8 ff ab ff ff       	callq  ffffffff8010a4c0 <releasesleep>
}
ffffffff8010f8c1:	48 83 c4 20          	add    $0x20,%rsp
ffffffff8010f8c5:	5d                   	pop    %rbp
ffffffff8010f8c6:	c3                   	retq   
ffffffff8010f8c7:	66 0f 1f 84 00 00 00 	nopw   0x0(%rax,%rax,1)
ffffffff8010f8ce:	00 00 

ffffffff8010f8d0 <recover_trans>:

void recover_trans()
{
ffffffff8010f8d0:	55                   	push   %rbp
ffffffff8010f8d1:	48 89 e5             	mov    %rsp,%rbp
  acquiresleep(&txinfo.lock);
ffffffff8010f8d4:	48 c7 c7 e0 55 22 83 	mov    $0xffffffff832255e0,%rdi
ffffffff8010f8db:	e8 40 ab ff ff       	callq  ffffffff8010a420 <acquiresleep>
  __recover_trans();
ffffffff8010f8e0:	e8 6b fc ff ff       	callq  ffffffff8010f550 <__recover_trans>
  releasesleep(&txinfo.lock);
ffffffff8010f8e5:	48 c7 c7 e0 55 22 83 	mov    $0xffffffff832255e0,%rdi
ffffffff8010f8ec:	e8 cf ab ff ff       	callq  ffffffff8010a4c0 <releasesleep>
}
ffffffff8010f8f1:	5d                   	pop    %rbp
ffffffff8010f8f2:	c3                   	retq   
ffffffff8010f8f3:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
ffffffff8010f8fa:	00 00 00 
ffffffff8010f8fd:	0f 1f 00             	nopl   (%rax)

ffffffff8010f900 <ideinit>:
static int disksize;
static uchar *memdisk;

void
ideinit(void)
{
ffffffff8010f900:	55                   	push   %rbp
ffffffff8010f901:	48 89 e5             	mov    %rsp,%rbp
  memdisk = _binary_out_fs_img_start;
ffffffff8010f904:	48 c7 04 25 a8 64 1f 	movq   $0xffffffff801223de,0xffffffff831f64a8
ffffffff8010f90b:	83 de 23 12 80 
  disksize = (uint64_t)_binary_out_fs_img_size/BSIZE;
ffffffff8010f910:	48 c7 c0 00 40 0d 03 	mov    $0x30d4000,%rax
ffffffff8010f917:	48 c1 e8 09          	shr    $0x9,%rax
ffffffff8010f91b:	89 c1                	mov    %eax,%ecx
ffffffff8010f91d:	89 0c 25 b0 64 1f 83 	mov    %ecx,0xffffffff831f64b0
}
ffffffff8010f924:	5d                   	pop    %rbp
ffffffff8010f925:	c3                   	retq   
ffffffff8010f926:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
ffffffff8010f92d:	00 00 00 

ffffffff8010f930 <ideintr>:

// Interrupt handler.
void
ideintr(void)
{
ffffffff8010f930:	55                   	push   %rbp
ffffffff8010f931:	48 89 e5             	mov    %rsp,%rbp
  // no-op
}
ffffffff8010f934:	5d                   	pop    %rbp
ffffffff8010f935:	c3                   	retq   
ffffffff8010f936:	66 2e 0f 1f 84 00 00 	nopw   %cs:0x0(%rax,%rax,1)
ffffffff8010f93d:	00 00 00 

ffffffff8010f940 <iderw>:
// Sync buf with disk.
// If B_DIRTY is set, write buf to disk, clear B_DIRTY, set B_VALID.
// Else if B_VALID is not set, read buf from disk, set B_VALID.
void
iderw(struct buf *b)
{
ffffffff8010f940:	55                   	push   %rbp
ffffffff8010f941:	48 89 e5             	mov    %rsp,%rbp
ffffffff8010f944:	48 83 ec 30          	sub    $0x30,%rsp
ffffffff8010f948:	48 89 7d f8          	mov    %rdi,-0x8(%rbp)
  uchar *p;

  if(!holdingsleep(&b->lock))
ffffffff8010f94c:	48 8b 7d f8          	mov    -0x8(%rbp),%rdi
ffffffff8010f950:	48 83 c7 10          	add    $0x10,%rdi
ffffffff8010f954:	e8 b7 ab ff ff       	callq  ffffffff8010a510 <holdingsleep>
ffffffff8010f959:	83 f8 00             	cmp    $0x0,%eax
ffffffff8010f95c:	0f 85 0c 00 00 00    	jne    ffffffff8010f96e <iderw+0x2e>
    panic("iderw: buf not locked");
ffffffff8010f962:	48 c7 c7 4f 07 11 80 	mov    $0xffffffff8011074f,%rdi
ffffffff8010f969:	e8 02 15 ff ff       	callq  ffffffff80100e70 <panic>
  if((b->flags & (B_VALID|B_DIRTY)) == B_VALID)
ffffffff8010f96e:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
ffffffff8010f972:	8b 08                	mov    (%rax),%ecx
ffffffff8010f974:	83 e1 06             	and    $0x6,%ecx
ffffffff8010f977:	83 f9 02             	cmp    $0x2,%ecx
ffffffff8010f97a:	0f 85 0c 00 00 00    	jne    ffffffff8010f98c <iderw+0x4c>
    panic("iderw: nothing to do");
ffffffff8010f980:	48 c7 c7 65 07 11 80 	mov    $0xffffffff80110765,%rdi
ffffffff8010f987:	e8 e4 14 ff ff       	callq  ffffffff80100e70 <panic>
  if(b->dev != 1)
ffffffff8010f98c:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
ffffffff8010f990:	83 78 04 01          	cmpl   $0x1,0x4(%rax)
ffffffff8010f994:	0f 84 0c 00 00 00    	je     ffffffff8010f9a6 <iderw+0x66>
    panic("iderw: request not for disk 1");
ffffffff8010f99a:	48 c7 c7 7a 07 11 80 	mov    $0xffffffff8011077a,%rdi
ffffffff8010f9a1:	e8 ca 14 ff ff       	callq  ffffffff80100e70 <panic>
  if(b->blockno >= disksize)
ffffffff8010f9a6:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
ffffffff8010f9aa:	8b 48 08             	mov    0x8(%rax),%ecx
ffffffff8010f9ad:	8b 14 25 b0 64 1f 83 	mov    0xffffffff831f64b0,%edx
ffffffff8010f9b4:	39 d1                	cmp    %edx,%ecx
ffffffff8010f9b6:	0f 82 0c 00 00 00    	jb     ffffffff8010f9c8 <iderw+0x88>
    panic("iderw: block out of range");
ffffffff8010f9bc:	48 c7 c7 98 07 11 80 	mov    $0xffffffff80110798,%rdi
ffffffff8010f9c3:	e8 a8 14 ff ff       	callq  ffffffff80100e70 <panic>

  p = memdisk + b->blockno*BSIZE;
ffffffff8010f9c8:	48 8b 04 25 a8 64 1f 	mov    0xffffffff831f64a8,%rax
ffffffff8010f9cf:	83 
ffffffff8010f9d0:	48 8b 4d f8          	mov    -0x8(%rbp),%rcx
ffffffff8010f9d4:	8b 51 08             	mov    0x8(%rcx),%edx
ffffffff8010f9d7:	c1 e2 09             	shl    $0x9,%edx
ffffffff8010f9da:	89 d2                	mov    %edx,%edx
ffffffff8010f9dc:	89 d1                	mov    %edx,%ecx
ffffffff8010f9de:	48 01 c8             	add    %rcx,%rax
ffffffff8010f9e1:	48 89 45 f0          	mov    %rax,-0x10(%rbp)

  if(b->flags & B_DIRTY){
ffffffff8010f9e5:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
ffffffff8010f9e9:	8b 10                	mov    (%rax),%edx
ffffffff8010f9eb:	83 e2 04             	and    $0x4,%edx
ffffffff8010f9ee:	83 fa 00             	cmp    $0x0,%edx
ffffffff8010f9f1:	0f 84 38 00 00 00    	je     ffffffff8010fa2f <iderw+0xef>
ffffffff8010f9f7:	b8 00 02 00 00       	mov    $0x200,%eax
    b->flags &= ~B_DIRTY;
ffffffff8010f9fc:	48 8b 4d f8          	mov    -0x8(%rbp),%rcx
ffffffff8010fa00:	8b 11                	mov    (%rcx),%edx
ffffffff8010fa02:	83 e2 fb             	and    $0xfffffffb,%edx
ffffffff8010fa05:	89 11                	mov    %edx,(%rcx)
    memmove(p, b->data, BSIZE);
ffffffff8010fa07:	48 8b 7d f0          	mov    -0x10(%rbp),%rdi
ffffffff8010fa0b:	48 8b 4d f8          	mov    -0x8(%rbp),%rcx
ffffffff8010fa0f:	48 81 c1 b0 00 00 00 	add    $0xb0,%rcx
ffffffff8010fa16:	ba 00 02 00 00       	mov    $0x200,%edx
ffffffff8010fa1b:	48 89 ce             	mov    %rcx,%rsi
ffffffff8010fa1e:	89 45 ec             	mov    %eax,-0x14(%rbp)
ffffffff8010fa21:	e8 6a b6 ff ff       	callq  ffffffff8010b090 <memmove>
  } else
ffffffff8010fa26:	48 89 45 e0          	mov    %rax,-0x20(%rbp)
ffffffff8010fa2a:	e9 28 00 00 00       	jmpq   ffffffff8010fa57 <iderw+0x117>
ffffffff8010fa2f:	b8 00 02 00 00       	mov    $0x200,%eax
    memmove(b->data, p, BSIZE);
ffffffff8010fa34:	48 8b 4d f8          	mov    -0x8(%rbp),%rcx
ffffffff8010fa38:	48 81 c1 b0 00 00 00 	add    $0xb0,%rcx
ffffffff8010fa3f:	48 8b 75 f0          	mov    -0x10(%rbp),%rsi
ffffffff8010fa43:	ba 00 02 00 00       	mov    $0x200,%edx
ffffffff8010fa48:	48 89 cf             	mov    %rcx,%rdi
ffffffff8010fa4b:	89 45 dc             	mov    %eax,-0x24(%rbp)
ffffffff8010fa4e:	e8 3d b6 ff ff       	callq  ffffffff8010b090 <memmove>
ffffffff8010fa53:	48 89 45 d0          	mov    %rax,-0x30(%rbp)
  b->flags |= B_VALID;
ffffffff8010fa57:	48 8b 45 f8          	mov    -0x8(%rbp),%rax
ffffffff8010fa5b:	8b 08                	mov    (%rax),%ecx
ffffffff8010fa5d:	83 c9 02             	or     $0x2,%ecx
ffffffff8010fa60:	89 08                	mov    %ecx,(%rax)
ffffffff8010fa62:	48 83 c4 30          	add    $0x30,%rsp
ffffffff8010fa66:	5d                   	pop    %rbp
ffffffff8010fa67:	c3                   	retq   
